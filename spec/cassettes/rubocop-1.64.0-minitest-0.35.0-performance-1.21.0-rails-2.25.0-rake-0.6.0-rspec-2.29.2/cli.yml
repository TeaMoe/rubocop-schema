---
http_interactions:
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '43058'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"5d1c3896cce1b9ec98164d114e208f320c5c1db5e8baeeaeb34668cce92512fa"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 43E4:12D701:138EC8C:14C7D2F:66541A7D
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:37 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230116-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787838.543080,VS0,VE235
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 05b8c1775dc8574845d195e613d0632d8fb08935
      Expires:
      - Mon, 27 May 2024 05:35:37 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        = Cops

        In RuboCop lingo the various checks performed on the code are called cops.
        Each cop is responsible for detecting one particular offense. There are several
        cop departments, grouping the cops by class of offense. A short description of
        the different departments is provided below.

        Many of the Style and Layout cops have configuration options, allowing them to
        enforce different coding conventions.

        You can also load xref:extensions.adoc#custom-cops[custom cops].

        Cop-related failures are silenced by default but can be turned on using the
        `--raise-cop-errors` option.

        == Style

        Style cops check for stylistic consistency of your code. Many of the them are
        based on the https://rubystyle.guide[Ruby Style Guide].

        == Layout

        Layout cops inspect your code for consistent use of indentation, alignment,
        and white space.

        == Lint

        Lint cops check for ambiguities and possible errors in your code.

        RuboCop implements, in a portable way, all built-in MRI lint checks
        (`ruby -wc`) and adds a lot of extra lint checks of its own.

        You can run only the Lint cops like this:

        [source,sh]
        ----
        $ rubocop -l
        ----

        The `-l`/`--lint` option can be used together with `--only` to run all the
        enabled Lint cops plus a selection of other cops.

        Disabling Lint cops is generally a bad idea.

        == Metrics

        Metrics cops deal with properties of the source code that can be measured,
        such as class length, method length, etc. Generally speaking, they have a
        configuration parameter called `Max` and when running
        `rubocop --auto-gen-config`, this parameter will be set to the highest value
        found for the inspected code.

        == Naming

        Naming cops check for naming issue of your code, such as method name, constant
        name, file name, etc.

        == Security

        Security cops checks for method calls and constructs which are known to be
        associated with potential security issues.

        == Bundler

        Bundler cops check for style and bad practices in Bundler files, e.g. `Gemfile`.

        == Gemspec

        Gemspec cops check for style and bad practices in gemspec files, e.g. `rubocop.gemspec`.

        == Available cops

        In the following section you find all available cops:

        // START_COP_LIST

        === Department xref:cops_bundler.adoc[Bundler]

        * xref:cops_bundler.adoc#bundlerduplicatedgem[Bundler/DuplicatedGem]
        * xref:cops_bundler.adoc#bundlerduplicatedgroup[Bundler/DuplicatedGroup]
        * xref:cops_bundler.adoc#bundlergemcomment[Bundler/GemComment]
        * xref:cops_bundler.adoc#bundlergemfilename[Bundler/GemFilename]
        * xref:cops_bundler.adoc#bundlergemversion[Bundler/GemVersion]
        * xref:cops_bundler.adoc#bundlerinsecureprotocolsource[Bundler/InsecureProtocolSource]
        * xref:cops_bundler.adoc#bundlerorderedgems[Bundler/OrderedGems]

        === Department xref:cops_gemspec.adoc[Gemspec]

        * xref:cops_gemspec.adoc#gemspecdependencyversion[Gemspec/DependencyVersion]
        * xref:cops_gemspec.adoc#gemspecdeprecatedattributeassignment[Gemspec/DeprecatedAttributeAssignment]
        * xref:cops_gemspec.adoc#gemspecdevelopmentdependencies[Gemspec/DevelopmentDependencies]
        * xref:cops_gemspec.adoc#gemspecduplicatedassignment[Gemspec/DuplicatedAssignment]
        * xref:cops_gemspec.adoc#gemspecordereddependencies[Gemspec/OrderedDependencies]
        * xref:cops_gemspec.adoc#gemspecrequiremfa[Gemspec/RequireMFA]
        * xref:cops_gemspec.adoc#gemspecrequiredrubyversion[Gemspec/RequiredRubyVersion]
        * xref:cops_gemspec.adoc#gemspecrubyversionglobalsusage[Gemspec/RubyVersionGlobalsUsage]

        === Department xref:cops_layout.adoc[Layout]

        * xref:cops_layout.adoc#layoutaccessmodifierindentation[Layout/AccessModifierIndentation]
        * xref:cops_layout.adoc#layoutargumentalignment[Layout/ArgumentAlignment]
        * xref:cops_layout.adoc#layoutarrayalignment[Layout/ArrayAlignment]
        * xref:cops_layout.adoc#layoutassignmentindentation[Layout/AssignmentIndentation]
        * xref:cops_layout.adoc#layoutbeginendalignment[Layout/BeginEndAlignment]
        * xref:cops_layout.adoc#layoutblockalignment[Layout/BlockAlignment]
        * xref:cops_layout.adoc#layoutblockendnewline[Layout/BlockEndNewline]
        * xref:cops_layout.adoc#layoutcaseindentation[Layout/CaseIndentation]
        * xref:cops_layout.adoc#layoutclassstructure[Layout/ClassStructure]
        * xref:cops_layout.adoc#layoutclosingheredocindentation[Layout/ClosingHeredocIndentation]
        * xref:cops_layout.adoc#layoutclosingparenthesisindentation[Layout/ClosingParenthesisIndentation]
        * xref:cops_layout.adoc#layoutcommentindentation[Layout/CommentIndentation]
        * xref:cops_layout.adoc#layoutconditionposition[Layout/ConditionPosition]
        * xref:cops_layout.adoc#layoutdefendalignment[Layout/DefEndAlignment]
        * xref:cops_layout.adoc#layoutdotposition[Layout/DotPosition]
        * xref:cops_layout.adoc#layoutelsealignment[Layout/ElseAlignment]
        * xref:cops_layout.adoc#layoutemptycomment[Layout/EmptyComment]
        * xref:cops_layout.adoc#layoutemptylineafterguardclause[Layout/EmptyLineAfterGuardClause]
        * xref:cops_layout.adoc#layoutemptylineaftermagiccomment[Layout/EmptyLineAfterMagicComment]
        * xref:cops_layout.adoc#layoutemptylineaftermultilinecondition[Layout/EmptyLineAfterMultilineCondition]
        * xref:cops_layout.adoc#layoutemptylinebetweendefs[Layout/EmptyLineBetweenDefs]
        * xref:cops_layout.adoc#layoutemptylines[Layout/EmptyLines]
        * xref:cops_layout.adoc#layoutemptylinesaroundaccessmodifier[Layout/EmptyLinesAroundAccessModifier]
        * xref:cops_layout.adoc#layoutemptylinesaroundarguments[Layout/EmptyLinesAroundArguments]
        * xref:cops_layout.adoc#layoutemptylinesaroundattributeaccessor[Layout/EmptyLinesAroundAttributeAccessor]
        * xref:cops_layout.adoc#layoutemptylinesaroundbeginbody[Layout/EmptyLinesAroundBeginBody]
        * xref:cops_layout.adoc#layoutemptylinesaroundblockbody[Layout/EmptyLinesAroundBlockBody]
        * xref:cops_layout.adoc#layoutemptylinesaroundclassbody[Layout/EmptyLinesAroundClassBody]
        * xref:cops_layout.adoc#layoutemptylinesaroundexceptionhandlingkeywords[Layout/EmptyLinesAroundExceptionHandlingKeywords]
        * xref:cops_layout.adoc#layoutemptylinesaroundmethodbody[Layout/EmptyLinesAroundMethodBody]
        * xref:cops_layout.adoc#layoutemptylinesaroundmodulebody[Layout/EmptyLinesAroundModuleBody]
        * xref:cops_layout.adoc#layoutendalignment[Layout/EndAlignment]
        * xref:cops_layout.adoc#layoutendofline[Layout/EndOfLine]
        * xref:cops_layout.adoc#layoutextraspacing[Layout/ExtraSpacing]
        * xref:cops_layout.adoc#layoutfirstargumentindentation[Layout/FirstArgumentIndentation]
        * xref:cops_layout.adoc#layoutfirstarrayelementindentation[Layout/FirstArrayElementIndentation]
        * xref:cops_layout.adoc#layoutfirstarrayelementlinebreak[Layout/FirstArrayElementLineBreak]
        * xref:cops_layout.adoc#layoutfirsthashelementindentation[Layout/FirstHashElementIndentation]
        * xref:cops_layout.adoc#layoutfirsthashelementlinebreak[Layout/FirstHashElementLineBreak]
        * xref:cops_layout.adoc#layoutfirstmethodargumentlinebreak[Layout/FirstMethodArgumentLineBreak]
        * xref:cops_layout.adoc#layoutfirstmethodparameterlinebreak[Layout/FirstMethodParameterLineBreak]
        * xref:cops_layout.adoc#layoutfirstparameterindentation[Layout/FirstParameterIndentation]
        * xref:cops_layout.adoc#layouthashalignment[Layout/HashAlignment]
        * xref:cops_layout.adoc#layoutheredocargumentclosingparenthesis[Layout/HeredocArgumentClosingParenthesis]
        * xref:cops_layout.adoc#layoutheredocindentation[Layout/HeredocIndentation]
        * xref:cops_layout.adoc#layoutindentationconsistency[Layout/IndentationConsistency]
        * xref:cops_layout.adoc#layoutindentationstyle[Layout/IndentationStyle]
        * xref:cops_layout.adoc#layoutindentationwidth[Layout/IndentationWidth]
        * xref:cops_layout.adoc#layoutinitialindentation[Layout/InitialIndentation]
        * xref:cops_layout.adoc#layoutleadingcommentspace[Layout/LeadingCommentSpace]
        * xref:cops_layout.adoc#layoutleadingemptylines[Layout/LeadingEmptyLines]
        * xref:cops_layout.adoc#layoutlinecontinuationleadingspace[Layout/LineContinuationLeadingSpace]
        * xref:cops_layout.adoc#layoutlinecontinuationspacing[Layout/LineContinuationSpacing]
        * xref:cops_layout.adoc#layoutlineendstringconcatenationindentation[Layout/LineEndStringConcatenationIndentation]
        * xref:cops_layout.adoc#layoutlinelength[Layout/LineLength]
        * xref:cops_layout.adoc#layoutmultilinearraybracelayout[Layout/MultilineArrayBraceLayout]
        * xref:cops_layout.adoc#layoutmultilinearraylinebreaks[Layout/MultilineArrayLineBreaks]
        * xref:cops_layout.adoc#layoutmultilineassignmentlayout[Layout/MultilineAssignmentLayout]
        * xref:cops_layout.adoc#layoutmultilineblocklayout[Layout/MultilineBlockLayout]
        * xref:cops_layout.adoc#layoutmultilinehashbracelayout[Layout/MultilineHashBraceLayout]
        * xref:cops_layout.adoc#layoutmultilinehashkeylinebreaks[Layout/MultilineHashKeyLineBreaks]
        * xref:cops_layout.adoc#layoutmultilinemethodargumentlinebreaks[Layout/MultilineMethodArgumentLineBreaks]
        * xref:cops_layout.adoc#layoutmultilinemethodcallbracelayout[Layout/MultilineMethodCallBraceLayout]
        * xref:cops_layout.adoc#layoutmultilinemethodcallindentation[Layout/MultilineMethodCallIndentation]
        * xref:cops_layout.adoc#layoutmultilinemethoddefinitionbracelayout[Layout/MultilineMethodDefinitionBraceLayout]
        * xref:cops_layout.adoc#layoutmultilinemethodparameterlinebreaks[Layout/MultilineMethodParameterLineBreaks]
        * xref:cops_layout.adoc#layoutmultilineoperationindentation[Layout/MultilineOperationIndentation]
        * xref:cops_layout.adoc#layoutparameteralignment[Layout/ParameterAlignment]
        * xref:cops_layout.adoc#layoutredundantlinebreak[Layout/RedundantLineBreak]
        * xref:cops_layout.adoc#layoutrescueensurealignment[Layout/RescueEnsureAlignment]
        * xref:cops_layout.adoc#layoutsinglelineblockchain[Layout/SingleLineBlockChain]
        * xref:cops_layout.adoc#layoutspaceaftercolon[Layout/SpaceAfterColon]
        * xref:cops_layout.adoc#layoutspaceaftercomma[Layout/SpaceAfterComma]
        * xref:cops_layout.adoc#layoutspaceaftermethodname[Layout/SpaceAfterMethodName]
        * xref:cops_layout.adoc#layoutspaceafternot[Layout/SpaceAfterNot]
        * xref:cops_layout.adoc#layoutspaceaftersemicolon[Layout/SpaceAfterSemicolon]
        * xref:cops_layout.adoc#layoutspacearoundblockparameters[Layout/SpaceAroundBlockParameters]
        * xref:cops_layout.adoc#layoutspacearoundequalsinparameterdefault[Layout/SpaceAroundEqualsInParameterDefault]
        * xref:cops_layout.adoc#layoutspacearoundkeyword[Layout/SpaceAroundKeyword]
        * xref:cops_layout.adoc#layoutspacearoundmethodcalloperator[Layout/SpaceAroundMethodCallOperator]
        * xref:cops_layout.adoc#layoutspacearoundoperators[Layout/SpaceAroundOperators]
        * xref:cops_layout.adoc#layoutspacebeforeblockbraces[Layout/SpaceBeforeBlockBraces]
        * xref:cops_layout.adoc#layoutspacebeforebrackets[Layout/SpaceBeforeBrackets]
        * xref:cops_layout.adoc#layoutspacebeforecomma[Layout/SpaceBeforeComma]
        * xref:cops_layout.adoc#layoutspacebeforecomment[Layout/SpaceBeforeComment]
        * xref:cops_layout.adoc#layoutspacebeforefirstarg[Layout/SpaceBeforeFirstArg]
        * xref:cops_layout.adoc#layoutspacebeforesemicolon[Layout/SpaceBeforeSemicolon]
        * xref:cops_layout.adoc#layoutspaceinlambdaliteral[Layout/SpaceInLambdaLiteral]
        * xref:cops_layout.adoc#layoutspaceinsidearrayliteralbrackets[Layout/SpaceInsideArrayLiteralBrackets]
        * xref:cops_layout.adoc#layoutspaceinsidearraypercentliteral[Layout/SpaceInsideArrayPercentLiteral]
        * xref:cops_layout.adoc#layoutspaceinsideblockbraces[Layout/SpaceInsideBlockBraces]
        * xref:cops_layout.adoc#layoutspaceinsidehashliteralbraces[Layout/SpaceInsideHashLiteralBraces]
        * xref:cops_layout.adoc#layoutspaceinsideparens[Layout/SpaceInsideParens]
        * xref:cops_layout.adoc#layoutspaceinsidepercentliteraldelimiters[Layout/SpaceInsidePercentLiteralDelimiters]
        * xref:cops_layout.adoc#layoutspaceinsiderangeliteral[Layout/SpaceInsideRangeLiteral]
        * xref:cops_layout.adoc#layoutspaceinsidereferencebrackets[Layout/SpaceInsideReferenceBrackets]
        * xref:cops_layout.adoc#layoutspaceinsidestringinterpolation[Layout/SpaceInsideStringInterpolation]
        * xref:cops_layout.adoc#layouttrailingemptylines[Layout/TrailingEmptyLines]
        * xref:cops_layout.adoc#layouttrailingwhitespace[Layout/TrailingWhitespace]

        === Department xref:cops_lint.adoc[Lint]

        * xref:cops_lint.adoc#lintambiguousassignment[Lint/AmbiguousAssignment]
        * xref:cops_lint.adoc#lintambiguousblockassociation[Lint/AmbiguousBlockAssociation]
        * xref:cops_lint.adoc#lintambiguousoperator[Lint/AmbiguousOperator]
        * xref:cops_lint.adoc#lintambiguousoperatorprecedence[Lint/AmbiguousOperatorPrecedence]
        * xref:cops_lint.adoc#lintambiguousrange[Lint/AmbiguousRange]
        * xref:cops_lint.adoc#lintambiguousregexpliteral[Lint/AmbiguousRegexpLiteral]
        * xref:cops_lint.adoc#lintassignmentincondition[Lint/AssignmentInCondition]
        * xref:cops_lint.adoc#lintbigdecimalnew[Lint/BigDecimalNew]
        * xref:cops_lint.adoc#lintbinaryoperatorwithidenticaloperands[Lint/BinaryOperatorWithIdenticalOperands]
        * xref:cops_lint.adoc#lintbooleansymbol[Lint/BooleanSymbol]
        * xref:cops_lint.adoc#lintcircularargumentreference[Lint/CircularArgumentReference]
        * xref:cops_lint.adoc#lintconstantdefinitioninblock[Lint/ConstantDefinitionInBlock]
        * xref:cops_lint.adoc#lintconstantoverwritteninrescue[Lint/ConstantOverwrittenInRescue]
        * xref:cops_lint.adoc#lintconstantresolution[Lint/ConstantResolution]
        * xref:cops_lint.adoc#lintdebugger[Lint/Debugger]
        * xref:cops_lint.adoc#lintdeprecatedclassmethods[Lint/DeprecatedClassMethods]
        * xref:cops_lint.adoc#lintdeprecatedconstants[Lint/DeprecatedConstants]
        * xref:cops_lint.adoc#lintdeprecatedopensslconstant[Lint/DeprecatedOpenSSLConstant]
        * xref:cops_lint.adoc#lintdisjunctiveassignmentinconstructor[Lint/DisjunctiveAssignmentInConstructor]
        * xref:cops_lint.adoc#lintduplicatebranch[Lint/DuplicateBranch]
        * xref:cops_lint.adoc#lintduplicatecasecondition[Lint/DuplicateCaseCondition]
        * xref:cops_lint.adoc#lintduplicateelsifcondition[Lint/DuplicateElsifCondition]
        * xref:cops_lint.adoc#lintduplicatehashkey[Lint/DuplicateHashKey]
        * xref:cops_lint.adoc#lintduplicatemagiccomment[Lint/DuplicateMagicComment]
        * xref:cops_lint.adoc#lintduplicatematchpattern[Lint/DuplicateMatchPattern]
        * xref:cops_lint.adoc#lintduplicatemethods[Lint/DuplicateMethods]
        * xref:cops_lint.adoc#lintduplicateregexpcharacterclasselement[Lint/DuplicateRegexpCharacterClassElement]
        * xref:cops_lint.adoc#lintduplicaterequire[Lint/DuplicateRequire]
        * xref:cops_lint.adoc#lintduplicaterescueexception[Lint/DuplicateRescueException]
        * xref:cops_lint.adoc#linteachwithobjectargument[Lint/EachWithObjectArgument]
        * xref:cops_lint.adoc#lintelselayout[Lint/ElseLayout]
        * xref:cops_lint.adoc#lintemptyblock[Lint/EmptyBlock]
        * xref:cops_lint.adoc#lintemptyclass[Lint/EmptyClass]
        * xref:cops_lint.adoc#lintemptyconditionalbody[Lint/EmptyConditionalBody]
        * xref:cops_lint.adoc#lintemptyensure[Lint/EmptyEnsure]
        * xref:cops_lint.adoc#lintemptyexpression[Lint/EmptyExpression]
        * xref:cops_lint.adoc#lintemptyfile[Lint/EmptyFile]
        * xref:cops_lint.adoc#lintemptyinpattern[Lint/EmptyInPattern]
        * xref:cops_lint.adoc#lintemptyinterpolation[Lint/EmptyInterpolation]
        * xref:cops_lint.adoc#lintemptywhen[Lint/EmptyWhen]
        * xref:cops_lint.adoc#lintensurereturn[Lint/EnsureReturn]
        * xref:cops_lint.adoc#linterbnewarguments[Lint/ErbNewArguments]
        * xref:cops_lint.adoc#lintflipflop[Lint/FlipFlop]
        * xref:cops_lint.adoc#lintfloatcomparison[Lint/FloatComparison]
        * xref:cops_lint.adoc#lintfloatoutofrange[Lint/FloatOutOfRange]
        * xref:cops_lint.adoc#lintformatparametermismatch[Lint/FormatParameterMismatch]
        * xref:cops_lint.adoc#linthashcomparebyidentity[Lint/HashCompareByIdentity]
        * xref:cops_lint.adoc#lintheredocmethodcallposition[Lint/HeredocMethodCallPosition]
        * xref:cops_lint.adoc#lintidentitycomparison[Lint/IdentityComparison]
        * xref:cops_lint.adoc#lintimplicitstringconcatenation[Lint/ImplicitStringConcatenation]
        * xref:cops_lint.adoc#lintincompatibleioselectwithfiberscheduler[Lint/IncompatibleIoSelectWithFiberScheduler]
        * xref:cops_lint.adoc#lintineffectiveaccessmodifier[Lint/IneffectiveAccessModifier]
        * xref:cops_lint.adoc#lintinheritexception[Lint/InheritException]
        * xref:cops_lint.adoc#lintinterpolationcheck[Lint/InterpolationCheck]
        * xref:cops_lint.adoc#lintitwithoutargumentsinblock[Lint/ItWithoutArgumentsInBlock]
        * xref:cops_lint.adoc#lintlambdawithoutliteralblock[Lint/LambdaWithoutLiteralBlock]
        * xref:cops_lint.adoc#lintliteralascondition[Lint/LiteralAsCondition]
        * xref:cops_lint.adoc#lintliteralassignmentincondition[Lint/LiteralAssignmentInCondition]
        * xref:cops_lint.adoc#lintliteralininterpolation[Lint/LiteralInInterpolation]
        * xref:cops_lint.adoc#lintloop[Lint/Loop]
        * xref:cops_lint.adoc#lintmissingcopenabledirective[Lint/MissingCopEnableDirective]
        * xref:cops_lint.adoc#lintmissingsuper[Lint/MissingSuper]
        * xref:cops_lint.adoc#lintmixedcaserange[Lint/MixedCaseRange]
        * xref:cops_lint.adoc#lintmixedregexpcapturetypes[Lint/MixedRegexpCaptureTypes]
        * xref:cops_lint.adoc#lintmultiplecomparison[Lint/MultipleComparison]
        * xref:cops_lint.adoc#lintnestedmethoddefinition[Lint/NestedMethodDefinition]
        * xref:cops_lint.adoc#lintnestedpercentliteral[Lint/NestedPercentLiteral]
        * xref:cops_lint.adoc#lintnextwithoutaccumulator[Lint/NextWithoutAccumulator]
        * xref:cops_lint.adoc#lintnoreturninbeginendblocks[Lint/NoReturnInBeginEndBlocks]
        * xref:cops_lint.adoc#lintnonatomicfileoperation[Lint/NonAtomicFileOperation]
        * xref:cops_lint.adoc#lintnondeterministicrequireorder[Lint/NonDeterministicRequireOrder]
        * xref:cops_lint.adoc#lintnonlocalexitfromiterator[Lint/NonLocalExitFromIterator]
        * xref:cops_lint.adoc#lintnumberconversion[Lint/NumberConversion]
        * xref:cops_lint.adoc#lintnumberedparameterassignment[Lint/NumberedParameterAssignment]
        * xref:cops_lint.adoc#lintorassignmenttoconstant[Lint/OrAssignmentToConstant]
        * xref:cops_lint.adoc#lintorderedmagiccomments[Lint/OrderedMagicComments]
        * xref:cops_lint.adoc#lintoutofrangeregexpref[Lint/OutOfRangeRegexpRef]
        * xref:cops_lint.adoc#lintparenthesesasgroupedexpression[Lint/ParenthesesAsGroupedExpression]
        * xref:cops_lint.adoc#lintpercentstringarray[Lint/PercentStringArray]
        * xref:cops_lint.adoc#lintpercentsymbolarray[Lint/PercentSymbolArray]
        * xref:cops_lint.adoc#lintraiseexception[Lint/RaiseException]
        * xref:cops_lint.adoc#lintrandone[Lint/RandOne]
        * xref:cops_lint.adoc#lintredundantcopdisabledirective[Lint/RedundantCopDisableDirective]
        * xref:cops_lint.adoc#lintredundantcopenabledirective[Lint/RedundantCopEnableDirective]
        * xref:cops_lint.adoc#lintredundantdirglobsort[Lint/RedundantDirGlobSort]
        * xref:cops_lint.adoc#lintredundantregexpquantifiers[Lint/RedundantRegexpQuantifiers]
        * xref:cops_lint.adoc#lintredundantrequirestatement[Lint/RedundantRequireStatement]
        * xref:cops_lint.adoc#lintredundantsafenavigation[Lint/RedundantSafeNavigation]
        * xref:cops_lint.adoc#lintredundantsplatexpansion[Lint/RedundantSplatExpansion]
        * xref:cops_lint.adoc#lintredundantstringcoercion[Lint/RedundantStringCoercion]
        * xref:cops_lint.adoc#lintredundantwithindex[Lint/RedundantWithIndex]
        * xref:cops_lint.adoc#lintredundantwithobject[Lint/RedundantWithObject]
        * xref:cops_lint.adoc#lintrefinementimportmethods[Lint/RefinementImportMethods]
        * xref:cops_lint.adoc#lintregexpascondition[Lint/RegexpAsCondition]
        * xref:cops_lint.adoc#lintrequireparentheses[Lint/RequireParentheses]
        * xref:cops_lint.adoc#lintrequirerangeparentheses[Lint/RequireRangeParentheses]
        * xref:cops_lint.adoc#lintrequirerelativeselfpath[Lint/RequireRelativeSelfPath]
        * xref:cops_lint.adoc#lintrescueexception[Lint/RescueException]
        * xref:cops_lint.adoc#lintrescuetype[Lint/RescueType]
        * xref:cops_lint.adoc#lintreturninvoidcontext[Lint/ReturnInVoidContext]
        * xref:cops_lint.adoc#lintsafenavigationchain[Lint/SafeNavigationChain]
        * xref:cops_lint.adoc#lintsafenavigationconsistency[Lint/SafeNavigationConsistency]
        * xref:cops_lint.adoc#lintsafenavigationwithempty[Lint/SafeNavigationWithEmpty]
        * xref:cops_lint.adoc#lintscriptpermission[Lint/ScriptPermission]
        * xref:cops_lint.adoc#lintselfassignment[Lint/SelfAssignment]
        * xref:cops_lint.adoc#lintsendwithmixinargument[Lint/SendWithMixinArgument]
        * xref:cops_lint.adoc#lintshadowedargument[Lint/ShadowedArgument]
        * xref:cops_lint.adoc#lintshadowedexception[Lint/ShadowedException]
        * xref:cops_lint.adoc#lintshadowingouterlocalvariable[Lint/ShadowingOuterLocalVariable]
        * xref:cops_lint.adoc#lintstructnewoverride[Lint/StructNewOverride]
        * xref:cops_lint.adoc#lintsuppressedexception[Lint/SuppressedException]
        * xref:cops_lint.adoc#lintsymbolconversion[Lint/SymbolConversion]
        * xref:cops_lint.adoc#lintsyntax[Lint/Syntax]
        * xref:cops_lint.adoc#linttoenumarguments[Lint/ToEnumArguments]
        * xref:cops_lint.adoc#linttojson[Lint/ToJSON]
        * xref:cops_lint.adoc#linttoplevelreturnwithargument[Lint/TopLevelReturnWithArgument]
        * xref:cops_lint.adoc#linttrailingcommainattributedeclaration[Lint/TrailingCommaInAttributeDeclaration]
        * xref:cops_lint.adoc#linttriplequotes[Lint/TripleQuotes]
        * xref:cops_lint.adoc#lintunderscoreprefixedvariablename[Lint/UnderscorePrefixedVariableName]
        * xref:cops_lint.adoc#lintunexpectedblockarity[Lint/UnexpectedBlockArity]
        * xref:cops_lint.adoc#lintunifiedinteger[Lint/UnifiedInteger]
        * xref:cops_lint.adoc#lintunmodifiedreduceaccumulator[Lint/UnmodifiedReduceAccumulator]
        * xref:cops_lint.adoc#lintunreachablecode[Lint/UnreachableCode]
        * xref:cops_lint.adoc#lintunreachableloop[Lint/UnreachableLoop]
        * xref:cops_lint.adoc#lintunusedblockargument[Lint/UnusedBlockArgument]
        * xref:cops_lint.adoc#lintunusedmethodargument[Lint/UnusedMethodArgument]
        * xref:cops_lint.adoc#linturiescapeunescape[Lint/UriEscapeUnescape]
        * xref:cops_lint.adoc#linturiregexp[Lint/UriRegexp]
        * xref:cops_lint.adoc#lintuselessaccessmodifier[Lint/UselessAccessModifier]
        * xref:cops_lint.adoc#lintuselessassignment[Lint/UselessAssignment]
        * xref:cops_lint.adoc#lintuselesselsewithoutrescue[Lint/UselessElseWithoutRescue]
        * xref:cops_lint.adoc#lintuselessmethoddefinition[Lint/UselessMethodDefinition]
        * xref:cops_lint.adoc#lintuselessrescue[Lint/UselessRescue]
        * xref:cops_lint.adoc#lintuselessruby2keywords[Lint/UselessRuby2Keywords]
        * xref:cops_lint.adoc#lintuselesssettercall[Lint/UselessSetterCall]
        * xref:cops_lint.adoc#lintuselesstimes[Lint/UselessTimes]
        * xref:cops_lint.adoc#lintvoid[Lint/Void]

        === Department xref:cops_metrics.adoc[Metrics]

        * xref:cops_metrics.adoc#metricsabcsize[Metrics/AbcSize]
        * xref:cops_metrics.adoc#metricsblocklength[Metrics/BlockLength]
        * xref:cops_metrics.adoc#metricsblocknesting[Metrics/BlockNesting]
        * xref:cops_metrics.adoc#metricsclasslength[Metrics/ClassLength]
        * xref:cops_metrics.adoc#metricscollectionliterallength[Metrics/CollectionLiteralLength]
        * xref:cops_metrics.adoc#metricscyclomaticcomplexity[Metrics/CyclomaticComplexity]
        * xref:cops_metrics.adoc#metricsmethodlength[Metrics/MethodLength]
        * xref:cops_metrics.adoc#metricsmodulelength[Metrics/ModuleLength]
        * xref:cops_metrics.adoc#metricsparameterlists[Metrics/ParameterLists]
        * xref:cops_metrics.adoc#metricsperceivedcomplexity[Metrics/PerceivedComplexity]

        === Department xref:cops_migration.adoc[Migration]

        * xref:cops_migration.adoc#migrationdepartmentname[Migration/DepartmentName]

        === Department xref:cops_naming.adoc[Naming]

        * xref:cops_naming.adoc#namingaccessormethodname[Naming/AccessorMethodName]
        * xref:cops_naming.adoc#namingasciiidentifiers[Naming/AsciiIdentifiers]
        * xref:cops_naming.adoc#namingbinaryoperatorparametername[Naming/BinaryOperatorParameterName]
        * xref:cops_naming.adoc#namingblockforwarding[Naming/BlockForwarding]
        * xref:cops_naming.adoc#namingblockparametername[Naming/BlockParameterName]
        * xref:cops_naming.adoc#namingclassandmodulecamelcase[Naming/ClassAndModuleCamelCase]
        * xref:cops_naming.adoc#namingconstantname[Naming/ConstantName]
        * xref:cops_naming.adoc#namingfilename[Naming/FileName]
        * xref:cops_naming.adoc#namingheredocdelimitercase[Naming/HeredocDelimiterCase]
        * xref:cops_naming.adoc#namingheredocdelimiternaming[Naming/HeredocDelimiterNaming]
        * xref:cops_naming.adoc#naminginclusivelanguage[Naming/InclusiveLanguage]
        * xref:cops_naming.adoc#namingmemoizedinstancevariablename[Naming/MemoizedInstanceVariableName]
        * xref:cops_naming.adoc#namingmethodname[Naming/MethodName]
        * xref:cops_naming.adoc#namingmethodparametername[Naming/MethodParameterName]
        * xref:cops_naming.adoc#namingpredicatename[Naming/PredicateName]
        * xref:cops_naming.adoc#namingrescuedexceptionsvariablename[Naming/RescuedExceptionsVariableName]
        * xref:cops_naming.adoc#namingvariablename[Naming/VariableName]
        * xref:cops_naming.adoc#namingvariablenumber[Naming/VariableNumber]

        === Department xref:cops_security.adoc[Security]

        * xref:cops_security.adoc#securitycompoundhash[Security/CompoundHash]
        * xref:cops_security.adoc#securityeval[Security/Eval]
        * xref:cops_security.adoc#securityiomethods[Security/IoMethods]
        * xref:cops_security.adoc#securityjsonload[Security/JSONLoad]
        * xref:cops_security.adoc#securitymarshalload[Security/MarshalLoad]
        * xref:cops_security.adoc#securityopen[Security/Open]
        * xref:cops_security.adoc#securityyamlload[Security/YAMLLoad]

        === Department xref:cops_style.adoc[Style]

        * xref:cops_style.adoc#styleaccessmodifierdeclarations[Style/AccessModifierDeclarations]
        * xref:cops_style.adoc#styleaccessorgrouping[Style/AccessorGrouping]
        * xref:cops_style.adoc#stylealias[Style/Alias]
        * xref:cops_style.adoc#styleandor[Style/AndOr]
        * xref:cops_style.adoc#styleargumentsforwarding[Style/ArgumentsForwarding]
        * xref:cops_style.adoc#stylearraycoercion[Style/ArrayCoercion]
        * xref:cops_style.adoc#stylearrayfirstlast[Style/ArrayFirstLast]
        * xref:cops_style.adoc#stylearrayintersect[Style/ArrayIntersect]
        * xref:cops_style.adoc#stylearrayjoin[Style/ArrayJoin]
        * xref:cops_style.adoc#styleasciicomments[Style/AsciiComments]
        * xref:cops_style.adoc#styleattr[Style/Attr]
        * xref:cops_style.adoc#styleautoresourcecleanup[Style/AutoResourceCleanup]
        * xref:cops_style.adoc#stylebarepercentliterals[Style/BarePercentLiterals]
        * xref:cops_style.adoc#stylebeginblock[Style/BeginBlock]
        * xref:cops_style.adoc#stylebisectedattraccessor[Style/BisectedAttrAccessor]
        * xref:cops_style.adoc#styleblockcomments[Style/BlockComments]
        * xref:cops_style.adoc#styleblockdelimiters[Style/BlockDelimiters]
        * xref:cops_style.adoc#stylecaseequality[Style/CaseEquality]
        * xref:cops_style.adoc#stylecaselikeif[Style/CaseLikeIf]
        * xref:cops_style.adoc#stylecharacterliteral[Style/CharacterLiteral]
        * xref:cops_style.adoc#styleclassandmodulechildren[Style/ClassAndModuleChildren]
        * xref:cops_style.adoc#styleclasscheck[Style/ClassCheck]
        * xref:cops_style.adoc#styleclassequalitycomparison[Style/ClassEqualityComparison]
        * xref:cops_style.adoc#styleclassmethods[Style/ClassMethods]
        * xref:cops_style.adoc#styleclassmethodsdefinitions[Style/ClassMethodsDefinitions]
        * xref:cops_style.adoc#styleclassvars[Style/ClassVars]
        * xref:cops_style.adoc#stylecollectioncompact[Style/CollectionCompact]
        * xref:cops_style.adoc#stylecollectionmethods[Style/CollectionMethods]
        * xref:cops_style.adoc#stylecolonmethodcall[Style/ColonMethodCall]
        * xref:cops_style.adoc#stylecolonmethoddefinition[Style/ColonMethodDefinition]
        * xref:cops_style.adoc#stylecombinableloops[Style/CombinableLoops]
        * xref:cops_style.adoc#stylecommandliteral[Style/CommandLiteral]
        * xref:cops_style.adoc#stylecommentannotation[Style/CommentAnnotation]
        * xref:cops_style.adoc#stylecommentedkeyword[Style/CommentedKeyword]
        * xref:cops_style.adoc#stylecomparableclamp[Style/ComparableClamp]
        * xref:cops_style.adoc#styleconcatarrayliterals[Style/ConcatArrayLiterals]
        * xref:cops_style.adoc#styleconditionalassignment[Style/ConditionalAssignment]
        * xref:cops_style.adoc#styleconstantvisibility[Style/ConstantVisibility]
        * xref:cops_style.adoc#stylecopyright[Style/Copyright]
        * xref:cops_style.adoc#styledatainheritance[Style/DataInheritance]
        * xref:cops_style.adoc#styledatetime[Style/DateTime]
        * xref:cops_style.adoc#styledefwithparentheses[Style/DefWithParentheses]
        * xref:cops_style.adoc#styledir[Style/Dir]
        * xref:cops_style.adoc#styledirempty[Style/DirEmpty]
        * xref:cops_style.adoc#styledisablecopswithinsourcecodedirective[Style/DisableCopsWithinSourceCodeDirective]
        * xref:cops_style.adoc#styledocumentdynamicevaldefinition[Style/DocumentDynamicEvalDefinition]
        * xref:cops_style.adoc#styledocumentation[Style/Documentation]
        * xref:cops_style.adoc#styledocumentationmethod[Style/DocumentationMethod]
        * xref:cops_style.adoc#styledoublecopdisabledirective[Style/DoubleCopDisableDirective]
        * xref:cops_style.adoc#styledoublenegation[Style/DoubleNegation]
        * xref:cops_style.adoc#styleeachforsimpleloop[Style/EachForSimpleLoop]
        * xref:cops_style.adoc#styleeachwithobject[Style/EachWithObject]
        * xref:cops_style.adoc#styleemptyblockparameter[Style/EmptyBlockParameter]
        * xref:cops_style.adoc#styleemptycasecondition[Style/EmptyCaseCondition]
        * xref:cops_style.adoc#styleemptyelse[Style/EmptyElse]
        * xref:cops_style.adoc#styleemptyheredoc[Style/EmptyHeredoc]
        * xref:cops_style.adoc#styleemptylambdaparameter[Style/EmptyLambdaParameter]
        * xref:cops_style.adoc#styleemptyliteral[Style/EmptyLiteral]
        * xref:cops_style.adoc#styleemptymethod[Style/EmptyMethod]
        * xref:cops_style.adoc#styleencoding[Style/Encoding]
        * xref:cops_style.adoc#styleendblock[Style/EndBlock]
        * xref:cops_style.adoc#styleendlessmethod[Style/EndlessMethod]
        * xref:cops_style.adoc#styleenvhome[Style/EnvHome]
        * xref:cops_style.adoc#styleevalwithlocation[Style/EvalWithLocation]
        * xref:cops_style.adoc#styleevenodd[Style/EvenOdd]
        * xref:cops_style.adoc#styleexactregexpmatch[Style/ExactRegexpMatch]
        * xref:cops_style.adoc#styleexpandpatharguments[Style/ExpandPathArguments]
        * xref:cops_style.adoc#styleexplicitblockargument[Style/ExplicitBlockArgument]
        * xref:cops_style.adoc#styleexponentialnotation[Style/ExponentialNotation]
        * xref:cops_style.adoc#stylefetchenvvar[Style/FetchEnvVar]
        * xref:cops_style.adoc#stylefileempty[Style/FileEmpty]
        * xref:cops_style.adoc#stylefileread[Style/FileRead]
        * xref:cops_style.adoc#stylefilewrite[Style/FileWrite]
        * xref:cops_style.adoc#stylefloatdivision[Style/FloatDivision]
        * xref:cops_style.adoc#stylefor[Style/For]
        * xref:cops_style.adoc#styleformatstring[Style/FormatString]
        * xref:cops_style.adoc#styleformatstringtoken[Style/FormatStringToken]
        * xref:cops_style.adoc#stylefrozenstringliteralcomment[Style/FrozenStringLiteralComment]
        * xref:cops_style.adoc#styleglobalstdstream[Style/GlobalStdStream]
        * xref:cops_style.adoc#styleglobalvars[Style/GlobalVars]
        * xref:cops_style.adoc#styleguardclause[Style/GuardClause]
        * xref:cops_style.adoc#stylehashaslastarrayitem[Style/HashAsLastArrayItem]
        * xref:cops_style.adoc#stylehashconversion[Style/HashConversion]
        * xref:cops_style.adoc#stylehasheachmethods[Style/HashEachMethods]
        * xref:cops_style.adoc#stylehashexcept[Style/HashExcept]
        * xref:cops_style.adoc#stylehashlikecase[Style/HashLikeCase]
        * xref:cops_style.adoc#stylehashsyntax[Style/HashSyntax]
        * xref:cops_style.adoc#stylehashtransformkeys[Style/HashTransformKeys]
        * xref:cops_style.adoc#stylehashtransformvalues[Style/HashTransformValues]
        * xref:cops_style.adoc#styleidenticalconditionalbranches[Style/IdenticalConditionalBranches]
        * xref:cops_style.adoc#styleifinsideelse[Style/IfInsideElse]
        * xref:cops_style.adoc#styleifunlessmodifier[Style/IfUnlessModifier]
        * xref:cops_style.adoc#styleifunlessmodifierofifunless[Style/IfUnlessModifierOfIfUnless]
        * xref:cops_style.adoc#styleifwithbooleanliteralbranches[Style/IfWithBooleanLiteralBranches]
        * xref:cops_style.adoc#styleifwithsemicolon[Style/IfWithSemicolon]
        * xref:cops_style.adoc#styleimplicitruntimeerror[Style/ImplicitRuntimeError]
        * xref:cops_style.adoc#styleinpatternthen[Style/InPatternThen]
        * xref:cops_style.adoc#styleinfiniteloop[Style/InfiniteLoop]
        * xref:cops_style.adoc#styleinlinecomment[Style/InlineComment]
        * xref:cops_style.adoc#styleinversemethods[Style/InverseMethods]
        * xref:cops_style.adoc#styleinvertibleunlesscondition[Style/InvertibleUnlessCondition]
        * xref:cops_style.adoc#styleipaddresses[Style/IpAddresses]
        * xref:cops_style.adoc#stylekeywordparametersorder[Style/KeywordParametersOrder]
        * xref:cops_style.adoc#stylelambda[Style/Lambda]
        * xref:cops_style.adoc#stylelambdacall[Style/LambdaCall]
        * xref:cops_style.adoc#stylelineendconcatenation[Style/LineEndConcatenation]
        * xref:cops_style.adoc#stylemagiccommentformat[Style/MagicCommentFormat]
        * xref:cops_style.adoc#stylemapcompactwithconditionalblock[Style/MapCompactWithConditionalBlock]
        * xref:cops_style.adoc#stylemapintoarray[Style/MapIntoArray]
        * xref:cops_style.adoc#stylemaptohash[Style/MapToHash]
        * xref:cops_style.adoc#stylemaptoset[Style/MapToSet]
        * xref:cops_style.adoc#stylemethodcallwithargsparentheses[Style/MethodCallWithArgsParentheses]
        * xref:cops_style.adoc#stylemethodcallwithoutargsparentheses[Style/MethodCallWithoutArgsParentheses]
        * xref:cops_style.adoc#stylemethodcalledondoendblock[Style/MethodCalledOnDoEndBlock]
        * xref:cops_style.adoc#stylemethoddefparentheses[Style/MethodDefParentheses]
        * xref:cops_style.adoc#styleminmax[Style/MinMax]
        * xref:cops_style.adoc#styleminmaxcomparison[Style/MinMaxComparison]
        * xref:cops_style.adoc#stylemissingelse[Style/MissingElse]
        * xref:cops_style.adoc#stylemissingrespondtomissing[Style/MissingRespondToMissing]
        * xref:cops_style.adoc#stylemixingrouping[Style/MixinGrouping]
        * xref:cops_style.adoc#stylemixinusage[Style/MixinUsage]
        * xref:cops_style.adoc#stylemodulefunction[Style/ModuleFunction]
        * xref:cops_style.adoc#stylemultilineblockchain[Style/MultilineBlockChain]
        * xref:cops_style.adoc#stylemultilineifmodifier[Style/MultilineIfModifier]
        * xref:cops_style.adoc#stylemultilineifthen[Style/MultilineIfThen]
        * xref:cops_style.adoc#stylemultilineinpatternthen[Style/MultilineInPatternThen]
        * xref:cops_style.adoc#stylemultilinememoization[Style/MultilineMemoization]
        * xref:cops_style.adoc#stylemultilinemethodsignature[Style/MultilineMethodSignature]
        * xref:cops_style.adoc#stylemultilineternaryoperator[Style/MultilineTernaryOperator]
        * xref:cops_style.adoc#stylemultilinewhenthen[Style/MultilineWhenThen]
        * xref:cops_style.adoc#stylemultiplecomparison[Style/MultipleComparison]
        * xref:cops_style.adoc#stylemutableconstant[Style/MutableConstant]
        * xref:cops_style.adoc#stylenegatedif[Style/NegatedIf]
        * xref:cops_style.adoc#stylenegatedifelsecondition[Style/NegatedIfElseCondition]
        * xref:cops_style.adoc#stylenegatedunless[Style/NegatedUnless]
        * xref:cops_style.adoc#stylenegatedwhile[Style/NegatedWhile]
        * xref:cops_style.adoc#stylenestedfiledirname[Style/NestedFileDirname]
        * xref:cops_style.adoc#stylenestedmodifier[Style/NestedModifier]
        * xref:cops_style.adoc#stylenestedparenthesizedcalls[Style/NestedParenthesizedCalls]
        * xref:cops_style.adoc#stylenestedternaryoperator[Style/NestedTernaryOperator]
        * xref:cops_style.adoc#stylenext[Style/Next]
        * xref:cops_style.adoc#stylenilcomparison[Style/NilComparison]
        * xref:cops_style.adoc#stylenillambda[Style/NilLambda]
        * xref:cops_style.adoc#stylenonnilcheck[Style/NonNilCheck]
        * xref:cops_style.adoc#stylenot[Style/Not]
        * xref:cops_style.adoc#stylenumberedparameters[Style/NumberedParameters]
        * xref:cops_style.adoc#stylenumberedparameterslimit[Style/NumberedParametersLimit]
        * xref:cops_style.adoc#stylenumericliteralprefix[Style/NumericLiteralPrefix]
        * xref:cops_style.adoc#stylenumericliterals[Style/NumericLiterals]
        * xref:cops_style.adoc#stylenumericpredicate[Style/NumericPredicate]
        * xref:cops_style.adoc#styleobjectthen[Style/ObjectThen]
        * xref:cops_style.adoc#styleonelineconditional[Style/OneLineConditional]
        * xref:cops_style.adoc#styleopenstructuse[Style/OpenStructUse]
        * xref:cops_style.adoc#styleoperatormethodcall[Style/OperatorMethodCall]
        * xref:cops_style.adoc#styleoptionhash[Style/OptionHash]
        * xref:cops_style.adoc#styleoptionalarguments[Style/OptionalArguments]
        * xref:cops_style.adoc#styleoptionalbooleanparameter[Style/OptionalBooleanParameter]
        * xref:cops_style.adoc#styleorassignment[Style/OrAssignment]
        * xref:cops_style.adoc#styleparallelassignment[Style/ParallelAssignment]
        * xref:cops_style.adoc#styleparenthesesaroundcondition[Style/ParenthesesAroundCondition]
        * xref:cops_style.adoc#stylepercentliteraldelimiters[Style/PercentLiteralDelimiters]
        * xref:cops_style.adoc#stylepercentqliterals[Style/PercentQLiterals]
        * xref:cops_style.adoc#styleperlbackrefs[Style/PerlBackrefs]
        * xref:cops_style.adoc#stylepreferredhashmethods[Style/PreferredHashMethods]
        * xref:cops_style.adoc#styleproc[Style/Proc]
        * xref:cops_style.adoc#stylequotedsymbols[Style/QuotedSymbols]
        * xref:cops_style.adoc#styleraiseargs[Style/RaiseArgs]
        * xref:cops_style.adoc#stylerandomwithoffset[Style/RandomWithOffset]
        * xref:cops_style.adoc#styleredundantargument[Style/RedundantArgument]
        * xref:cops_style.adoc#styleredundantarrayconstructor[Style/RedundantArrayConstructor]
        * xref:cops_style.adoc#styleredundantassignment[Style/RedundantAssignment]
        * xref:cops_style.adoc#styleredundantbegin[Style/RedundantBegin]
        * xref:cops_style.adoc#styleredundantcapitalw[Style/RedundantCapitalW]
        * xref:cops_style.adoc#styleredundantcondition[Style/RedundantCondition]
        * xref:cops_style.adoc#styleredundantconditional[Style/RedundantConditional]
        * xref:cops_style.adoc#styleredundantconstantbase[Style/RedundantConstantBase]
        * xref:cops_style.adoc#styleredundantcurrentdirectoryinpath[Style/RedundantCurrentDirectoryInPath]
        * xref:cops_style.adoc#styleredundantdoublesplathashbraces[Style/RedundantDoubleSplatHashBraces]
        * xref:cops_style.adoc#styleredundanteach[Style/RedundantEach]
        * xref:cops_style.adoc#styleredundantexception[Style/RedundantException]
        * xref:cops_style.adoc#styleredundantfetchblock[Style/RedundantFetchBlock]
        * xref:cops_style.adoc#styleredundantfileextensioninrequire[Style/RedundantFileExtensionInRequire]
        * xref:cops_style.adoc#styleredundantfilterchain[Style/RedundantFilterChain]
        * xref:cops_style.adoc#styleredundantfreeze[Style/RedundantFreeze]
        * xref:cops_style.adoc#styleredundantheredocdelimiterquotes[Style/RedundantHeredocDelimiterQuotes]
        * xref:cops_style.adoc#styleredundantinitialize[Style/RedundantInitialize]
        * xref:cops_style.adoc#styleredundantinterpolation[Style/RedundantInterpolation]
        * xref:cops_style.adoc#styleredundantlinecontinuation[Style/RedundantLineContinuation]
        * xref:cops_style.adoc#styleredundantparentheses[Style/RedundantParentheses]
        * xref:cops_style.adoc#styleredundantpercentq[Style/RedundantPercentQ]
        * xref:cops_style.adoc#styleredundantregexpargument[Style/RedundantRegexpArgument]
        * xref:cops_style.adoc#styleredundantregexpcharacterclass[Style/RedundantRegexpCharacterClass]
        * xref:cops_style.adoc#styleredundantregexpconstructor[Style/RedundantRegexpConstructor]
        * xref:cops_style.adoc#styleredundantregexpescape[Style/RedundantRegexpEscape]
        * xref:cops_style.adoc#styleredundantreturn[Style/RedundantReturn]
        * xref:cops_style.adoc#styleredundantself[Style/RedundantSelf]
        * xref:cops_style.adoc#styleredundantselfassignment[Style/RedundantSelfAssignment]
        * xref:cops_style.adoc#styleredundantselfassignmentbranch[Style/RedundantSelfAssignmentBranch]
        * xref:cops_style.adoc#styleredundantsort[Style/RedundantSort]
        * xref:cops_style.adoc#styleredundantsortby[Style/RedundantSortBy]
        * xref:cops_style.adoc#styleredundantstringescape[Style/RedundantStringEscape]
        * xref:cops_style.adoc#styleregexpliteral[Style/RegexpLiteral]
        * xref:cops_style.adoc#stylerequireorder[Style/RequireOrder]
        * xref:cops_style.adoc#stylerescuemodifier[Style/RescueModifier]
        * xref:cops_style.adoc#stylerescuestandarderror[Style/RescueStandardError]
        * xref:cops_style.adoc#stylereturnnil[Style/ReturnNil]
        * xref:cops_style.adoc#stylereturnnilinpredicatemethoddefinition[Style/ReturnNilInPredicateMethodDefinition]
        * xref:cops_style.adoc#stylesafenavigation[Style/SafeNavigation]
        * xref:cops_style.adoc#stylesample[Style/Sample]
        * xref:cops_style.adoc#styleselectbyregexp[Style/SelectByRegexp]
        * xref:cops_style.adoc#styleselfassignment[Style/SelfAssignment]
        * xref:cops_style.adoc#stylesemicolon[Style/Semicolon]
        * xref:cops_style.adoc#stylesend[Style/Send]
        * xref:cops_style.adoc#stylesendwithliteralmethodname[Style/SendWithLiteralMethodName]
        * xref:cops_style.adoc#stylesignalexception[Style/SignalException]
        * xref:cops_style.adoc#stylesingleargumentdig[Style/SingleArgumentDig]
        * xref:cops_style.adoc#stylesinglelineblockparams[Style/SingleLineBlockParams]
        * xref:cops_style.adoc#stylesinglelinedoendblock[Style/SingleLineDoEndBlock]
        * xref:cops_style.adoc#stylesinglelinemethods[Style/SingleLineMethods]
        * xref:cops_style.adoc#styleslicingwithrange[Style/SlicingWithRange]
        * xref:cops_style.adoc#stylesolenestedconditional[Style/SoleNestedConditional]
        * xref:cops_style.adoc#stylespecialglobalvars[Style/SpecialGlobalVars]
        * xref:cops_style.adoc#stylestabbylambdaparentheses[Style/StabbyLambdaParentheses]
        * xref:cops_style.adoc#stylestaticclass[Style/StaticClass]
        * xref:cops_style.adoc#stylestderrputs[Style/StderrPuts]
        * xref:cops_style.adoc#stylestringchars[Style/StringChars]
        * xref:cops_style.adoc#stylestringconcatenation[Style/StringConcatenation]
        * xref:cops_style.adoc#stylestringhashkeys[Style/StringHashKeys]
        * xref:cops_style.adoc#stylestringliterals[Style/StringLiterals]
        * xref:cops_style.adoc#stylestringliteralsininterpolation[Style/StringLiteralsInInterpolation]
        * xref:cops_style.adoc#stylestringmethods[Style/StringMethods]
        * xref:cops_style.adoc#stylestrip[Style/Strip]
        * xref:cops_style.adoc#stylestructinheritance[Style/StructInheritance]
        * xref:cops_style.adoc#stylesuperarguments[Style/SuperArguments]
        * xref:cops_style.adoc#stylesuperwithargsparentheses[Style/SuperWithArgsParentheses]
        * xref:cops_style.adoc#styleswapvalues[Style/SwapValues]
        * xref:cops_style.adoc#stylesymbolarray[Style/SymbolArray]
        * xref:cops_style.adoc#stylesymbolliteral[Style/SymbolLiteral]
        * xref:cops_style.adoc#stylesymbolproc[Style/SymbolProc]
        * xref:cops_style.adoc#styleternaryparentheses[Style/TernaryParentheses]
        * xref:cops_style.adoc#styletoplevelmethoddefinition[Style/TopLevelMethodDefinition]
        * xref:cops_style.adoc#styletrailingbodyonclass[Style/TrailingBodyOnClass]
        * xref:cops_style.adoc#styletrailingbodyonmethoddefinition[Style/TrailingBodyOnMethodDefinition]
        * xref:cops_style.adoc#styletrailingbodyonmodule[Style/TrailingBodyOnModule]
        * xref:cops_style.adoc#styletrailingcommainarguments[Style/TrailingCommaInArguments]
        * xref:cops_style.adoc#styletrailingcommainarrayliteral[Style/TrailingCommaInArrayLiteral]
        * xref:cops_style.adoc#styletrailingcommainblockargs[Style/TrailingCommaInBlockArgs]
        * xref:cops_style.adoc#styletrailingcommainhashliteral[Style/TrailingCommaInHashLiteral]
        * xref:cops_style.adoc#styletrailingmethodendstatement[Style/TrailingMethodEndStatement]
        * xref:cops_style.adoc#styletrailingunderscorevariable[Style/TrailingUnderscoreVariable]
        * xref:cops_style.adoc#styletrivialaccessors[Style/TrivialAccessors]
        * xref:cops_style.adoc#styleunlesselse[Style/UnlessElse]
        * xref:cops_style.adoc#styleunlesslogicaloperators[Style/UnlessLogicalOperators]
        * xref:cops_style.adoc#styleunpackfirst[Style/UnpackFirst]
        * xref:cops_style.adoc#stylevariableinterpolation[Style/VariableInterpolation]
        * xref:cops_style.adoc#stylewhenthen[Style/WhenThen]
        * xref:cops_style.adoc#stylewhileuntildo[Style/WhileUntilDo]
        * xref:cops_style.adoc#stylewhileuntilmodifier[Style/WhileUntilModifier]
        * xref:cops_style.adoc#stylewordarray[Style/WordArray]
        * xref:cops_style.adoc#styleyamlfileread[Style/YAMLFileRead]
        * xref:cops_style.adoc#styleyodacondition[Style/YodaCondition]
        * xref:cops_style.adoc#styleyodaexpression[Style/YodaExpression]
        * xref:cops_style.adoc#stylezerolengthpredicate[Style/ZeroLengthPredicate]

        // END_COP_LIST
  recorded_at: Mon, 27 May 2024 05:30:37 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_bundler.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '8938'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"2db792edd11b9aefe7736697add7e8ec647d878365c8dd156e78786736cd970f"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 68D2:19D255:9DDA8E:A83CA0:66541A7D
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:38 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230046-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787838.936384,VS0,VE188
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 796602520d4123e2286b683e146cd86886702401
      Expires:
      - Mon, 27 May 2024 05:35:38 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Bundler

        == Bundler/DuplicatedGem

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.46
        | 1.40
        |===

        A Gem's requirements should be listed only once in a Gemfile.

        === Examples

        [source,ruby]
        ----
        # bad
        gem 'rubocop'
        gem 'rubocop'

        # bad
        group :development do
          gem 'rubocop'
        end

        group :test do
          gem 'rubocop'
        end

        # good
        group :development, :test do
          gem 'rubocop'
        end

        # good
        gem 'rubocop', groups: [:development, :test]

        # good - conditional declaration
        if Dir.exist?(local)
          gem 'rubocop', path: local
        elsif ENV['RUBOCOP_VERSION'] == 'master'
          gem 'rubocop', git: 'https://github.com/rubocop/rubocop.git'
        else
          gem 'rubocop', '~> 0.90.0'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array
        |===

        == Bundler/DuplicatedGroup

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 1.56
        | -
        |===

        A Gem group, or a set of groups, should be listed only once in a Gemfile.

        For example, if the values of `source`, `git`, `platforms`, or `path`
        surrounding `group` are different, no offense will be registered:

        [source,ruby]
        -----
        platforms :ruby do
          group :default do
            gem 'openssl'
          end
        end

        platforms :jruby do
          group :default do
            gem 'jruby-openssl'
          end
        end
        -----

        === Examples

        [source,ruby]
        ----
        # bad
        group :development do
          gem 'rubocop'
        end

        group :development do
          gem 'rubocop-rails'
        end

        # bad (same set of groups declared twice)
        group :development, :test do
          gem 'rubocop'
        end

        group :test, :development do
          gem 'rspec'
        end

        # good
        group :development do
          gem 'rubocop'
        end

        group :development, :test do
          gem 'rspec'
        end

        # good
        gem 'rubocop', groups: [:development, :test]
        gem 'rspec', groups: [:development, :test]
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array
        |===

        == Bundler/GemComment

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 0.59
        | 0.85
        |===

        Each gem in the Gemfile should have a comment explaining
        its purpose in the project, or the reason for its version
        or source.

        The optional "OnlyFor" configuration array
        can be used to only register offenses when the gems
        use certain options or have version specifiers.

        When "version_specifiers" is included, a comment
        will be enforced if the gem has any version specifier.

        When "restrictive_version_specifiers" is included, a comment
        will be enforced if the gem has a version specifier that
        holds back the version of the gem.

        For any other value in the array, a comment will be enforced for
        a gem if an option by the same name is present.
        A useful use case is to enforce a comment when using
        options that change the source of a gem:

        - `bitbucket`
        - `gist`
        - `git`
        - `github`
        - `source`

        For a full list of options supported by bundler,
        see https://bundler.io/man/gemfile.5.html
        .

        === Examples

        ==== OnlyFor: [] (default)

        [source,ruby]
        ----
        # bad

        gem 'foo'

        # good

        # Helpers for the foo things.
        gem 'foo'
        ----

        ==== OnlyFor: ['version_specifiers']

        [source,ruby]
        ----
        # bad

        gem 'foo', '< 2.1'

        # good

        # Version 2.1 introduces breaking change baz
        gem 'foo', '< 2.1'
        ----

        ==== OnlyFor: ['restrictive_version_specifiers']

        [source,ruby]
        ----
        # bad

        gem 'foo', '< 2.1'

        # good

        gem 'foo', '>= 1.0'

        # Version 2.1 introduces breaking change baz
        gem 'foo', '< 2.1'
        ----

        ==== OnlyFor: ['version_specifiers', 'github']

        [source,ruby]
        ----
        # bad

        gem 'foo', github: 'some_account/some_fork_of_foo'

        gem 'bar', '< 2.1'

        # good

        # Using this fork because baz
        gem 'foo', github: 'some_account/some_fork_of_foo'

        # Version 2.1 introduces breaking change baz
        gem 'bar', '< 2.1'
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array

        | IgnoredGems
        | `[]`
        | Array

        | OnlyFor
        | `[]`
        | Array
        |===

        == Bundler/GemFilename

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 1.20
        | -
        |===

        Verifies that a project contains Gemfile or gems.rb file and correct
        associated lock file based on the configuration.

        === Examples

        ==== EnforcedStyle: Gemfile (default)

        [source,ruby]
        ----
        # bad
        Project contains gems.rb and gems.locked files

        # bad
        Project contains Gemfile and gems.locked file

        # good
        Project contains Gemfile and Gemfile.lock
        ----

        ==== EnforcedStyle: gems.rb

        [source,ruby]
        ----
        # bad
        Project contains Gemfile and Gemfile.lock files

        # bad
        Project contains gems.rb and Gemfile.lock file

        # good
        Project contains gems.rb and gems.locked files
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | EnforcedStyle
        | `Gemfile`
        | `Gemfile`, `gems.rb`

        | Include
        | `+**/Gemfile+`, `+**/gems.rb+`, `+**/Gemfile.lock+`, `+**/gems.locked+`
        | Array
        |===

        == Bundler/GemVersion

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 1.14
        | -
        |===

        Enforce that Gem version specifications or a commit reference (branch,
        ref, or tag) are either required or forbidden.

        === Examples

        ==== EnforcedStyle: required (default)

        [source,ruby]
        ----
        # bad
        gem 'rubocop'

        # good
        gem 'rubocop', '~> 1.12'

        # good
        gem 'rubocop', '>= 1.10.0'

        # good
        gem 'rubocop', '>= 1.5.0', '< 1.10.0'

        # good
        gem 'rubocop', branch: 'feature-branch'

        # good
        gem 'rubocop', ref: '74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b'

        # good
        gem 'rubocop', tag: 'v1.17.0'
        ----

        ==== EnforcedStyle: forbidden

        [source,ruby]
        ----
        # good
        gem 'rubocop'

        # bad
        gem 'rubocop', '~> 1.12'

        # bad
        gem 'rubocop', '>= 1.10.0'

        # bad
        gem 'rubocop', '>= 1.5.0', '< 1.10.0'

        # bad
        gem 'rubocop', branch: 'feature-branch'

        # bad
        gem 'rubocop', ref: '74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b'

        # bad
        gem 'rubocop', tag: 'v1.17.0'
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | EnforcedStyle
        | `required`
        | `required`, `forbidden`

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array

        | AllowedGems
        | `[]`
        | Array
        |===

        == Bundler/InsecureProtocolSource

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.50
        | 1.40
        |===

        Passing symbol arguments to `source` (e.g. `source :rubygems`) is
        deprecated because they default to using HTTP requests. Instead, specify
        `'https://rubygems.org'` if possible, or `'http://rubygems.org'` if not.

        When autocorrecting, this cop will replace symbol arguments with
        `'https://rubygems.org'`.

        This cop will not replace existing sources that use `http://`. This may
        be necessary where HTTPS is not available. For example, where using an
        internal gem server via an intranet, or where HTTPS is prohibited.
        However, you should strongly prefer `https://` where possible, as it is
        more secure.

        If you don't allow `http://`, please set `false` to `AllowHttpProtocol`.
        This option is `true` by default for safe autocorrection.

        === Examples

        [source,ruby]
        ----
        # bad
        source :gemcutter
        source :rubygems
        source :rubyforge

        # good
        source 'https://rubygems.org' # strongly recommended
        ----

        ==== AllowHttpProtocol: true (default)

        [source,ruby]
        ----
        # good
        source 'http://rubygems.org' # use only if HTTPS is unavailable
        ----

        ==== AllowHttpProtocol: false

        [source,ruby]
        ----
        # bad
        source 'http://rubygems.org'
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | AllowHttpProtocol
        | `true`
        | Boolean

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array
        |===

        == Bundler/OrderedGems

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.46
        | 0.47
        |===

        Gems should be alphabetically sorted within groups.

        === Examples

        [source,ruby]
        ----
        # bad
        gem 'rubocop'
        gem 'rspec'

        # good
        gem 'rspec'
        gem 'rubocop'

        # good
        gem 'rubocop'

        gem 'rspec'
        ----

        ==== TreatCommentsAsGroupSeparators: true (default)

        [source,ruby]
        ----
        # good
        # For code quality
        gem 'rubocop'
        # For tests
        gem 'rspec'
        ----

        ==== TreatCommentsAsGroupSeparators: false

        [source,ruby]
        ----
        # bad
        # For code quality
        gem 'rubocop'
        # For tests
        gem 'rspec'
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | TreatCommentsAsGroupSeparators
        | `true`
        | Boolean

        | ConsiderPunctuation
        | `false`
        | Boolean

        | Include
        | `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array
        |===
  recorded_at: Mon, 27 May 2024 05:30:38 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_gemspec.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '10984'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"e9751fd7435976774c62c66779c584390152ee3d324de2b9e0e6a42cfbc98f56"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - C98E:3BC15A:1331E6C:146AE25:66541A7D
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:38 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230039-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787838.344481,VS0,VE199
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 03b349f0cc9be34edf4259af0dfcfd1bcbce0926
      Expires:
      - Mon, 27 May 2024 05:35:38 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Gemspec

        == Gemspec/DependencyVersion

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 1.29
        | -
        |===

        Enforce that gem dependency version specifications or a commit reference (branch,
        ref, or tag) are either required or forbidden.

        === Examples

        ==== EnforcedStyle: required (default)

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          spec.add_dependency 'parser'
        end

        # bad
        Gem::Specification.new do |spec|
          spec.add_development_dependency 'parser'
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_dependency 'parser', '>= 2.3.3.1', '< 3.0'
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_development_dependency 'parser', '>= 2.3.3.1', '< 3.0'
        end
        ----

        ==== EnforcedStyle: forbidden

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          spec.add_dependency 'parser', '>= 2.3.3.1', '< 3.0'
        end

        # bad
        Gem::Specification.new do |spec|
          spec.add_development_dependency 'parser', '>= 2.3.3.1', '< 3.0'
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_dependency 'parser'
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_development_dependency 'parser'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | EnforcedStyle
        | `required`
        | `required`, `forbidden`

        | Include
        | `+**/*.gemspec+`
        | Array

        | AllowedGems
        | `[]`
        | Array
        |===

        == Gemspec/DeprecatedAttributeAssignment

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.30
        | 1.40
        |===

        Checks that deprecated attributes are not set in a gemspec file.
        Removing deprecated attributes allows the user to receive smaller packed gems.

        === Examples

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          spec.name = 'your_cool_gem_name'
          spec.test_files = Dir.glob('test/**/*')
        end

        # bad
        Gem::Specification.new do |spec|
          spec.name = 'your_cool_gem_name'
          spec.test_files += Dir.glob('test/**/*')
        end

        # good
        Gem::Specification.new do |spec|
          spec.name = 'your_cool_gem_name'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        == Gemspec/DevelopmentDependencies

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 1.44
        | -
        |===

        Enforce that development dependencies for a gem are specified in
        `Gemfile`, rather than in the `gemspec` using
        `add_development_dependency`. Alternatively, using `EnforcedStyle:
        gemspec`, enforce that all dependencies are specified in `gemspec`,
        rather than in `Gemfile`.

        === Examples

        ==== EnforcedStyle: Gemfile (default)

        [source,ruby]
        ----
        # Specify runtime dependencies in your gemspec,
        # but all other dependencies in your Gemfile.

        # bad
        # example.gemspec
        s.add_development_dependency "foo"

        # good
        # Gemfile
        gem "foo"

        # good
        # gems.rb
        gem "foo"

        # good (with AllowedGems: ["bar"])
        # example.gemspec
        s.add_development_dependency "bar"
        ----

        ==== EnforcedStyle: gems.rb

        [source,ruby]
        ----
        # Specify runtime dependencies in your gemspec,
        # but all other dependencies in your Gemfile.
        #
        # Identical to `EnforcedStyle: Gemfile`, but with a different error message.
        # Rely on Bundler/GemFilename to enforce the use of `Gemfile` vs `gems.rb`.

        # bad
        # example.gemspec
        s.add_development_dependency "foo"

        # good
        # Gemfile
        gem "foo"

        # good
        # gems.rb
        gem "foo"

        # good (with AllowedGems: ["bar"])
        # example.gemspec
        s.add_development_dependency "bar"
        ----

        ==== EnforcedStyle: gemspec

        [source,ruby]
        ----
        # Specify all dependencies in your gemspec.

        # bad
        # Gemfile
        gem "foo"

        # good
        # example.gemspec
        s.add_development_dependency "foo"

        # good (with AllowedGems: ["bar"])
        # Gemfile
        gem "bar"
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | EnforcedStyle
        | `Gemfile`
        | `Gemfile`, `gems.rb`, `gemspec`

        | AllowedGems
        | `[]`
        | Array

        | Include
        | `+**/*.gemspec+`, `+**/Gemfile+`, `+**/gems.rb+`
        | Array
        |===

        == Gemspec/DuplicatedAssignment

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.52
        | 1.40
        |===

        An attribute assignment method calls should be listed only once
        in a gemspec.

        Assigning to an attribute with the same name using `spec.foo =` will be
        an unintended usage. On the other hand, duplication of methods such
        as `spec.requirements`, `spec.add_runtime_dependency`, and others are
        permitted because it is the intended use of appending values.

        === Examples

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          spec.name = 'rubocop'
          spec.name = 'rubocop2'
        end

        # good
        Gem::Specification.new do |spec|
          spec.name = 'rubocop'
        end

        # good
        Gem::Specification.new do |spec|
          spec.requirements << 'libmagick, v6.0'
          spec.requirements << 'A good graphics card'
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_runtime_dependency('parallel', '~> 1.10')
          spec.add_runtime_dependency('parser', '>= 2.3.3.1', '< 3.0')
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        == Gemspec/OrderedDependencies

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.51
        | -
        |===

        Dependencies in the gemspec should be alphabetically sorted.

        === Examples

        [source,ruby]
        ----
        # bad
        spec.add_dependency 'rubocop'
        spec.add_dependency 'rspec'

        # good
        spec.add_dependency 'rspec'
        spec.add_dependency 'rubocop'

        # good
        spec.add_dependency 'rubocop'

        spec.add_dependency 'rspec'

        # bad
        spec.add_development_dependency 'rubocop'
        spec.add_development_dependency 'rspec'

        # good
        spec.add_development_dependency 'rspec'
        spec.add_development_dependency 'rubocop'

        # good
        spec.add_development_dependency 'rubocop'

        spec.add_development_dependency 'rspec'

        # bad
        spec.add_runtime_dependency 'rubocop'
        spec.add_runtime_dependency 'rspec'

        # good
        spec.add_runtime_dependency 'rspec'
        spec.add_runtime_dependency 'rubocop'

        # good
        spec.add_runtime_dependency 'rubocop'

        spec.add_runtime_dependency 'rspec'
        ----

        ==== TreatCommentsAsGroupSeparators: true (default)

        [source,ruby]
        ----
        # good
        # For code quality
        spec.add_dependency 'rubocop'
        # For tests
        spec.add_dependency 'rspec'
        ----

        ==== TreatCommentsAsGroupSeparators: false

        [source,ruby]
        ----
        # bad
        # For code quality
        spec.add_dependency 'rubocop'
        # For tests
        spec.add_dependency 'rspec'
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | TreatCommentsAsGroupSeparators
        | `true`
        | Boolean

        | ConsiderPunctuation
        | `false`
        | Boolean

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        == Gemspec/RequireMFA

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.23
        | 1.40
        |===

        Requires a gemspec to have `rubygems_mfa_required` metadata set.

        This setting tells RubyGems that MFA (Multi-Factor Authentication) is
        required for accounts to be able perform privileged operations, such as
        (see RubyGems' documentation for the full list of privileged
        operations):

        * `gem push`
        * `gem yank`
        * `gem owner --add/remove`
        * adding or removing owners using gem ownership page

        This helps make your gem more secure, as users can be more
        confident that gem updates were pushed by maintainers.

        === Examples

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          # no `rubygems_mfa_required` metadata specified
        end

        # good
        Gem::Specification.new do |spec|
          spec.metadata = {
            'rubygems_mfa_required' => 'true'
          }
        end

        # good
        Gem::Specification.new do |spec|
          spec.metadata['rubygems_mfa_required'] = 'true'
        end

        # bad
        Gem::Specification.new do |spec|
          spec.metadata = {
            'rubygems_mfa_required' => 'false'
          }
        end

        # good
        Gem::Specification.new do |spec|
          spec.metadata = {
            'rubygems_mfa_required' => 'true'
          }
        end

        # bad
        Gem::Specification.new do |spec|
          spec.metadata['rubygems_mfa_required'] = 'false'
        end

        # good
        Gem::Specification.new do |spec|
          spec.metadata['rubygems_mfa_required'] = 'true'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        === References

        * https://guides.rubygems.org/mfa-requirement-opt-in/

        == Gemspec/RequiredRubyVersion

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.52
        | 1.40
        |===

        Checks that `required_ruby_version` in a gemspec file is set to a valid
        value (non-blank) and matches `TargetRubyVersion` as set in RuboCop's
        configuration for the gem.

        This ensures that RuboCop is using the same Ruby version as the gem.

        === Examples

        [source,ruby]
        ----
        # When `TargetRubyVersion` of .rubocop.yml is `2.5`.

        # bad
        Gem::Specification.new do |spec|
          # no `required_ruby_version` specified
        end

        # bad
        Gem::Specification.new do |spec|
          spec.required_ruby_version = '>= 2.4.0'
        end

        # bad
        Gem::Specification.new do |spec|
          spec.required_ruby_version = '>= 2.6.0'
        end

        # bad
        Gem::Specification.new do |spec|
          spec.required_ruby_version = ''
        end

        # good
        Gem::Specification.new do |spec|
          spec.required_ruby_version = '>= 2.5.0'
        end

        # good
        Gem::Specification.new do |spec|
          spec.required_ruby_version = '>= 2.5'
        end

        # accepted but not recommended
        Gem::Specification.new do |spec|
          spec.required_ruby_version = ['>= 2.5.0', '< 2.7.0']
        end

        # accepted but not recommended, since
        # Ruby does not really follow semantic versioning
        Gem::Specification.new do |spec|
          spec.required_ruby_version = '~> 2.5'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        == Gemspec/RubyVersionGlobalsUsage

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.72
        | 1.40
        |===

        Checks that `RUBY_VERSION` constant is not used in gemspec.
        Using `RUBY_VERSION` is dangerous because value of the
        constant is determined by `rake release`.
        It's possible to have dependency based on ruby version used
        to execute `rake release` and not user's ruby version.

        === Examples

        [source,ruby]
        ----
        # bad
        Gem::Specification.new do |spec|
          if RUBY_VERSION >= '3.0'
            spec.add_runtime_dependency 'gem_a'
          else
            spec.add_runtime_dependency 'gem_b'
          end
        end

        # good
        Gem::Specification.new do |spec|
          spec.add_runtime_dependency 'gem_a'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | Include
        | `+**/*.gemspec+`
        | Array
        |===

        === References

        * https://rubystyle.guide#no-ruby-version-in-the-gemspec
  recorded_at: Mon, 27 May 2024 05:30:38 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_layout.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '104775'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"fd4e84b71142e894dd1409df48d3fe34df38db9ed5641b0ef9dabfb7757cd897"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 7D80:23E66:13974FF:14D05F2:66541A7E
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:38 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230068-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787839.657448,VS0,VE179
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 4ffba6d952587c9ae954b289fc217aef68bb8a5c
      Expires:
      - Mon, 27 May 2024 05:35:38 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: "////\n  Do NOT edit this file by hand directly, as it is automatically
        generated.\n\n  Please make any necessary changes to the cop documentation
        within the source files themselves.\n////\n\n= Layout\n\n== Layout/AccessModifierIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nBare access modifiers
        (those not applying to specific methods) should be\nindented as deep as method
        definitions, or as deep as the class/module\nkeyword, depending on configuration.\n\n===
        Examples\n\n==== EnforcedStyle: indent (default)\n\n[source,ruby]\n----\n#
        bad\nclass Plumbus\nprivate\n  def smooth; end\nend\n\n# good\nclass Plumbus\n
        \ private\n  def smooth; end\nend\n----\n\n==== EnforcedStyle: outdent\n\n[source,ruby]\n----\n#
        bad\nclass Plumbus\n  private\n  def smooth; end\nend\n\n# good\nclass Plumbus\nprivate\n
        \ def smooth; end\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| EnforcedStyle\n| `indent`\n| `outdent`,
        `indent`\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n=== References\n\n*
        https://rubystyle.guide#indent-public-private-protected\n\n== Layout/ArgumentAlignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.68\n| 0.77\n|===\n\nHere we check
        if the arguments on a multi-line method\ndefinition are aligned.\n\n=== Examples\n\n====
        EnforcedStyle: with_first_argument (default)\n\n[source,ruby]\n----\n# good\n\nfoo
        :bar,\n    :baz,\n    key: value\n\nfoo(\n  :bar,\n  :baz,\n  key: value\n)\n\n#
        bad\n\nfoo :bar,\n  :baz,\n  key: value\n\nfoo(\n  :bar,\n    :baz,\n    key:
        value\n)\n----\n\n==== EnforcedStyle: with_fixed_indentation\n\n[source,ruby]\n----\n#
        good\n\nfoo :bar,\n  :baz,\n  key: value\n\n# bad\n\nfoo :bar,\n    :baz,\n
        \   key: value\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| EnforcedStyle\n| `with_first_argument`\n|
        `with_first_argument`, `with_fixed_indentation`\n\n| IndentationWidth\n| `<none>`\n|
        Integer\n|===\n\n=== References\n\n* https://rubystyle.guide#no-double-indent\n\n==
        Layout/ArrayAlignment\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        0.77\n|===\n\nHere we check if the elements of a multi-line array literal
        are\naligned.\n\n=== Examples\n\n==== EnforcedStyle: with_first_element (default)\n\n[source,ruby]\n----\n#
        good\n\narray = [1, 2, 3,\n         4, 5, 6]\narray = ['run',\n         'forrest',\n
        \        'run']\n\n# bad\n\narray = [1, 2, 3,\n  4, 5, 6]\narray = ['run',\n
        \    'forrest',\n     'run']\n----\n\n==== EnforcedStyle: with_fixed_indentation\n\n[source,ruby]\n----\n#
        good\n\narray = [1, 2, 3,\n  4, 5, 6]\n\n# bad\n\narray = [1, 2, 3,\n         4,
        5, 6]\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default value
        | Configurable values\n\n| EnforcedStyle\n| `with_first_element`\n| `with_first_element`,
        `with_fixed_indentation`\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n===
        References\n\n* https://rubystyle.guide#no-double-indent\n\n== Layout/AssignmentIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| 1.45\n|===\n\nChecks the
        indentation of the first line of the\nright-hand-side of a multi-line assignment.\n\nThe
        indentation of the remaining lines can be corrected with\nother cops such
        as `IndentationConsistency` and `EndAlignment`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nvalue =\nif foo\n  'bar'\nend\n\n# good\nvalue =\n  if foo\n    'bar'\n
        \ end\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default value
        | Configurable values\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n==
        Layout/BeginEndAlignment\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.91\n|
        -\n|===\n\nChecks whether the end keyword of `begin` is aligned properly.\n\nTwo
        modes are supported through the `EnforcedStyleAlignWith` configuration\nparameter.
        If it's set to `start_of_line` (which is the default), the\n`end` shall be
        aligned with the start of the line where the `begin`\nkeyword is. If it's
        set to `begin`, the `end` shall be aligned with the\n`begin` keyword.\n\n`Layout/EndAlignment`
        cop aligns with keywords (e.g. `if`, `while`, `case`)\nby default. On the
        other hand, `||= begin` that this cop targets tends to\nalign with the start
        of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`.\nThese
        style can be configured by each cop.\n\n=== Examples\n\n==== EnforcedStyleAlignWith:
        start_of_line (default)\n\n[source,ruby]\n----\n# bad\nfoo ||= begin\n          do_something\n
        \       end\n\n# good\nfoo ||= begin\n  do_something\nend\n----\n\n==== EnforcedStyleAlignWith:
        begin\n\n[source,ruby]\n----\n# bad\nfoo ||= begin\n  do_something\nend\n\n#
        good\nfoo ||= begin\n          do_something\n        end\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyleAlignWith\n|
        `start_of_line`\n| `start_of_line`, `begin`\n\n| Severity\n| `warning`\n|
        String\n|===\n\n== Layout/BlockAlignment\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.53\n| -\n|===\n\nChecks whether the end keywords are aligned
        properly for do\nend blocks.\n\nThree modes are supported through the `EnforcedStyleAlignWith`\nconfiguration
        parameter:\n\n`start_of_block` : the `end` shall be aligned with the\nstart
        of the line where the `do` appeared.\n\n`start_of_line` : the `end` shall
        be aligned with the\nstart of the line where the expression started.\n\n`either`
        (which is the default) : the `end` is allowed to be in either\nlocation. The
        autofixer will default to `start_of_line`.\n\n=== Examples\n\n==== EnforcedStyleAlignWith:
        either (default)\n\n[source,ruby]\n----\n# bad\n\nfoo.bar\n  .each do\n    baz\n
        \     end\n\n# good\n\nfoo.bar\n  .each do\n    baz\nend\n----\n\n==== EnforcedStyleAlignWith:
        start_of_block\n\n[source,ruby]\n----\n# bad\n\nfoo.bar\n  .each do\n    baz\n
        \     end\n\n# good\n\nfoo.bar\n  .each do\n    baz\n  end\n----\n\n==== EnforcedStyleAlignWith:
        start_of_line\n\n[source,ruby]\n----\n# bad\n\nfoo.bar\n  .each do\n    baz\n
        \     end\n\n# good\n\nfoo.bar\n  .each do\n    baz\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyleAlignWith\n|
        `either`\n| `either`, `start_of_block`, `start_of_line`\n|===\n\n== Layout/BlockEndNewline\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks whether
        the end statement of a do..end block\nis on its own line.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nblah do |i|\n  foo(i) end\n\n# good\nblah do |i|\n  foo(i)\nend\n\n#
        bad\nblah { |i|\n  foo(i) }\n\n# good\nblah { |i|\n  foo(i)\n}\n----\n\n==
        Layout/CaseIndentation\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        1.16\n|===\n\nChecks how the `when` and ``in``s of a `case` expression\nare
        indented in relation to its `case` or `end` keyword.\n\nIt will register a
        separate offense for each misaligned `when` and `in`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        If Layout/EndAlignment is set to keyword style (default)\n# *case* and *end*
        should always be aligned to same depth,\n# and therefore *when* should always
        be aligned to both -\n# regardless of configuration.\n\n# bad for all styles\ncase
        n\n  when 0\n    x * 2\n  else\n    y / 3\nend\n\ncase n\n  in pattern\n    x
        * 2\n  else\n    y / 3\nend\n\n# good for all styles\ncase n\nwhen 0\n  x
        * 2\nelse\n  y / 3\nend\n\ncase n\nin pattern\n  x * 2\nelse\n  y / 3\nend\n----\n\n====
        EnforcedStyle: case (default)\n\n[source,ruby]\n----\n# if EndAlignment is
        set to other style such as\n# start_of_line (as shown below), then *when*
        alignment\n# configuration does have an effect.\n\n# bad\na = case n\nwhen
        0\n  x * 2\nelse\n  y / 3\nend\n\na = case n\nin pattern\n  x * 2\nelse\n
        \ y / 3\nend\n\n# good\na = case n\n    when 0\n      x * 2\n    else\n      y
        / 3\nend\n\na = case n\n    in pattern\n      x * 2\n    else\n      y / 3\nend\n----\n\n====
        EnforcedStyle: end\n\n[source,ruby]\n----\n# bad\na = case n\n    when 0\n
        \     x * 2\n    else\n      y / 3\nend\n\na = case n\n    in pattern\n      x
        * 2\n    else\n      y / 3\nend\n\n# good\na = case n\nwhen 0\n  x * 2\nelse\n
        \ y / 3\nend\n\na = case n\nin pattern\n  x * 2\nelse\n  y / 3\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `case`\n| `case`, `end`\n\n| IndentOneStep\n| `false`\n|
        Boolean\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n=== References\n\n*
        https://rubystyle.guide#indent-when-to-case\n\n== Layout/ClassStructure\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always (Unsafe)\n| 0.52\n| 1.53\n|===\n\nChecks
        if the code style follows the ExpectedOrder configuration:\n\n`Categories`
        allows us to map macro names into a category.\n\nConsider an example of code
        style that covers the following order:\n\n* Module inclusion (include, prepend,
        extend)\n* Constants\n* Associations (has_one, has_many)\n* Public attribute
        macros (attr_accessor, attr_writer, attr_reader)\n* Other macros (validates,
        validate)\n* Public class methods\n* Initializer\n* Public instance methods\n*
        Protected attribute macros (attr_accessor, attr_writer, attr_reader)\n* Protected
        instance methods\n* Private attribute macros (attr_accessor, attr_writer,
        attr_reader)\n* Private instance methods\n\nYou can configure the following
        order:\n\n[source,yaml]\n----\n Layout/ClassStructure:\n   ExpectedOrder:\n
        \    - module_inclusion\n     - constants\n     - association\n     - public_attribute_macros\n
        \    - public_delegate\n     - macros\n     - public_class_methods\n     -
        initializer\n     - public_methods\n     - protected_attribute_macros\n     -
        protected_methods\n     - private_attribute_macros\n     - private_delegate\n
        \    - private_methods\n----\n\nInstead of putting all literals in the expected
        order, is also\npossible to group categories of macros. Visibility levels
        are handled\nautomatically.\n\n[source,yaml]\n----\n Layout/ClassStructure:\n
        \  Categories:\n     association:\n       - has_many\n       - has_one\n     attribute_macros:\n
        \      - attr_accessor\n       - attr_reader\n       - attr_writer\n     macros:\n
        \      - validates\n       - validate\n     module_inclusion:\n       - include\n
        \      - prepend\n       - extend\n----\n\n=== Safety\n\nAutocorrection is
        unsafe because class methods and module inclusion\ncan behave differently,
        based on which methods or constants have\nalready been defined.\n\nConstants
        will only be moved when they are assigned with literals.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n# Expect extend be before constant\nclass Person < ApplicationRecord\n
        \ has_many :orders\n  ANSWER = 42\n\n  extend SomeModule\n  include AnotherModule\nend\n\n#
        good\nclass Person\n  # extend and include go first\n  extend SomeModule\n
        \ include AnotherModule\n\n  # inner classes\n  CustomError = Class.new(StandardError)\n\n
        \ # constants are next\n  SOME_CONSTANT = 20\n\n  # afterwards we have public
        attribute macros\n  attr_reader :name\n\n  # followed by other macros (if
        any)\n  validates :name\n\n  # then we have public delegate macros\n  delegate
        :to_s, to: :name\n\n  # public class methods are next in line\n  def self.some_method\n
        \ end\n\n  # initialization goes between class methods and instance methods\n
        \ def initialize\n  end\n\n  # followed by other public instance methods\n
        \ def some_method\n  end\n\n  # protected attribute macros and methods go
        next\n  protected\n\n  attr_reader :protected_name\n\n  def some_protected_method\n
        \ end\n\n  # private attribute macros, delegate macros and methods\n  # are
        grouped near the end\n  private\n\n  attr_reader :private_name\n\n  delegate
        :some_private_delegate, to: :name\n\n  def some_private_method\n  end\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        Categories\n| `{\"module_inclusion\"=>[\"include\", \"prepend\", \"extend\"]}`\n|
        \n\n| ExpectedOrder\n| `module_inclusion`, `constants`, `public_class_methods`,
        `initializer`, `public_methods`, `protected_methods`, `private_methods`\n|
        Array\n|===\n\n=== References\n\n* https://rubystyle.guide#consistent-classes\n\n==
        Layout/ClosingHeredocIndentation\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.57\n| -\n|===\n\nChecks the indentation of here document closings.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nclass Foo\n  def bar\n    <<~SQL\n
        \     'Hi'\n  SQL\n  end\nend\n\n# good\nclass Foo\n  def bar\n    <<~SQL\n
        \     'Hi'\n    SQL\n  end\nend\n\n# bad\n\n# heredoc contents is before closing
        heredoc.\nfoo arg,\n    <<~EOS\n  Hi\n    EOS\n\n# good\nfoo arg,\n    <<~EOS\n
        \ Hi\nEOS\n\n# good\nfoo arg,\n    <<~EOS\n      Hi\n    EOS\n----\n\n== Layout/ClosingParenthesisIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks the indentation
        of hanging closing parentheses in\nmethod calls, method definitions, and grouped
        expressions. A hanging\nclosing parenthesis means `)` preceded by a line break.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nsome_method(\n  a,\n  b\n  )\n\nsome_method(\n
        \ a, b\n  )\n\nsome_method(a, b, c\n  )\n\nsome_method(a,\n            b,\n
        \           c\n  )\n\nsome_method(a,\n  x: 1,\n  y: 2\n  )\n\n# Scenario 1:
        When First Parameter Is On Its Own Line\n\n# good: when first param is on
        a new line, right paren is *always*\n#       outdented by IndentationWidth\nsome_method(\n
        \ a,\n  b\n)\n\n# good\nsome_method(\n  a, b\n)\n\n# Scenario 2: When First
        Parameter Is On The Same Line\n\n# good: when all other params are also on
        the same line, outdent\n#       right paren by IndentationWidth\nsome_method(a,
        b, c\n           )\n\n# good: when all other params are on multiple lines,
        but are lined\n#       up, align right paren with left paren\nsome_method(a,\n
        \           b,\n            c\n           )\n\n# good: when other params are
        not lined up on multiple lines, outdent\n#       right paren by IndentationWidth\nsome_method(a,\n
        \ x: 1,\n  y: 2\n)\n----\n\n== Layout/CommentIndentation\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| 1.24\n|===\n\nChecks the indentation of
        comments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n  # comment here\ndef
        method_name\nend\n\n  # comment here\na = 'hello'\n\n# yet another comment\n
        \ if true\n    true\n  end\n\n# good\n# comment here\ndef method_name\nend\n\n#
        comment here\na = 'hello'\n\n# yet another comment\nif true\n  true\nend\n----\n\n====
        AllowForAlignment: false (default)\n\n[source,ruby]\n----\n# bad\na = 1 #
        A really long comment\n      # spanning two lines.\n\n# good\n# A really long
        comment spanning one line.\na = 1\n----\n\n==== AllowForAlignment: true\n\n[source,ruby]\n----\n#
        good\na = 1 # A really long comment\n      # spanning two lines.\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowForAlignment\n| `false`\n| Boolean\n|===\n\n== Layout/ConditionPosition\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.53\n| 0.83\n|===\n\nChecks for
        conditions that are not on the same line as\nif/while/until.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nif\n  some_condition\n  do_something\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nif some_condition\n  do_something\nend\n----\n\n=== References\n\n*
        https://rubystyle.guide#same-line-condition\n\n== Layout/DefEndAlignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.53\n| -\n|===\n\nChecks whether
        the end keywords of method definitions are\naligned properly.\n\nTwo modes
        are supported through the EnforcedStyleAlignWith configuration\nparameter.
        If it's set to `start_of_line` (which is the default), the\n`end` shall be
        aligned with the start of the line where the `def`\nkeyword is. If it's set
        to `def`, the `end` shall be aligned with the\n`def` keyword.\n\n=== Examples\n\n====
        EnforcedStyleAlignWith: start_of_line (default)\n\n[source,ruby]\n----\n#
        bad\n\nprivate def foo\n            end\n\n# good\n\nprivate def foo\nend\n----\n\n====
        EnforcedStyleAlignWith: def\n\n[source,ruby]\n----\n# bad\n\nprivate def foo\n
        \           end\n\n# good\n\nprivate def foo\n        end\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyleAlignWith\n|
        `start_of_line`\n| `start_of_line`, `def`\n\n| Severity\n| `warning`\n| String\n|===\n\n==
        Layout/DotPosition\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        -\n|===\n\nChecks the . position in multi-line method calls.\n\n=== Examples\n\n====
        EnforcedStyle: leading (default)\n\n[source,ruby]\n----\n# bad\nsomething.\n
        \ method\n\n# good\nsomething\n  .method\n----\n\n==== EnforcedStyle: trailing\n\n[source,ruby]\n----\n#
        bad\nsomething\n  .method\n\n# good\nsomething.\n  method\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `leading`\n| `leading`, `trailing`\n|===\n\n=== References\n\n* https://rubystyle.guide#consistent-multi-line-chains\n\n==
        Layout/ElseAlignment\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        -\n|===\n\nChecks the alignment of else keywords. Normally they should\nbe
        aligned with an if/unless/while/until/begin/def/rescue keyword, but there\nare
        special cases when they should follow the same rules as the\nalignment of
        end.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif something\n  code\n
        else\n  code\nend\n\n# bad\nif something\n  code\n elsif something\n  code\nend\n\n#
        good\nif something\n  code\nelse\n  code\nend\n----\n\n== Layout/EmptyComment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only\n| 0.53\n| 1.61\n|===\n\nChecks
        empty comment.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n#\nclass Foo\nend\n\n#
        good\n\n#\n# Description of `Foo` class.\n#\nclass Foo\nend\n----\n\n====
        AllowBorderComment: true (default)\n\n[source,ruby]\n----\n# good\n\ndef foo\nend\n\n#################\n\ndef
        bar\nend\n----\n\n==== AllowBorderComment: false\n\n[source,ruby]\n----\n#
        bad\n\ndef foo\nend\n\n#################\n\ndef bar\nend\n----\n\n==== AllowMarginComment:
        true (default)\n\n[source,ruby]\n----\n# good\n\n#\n# Description of `Foo`
        class.\n#\nclass Foo\nend\n----\n\n==== AllowMarginComment: false\n\n[source,ruby]\n----\n#
        bad\n\n#\n# Description of `Foo` class.\n#\nclass Foo\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| AllowBorderComment\n|
        `true`\n| Boolean\n\n| AllowMarginComment\n| `true`\n| Boolean\n|===\n\n==
        Layout/EmptyLineAfterGuardClause\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.56\n| 0.59\n|===\n\nEnforces empty line after guard clause.\n\nThis cop
        allows `# :nocov:` directive after guard clause because\nSimpleCov excludes
        code from the coverage report by wrapping it in `# :nocov:`:\n\n[source,ruby]\n----\ndef
        foo\n  # :nocov:\n  return if condition\n  # :nocov:\n  bar\nend\n----\n\nRefer
        to SimpleCov's documentation for more details:\nhttps://github.com/simplecov-ruby/simplecov#ignoringskipping-code\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\ndef foo\n  return if need_return?\n
        \ bar\nend\n\n# good\ndef foo\n  return if need_return?\n\n  bar\nend\n\n#
        good\ndef foo\n  return if something?\n  return if something_different?\n\n
        \ bar\nend\n\n# also good\ndef foo\n  if something?\n    do_something\n    return
        if need_return?\n  end\nend\n----\n\n== Layout/EmptyLineAfterMagicComment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for a newline
        after the final magic comment.\n\n=== Examples\n\n[source,ruby]\n----\n# good\n#
        frozen_string_literal: true\n\n# Some documentation for Person\nclass Person\n
        \ # Some code\nend\n\n# bad\n# frozen_string_literal: true\n# Some documentation
        for Person\nclass Person\n  # Some code\nend\n----\n\n=== References\n\n*
        https://rubystyle.guide#separate-magic-comments-from-code\n\n== Layout/EmptyLineAfterMultilineCondition\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.90\n| -\n|===\n\nEnforces empty
        line after multiline condition.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nif multiline &&\n  condition\n  do_something\nend\n\n# good\nif multiline
        &&\n  condition\n\n  do_something\nend\n\n# bad\ncase x\nwhen foo,\n  bar\n
        \ do_something\nend\n\n# good\ncase x\nwhen foo,\n  bar\n\n  do_something\nend\n\n#
        bad\nbegin\n  do_something\nrescue FooError,\n  BarError\n  handle_error\nend\n\n#
        good\nbegin\n  do_something\nrescue FooError,\n  BarError\n\n  handle_error\nend\n----\n\n===
        References\n\n* https://github.com/airbnb/ruby#multiline-if-newline\n\n==
        Layout/EmptyLineBetweenDefs\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| 1.23\n|===\n\nChecks whether class/module/method definitions are\nseparated
        by one or more empty lines.\n\n`NumberOfEmptyLines` can be an integer (default
        is 1) or\nan array (e.g. [1, 2]) to specify a minimum and maximum\nnumber
        of empty lines permitted.\n\n`AllowAdjacentOneLineDefs` configures whether
        adjacent\none-line definitions are considered an offense.\n\n=== Examples\n\n====
        EmptyLineBetweenMethodDefs: true (default)\n\n[source,ruby]\n----\n# checks
        for empty lines between method definitions.\n\n# bad\ndef a\nend\ndef b\nend\n----\n\n[source,ruby]\n----\n#
        good\ndef a\nend\n\ndef b\nend\n----\n\n==== EmptyLineBetweenClassDefs: true
        (default)\n\n[source,ruby]\n----\n# checks for empty lines between class definitions.\n\n#
        bad\nclass A\nend\nclass B\nend\ndef b\nend\n----\n\n[source,ruby]\n----\n#
        good\nclass A\nend\n\nclass B\nend\n\ndef b\nend\n----\n\n==== EmptyLineBetweenModuleDefs:
        true (default)\n\n[source,ruby]\n----\n# checks for empty lines between module
        definitions.\n\n# bad\nmodule A\nend\nmodule B\nend\ndef b\nend\n----\n\n[source,ruby]\n----\n#
        good\nmodule A\nend\n\nmodule B\nend\n\ndef b\nend\n----\n\n==== AllowAdjacentOneLineDefs:
        true (default)\n\n[source,ruby]\n----\n# good\nclass ErrorA < BaseError; end\nclass
        ErrorB < BaseError; end\nclass ErrorC < BaseError; end\n\n# good\nclass ErrorA
        < BaseError; end\n\nclass ErrorB < BaseError; end\n\nclass ErrorC < BaseError;
        end\n----\n\n==== AllowAdjacentOneLineDefs: false\n\n[source,ruby]\n----\n#
        bad\nclass ErrorA < BaseError; end\nclass ErrorB < BaseError; end\nclass ErrorC
        < BaseError; end\n\n# good\nclass ErrorA < BaseError; end\n\nclass ErrorB
        < BaseError; end\n\nclass ErrorC < BaseError; end\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EmptyLineBetweenMethodDefs\n|
        `true`\n| Boolean\n\n| EmptyLineBetweenClassDefs\n| `true`\n| Boolean\n\n|
        EmptyLineBetweenModuleDefs\n| `true`\n| Boolean\n\n| DefLikeMacros\n| `[]`\n|
        Array\n\n| AllowAdjacentOneLineDefs\n| `true`\n| Boolean\n\n| NumberOfEmptyLines\n|
        `1`\n| Integer\n|===\n\n=== References\n\n* https://rubystyle.guide#empty-lines-between-methods\n\n==
        Layout/EmptyLines\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        -\n|===\n\nChecks for two or more consecutive blank lines.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad - It has two empty lines.\nsome_method\n# one empty line\n# two empty
        lines\nsome_method\n\n# good\nsome_method\n# one empty line\nsome_method\n----\n\n===
        References\n\n* https://rubystyle.guide#two-or-more-empty-lines\n\n== Layout/EmptyLinesAroundAccessModifier\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nAccess modifiers
        should be surrounded by blank lines.\n\n=== Examples\n\n==== EnforcedStyle:
        around (default)\n\n[source,ruby]\n----\n# bad\nclass Foo\n  def bar; end\n
        \ private\n  def baz; end\nend\n\n# good\nclass Foo\n  def bar; end\n\n  private\n\n
        \ def baz; end\nend\n----\n\n==== EnforcedStyle: only_before\n\n[source,ruby]\n----\n#
        bad\nclass Foo\n  def bar; end\n  private\n  def baz; end\nend\n\n# good\nclass
        Foo\n  def bar; end\n\n  private\n  def baz; end\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `around`\n| `around`, `only_before`\n|===\n\n=== References\n\n* https://rubystyle.guide#empty-lines-around-access-modifier\n*
        https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions\n\n==
        Layout/EmptyLinesAroundArguments\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.52\n| -\n|===\n\nChecks if empty lines exist around the arguments\nof a
        method invocation.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndo_something(\n
        \ foo\n\n)\n\nprocess(bar,\n\n        baz: qux,\n        thud: fred)\n\nsome_method(\n\n
        \ [1,2,3],\n  x: y\n)\n\n# good\ndo_something(\n  foo\n)\n\nprocess(bar,\n
        \       baz: qux,\n        thud: fred)\n\nsome_method(\n  [1,2,3],\n  x: y\n)\n----\n\n==
        Layout/EmptyLinesAroundAttributeAccessor\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.83\n| 0.84\n|===\n\nChecks for a newline after an attribute
        accessor or a group of them.\n`alias` syntax and `alias_method`, `public`,
        `protected`, and `private` methods are allowed\nby default. These are customizable
        with `AllowAliasSyntax` and `AllowedMethods` options.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nattr_accessor :foo\ndef do_something\nend\n\n# good\nattr_accessor :foo\n\ndef
        do_something\nend\n\n# good\nattr_accessor :foo\nattr_reader :bar\nattr_writer
        :baz\nattr :qux\n\ndef do_something\nend\n----\n\n==== AllowAliasSyntax: true
        (default)\n\n[source,ruby]\n----\n# good\nattr_accessor :foo\nalias :foo?
        :foo\n\ndef do_something\nend\n----\n\n==== AllowAliasSyntax: false\n\n[source,ruby]\n----\n#
        bad\nattr_accessor :foo\nalias :foo? :foo\n\ndef do_something\nend\n\n# good\nattr_accessor
        :foo\n\nalias :foo? :foo\n\ndef do_something\nend\n----\n\n==== AllowedMethods:
        ['private']\n\n[source,ruby]\n----\n# good\nattr_accessor :foo\nprivate :foo\n\ndef
        do_something\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| AllowAliasSyntax\n| `true`\n| Boolean\n\n|
        AllowedMethods\n| `alias_method`, `public`, `protected`, `private`\n| Array\n|===\n\n===
        References\n\n* https://rubystyle.guide#empty-lines-around-attribute-accessor\n\n==
        Layout/EmptyLinesAroundBeginBody\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks if empty lines exist around the bodies of begin-end\nblocks.\n\n===
        Examples\n\n[source,ruby]\n----\n# good\n\nbegin\n  # ...\nend\n\n# bad\n\nbegin\n\n
        \ # ...\n\nend\n----\n\n=== References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n==
        Layout/EmptyLinesAroundBlockBody\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks if empty lines around the bodies of blocks match\nthe
        configuration.\n\n=== Examples\n\n==== EnforcedStyle: no_empty_lines (default)\n\n[source,ruby]\n----\n#
        good\n\nfoo do |bar|\n  # ...\nend\n----\n\n==== EnforcedStyle: empty_lines\n\n[source,ruby]\n----\n#
        good\n\nfoo do |bar|\n\n  # ...\n\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `no_empty_lines`\n|
        `empty_lines`, `no_empty_lines`\n|===\n\n=== References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n==
        Layout/EmptyLinesAroundClassBody\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| 0.53\n|===\n\nChecks if empty lines around the bodies of classes match\nthe
        configuration.\n\n=== Examples\n\n==== EnforcedStyle: no_empty_lines (default)\n\n[source,ruby]\n----\n#
        good\n\nclass Foo\n  def bar\n    # ...\n  end\nend\n----\n\n==== EnforcedStyle:
        empty_lines\n\n[source,ruby]\n----\n# good\n\nclass Foo\n\n  def bar\n    #
        ...\n  end\n\nend\n----\n\n==== EnforcedStyle: empty_lines_except_namespace\n\n[source,ruby]\n----\n#
        good\n\nclass Foo\n  class Bar\n\n    # ...\n\n  end\nend\n----\n\n==== EnforcedStyle:
        empty_lines_special\n\n[source,ruby]\n----\n# good\nclass Foo\n\n  def bar;
        end\n\nend\n----\n\n==== EnforcedStyle: beginning_only\n\n[source,ruby]\n----\n#
        good\n\nclass Foo\n\n  def bar\n    # ...\n  end\nend\n----\n\n==== EnforcedStyle:
        ending_only\n\n[source,ruby]\n----\n# good\n\nclass Foo\n  def bar\n    #
        ...\n  end\n\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| EnforcedStyle\n| `no_empty_lines`\n| `empty_lines`,
        `empty_lines_except_namespace`, `empty_lines_special`, `no_empty_lines`, `beginning_only`,
        `ending_only`\n|===\n\n=== References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n==
        Layout/EmptyLinesAroundExceptionHandlingKeywords\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks if empty lines exist around the
        bodies of `begin`\nsections. This cop doesn't check empty lines at `begin`
        body\nbeginning/end and around method definition body.\n`Style/EmptyLinesAroundBeginBody`
        or `Style/EmptyLinesAroundMethodBody`\ncan be used for this purpose.\n\n===
        Examples\n\n[source,ruby]\n----\n# good\n\nbegin\n  do_something\nrescue\n
        \ do_something2\nelse\n  do_something3\nensure\n  do_something4\nend\n\n#
        good\n\ndef foo\n  do_something\nrescue\n  do_something2\nend\n\n# bad\n\nbegin\n
        \ do_something\n\nrescue\n\n  do_something2\n\nelse\n\n  do_something3\n\nensure\n\n
        \ do_something4\nend\n\n# bad\n\ndef foo\n  do_something\n\nrescue\n\n  do_something2\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n== Layout/EmptyLinesAroundMethodBody\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks if empty
        lines exist around the bodies of methods.\n\n=== Examples\n\n[source,ruby]\n----\n#
        good\n\ndef foo\n  # ...\nend\n\n# bad\n\ndef bar\n\n  # ...\n\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n== Layout/EmptyLinesAroundModuleBody\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks if empty
        lines around the bodies of modules match\nthe configuration.\n\n=== Examples\n\n====
        EnforcedStyle: no_empty_lines (default)\n\n[source,ruby]\n----\n# good\n\nmodule
        Foo\n  def bar\n    # ...\n  end\nend\n----\n\n==== EnforcedStyle: empty_lines\n\n[source,ruby]\n----\n#
        good\n\nmodule Foo\n\n  def bar\n    # ...\n  end\n\nend\n----\n\n==== EnforcedStyle:
        empty_lines_except_namespace\n\n[source,ruby]\n----\n# good\n\nmodule Foo\n
        \ module Bar\n\n    # ...\n\n  end\nend\n----\n\n==== EnforcedStyle: empty_lines_special\n\n[source,ruby]\n----\n#
        good\nmodule Foo\n\n  def bar; end\n\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `no_empty_lines`\n|
        `empty_lines`, `empty_lines_except_namespace`, `empty_lines_special`, `no_empty_lines`\n|===\n\n===
        References\n\n* https://rubystyle.guide#empty-lines-around-bodies\n\n== Layout/EndAlignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.53\n| -\n|===\n\nChecks whether
        the end keywords are aligned properly.\n\nThree modes are supported through
        the `EnforcedStyleAlignWith`\nconfiguration parameter:\n\nIf it's set to `keyword`
        (which is the default), the `end`\nshall be aligned with the start of the
        keyword (if, class, etc.).\n\nIf it's set to `variable` the `end` shall be
        aligned with the\nleft-hand-side of the variable assignment, if there is one.\n\nIf
        it's set to `start_of_line`, the `end` shall be aligned with the\nstart of
        the line where the matching keyword appears.\n\nThis `Layout/EndAlignment`
        cop aligns with keywords (e.g. `if`, `while`, `case`)\nby default. On the
        other hand, `Layout/BeginEndAlignment` cop aligns with\n`EnforcedStyleAlignWith:
        start_of_line` by default due to `||= begin` tends\nto align with the start
        of the line. `Layout/DefEndAlignment` cop also aligns with\n`EnforcedStyleAlignWith:
        start_of_line` by default.\nThese style can be configured by each cop.\n\n===
        Examples\n\n==== EnforcedStyleAlignWith: keyword (default)\n\n[source,ruby]\n----\n#
        bad\n\nvariable = if true\n    end\n\n# good\n\nvariable = if true\n           end\n\nvariable
        =\n  if true\n  end\n----\n\n==== EnforcedStyleAlignWith: variable\n\n[source,ruby]\n----\n#
        bad\n\nvariable = if true\n    end\n\n# good\n\nvariable = if true\nend\n\nvariable
        =\n  if true\n  end\n----\n\n==== EnforcedStyleAlignWith: start_of_line\n\n[source,ruby]\n----\n#
        bad\n\nvariable = if true\n    end\n\nputs(if true\n     end)\n\n# good\n\nvariable
        = if true\nend\n\nputs(if true\nend)\n\nvariable =\n  if true\n  end\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyleAlignWith\n| `keyword`\n| `keyword`, `variable`, `start_of_line`\n\n|
        Severity\n| `warning`\n| String\n|===\n\n== Layout/EndOfLine\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| No\n| 0.49\n| -\n|===\n\nChecks for Windows-style line endings
        in the source code.\n\n=== Examples\n\n==== EnforcedStyle: native (default)\n\n[source,ruby]\n----\n#
        The `native` style means that CR+LF (Carriage Return + Line Feed) is\n# enforced
        on Windows, and LF is enforced on other platforms.\n\n# bad\nputs 'Hello'
        # Return character is LF on Windows.\nputs 'Hello' # Return character is CR+LF
        on other than Windows.\n\n# good\nputs 'Hello' # Return character is CR+LF
        on Windows.\nputs 'Hello' # Return character is LF on other than Windows.\n----\n\n====
        EnforcedStyle: lf\n\n[source,ruby]\n----\n# The `lf` style means that LF (Line
        Feed) is enforced on\n# all platforms.\n\n# bad\nputs 'Hello' # Return character
        is CR+LF on all platforms.\n\n# good\nputs 'Hello' # Return character is LF
        on all platforms.\n----\n\n==== EnforcedStyle: crlf\n\n[source,ruby]\n----\n#
        The `crlf` style means that CR+LF (Carriage Return + Line Feed) is\n# enforced
        on all platforms.\n\n# bad\nputs 'Hello' # Return character is LF on all platforms.\n\n#
        good\nputs 'Hello' # Return character is CR+LF on all platforms.\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `native`\n| `native`, `lf`, `crlf`\n|===\n\n=== References\n\n*
        https://rubystyle.guide#crlf\n\n== Layout/ExtraSpacing\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for extra/unnecessary
        whitespace.\n\n=== Examples\n\n[source,ruby]\n----\n# good if AllowForAlignment
        is true\nname      = \"RuboCop\"\n# Some comment and an empty line\n\nwebsite
        \ += \"/rubocop/rubocop\" unless cond\nputs        \"rubocop\"          if
        \    debug\n\n# bad for any configuration\nset_app(\"RuboCop\")\nwebsite  =
        \"https://github.com/rubocop/rubocop\"\n\n# good only if AllowBeforeTrailingComments
        is true\nobject.method(arg)  # this is a comment\n\n# good even if AllowBeforeTrailingComments
        is false or not set\nobject.method(arg) # this is a comment\n\n# good with
        either AllowBeforeTrailingComments or AllowForAlignment\nobject.method(arg)
        \        # this is a comment\nanother_object.method(arg) # this is another
        comment\nsome_object.method(arg)    # this is some comment\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| AllowForAlignment\n|
        `true`\n| Boolean\n\n| AllowBeforeTrailingComments\n| `false`\n| Boolean\n\n|
        ForceEqualSignAlignment\n| `false`\n| Boolean\n|===\n\n== Layout/FirstArgumentIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.68\n| 0.77\n|===\n\nChecks the
        indentation of the first argument in a method call.\nArguments after the first
        one are checked by `Layout/ArgumentAlignment`,\nnot by this cop.\n\nFor indenting
        the first parameter of method _definitions_, check out\n`Layout/FirstParameterIndentation`.\n\nThis
        cop will respect `Layout/ArgumentAlignment` and will not work when\n`EnforcedStyle:
        with_fixed_indentation` is specified for `Layout/ArgumentAlignment`.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nsome_method(\nfirst_param,\nsecond_param)\n\nfoo
        = some_method(\nfirst_param,\nsecond_param)\n\nfoo = some_method(nested_call(\nnested_first_param),\nsecond_param)\n\nfoo
        = some_method(\nnested_call(\nnested_first_param),\nsecond_param)\n\nsome_method
        nested_call(\nnested_first_param),\nsecond_param\n----\n\n==== EnforcedStyle:
        special_for_inner_method_call_in_parentheses (default)\n\n[source,ruby]\n----\n#
        Same as `special_for_inner_method_call` except that the special rule\n# only
        applies if the outer method call encloses its arguments in\n# parentheses.\n\n#
        good\nsome_method(\n  first_param,\nsecond_param)\n\nfoo = some_method(\n
        \ first_param,\nsecond_param)\n\nfoo = some_method(nested_call(\n                    nested_first_param),\nsecond_param)\n\nfoo
        = some_method(\n  nested_call(\n    nested_first_param),\nsecond_param)\n\nsome_method
        nested_call(\n  nested_first_param),\nsecond_param\n----\n\n==== EnforcedStyle:
        consistent\n\n[source,ruby]\n----\n# The first argument should always be indented
        one step more than the\n# preceding line.\n\n# good\nsome_method(\n  first_param,\nsecond_param)\n\nfoo
        = some_method(\n  first_param,\nsecond_param)\n\nfoo = some_method(nested_call(\n
        \ nested_first_param),\nsecond_param)\n\nfoo = some_method(\n  nested_call(\n
        \   nested_first_param),\nsecond_param)\n\nsome_method nested_call(\n  nested_first_param),\nsecond_param\n----\n\n====
        EnforcedStyle: consistent_relative_to_receiver\n\n[source,ruby]\n----\n# The
        first argument should always be indented one level relative to\n# the parent
        that is receiving the argument\n\n# good\nsome_method(\n  first_param,\nsecond_param)\n\nfoo
        = some_method(\n        first_param,\nsecond_param)\n\nfoo = some_method(nested_call(\n
        \                   nested_first_param),\nsecond_param)\n\nfoo = some_method(\n
        \       nested_call(\n          nested_first_param),\nsecond_param)\n\nsome_method
        nested_call(\n              nested_first_param),\nsecond_params\n----\n\n====
        EnforcedStyle: special_for_inner_method_call\n\n[source,ruby]\n----\n# The
        first argument should normally be indented one step more than\n# the preceding
        line, but if it's a argument for a method call that\n# is itself a argument
        in a method call, then the inner argument\n# should be indented relative to
        the inner method.\n\n# good\nsome_method(\n  first_param,\nsecond_param)\n\nfoo
        = some_method(\n  first_param,\nsecond_param)\n\nfoo = some_method(nested_call(\n
        \                   nested_first_param),\nsecond_param)\n\nfoo = some_method(\n
        \ nested_call(\n    nested_first_param),\nsecond_param)\n\nsome_method nested_call(\n
        \             nested_first_param),\nsecond_param\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `special_for_inner_method_call_in_parentheses`\n| `consistent`, `consistent_relative_to_receiver`,
        `special_for_inner_method_call`, `special_for_inner_method_call_in_parentheses`\n\n|
        IndentationWidth\n| `<none>`\n| Integer\n|===\n\n== Layout/FirstArrayElementIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.68\n| 0.77\n|===\n\nChecks the
        indentation of the first element in an array literal\nwhere the opening bracket
        and the first element are on separate lines.\nThe other elements' indentations
        are handled by `Layout/ArrayAlignment` cop.\n\nThis cop will respect `Layout/ArrayAlignment`
        and will not work when\n`EnforcedStyle: with_fixed_indentation` is specified
        for `Layout/ArrayAlignment`.\n\nBy default, array literals that are arguments
        in a method call with\nparentheses, and where the opening square bracket of
        the array is on the\nsame line as the opening parenthesis of the method call,
        shall have\ntheir first element indented one step (two spaces) more than the\nposition
        inside the opening parenthesis.\n\nOther array literals shall have their first
        element indented one step\nmore than the start of the line where the opening
        square bracket is.\n\nThis default style is called 'special_inside_parentheses'.
        Alternative\nstyles are 'consistent' and 'align_brackets'. Here are examples:\n\n===
        Examples\n\n==== EnforcedStyle: special_inside_parentheses (default)\n\n[source,ruby]\n----\n#
        The `special_inside_parentheses` style enforces that the first\n# element
        in an array literal where the opening bracket and first\n# element are on
        separate lines is indented one step (two spaces) more\n# than the position
        inside the opening parenthesis.\n\n# bad\narray = [\n  :value\n]\nand_in_a_method_call([\n
        \ :no_difference\n                     ])\n\n# good\narray = [\n  :value\n]\nbut_in_a_method_call([\n
        \                      :its_like_this\n                     ])\n----\n\n====
        EnforcedStyle: consistent\n\n[source,ruby]\n----\n# The `consistent` style
        enforces that the first element in an array\n# literal where the opening bracket
        and the first element are on\n# separate lines is indented the same as an
        array literal which is not\n# defined inside a method call.\n\n# bad\n# consistent\narray
        = [\n  :value\n]\nbut_in_a_method_call([\n                       :its_like_this\n])\n\n#
        good\narray = [\n  :value\n]\nand_in_a_method_call([\n  :no_difference\n])\n----\n\n====
        EnforcedStyle: align_brackets\n\n[source,ruby]\n----\n# The `align_brackets`
        style enforces that the opening and closing\n# brackets are indented to the
        same position.\n\n# bad\n# align_brackets\nand_now_for_something = [\n                          :completely_different\n]\n\n#
        good\n# align_brackets\nand_now_for_something = [\n                          :completely_different\n
        \                       ]\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `special_inside_parentheses`\n|
        `special_inside_parentheses`, `consistent`, `align_brackets`\n\n| IndentationWidth\n|
        `<none>`\n| Integer\n|===\n\n== Layout/FirstArrayElementLineBreak\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for a
        line break before the first element in a\nmulti-line array.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n[ :a,\n  :b]\n\n# good\n[\n  :a,\n  :b]\n\n# good\n[:a, :b]\n----\n\n====
        AllowMultilineFinalElement: false (default)\n\n[source,ruby]\n----\n# bad\n[
        :a, {\n  :b => :c\n}]\n\n# good\n[\n  :a, {\n  :b => :c\n}]\n----\n\n====
        AllowMultilineFinalElement: true\n\n[source,ruby]\n----\n# good\n[:a, {\n
        \ :b => :c\n}]\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/FirstHashElementIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.68\n| 0.77\n|===\n\nChecks the
        indentation of the first key in a hash literal\nwhere the opening brace and
        the first key are on separate lines. The\nother keys' indentations are handled
        by the HashAlignment cop.\n\nBy default, Hash literals that are arguments
        in a method call with\nparentheses, and where the opening curly brace of the
        hash is on the\nsame line as the opening parenthesis of the method call, shall
        have\ntheir first key indented one step (two spaces) more than the position\ninside
        the opening parenthesis.\n\nOther hash literals shall have their first key
        indented one step more\nthan the start of the line where the opening curly
        brace is.\n\nThis default style is called 'special_inside_parentheses'. Alternative\nstyles
        are 'consistent' and 'align_braces'. Here are examples:\n\n=== Examples\n\n====
        EnforcedStyle: special_inside_parentheses (default)\n\n[source,ruby]\n----\n#
        The `special_inside_parentheses` style enforces that the first key\n# in a
        hash literal where the opening brace and the first key are on\n# separate
        lines is indented one step (two spaces) more than the\n# position inside the
        opening parentheses.\n\n# bad\nhash = {\n  key: :value\n}\nand_in_a_method_call({\n
        \ no: :difference\n                     })\ntakes_multi_pairs_hash(x: {\n
        \ a: 1,\n  b: 2\n},\n                       y: {\n                         c:
        1,\n                         d: 2\n                       })\n\n# good\nspecial_inside_parentheses\nhash
        = {\n  key: :value\n}\nbut_in_a_method_call({\n                       its_like:
        :this\n                     })\ntakes_multi_pairs_hash(x: {\n                         a:
        1,\n                         b: 2\n                       },\n                       y:
        {\n                         c: 1,\n                         d: 2\n                       })\n----\n\n====
        EnforcedStyle: consistent\n\n[source,ruby]\n----\n# The `consistent` style
        enforces that the first key in a hash\n# literal where the opening brace and
        the first key are on\n# separate lines is indented the same as a hash literal
        which is not\n# defined inside a method call.\n\n# bad\nhash = {\n  key: :value\n}\nbut_in_a_method_call({\n
        \                      its_like: :this\n                      })\n\n# good\nhash
        = {\n  key: :value\n}\nand_in_a_method_call({\n  no: :difference\n})\n----\n\n====
        EnforcedStyle: align_braces\n\n[source,ruby]\n----\n# The `align_brackets`
        style enforces that the opening and closing\n# braces are indented to the
        same position.\n\n# bad\nand_now_for_something = {\n                          completely:
        :different\n}\ntakes_multi_pairs_hash(x: {\n  a: 1,\n  b: 2\n},\n                        y:
        {\n                             c: 1,\n                             d: 2\n
        \                          })\n\n# good\nand_now_for_something = {\n                          completely:
        :different\n                        }\ntakes_multi_pairs_hash(x: {\n                            a:
        1,\n                            b: 2\n                          },\n                       y:
        {\n                            c: 1,\n                            d: 2\n                          })\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `special_inside_parentheses`\n| `special_inside_parentheses`,
        `consistent`, `align_braces`\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n==
        Layout/FirstHashElementLineBreak\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Disabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks for a line break before the first element in a\nmulti-line
        hash.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n{ a: 1,\n  b: 2}\n\n#
        good\n{\n  a: 1,\n  b: 2 }\n\n# good\n{\n  a: 1, b: {\n  c: 3\n}}\n----\n\n====
        AllowMultilineFinalElement: false (default)\n\n[source,ruby]\n----\n# bad\n{
        a: 1, b: {\n  c: 3\n}}\n----\n\n==== AllowMultilineFinalElement: true\n\n[source,ruby]\n----\n#
        bad\n{ a: 1,\n  b: {\n  c: 3\n}}\n\n# good\n{ a: 1, b: {\n  c: 3\n}}\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/FirstMethodArgumentLineBreak\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for a
        line break before the first argument in a\nmulti-line method call.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nmethod(foo, bar,\n  baz)\n\n# good\nmethod(\n
        \ foo, bar,\n  baz)\n\n  # ignored\n  method foo, bar,\n    baz\n----\n\n====
        AllowMultilineFinalElement: false (default)\n\n[source,ruby]\n----\n# bad\nmethod(foo,
        bar, {\n  baz: \"a\",\n  qux: \"b\",\n})\n\n# good\nmethod(\n  foo, bar, {\n
        \ baz: \"a\",\n  qux: \"b\",\n})\n----\n\n==== AllowMultilineFinalElement:
        true\n\n[source,ruby]\n----\n# bad\nmethod(foo,\n  bar,\n  {\n    baz: \"a\",\n
        \   qux: \"b\",\n  }\n)\n\n# good\nmethod(foo, bar, {\n  baz: \"a\",\n  qux:
        \"b\",\n})\n\n# good\nmethod(\n  foo,\n  bar,\n  {\n    baz: \"a\",\n    qux:
        \"b\",\n  }\n)\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/FirstMethodParameterLineBreak\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for a
        line break before the first parameter in a\nmulti-line method parameter definition.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\ndef method(foo, bar,\n    baz)\n  do_something\nend\n\n#
        good\ndef method(\n    foo, bar,\n    baz)\n  do_something\nend\n\n# ignored\ndef
        method foo,\n    bar\n  do_something\nend\n----\n\n==== AllowMultilineFinalElement:
        false (default)\n\n[source,ruby]\n----\n# bad\ndef method(foo, bar, baz =
        {\n  :a => \"b\",\n})\n  do_something\nend\n\n# good\ndef method(\n  foo,
        bar, baz = {\n  :a => \"b\",\n})\n  do_something\nend\n----\n\n==== AllowMultilineFinalElement:
        true\n\n[source,ruby]\n----\n# good\ndef method(foo, bar, baz = {\n  :a =>
        \"b\",\n})\n  do_something\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/FirstParameterIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| 0.77\n|===\n\nChecks the
        indentation of the first parameter in a method\ndefinition. Parameters after
        the first one are checked by\nLayout/ParameterAlignment, not by this cop.\n\nFor
        indenting the first argument of method _calls_, check out\nLayout/FirstArgumentIndentation,
        which supports options related to\nnesting that are irrelevant for method
        _definitions_.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef some_method(\nfirst_param,\nsecond_param)\n
        \ 123\nend\n----\n\n==== EnforcedStyle: consistent (default)\n\n[source,ruby]\n----\n#
        The first parameter should always be indented one step more than the\n# preceding
        line.\n\n# good\ndef some_method(\n  first_param,\nsecond_param)\n  123\nend\n----\n\n====
        EnforcedStyle: align_parentheses\n\n[source,ruby]\n----\n# The first parameter
        should always be indented one step more than the\n# opening parenthesis.\n\n#
        good\ndef some_method(\n                 first_param,\nsecond_param)\n  123\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `consistent`\n| `consistent`, `align_parentheses`\n\n| IndentationWidth\n|
        `<none>`\n| Integer\n|===\n\n== Layout/HashAlignment\n\n|===\n| Enabled by
        default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| 1.16\n|===\n\nCheck that the keys, separators,
        and values of a multi-line hash\nliteral are aligned according to configuration.
        The configuration\noptions are:\n\n* key (left align keys, one space before
        hash rockets and values)\n* separator (align hash rockets and colons, right
        align keys)\n* table (left align keys, hash rockets, and values)\n\nThe treatment
        of hashes passed as the last argument to a method call\ncan also be configured.
        The options are:\n\n* always_inspect\n* always_ignore\n* ignore_implicit (without
        curly braces)\n\nAlternatively you can specify multiple allowed styles. That's
        done by\npassing a list of styles to EnforcedStyles.\n\n=== Examples\n\n====
        EnforcedHashRocketStyle: key (default)\n\n[source,ruby]\n----\n# bad\n{\n
        \ :foo => bar,\n   :ba => baz\n}\n{\n  :foo => bar,\n  :ba  => baz\n}\n\n#
        good\n{\n  :foo => bar,\n  :ba => baz\n}\n----\n\n==== EnforcedHashRocketStyle:
        separator\n\n[source,ruby]\n----\n# bad\n{\n  :foo => bar,\n  :ba => baz\n}\n{\n
        \ :foo => bar,\n  :ba  => baz\n}\n\n# good\n{\n  :foo => bar,\n   :ba => baz\n}\n----\n\n====
        EnforcedHashRocketStyle: table\n\n[source,ruby]\n----\n# bad\n{\n  :foo =>
        bar,\n   :ba => baz\n}\n\n# good\n{\n  :foo => bar,\n  :ba  => baz\n}\n----\n\n====
        EnforcedColonStyle: key (default)\n\n[source,ruby]\n----\n# bad\n{\n  foo:
        bar,\n   ba: baz\n}\n{\n  foo: bar,\n  ba:  baz\n}\n\n# good\n{\n  foo: bar,\n
        \ ba: baz\n}\n----\n\n==== EnforcedColonStyle: separator\n\n[source,ruby]\n----\n#
        bad\n{\n  foo: bar,\n  ba: baz\n}\n\n# good\n{\n  foo: bar,\n   ba: baz\n}\n----\n\n====
        EnforcedColonStyle: table\n\n[source,ruby]\n----\n# bad\n{\n  foo: bar,\n
        \ ba: baz\n}\n\n# good\n{\n  foo: bar,\n  ba:  baz\n}\n----\n\n==== EnforcedLastArgumentHashStyle:
        always_inspect (default)\n\n[source,ruby]\n----\n# Inspect both implicit and
        explicit hashes.\n\n# bad\ndo_something(foo: 1,\n  bar: 2)\n\n# bad\ndo_something({foo:
        1,\n  bar: 2})\n\n# good\ndo_something(foo: 1,\n             bar: 2)\n\n#
        good\ndo_something(\n  foo: 1,\n  bar: 2\n)\n\n# good\ndo_something({foo:
        1,\n              bar: 2})\n\n# good\ndo_something({\n  foo: 1,\n  bar: 2\n})\n----\n\n====
        EnforcedLastArgumentHashStyle: always_ignore\n\n[source,ruby]\n----\n# Ignore
        both implicit and explicit hashes.\n\n# good\ndo_something(foo: 1,\n  bar:
        2)\n\n# good\ndo_something({foo: 1,\n  bar: 2})\n----\n\n==== EnforcedLastArgumentHashStyle:
        ignore_implicit\n\n[source,ruby]\n----\n# Ignore only implicit hashes.\n\n#
        bad\ndo_something({foo: 1,\n  bar: 2})\n\n# good\ndo_something(foo: 1,\n  bar:
        2)\n----\n\n==== EnforcedLastArgumentHashStyle: ignore_explicit\n\n[source,ruby]\n----\n#
        Ignore only explicit hashes.\n\n# bad\ndo_something(foo: 1,\n  bar: 2)\n\n#
        good\ndo_something({foo: 1,\n  bar: 2})\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedHashRocketStyle\n|
        `key`\n| `key`, `separator`, `table`\n\n| EnforcedColonStyle\n| `key`\n| `key`,
        `separator`, `table`\n\n| EnforcedLastArgumentHashStyle\n| `always_inspect`\n|
        `always_inspect`, `always_ignore`, `ignore_implicit`, `ignore_explicit`\n|===\n\n==
        Layout/HeredocArgumentClosingParenthesis\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Disabled\n|
        Yes\n| Always\n| 0.68\n| -\n|===\n\nChecks for the placement of the closing
        parenthesis\nin a method call that passes a HEREDOC string as an argument.\nIt
        should be placed at the end of the line containing the\nopening HEREDOC tag.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\n   foo(<<-SQL\n     bar\n   SQL\n
        \  )\n\n   foo(<<-SQL, 123, <<-NOSQL,\n     bar\n   SQL\n     baz\n   NOSQL\n
        \  )\n\n   foo(\n     bar(<<-SQL\n       baz\n     SQL\n     ),\n     123,\n
        \  )\n\n# good\n\n   foo(<<-SQL)\n     bar\n   SQL\n\n   foo(<<-SQL, 123,
        <<-NOSQL)\n     bar\n   SQL\n     baz\n   NOSQL\n\n   foo(\n     bar(<<-SQL),\n
        \      baz\n     SQL\n     123,\n   )\n----\n\n=== References\n\n* https://rubystyle.guide#heredoc-argument-closing-parentheses\n\n==
        Layout/HeredocIndentation\n\nNOTE: Required Ruby version: 2.3\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| 0.85\n|===\n\nChecks the indentation of
        the here document bodies. The bodies\nare indented one step.\n\nNote: When
        ``Layout/LineLength``'s `AllowHeredoc` is false (not default),\n      this
        cop does not add any offenses for long here documents to\n      avoid ``Layout/LineLength``'s
        offenses.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n<<-RUBY\nsomething\nRUBY\n\n#
        good\n<<~RUBY\n  something\nRUBY\n----\n\n=== References\n\n* https://rubystyle.guide#squiggly-heredocs\n\n==
        Layout/IndentationConsistency\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks for inconsistent indentation.\n\nThe difference
        between `indented_internal_methods` and `normal` is\nthat the `indented_internal_methods`
        style prescribes that in\nclasses and modules the `protected` and `private`
        modifier keywords\nshall be indented the same as public methods and that protected
        and\nprivate members shall be indented one step more than the modifiers.\nOther
        than that, both styles mean that entities on the same logical\ndepth shall
        have the same indentation.\n\n=== Examples\n\n==== EnforcedStyle: normal (default)\n\n[source,ruby]\n----\n#
        bad\nclass A\n  def test\n    puts 'hello'\n     puts 'world'\n  end\nend\n\n#
        bad\nclass A\n  def test\n    puts 'hello'\n    puts 'world'\n  end\n\n  protected\n\n
        \   def foo\n    end\n\n  private\n\n    def bar\n    end\nend\n\n# good\nclass
        A\n  def test\n    puts 'hello'\n    puts 'world'\n  end\nend\n\n# good\nclass
        A\n  def test\n    puts 'hello'\n    puts 'world'\n  end\n\n  protected\n\n
        \ def foo\n  end\n\n  private\n\n  def bar\n  end\nend\n----\n\n==== EnforcedStyle:
        indented_internal_methods\n\n[source,ruby]\n----\n# bad\nclass A\n  def test\n
        \   puts 'hello'\n     puts 'world'\n  end\nend\n\n# bad\nclass A\n  def test\n
        \   puts 'hello'\n    puts 'world'\n  end\n\n  protected\n\n  def foo\n  end\n\n
        \ private\n\n  def bar\n  end\nend\n\n# good\nclass A\n  def test\n    puts
        'hello'\n    puts 'world'\n  end\nend\n\n# good\nclass A\n  def test\n    puts
        'hello'\n    puts 'world'\n  end\n\n  protected\n\n    def foo\n    end\n\n
        \ private\n\n    def bar\n    end\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `normal`\n|
        `normal`, `indented_internal_methods`\n|===\n\n=== References\n\n* https://rubystyle.guide#spaces-indentation\n*
        https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions\n\n==
        Layout/IndentationStyle\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        0.82\n|===\n\nChecks that the indentation method is consistent.\nEither tabs
        only or spaces only are used for indentation.\n\n=== Examples\n\n==== EnforcedStyle:
        spaces (default)\n\n[source,ruby]\n----\n# bad\n# This example uses a tab
        to indent bar.\ndef foo\n  bar\nend\n\n# good\n# This example uses spaces
        to indent bar.\ndef foo\n  bar\nend\n----\n\n==== EnforcedStyle: tabs\n\n[source,ruby]\n----\n#
        bad\n# This example uses spaces to indent bar.\ndef foo\n  bar\nend\n\n# good\n#
        This example uses a tab to indent bar.\ndef foo\n  bar\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| IndentationWidth\n|
        `<none>`\n| Integer\n\n| EnforcedStyle\n| `spaces`\n| `spaces`, `tabs`\n|===\n\n===
        References\n\n* https://rubystyle.guide#spaces-indentation\n\n== Layout/IndentationWidth\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for indentation
        that doesn't use the specified number\nof spaces.\n\nSee also the IndentationConsistency
        cop which is the companion to this\none.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nclass A\n def test\n  puts 'hello'\n end\nend\n\n# good\nclass A\n  def
        test\n    puts 'hello'\n  end\nend\n----\n\n==== AllowedPatterns: ['^\\s*module']\n\n[source,ruby]\n----\n#
        bad\nmodule A\nclass B\n  def test\n  puts 'hello'\n  end\nend\nend\n\n# good\nmodule
        A\nclass B\n  def test\n    puts 'hello'\n  end\nend\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| Width\n|
        `2`\n| Integer\n\n| AllowedPatterns\n| `[]`\n| Array\n|===\n\n=== References\n\n*
        https://rubystyle.guide#spaces-indentation\n\n== Layout/InitialIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for indentation
        of the first non-blank non-comment\nline in a file.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n   class A\n     def foo; end\n   end\n\n# good\nclass A\n  def foo;
        end\nend\n----\n\n== Layout/LeadingCommentSpace\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| 0.73\n|===\n\nChecks whether comments have a leading
        space after the\n`#` denoting the start of the comment. The leading space
        is not\nrequired for some RDoc special syntax, like `#++`, `#--`,\n`#:nodoc`,
        `=begin`- and `=end` comments, \"shebang\" directives,\nor rackup options.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n#Some comment\n\n# good\n# Some comment\n----\n\n====
        AllowDoxygenCommentStyle: false (default)\n\n[source,ruby]\n----\n# bad\n\n#**\n#
        Some comment\n# Another line of comment\n#*\n----\n\n==== AllowDoxygenCommentStyle:
        true\n\n[source,ruby]\n----\n# good\n\n#**\n# Some comment\n# Another line
        of comment\n#*\n----\n\n==== AllowGemfileRubyComment: false (default)\n\n[source,ruby]\n----\n#
        bad\n\n#ruby=2.7.0\n#ruby-gemset=myproject\n----\n\n==== AllowGemfileRubyComment:
        true\n\n[source,ruby]\n----\n# good\n\n#ruby=2.7.0\n#ruby-gemset=myproject\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowDoxygenCommentStyle\n| `false`\n| Boolean\n\n| AllowGemfileRubyComment\n|
        `false`\n| Boolean\n|===\n\n=== References\n\n* https://rubystyle.guide#hash-space\n\n==
        Layout/LeadingEmptyLines\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.57\n|
        0.77\n|===\n\nChecks for unnecessary leading blank lines at the beginning\nof
        a file.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n# (start of file)\n\nclass
        Foo\nend\n\n# bad\n# (start of file)\n\n# a comment\n\n# good\n# (start of
        file)\nclass Foo\nend\n\n# good\n# (start of file)\n# a comment\n----\n\n==
        Layout/LineContinuationLeadingSpace\n\n|===\n| Enabled by default | Safe |
        Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| Always\n| 1.31\n| 1.45\n|===\n\nChecks that strings broken over multiple
        lines (by a backslash) contain\ntrailing spaces instead of leading spaces
        (default) or leading spaces\ninstead of trailing spaces.\n\n=== Examples\n\n====
        EnforcedStyle: trailing (default)\n\n[source,ruby]\n----\n# bad\n'this text
        contains a lot of' \\\n'               spaces'\n\n# good\n'this text contains
        a lot of               ' \\\n'spaces'\n\n# bad\n'this text is too' \\\n' long'\n\n#
        good\n'this text is too ' \\\n'long'\n----\n\n==== EnforcedStyle: leading\n\n[source,ruby]\n----\n#
        bad\n'this text contains a lot of               ' \\\n'spaces'\n\n# good\n'this
        text contains a lot of' \\\n'               spaces'\n\n# bad\n'this text is
        too ' \\\n'long'\n\n# good\n'this text is too' \\\n' long'\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `trailing`\n| `leading`, `trailing`\n|===\n\n== Layout/LineContinuationSpacing\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.31\n| -\n|===\n\nChecks that the
        backslash of a line continuation is separated from\npreceding text by exactly
        one space (default) or zero spaces.\n\n=== Examples\n\n==== EnforcedStyle:
        space (default)\n\n[source,ruby]\n----\n# bad\n'a'\\\n'b'  \\\n'c'\n\n# good\n'a'
        \\\n'b' \\\n'c'\n----\n\n==== EnforcedStyle: no_space\n\n[source,ruby]\n----\n#
        bad\n'a' \\\n'b'  \\\n'c'\n\n# good\n'a'\\\n'b'\\\n'c'\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `space`\n| `space`, `no_space`\n|===\n\n== Layout/LineEndStringConcatenationIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.18\n| -\n|===\n\nChecks the indentation
        of the next line after a line that ends with a string\nliteral and a backslash.\n\nIf
        `EnforcedStyle: aligned` is set, the concatenated string parts shall be aligned
        with the\nfirst part. There are some exceptions, such as implicit return values,
        where the\nconcatenated string parts shall be indented regardless of `EnforcedStyle`
        configuration.\n\nIf `EnforcedStyle: indented` is set, it's the second line
        that shall be indented one step\nmore than the first line. Lines 3 and forward
        shall be aligned with line 2.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef
        some_method\n  'x' \\\n  'y' \\\n  'z'\nend\n\nmy_hash = {\n  first: 'a message'
        \\\n    'in two parts'\n}\n\n# good\ndef some_method\n  'x' \\\n    'y' \\\n
        \   'z'\nend\n----\n\n==== EnforcedStyle: aligned (default)\n\n[source,ruby]\n----\n#
        bad\nputs 'x' \\\n  'y'\n\nmy_hash = {\n  first: 'a message' \\\n    'in two
        parts'\n}\n\n# good\nputs 'x' \\\n     'y'\n\nmy_hash = {\n  first: 'a message'
        \\\n         'in two parts'\n}\n----\n\n==== EnforcedStyle: indented\n\n[source,ruby]\n----\n#
        bad\nresult = 'x' \\\n         'y'\n\nmy_hash = {\n  first: 'a message' \\\n
        \        'in two parts'\n}\n\n# good\nresult = 'x' \\\n  'y'\n\nmy_hash =
        {\n  first: 'a message' \\\n    'in two parts'\n}\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `aligned`\n| `aligned`, `indented`\n\n| IndentationWidth\n| `<none>`\n| Integer\n|===\n\n==
        Layout/LineLength\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.25\n|
        1.4\n|===\n\nChecks the length of lines in the source code.\nThe maximum length
        is configurable.\nThe tab size is configured in the `IndentationWidth`\nof
        the `Layout/IndentationStyle` cop.\nIt also ignores a shebang line by default.\n\nThis
        cop has some autocorrection capabilities.\nIt can programmatically shorten
        certain long lines by\ninserting line breaks into expressions that can be
        safely\nsplit across lines. These include arrays, hashes, and\nmethod calls
        with argument lists.\n\nIf autocorrection is enabled, the following Layout
        cops\nare recommended to further format the broken lines.\n(Many of these
        are enabled by default.)\n\n* ArgumentAlignment\n* ArrayAlignment\n* BlockAlignment\n*
        BlockDelimiters\n* BlockEndNewline\n* ClosingParenthesisIndentation\n* FirstArgumentIndentation\n*
        FirstArrayElementIndentation\n* FirstHashElementIndentation\n* FirstParameterIndentation\n*
        HashAlignment\n* IndentationWidth\n* MultilineArrayLineBreaks\n* MultilineBlockLayout\n*
        MultilineHashBraceLayout\n* MultilineHashKeyLineBreaks\n* MultilineMethodArgumentLineBreaks\n*
        MultilineMethodParameterLineBreaks\n* ParameterAlignment\n\nTogether, these
        cops will pretty print hashes, arrays,\nmethod calls, etc. For example, let's
        say the max columns\nis 25:\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n{foo:
        \"0000000000\", bar: \"0000000000\", baz: \"0000000000\"}\n\n# good\n{foo:
        \"0000000000\",\nbar: \"0000000000\", baz: \"0000000000\"}\n\n# good (with
        recommended cops enabled)\n{\n  foo: \"0000000000\",\n  bar: \"0000000000\",\n
        \ baz: \"0000000000\",\n}\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| Max\n| `120`\n| Integer\n\n|
        AllowHeredoc\n| `true`\n| Boolean\n\n| AllowURI\n| `true`\n| Boolean\n\n|
        URISchemes\n| `http`, `https`\n| Array\n\n| IgnoreCopDirectives\n| `true`\n|
        Boolean\n\n| AllowedPatterns\n| `[]`\n| Array\n|===\n\n=== References\n\n*
        https://rubystyle.guide#max-line-length\n\n== Layout/MultilineArrayBraceLayout\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that the
        closing brace in an array literal is either\non the same line as the last
        array element or on a new line.\n\nWhen using the `symmetrical` (default)
        style:\n\nIf an array's opening brace is on the same line as the first element\nof
        the array, then the closing brace should be on the same line as\nthe last
        element of the array.\n\nIf an array's opening brace is on the line above
        the first element\nof the array, then the closing brace should be on the line
        below\nthe last element of the array.\n\nWhen using the `new_line` style:\n\nThe
        closing brace of a multi-line array literal must be on the line\nafter the
        last element of the array.\n\nWhen using the `same_line` style:\n\nThe closing
        brace of a multi-line array literal must be on the same\nline as the last
        element of the array.\n\n=== Examples\n\n==== EnforcedStyle: symmetrical (default)\n\n[source,ruby]\n----\n#
        bad\n[ :a,\n  :b\n]\n\n# bad\n[\n  :a,\n  :b ]\n\n# good\n[ :a,\n  :b ]\n\n#
        good\n[\n  :a,\n  :b\n]\n----\n\n==== EnforcedStyle: new_line\n\n[source,ruby]\n----\n#
        bad\n[\n  :a,\n  :b ]\n\n# bad\n[ :a,\n  :b ]\n\n# good\n[ :a,\n  :b\n]\n\n#
        good\n[\n  :a,\n  :b\n]\n----\n\n==== EnforcedStyle: same_line\n\n[source,ruby]\n----\n#
        bad\n[ :a,\n  :b\n]\n\n# bad\n[\n  :a,\n  :b\n]\n\n# good\n[\n  :a,\n  :b
        ]\n\n# good\n[ :a,\n  :b ]\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `symmetrical`\n|
        `symmetrical`, `new_line`, `same_line`\n|===\n\n== Layout/MultilineArrayLineBreaks\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.67\n| -\n|===\n\nEnsures that
        each item in a multi-line array\nstarts on a separate line.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n[\n  a, b,\n  c\n]\n\n# good\n[\n  a,\n  b,\n  c\n]\n\n# good\n[\n  a,\n
        \ b,\n  foo(\n    bar\n  )\n]\n----\n\n==== AllowMultilineFinalElement: false
        (default)\n\n[source,ruby]\n----\n# bad\n[a, b, foo(\n  bar\n)]\n----\n\n====
        AllowMultilineFinalElement: true\n\n[source,ruby]\n----\n# good\n[a, b, foo(\n
        \ bar\n)]\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default value
        | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/MultilineAssignmentLayout\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks whether
        the multiline assignments have a newline\nafter the assignment operator.\n\n===
        Examples\n\n==== EnforcedStyle: new_line (default)\n\n[source,ruby]\n----\n#
        bad\nfoo = if expression\n  'bar'\nend\n\n# good\nfoo =\n  if expression\n
        \   'bar'\n  end\n\n# good\nfoo =\n  begin\n    compute\n  rescue => e\n    nil\n
        \ end\n----\n\n==== EnforcedStyle: same_line\n\n[source,ruby]\n----\n# good\nfoo
        = if expression\n  'bar'\nend\n----\n\n==== SupportedTypes: ['block', 'case',
        'class', 'if', 'kwbegin', 'module'] (default)\n\n[source,ruby]\n----\n# good\nfoo
        =\n  if expression\n    'bar'\n  end\n\n# good\nfoo =\n  [1].map do |i|\n
        \   i + 1\n  end\n----\n\n==== SupportedTypes: ['block']\n\n[source,ruby]\n----\n#
        good\nfoo = if expression\n  'bar'\nend\n\n# good\nfoo =\n  [1].map do |i|\n
        \   'bar' * i\n  end\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| EnforcedStyle\n| `new_line`\n|
        `same_line`, `new_line`\n|===\n\n=== References\n\n* https://rubystyle.guide#indent-conditional-assignment\n\n==
        Layout/MultilineBlockLayout\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks whether the multiline do end blocks have a newline\nafter
        the start of the block. Additionally, it checks whether the block\narguments,
        if any, are on the same line as the start of the\nblock. Putting block arguments
        on separate lines, because the whole\nline would otherwise be too long, is
        accepted.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nblah do |i| foo(i)\n
        \ bar(i)\nend\n\n# bad\nblah do\n  |i| foo(i)\n  bar(i)\nend\n\n# good\nblah
        do |i|\n  foo(i)\n  bar(i)\nend\n\n# bad\nblah { |i| foo(i)\n  bar(i)\n}\n\n#
        good\nblah { |i|\n  foo(i)\n  bar(i)\n}\n\n# good\nblah { |\n  long_list,\n
        \ of_parameters,\n  that_would_not,\n  fit_on_one_line\n|\n  foo(i)\n  bar(i)\n}\n----\n\n==
        Layout/MultilineHashBraceLayout\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks that the closing brace in a hash literal is either\non
        the same line as the last hash element, or a new line.\n\nWhen using the `symmetrical`
        (default) style:\n\nIf a hash's opening brace is on the same line as the first
        element\nof the hash, then the closing brace should be on the same line as\nthe
        last element of the hash.\n\nIf a hash's opening brace is on the line above
        the first element\nof the hash, then the closing brace should be on the line
        below\nthe last element of the hash.\n\nWhen using the `new_line` style:\n\nThe
        closing brace of a multi-line hash literal must be on the line\nafter the
        last element of the hash.\n\nWhen using the `same_line` style:\n\nThe closing
        brace of a multi-line hash literal must be on the same\nline as the last element
        of the hash.\n\n=== Examples\n\n==== EnforcedStyle: symmetrical (default)\n\n[source,ruby]\n----\n#
        bad\n{ a: 1,\n  b: 2\n}\n# bad\n{\n  a: 1,\n  b: 2 }\n\n# good\n{ a: 1,\n
        \ b: 2 }\n\n# good\n{\n  a: 1,\n  b: 2\n}\n----\n\n==== EnforcedStyle: new_line\n\n[source,ruby]\n----\n#
        bad\n{\n  a: 1,\n  b: 2 }\n\n# bad\n{ a: 1,\n  b: 2 }\n\n# good\n{ a: 1,\n
        \ b: 2\n}\n\n# good\n{\n  a: 1,\n  b: 2\n}\n----\n\n==== EnforcedStyle: same_line\n\n[source,ruby]\n----\n#
        bad\n{ a: 1,\n  b: 2\n}\n\n# bad\n{\n  a: 1,\n  b: 2\n}\n\n# good\n{\n  a:
        1,\n  b: 2 }\n\n# good\n{ a: 1,\n  b: 2 }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `symmetrical`\n|
        `symmetrical`, `new_line`, `same_line`\n|===\n\n== Layout/MultilineHashKeyLineBreaks\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.67\n| -\n|===\n\nEnsures that
        each key in a multi-line hash\nstarts on a separate line.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n{\n  a: 1, b: 2,\n  c: 3\n}\n\n# good\n{\n  a: 1,\n  b: 2,\n  c: 3\n}\n\n#
        good\n{\n  a: 1,\n  b: {\n    c: 3,\n  }\n}\n----\n\n==== AllowMultilineFinalElement:
        false (default)\n\n[source,ruby]\n----\n# bad\n{ a: 1, b: {\n  c: 3,\n}}\n----\n\n====
        AllowMultilineFinalElement: true\n\n[source,ruby]\n----\n# good\n{ a: 1, b:
        {\n  c: 3,\n}}\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/MultilineMethodArgumentLineBreaks\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.67\n| -\n|===\n\nEnsures that
        each argument in a multi-line method call\nstarts on a separate line.\n\nNOTE:
        This cop does not move the first argument, if you want that to\nbe on a separate
        line, see `Layout/FirstMethodArgumentLineBreak`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nfoo(a, b,\n  c\n)\n\n# bad\nfoo(a, b, {\n  foo: \"bar\",\n})\n\n# good\nfoo(\n
        \ a,\n  b,\n  c\n)\n\n# good\nfoo(a, b, c)\n----\n\n==== AllowMultilineFinalElement:
        false (default)\n\n[source,ruby]\n----\n# good\nfoo(\n  a,\n  b,\n  {\n    foo:
        \"bar\",\n  }\n)\n----\n\n==== AllowMultilineFinalElement: true\n\n[source,ruby]\n----\n#
        good\nfoo(\n  a,\n  b,\n  {\n    foo: \"bar\",\n  }\n)\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/MultilineMethodCallBraceLayout\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that the
        closing brace in a method call is either\non the same line as the last method
        argument, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf
        a method call's opening brace is on the same line as the first\nargument of
        the call, then the closing brace should be on the same\nline as the last argument
        of the call.\n\nIf an method call's opening brace is on the line above the
        first\nargument of the call, then the closing brace should be on the line\nbelow
        the last argument of the call.\n\nWhen using the `new_line` style:\n\nThe
        closing brace of a multi-line method call must be on the line\nafter the last
        argument of the call.\n\nWhen using the `same_line` style:\n\nThe closing
        brace of a multi-line method call must be on the same\nline as the last argument
        of the call.\n\n=== Examples\n\n==== EnforcedStyle: symmetrical (default)\n\n[source,ruby]\n----\n#
        bad\nfoo(a,\n  b\n)\n\n# bad\nfoo(\n  a,\n  b)\n\n# good\nfoo(a,\n  b)\n\n#
        good\nfoo(\n  a,\n  b\n)\n----\n\n==== EnforcedStyle: new_line\n\n[source,ruby]\n----\n#
        bad\nfoo(\n  a,\n  b)\n\n# bad\nfoo(a,\n  b)\n\n# good\nfoo(a,\n  b\n)\n\n#
        good\nfoo(\n  a,\n  b\n)\n----\n\n==== EnforcedStyle: same_line\n\n[source,ruby]\n----\n#
        bad\nfoo(a,\n  b\n)\n\n# bad\nfoo(\n  a,\n  b\n)\n\n# good\nfoo(\n  a,\n  b)\n\n#
        good\nfoo(a,\n  b)\n----\n\n=== Configurable attributes\n\n|===\n| Name |
        Default value | Configurable values\n\n| EnforcedStyle\n| `symmetrical`\n|
        `symmetrical`, `new_line`, `same_line`\n|===\n\n== Layout/MultilineMethodCallIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks the indentation
        of the method name part in method calls\nthat span more than one line.\n\n===
        Examples\n\n==== EnforcedStyle: aligned (default)\n\n[source,ruby]\n----\n#
        bad\nwhile myvariable\n.b\n  # do something\nend\n\n# good\nwhile myvariable\n
        \     .b\n  # do something\nend\n\n# good\nThing.a\n     .b\n     .c\n----\n\n====
        EnforcedStyle: indented\n\n[source,ruby]\n----\n# good\nwhile myvariable\n
        \ .b\n\n  # do something\nend\n----\n\n==== EnforcedStyle: indented_relative_to_receiver\n\n[source,ruby]\n----\n#
        good\nwhile myvariable\n        .a\n        .b\n\n  # do something\nend\n\n#
        good\nmyvariable = Thing\n               .a\n               .b\n               .c\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `aligned`\n| `aligned`, `indented`, `indented_relative_to_receiver`\n\n|
        IndentationWidth\n| `<none>`\n| Integer\n|===\n\n== Layout/MultilineMethodDefinitionBraceLayout\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that the
        closing brace in a method definition is either\non the same line as the last
        method parameter, or a new line.\n\nWhen using the `symmetrical` (default)
        style:\n\nIf a method definition's opening brace is on the same line as the\nfirst
        parameter of the definition, then the closing brace should be\non the same
        line as the last parameter of the definition.\n\nIf an method definition's
        opening brace is on the line above the first\nparameter of the definition,
        then the closing brace should be on the\nline below the last parameter of
        the definition.\n\nWhen using the `new_line` style:\n\nThe closing brace of
        a multi-line method definition must be on the line\nafter the last parameter
        of the definition.\n\nWhen using the `same_line` style:\n\nThe closing brace
        of a multi-line method definition must be on the same\nline as the last parameter
        of the definition.\n\n=== Examples\n\n==== EnforcedStyle: symmetrical (default)\n\n[source,ruby]\n----\n#
        bad\ndef foo(a,\n  b\n)\nend\n\n# bad\ndef foo(\n  a,\n  b)\nend\n\n# good\ndef
        foo(a,\n  b)\nend\n\n# good\ndef foo(\n  a,\n  b\n)\nend\n----\n\n==== EnforcedStyle:
        new_line\n\n[source,ruby]\n----\n# bad\ndef foo(\n  a,\n  b)\nend\n\n# bad\ndef
        foo(a,\n  b)\nend\n\n# good\ndef foo(a,\n  b\n)\nend\n\n# good\ndef foo(\n
        \ a,\n  b\n)\nend\n----\n\n==== EnforcedStyle: same_line\n\n[source,ruby]\n----\n#
        bad\ndef foo(a,\n  b\n)\nend\n\n# bad\ndef foo(\n  a,\n  b\n)\nend\n\n# good\ndef
        foo(\n  a,\n  b)\nend\n\n# good\ndef foo(a,\n  b)\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `symmetrical`\n| `symmetrical`, `new_line`, `same_line`\n|===\n\n== Layout/MultilineMethodParameterLineBreaks\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 1.32\n| -\n|===\n\nEnsures that
        each parameter in a multi-line method definition\nstarts on a separate line.\n\nNOTE:
        This cop does not move the first argument, if you want that to\nbe on a separate
        line, see `Layout/FirstMethodParameterLineBreak`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndef foo(a, b,\n  c\n)\nend\n\n# good\ndef foo(\n  a,\n  b,\n  c\n)\nend\n\n#
        good\ndef foo(\n  a,\n  b = {\n    foo: \"bar\",\n  }\n)\nend\n\n# good\ndef
        foo(a, b, c)\nend\n----\n\n==== AllowMultilineFinalElement: false (default)\n\n[source,ruby]\n----\n#
        bad\ndef foo(a, b = {\n  foo: \"bar\",\n})\nend\n----\n\n==== AllowMultilineFinalElement:
        true\n\n[source,ruby]\n----\n# good\ndef foo(a, b = {\n  foo: \"bar\",\n})\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        xref:cops_layout.adoc#allowmultilinefinalelement[AllowMultilineFinalElement]\n|
        `false`\n| Boolean\n|===\n\n== Layout/MultilineOperationIndentation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks the indentation
        of the right hand side operand in binary operations that\nspan more than one
        line.\n\nThe `aligned` style checks that operators are aligned if they are
        part of an `if` or `while`\ncondition, an explicit `return` statement, etc.
        In other contexts, the second operand should\nbe indented regardless of enforced
        style.\n\n=== Examples\n\n==== EnforcedStyle: aligned (default)\n\n[source,ruby]\n----\n#
        bad\nif a +\n    b\n  something &&\n  something_else\nend\n\n# good\nif a
        +\n   b\n  something &&\n    something_else\nend\n----\n\n==== EnforcedStyle:
        indented\n\n[source,ruby]\n----\n# bad\nif a +\n   b\n  something &&\n  something_else\nend\n\n#
        good\nif a +\n    b\n  something &&\n    something_else\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `aligned`\n| `aligned`, `indented`\n\n| IndentationWidth\n|
        `<none>`\n| Integer\n|===\n\n== Layout/ParameterAlignment\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| 0.77\n|===\n\nHere we check if the parameters
        on a multi-line method call or\ndefinition are aligned.\n\nTo set the alignment
        of the first argument, use the cop\nFirstParameterIndentation.\n\n=== Examples\n\n====
        EnforcedStyle: with_first_parameter (default)\n\n[source,ruby]\n----\n# good\n\ndef
        foo(bar,\n        baz)\n  123\nend\n\ndef foo(\n  bar,\n  baz\n)\n  123\nend\n\n#
        bad\n\ndef foo(bar,\n     baz)\n  123\nend\n\n# bad\n\ndef foo(\n  bar,\n
        \    baz)\n  123\nend\n----\n\n==== EnforcedStyle: with_fixed_indentation\n\n[source,ruby]\n----\n#
        good\n\ndef foo(bar,\n  baz)\n  123\nend\n\ndef foo(\n  bar,\n  baz\n)\n  123\nend\n\n#
        bad\n\ndef foo(bar,\n        baz)\n  123\nend\n\n# bad\n\ndef foo(\n  bar,\n
        \    baz)\n  123\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| EnforcedStyle\n| `with_first_parameter`\n|
        `with_first_parameter`, `with_fixed_indentation`\n\n| IndentationWidth\n|
        `<none>`\n| Integer\n|===\n\n=== References\n\n* https://rubystyle.guide#no-double-indent\n\n==
        Layout/RedundantLineBreak\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Disabled\n| Yes\n| Always\n|
        1.13\n| -\n|===\n\nChecks whether certain expressions, e.g. method calls,
        that could fit\ncompletely on a single line, are broken up into multiple lines
        unnecessarily.\n\n=== Examples\n\n==== any configuration\n\n[source,ruby]\n----\n#
        bad\nfoo(\n  a,\n  b\n)\n\nputs 'string that fits on ' \\\n     'a single
        line'\n\nthings\n  .select { |thing| thing.cond? }\n  .join('-')\n\n# good\nfoo(a,
        b)\n\nputs 'string that fits on a single line'\n\nthings.select { |thing|
        thing.cond? }.join('-')\n----\n\n==== InspectBlocks: false (default)\n\n[source,ruby]\n----\n#
        good\nfoo(a) do |x|\n  puts x\nend\n----\n\n==== InspectBlocks: true\n\n[source,ruby]\n----\n#
        bad\nfoo(a) do |x|\n  puts x\nend\n\n# good\nfoo(a) { |x| puts x }\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        InspectBlocks\n| `false`\n| Boolean\n|===\n\n== Layout/RescueEnsureAlignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks whether
        the rescue and ensure keywords are aligned\nproperly.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nbegin\n  something\n  rescue\n  puts 'error'\nend\n\n# good\nbegin\n
        \ something\nrescue\n  puts 'error'\nend\n----\n\n== Layout/SingleLineBlockChain\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 1.14\n| -\n|===\n\nChecks if method
        calls are chained onto single line blocks. It considers that a\nline break
        before the dot improves the readability of the code.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nexample.select { |item| item.cond? }.join('-')\n\n# good\nexample.select
        { |item| item.cond? }\n       .join('-')\n\n# good (not a concern for this
        cop)\nexample.select do |item|\n  item.cond?\nend.join('-')\n----\n\n== Layout/SpaceAfterColon\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for colon
        (:) not followed by some kind of space.\nN.B. this cop does not handle spaces
        after a ternary operator, which are\ninstead handled by Layout/SpaceAroundOperators.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\ndef f(a:, b:2); {a:3}; end\n\n# good\ndef
        f(a:, b: 2); {a: 3}; end\n----\n\n=== References\n\n* https://rubystyle.guide#spaces-operators\n\n==
        Layout/SpaceAfterComma\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        -\n|===\n\nChecks for comma (,) not followed by some kind of space.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n[1,2]\n{ foo:bar,}\n\n# good\n[1,
        2]\n{ foo:bar, }\n----\n\n=== References\n\n* https://rubystyle.guide#spaces-operators\n\n==
        Layout/SpaceAfterMethodName\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks for space between a method name and a left parenthesis
        in defs.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef func (x) end\ndef
        method= (y) end\n\n# good\ndef func(x) end\ndef method=(y) end\n----\n\n===
        References\n\n* https://rubystyle.guide#parens-no-spaces\n\n== Layout/SpaceAfterNot\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for space
        after `!`.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n! something\n\n#
        good\n!something\n----\n\n=== References\n\n* https://rubystyle.guide#no-space-bang\n\n==
        Layout/SpaceAfterSemicolon\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks for semicolon (;) not followed by some kind of space.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nx = 1;y = 2\n\n# good\nx = 1; y =
        2\n----\n\n=== References\n\n* https://rubystyle.guide#spaces-operators\n\n==
        Layout/SpaceAroundBlockParameters\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks the spacing inside and after block parameters pipes.
        Line breaks\ninside parameter pipes are checked by `Layout/MultilineBlockLayout`
        and\nnot by this cop.\n\n=== Examples\n\n==== EnforcedStyleInsidePipes: no_space
        (default)\n\n[source,ruby]\n----\n# bad\n{}.each { | x,  y |puts x }\n->(
        x,  y ) { puts x }\n\n# good\n{}.each { |x, y| puts x }\n->(x, y) { puts x
        }\n----\n\n==== EnforcedStyleInsidePipes: space\n\n[source,ruby]\n----\n#
        bad\n{}.each { |x,  y| puts x }\n->(x,  y) { puts x }\n\n# good\n{}.each {
        | x, y | puts x }\n->( x, y ) { puts x }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyleInsidePipes\n|
        `no_space`\n| `space`, `no_space`\n|===\n\n== Layout/SpaceAroundEqualsInParameterDefault\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that the
        equals signs in parameter default assignments\nhave or don't have surrounding
        space depending on configuration.\n\n=== Examples\n\n==== EnforcedStyle: space
        (default)\n\n[source,ruby]\n----\n# bad\ndef some_method(arg1=:default, arg2=nil,
        arg3=[])\n  # do something...\nend\n\n# good\ndef some_method(arg1 = :default,
        arg2 = nil, arg3 = [])\n  # do something...\nend\n----\n\n==== EnforcedStyle:
        no_space\n\n[source,ruby]\n----\n# bad\ndef some_method(arg1 = :default, arg2
        = nil, arg3 = [])\n  # do something...\nend\n\n# good\ndef some_method(arg1=:default,
        arg2=nil, arg3=[])\n  # do something...\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `space`\n|
        `space`, `no_space`\n|===\n\n=== References\n\n* https://rubystyle.guide#spaces-around-equals\n\n==
        Layout/SpaceAroundKeyword\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks the spacing around the keywords.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nsomething 'test'do|x|\nend\n\nwhile(something)\nend\n\nsomething = 123if
        test\n\n# good\nsomething 'test' do |x|\nend\n\nwhile (something)\nend\n\nsomething
        = 123 if test\n----\n\n== Layout/SpaceAroundMethodCallOperator\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.82\n| -\n|===\n\nChecks method
        call operators to not have spaces around them.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nfoo. bar\nfoo .bar\nfoo . bar\nfoo. bar .buzz\nfoo\n  . bar\n  . buzz\nfoo&.
        bar\nfoo &.bar\nfoo &. bar\nfoo &. bar&. buzz\nRuboCop:: Cop\nRuboCop:: Cop::
        Base\n:: RuboCop::Cop\n\n# good\nfoo.bar\nfoo.bar.buzz\nfoo\n  .bar\n  .buzz\nfoo&.bar\nfoo&.bar&.buzz\nRuboCop::Cop\nRuboCop::Cop::Base\n::RuboCop::Cop\n----\n\n==
        Layout/SpaceAroundOperators\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| -\n|===\n\nChecks that operators have space around them, except for
        ** which\nshould or shouldn't have surrounding space depending on configuration.\nIt
        allows vertical alignment consisting of one or more whitespace\naround operators.\n\nThis
        cop has `AllowForAlignment` option. When `true`, allows most\nuses of extra
        spacing if the intent is to align with an operator on\nthe previous or next
        line, not counting empty lines or comment lines.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ntotal = 3*4\n\"apple\"+\"juice\"\nmy_number = 38/4\n\n# good\ntotal =
        3 * 4\n\"apple\" + \"juice\"\nmy_number = 38 / 4\n----\n\n==== AllowForAlignment:
        true (default)\n\n[source,ruby]\n----\n# good\n{\n  1 =>  2,\n  11 => 3\n}\n----\n\n====
        AllowForAlignment: false\n\n[source,ruby]\n----\n# bad\n{\n  1 =>  2,\n  11
        => 3\n}\n----\n\n==== EnforcedStyleForExponentOperator: no_space (default)\n\n[source,ruby]\n----\n#
        bad\na ** b\n\n# good\na**b\n----\n\n==== EnforcedStyleForExponentOperator:
        space\n\n[source,ruby]\n----\n# bad\na**b\n\n# good\na ** b\n----\n\n====
        EnforcedStyleForRationalLiterals: no_space (default)\n\n[source,ruby]\n----\n#
        bad\n1 / 48r\n\n# good\n1/48r\n----\n\n==== EnforcedStyleForRationalLiterals:
        space\n\n[source,ruby]\n----\n# bad\n1/48r\n\n# good\n1 / 48r\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowForAlignment\n| `true`\n| Boolean\n\n| EnforcedStyleForExponentOperator\n|
        `no_space`\n| `space`, `no_space`\n\n| EnforcedStyleForRationalLiterals\n|
        `no_space`\n| `space`, `no_space`\n|===\n\n=== References\n\n* https://rubystyle.guide#spaces-operators\n\n==
        Layout/SpaceBeforeBlockBraces\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| 0.52\n|===\n\nChecks that block braces have or don't have a space
        before the opening\nbrace depending on configuration.\n\n=== Examples\n\n====
        EnforcedStyle: space (default)\n\n[source,ruby]\n----\n# bad\nfoo.map{ |a|\n
        \ a.bar.to_s\n}\n\n# good\nfoo.map { |a|\n  a.bar.to_s\n}\n----\n\n==== EnforcedStyle:
        no_space\n\n[source,ruby]\n----\n# bad\nfoo.map { |a|\n  a.bar.to_s\n}\n\n#
        good\nfoo.map{ |a|\n  a.bar.to_s\n}\n----\n\n==== EnforcedStyleForEmptyBraces:
        space (default)\n\n[source,ruby]\n----\n# bad\n7.times{}\n\n# good\n7.times
        {}\n----\n\n==== EnforcedStyleForEmptyBraces: no_space\n\n[source,ruby]\n----\n#
        bad\n7.times {}\n\n# good\n7.times{}\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `space`\n|
        `space`, `no_space`\n\n| EnforcedStyleForEmptyBraces\n| `space`\n| `space`,
        `no_space`\n|===\n\n== Layout/SpaceBeforeBrackets\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| Always\n| 1.7\n| -\n|===\n\nChecks for space between the name of a
        receiver and a left\nbrackets.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ncollection
        [index_or_key]\n\n# good\ncollection[index_or_key]\n----\n\n=== References\n\n*
        https://rubystyle.guide#space-in-brackets-access\n\n== Layout/SpaceBeforeComma\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for comma
        (,) preceded by space.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n[1 ,
        2 , 3]\na(1 , 2)\neach { |a , b| }\n\n# good\n[1, 2, 3]\na(1, 2)\neach { |a,
        b| }\n----\n\n== Layout/SpaceBeforeComment\n\n|===\n| Enabled by default |
        Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for missing space between a token
        and a comment on the\nsame line.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n1 + 1# this operation does ...\n\n# good\n1 + 1 # this operation does
        ...\n----\n\n== Layout/SpaceBeforeFirstArg\n\n|===\n| Enabled by default |
        Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that exactly one space is used
        between a method name and the\nfirst argument for method calls without parentheses.\n\nAlternatively,
        extra spaces can be added to align the argument with\nsomething on a preceding
        or following line, if the AllowForAlignment\nconfig parameter is true.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nsomething  x\nsomething   y, z\nsomething'hello'\n\n#
        good\nsomething x\nsomething y, z\nsomething 'hello'\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| AllowForAlignment\n|
        `true`\n| Boolean\n|===\n\n== Layout/SpaceBeforeSemicolon\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for semicolon (;) preceded
        by space.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nx = 1 ; y = 2\n\n#
        good\nx = 1; y = 2\n----\n\n== Layout/SpaceInLambdaLiteral\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for spaces between `->`
        and opening parameter\nparenthesis (`(`) in lambda literals.\n\n=== Examples\n\n====
        EnforcedStyle: require_no_space (default)\n\n[source,ruby]\n----\n# bad\na
        = -> (x, y) { x + y }\n\n# good\na = ->(x, y) { x + y }\n----\n\n==== EnforcedStyle:
        require_space\n\n[source,ruby]\n----\n# bad\na = ->(x, y) { x + y }\n\n# good\na
        = -> (x, y) { x + y }\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| EnforcedStyle\n| `require_no_space`\n|
        `require_no_space`, `require_space`\n|===\n\n== Layout/SpaceInsideArrayLiteralBrackets\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.52\n| -\n|===\n\nChecks that brackets
        used for array literals have or don't have\nsurrounding space depending on
        configuration.\n\n=== Examples\n\n==== EnforcedStyle: no_space (default)\n\n[source,ruby]\n----\n#
        The `no_space` style enforces that array literals have\n# no surrounding space.\n\n#
        bad\narray = [ a, b, c, d ]\n\n# good\narray = [a, b, c, d]\n----\n\n====
        EnforcedStyle: space\n\n[source,ruby]\n----\n# The `space` style enforces
        that array literals have\n# surrounding space.\n\n# bad\narray = [a, b, c,
        d]\n\n# good\narray = [ a, b, c, d ]\n----\n\n==== EnforcedStyle: compact\n\n[source,ruby]\n----\n#
        The `compact` style normally requires a space inside\n# array brackets, with
        the exception that successive left\n# or right brackets are collapsed together
        in nested arrays.\n\n# bad\narray = [ a, [ b, c ] ]\narray = [\n  [ a ],\n
        \ [ b, c ]\n]\n\n# good\narray = [ a, [ b, c ]]\narray = [[ a ],\n  [ b, c
        ]]\n----\n\n==== EnforcedStyleForEmptyBrackets: no_space (default)\n\n[source,ruby]\n----\n#
        The `no_space` EnforcedStyleForEmptyBrackets style enforces that\n# empty
        array brackets do not contain spaces.\n\n# bad\nfoo = [ ]\nbar = [     ]\n\n#
        good\nfoo = []\nbar = []\n----\n\n==== EnforcedStyleForEmptyBrackets: space\n\n[source,ruby]\n----\n#
        The `space` EnforcedStyleForEmptyBrackets style enforces that\n# empty array
        brackets contain exactly one space.\n\n# bad\nfoo = []\nbar = [    ]\n\n#
        good\nfoo = [ ]\nbar = [ ]\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `no_space`\n|
        `space`, `no_space`, `compact`\n\n| EnforcedStyleForEmptyBrackets\n| `no_space`\n|
        `space`, `no_space`\n|===\n\n== Layout/SpaceInsideArrayPercentLiteral\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for unnecessary
        additional spaces inside array percent literals\n(i.e. %i/%w).\n\nNote that
        blank percent literals (e.g. `%i( )`) are checked by\n`Layout/SpaceInsidePercentLiteralDelimiters`.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n%w(foo  bar  baz)\n# good\n%i(foo
        bar baz)\n----\n\n== Layout/SpaceInsideBlockBraces\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that block braces have or don't
        have surrounding space inside\nthem on configuration. For blocks taking parameters,
        it checks that the\nleft brace has or doesn't have trailing space depending
        on\nconfiguration.\n\n=== Examples\n\n==== EnforcedStyle: space (default)\n\n[source,ruby]\n----\n#
        The `space` style enforces that block braces have\n# surrounding space.\n\n#
        bad\nsome_array.each {puts e}\n\n# good\nsome_array.each { puts e }\n----\n\n====
        EnforcedStyle: no_space\n\n[source,ruby]\n----\n# The `no_space` style enforces
        that block braces don't\n# have surrounding space.\n\n# bad\nsome_array.each
        { puts e }\n\n# good\nsome_array.each {puts e}\n----\n\n==== EnforcedStyleForEmptyBraces:
        no_space (default)\n\n[source,ruby]\n----\n# The `no_space` EnforcedStyleForEmptyBraces
        style enforces that\n# block braces don't have a space in between when empty.\n\n#
        bad\nsome_array.each {   }\nsome_array.each {  }\nsome_array.each { }\n\n#
        good\nsome_array.each {}\n----\n\n==== EnforcedStyleForEmptyBraces: space\n\n[source,ruby]\n----\n#
        The `space` EnforcedStyleForEmptyBraces style enforces that\n# block braces
        have at least a space in between when empty.\n\n# bad\nsome_array.each {}\n\n#
        good\nsome_array.each { }\nsome_array.each {  }\nsome_array.each {   }\n----\n\n====
        SpaceBeforeBlockParameters: true (default)\n\n[source,ruby]\n----\n# The SpaceBeforeBlockParameters
        style set to `true` enforces that\n# there is a space between `{` and `|`.
        Overrides `EnforcedStyle`\n# if there is a conflict.\n\n# bad\n[1, 2, 3].each
        {|n| n * 2 }\n\n# good\n[1, 2, 3].each { |n| n * 2 }\n----\n\n==== SpaceBeforeBlockParameters:
        false\n\n[source,ruby]\n----\n# The SpaceBeforeBlockParameters style set to
        `false` enforces that\n# there is no space between `{` and `|`. Overrides
        `EnforcedStyle`\n# if there is a conflict.\n\n# bad\n[1, 2, 3].each { |n|
        n * 2 }\n\n# good\n[1, 2, 3].each {|n| n * 2 }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `space`\n|
        `space`, `no_space`\n\n| EnforcedStyleForEmptyBraces\n| `no_space`\n| `space`,
        `no_space`\n\n| SpaceBeforeBlockParameters\n| `true`\n| Boolean\n|===\n\n==
        Layout/SpaceInsideHashLiteralBraces\n\n|===\n| Enabled by default | Safe |
        Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks that braces used for hash literals
        have or don't have\nsurrounding space depending on configuration.\n\n=== Examples\n\n====
        EnforcedStyle: space (default)\n\n[source,ruby]\n----\n# The `space` style
        enforces that hash literals have\n# surrounding space.\n\n# bad\nh = {a: 1,
        b: 2}\n\n# good\nh = { a: 1, b: 2 }\n----\n\n==== EnforcedStyle: no_space\n\n[source,ruby]\n----\n#
        The `no_space` style enforces that hash literals have\n# no surrounding space.\n\n#
        bad\nh = { a: 1, b: 2 }\n\n# good\nh = {a: 1, b: 2}\n----\n\n==== EnforcedStyle:
        compact\n\n[source,ruby]\n----\n# The `compact` style normally requires a
        space inside\n# hash braces, with the exception that successive left\n# braces
        or right braces are collapsed together in nested hashes.\n\n# bad\nh = { a:
        { b: 2 } }\nfoo = { { a: 1 } => { b: { c: 2 } } }\n\n# good\nh = { a: { b:
        2 }}\nfoo = {{ a: 1 } => { b: { c: 2 }}}\n----\n\n==== EnforcedStyleForEmptyBraces:
        no_space (default)\n\n[source,ruby]\n----\n# The `no_space` EnforcedStyleForEmptyBraces
        style enforces that\n# empty hash braces do not contain spaces.\n\n# bad\nfoo
        = { }\nbar = {    }\nbaz = {\n}\n\n# good\nfoo = {}\nbar = {}\nbaz = {}\n----\n\n====
        EnforcedStyleForEmptyBraces: space\n\n[source,ruby]\n----\n# The `space` EnforcedStyleForEmptyBraces
        style enforces that\n# empty hash braces contain space.\n\n# bad\nfoo = {}\n\n#
        good\nfoo = { }\nfoo = {    }\nfoo = {\n}\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `space`\n|
        `space`, `no_space`, `compact`\n\n| EnforcedStyleForEmptyBraces\n| `no_space`\n|
        `space`, `no_space`\n|===\n\n=== References\n\n* https://rubystyle.guide#spaces-braces\n\n==
        Layout/SpaceInsideParens\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n|
        1.22\n|===\n\nChecks for spaces inside ordinary round parentheses.\n\n===
        Examples\n\n==== EnforcedStyle: no_space (default)\n\n[source,ruby]\n----\n#
        The `no_space` style enforces that parentheses do not have spaces.\n\n# bad\nf(
        3)\ng = (a + 3 )\nf( )\n\n# good\nf(3)\ng = (a + 3)\nf()\n----\n\n==== EnforcedStyle:
        space\n\n[source,ruby]\n----\n# The `space` style enforces that parentheses
        have a space at the\n# beginning and end.\n# Note: Empty parentheses should
        not have spaces.\n\n# bad\nf(3)\ng = (a + 3)\ny( )\n\n# good\nf( 3 )\ng =
        ( a + 3 )\ny()\n----\n\n==== EnforcedStyle: compact\n\n[source,ruby]\n----\n#
        The `compact` style enforces that parentheses have a space at the\n# beginning
        with the exception that successive parentheses are allowed.\n# Note: Empty
        parentheses should not have spaces.\n\n# bad\nf(3)\ng = (a + 3)\ny( )\ng(
        f( x ) )\ng( f( x( 3 ) ), 5 )\ng( ( ( 3 + 5 ) * f) ** x, 5 )\n\n# good\nf(
        3 )\ng = ( a + 3 )\ny()\ng( f( x ))\ng( f( x( 3 )), 5 )\ng((( 3 + 5 ) * f
        ) ** x, 5 )\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default
        value | Configurable values\n\n| EnforcedStyle\n| `no_space`\n| `space`, `compact`,
        `no_space`\n|===\n\n=== References\n\n* https://rubystyle.guide#spaces-braces\n\n==
        Layout/SpaceInsidePercentLiteralDelimiters\n\n|===\n| Enabled by default |
        Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for unnecessary additional spaces
        inside the delimiters of\n%i/%w/%x literals.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n%i( foo bar baz )\n\n# good\n%i(foo bar baz)\n\n# bad\n%w( foo bar baz
        )\n\n# good\n%w(foo bar baz)\n\n# bad\n%x(  ls -l )\n\n# good\n%x(ls -l)\n\n#
        bad\n%w( )\n%w(\n)\n\n# good\n%w()\n----\n\n== Layout/SpaceInsideRangeLiteral\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for spaces
        inside range literals.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n1 ..
        3\n\n# good\n1..3\n\n# bad\n'a' .. 'z'\n\n# good\n'a'..'z'\n----\n\n=== References\n\n*
        https://rubystyle.guide#no-space-inside-range-literals\n\n== Layout/SpaceInsideReferenceBrackets\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.52\n| 0.53\n|===\n\nChecks that
        reference brackets have or don't have\nsurrounding space depending on configuration.\n\n===
        Examples\n\n==== EnforcedStyle: no_space (default)\n\n[source,ruby]\n----\n#
        The `no_space` style enforces that reference brackets have\n# no surrounding
        space.\n\n# bad\nhash[ :key ]\narray[ index ]\n\n# good\nhash[:key]\narray[index]\n----\n\n====
        EnforcedStyle: space\n\n[source,ruby]\n----\n# The `space` style enforces
        that reference brackets have\n# surrounding space.\n\n# bad\nhash[:key]\narray[index]\n\n#
        good\nhash[ :key ]\narray[ index ]\n----\n\n==== EnforcedStyleForEmptyBrackets:
        no_space (default)\n\n[source,ruby]\n----\n# The `no_space` EnforcedStyleForEmptyBrackets
        style enforces that\n# empty reference brackets do not contain spaces.\n\n#
        bad\nfoo[ ]\nfoo[     ]\nfoo[\n]\n\n# good\nfoo[]\n----\n\n==== EnforcedStyleForEmptyBrackets:
        space\n\n[source,ruby]\n----\n# The `space` EnforcedStyleForEmptyBrackets
        style enforces that\n# empty reference brackets contain exactly one space.\n\n#
        bad\nfoo[]\nfoo[    ]\nfoo[\n]\n\n# good\nfoo[ ]\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `no_space`\n| `space`, `no_space`\n\n| EnforcedStyleForEmptyBrackets\n| `no_space`\n|
        `space`, `no_space`\n|===\n\n== Layout/SpaceInsideStringInterpolation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nChecks for whitespace
        within string interpolations.\n\n=== Examples\n\n==== EnforcedStyle: no_space
        (default)\n\n[source,ruby]\n----\n# bad\n   var = \"This is the #{ space }
        example\"\n\n# good\n   var = \"This is the #{no_space} example\"\n----\n\n====
        EnforcedStyle: space\n\n[source,ruby]\n----\n# bad\n   var = \"This is the
        #{no_space} example\"\n\n# good\n   var = \"This is the #{ space } example\"\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        EnforcedStyle\n| `no_space`\n| `space`, `no_space`\n|===\n\n=== References\n\n*
        https://rubystyle.guide#string-interpolation\n\n== Layout/TrailingEmptyLines\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| 0.77\n|===\n\nLooks for trailing
        blank lines and a final newline in the\nsource code.\n\n=== Examples\n\n====
        EnforcedStyle: final_newline (default)\n\n[source,ruby]\n----\n# `final_newline`
        looks for one newline at the end of files.\n\n# bad\nclass Foo; end\n\n# EOF\n\n#
        bad\nclass Foo; end # EOF\n\n# good\nclass Foo; end\n# EOF\n----\n\n==== EnforcedStyle:
        final_blank_line\n\n[source,ruby]\n----\n# `final_blank_line` looks for one
        blank line followed by a new line\n# at the end of files.\n\n# bad\nclass
        Foo; end\n# EOF\n\n# bad\nclass Foo; end # EOF\n\n# good\nclass Foo; end\n\n#
        EOF\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default value |
        Configurable values\n\n| EnforcedStyle\n| `final_newline`\n| `final_newline`,
        `final_blank_line`\n|===\n\n=== References\n\n* https://rubystyle.guide#newline-eof\n\n==
        Layout/TrailingWhitespace\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.49\n| 1.0\n|===\n\nLooks for trailing whitespace in the source code.\n\n===
        Examples\n\n[source,ruby]\n----\n# The line in this example contains spaces
        after the 0.\n# bad\nx = 0\n\n# The line in this example ends directly after
        the 0.\n# good\nx = 0\n----\n\n==== AllowInHeredoc: false (default)\n\n[source,ruby]\n----\n#
        The line in this example contains spaces after the 0.\n# bad\ncode = <<~RUBY\n
        \ x = 0\nRUBY\n\n# ok\ncode = <<~RUBY\n  x = 0 #{}\nRUBY\n\n# good\ntrailing_whitespace
        = ' '\ncode = <<~RUBY\n  x = 0#{trailing_whitespace}\nRUBY\n----\n\n==== AllowInHeredoc:
        true\n\n[source,ruby]\n----\n# The line in this example contains spaces after
        the 0.\n# good\ncode = <<~RUBY\n  x = 0\nRUBY\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowInHeredoc\n| `false`\n|
        Boolean\n|===\n\n=== References\n\n* https://rubystyle.guide#no-trailing-whitespace\n\ninclude::../partials/cops_layout_footer.adoc[]\n"
  recorded_at: Mon, 27 May 2024 05:30:39 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_lint.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '123499'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"b2251455dfd7a296fad6e4c5b2c1f2af065ae787354a09e7ec7ee43d10997089"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - ED48:3BC15A:1331EAB:146AE6B:66541A7D
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:39 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230140-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787839.040424,VS0,VE217
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 298122e13dca9568edce1b5f03cc7d76b7df4e5b
      Expires:
      - Mon, 27 May 2024 05:35:39 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: "////\n  Do NOT edit this file by hand directly, as it is automatically
        generated.\n\n  Please make any necessary changes to the cop documentation
        within the source files themselves.\n////\n\n= Lint\n\n== Lint/AmbiguousAssignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.7\n| -\n|===\n\nChecks for mistyped
        shorthand assignments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nx =-
        y\nx =+ y\nx =* y\nx =! y\n\n# good\nx -= y # or x = -y\nx += y # or x = +y\nx
        *= y # or x = *y\nx != y # or x = !y\n----\n\n== Lint/AmbiguousBlockAssociation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.48\n| 1.13\n|===\n\nChecks for
        ambiguous block association with method\nwhen param passed without parentheses.\n\nThis
        cop can customize allowed methods with `AllowedMethods`.\nBy default, there
        are no methods to allowed.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nsome_method
        a { |val| puts val }\n----\n\n[source,ruby]\n----\n# good\n# With parentheses,
        there's no ambiguity.\nsome_method(a { |val| puts val })\n# or (different
        meaning)\nsome_method(a) { |val| puts val }\n\n# good\n# Operator methods
        require no disambiguation\nfoo == bar { |b| b.baz }\n\n# good\n# Lambda arguments
        require no disambiguation\nfoo = ->(bar) { bar.baz }\n----\n\n==== AllowedMethods:
        [] (default)\n\n[source,ruby]\n----\n# bad\nexpect { do_something }.to change
        { object.attribute }\n----\n\n==== AllowedMethods: [change]\n\n[source,ruby]\n----\n#
        good\nexpect { do_something }.to change { object.attribute }\n----\n\n====
        AllowedPatterns: [] (default)\n\n[source,ruby]\n----\n# bad\nexpect { do_something
        }.to change { object.attribute }\n----\n\n==== AllowedPatterns: ['change']\n\n[source,ruby]\n----\n#
        good\nexpect { do_something }.to change { object.attribute }\nexpect { do_something
        }.to not_change { object.attribute }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedMethods\n| `[]`\n|
        Array\n\n| AllowedPatterns\n| `[]`\n| Array\n|===\n\n== Lint/AmbiguousOperator\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.17\n| 0.83\n|===\n\nChecks for
        ambiguous operators in the first argument of a\nmethod invocation without
        parentheses.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n# The `*` is
        interpreted as a splat operator but it could possibly be\n# a `*` method invocation
        (i.e. `do_something.*(some_array)`).\ndo_something *some_array\n----\n\n[source,ruby]\n----\n#
        good\n\n# With parentheses, there's no ambiguity.\ndo_something(*some_array)\n----\n\n===
        References\n\n* https://rubystyle.guide#method-invocation-parens\n\n== Lint/AmbiguousOperatorPrecedence\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.21\n| -\n|===\n\nLooks for expressions
        containing multiple binary operators\nwhere precedence is ambiguous due to
        lack of parentheses. For example,\nin `1 + 2 * 3`, the multiplication will
        happen before the addition, but\nlexically it appears that the addition will
        happen first.\n\nThe cop does not consider unary operators (ie. `!a` or `-b`)
        or comparison\noperators (ie. `a =~ b`) because those are not ambiguous.\n\nNOTE:
        Ranges are handled by `Lint/AmbiguousRange`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\na + b * c\na || b && c\na ** b + c\n\n# good (different precedence)\na
        + (b * c)\na || (b && c)\n(a ** b) + c\n\n# good (same precedence)\na + b
        + c\na * b / c % d\n----\n\n== Lint/AmbiguousRange\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| Always (Unsafe)\n| 1.19\n| -\n|===\n\nChecks for ambiguous ranges.\n\nRanges
        have quite low precedence, which leads to unexpected behavior when\nusing
        a range with other operators. This cop avoids that by making ranges\nexplicit
        by requiring parenthesis around complex range boundaries (anything\nthat is
        not a literal: numerics, strings, symbols, etc.).\n\nThis cop can be configured
        with `RequireParenthesesForMethodChains` in order to\nspecify whether method
        chains (including `self.foo`) should be wrapped in parens\nby this cop.\n\nNOTE:
        Regardless of this configuration, if a method receiver is a basic literal\nvalue,
        it will be wrapped in order to prevent the ambiguity of `1..2.to_a`.\n\n===
        Safety\n\nThe cop autocorrects by wrapping the entire boundary in parentheses,
        which\nmakes the outcome more explicit but is possible to not be the intention
        of the\nprogrammer. For this reason, this cop's autocorrect is unsafe (it
        will not\nchange the behavior of the code, but will not necessarily match
        the\nintent of the program).\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nx
        || 1..2\n(x || 1..2)\n1..2.to_a\n\n# good, unambiguous\n1..2\n'a'..'z'\n:bar..:baz\nMyClass::MIN..MyClass::MAX\n@min..@max\na..b\n-a..b\n\n#
        good, ambiguity removed\nx || (1..2)\n(x || 1)..2\n(x || 1)..(y || 2)\n(1..2).to_a\n----\n\n====
        RequireParenthesesForMethodChains: false (default)\n\n[source,ruby]\n----\n#
        good\na.foo..b.bar\n(a.foo)..(b.bar)\n----\n\n==== RequireParenthesesForMethodChains:
        true\n\n[source,ruby]\n----\n# bad\na.foo..b.bar\n\n# good\n(a.foo)..(b.bar)\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        RequireParenthesesForMethodChains\n| `false`\n| Boolean\n|===\n\n== Lint/AmbiguousRegexpLiteral\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.17\n| 0.83\n|===\n\nChecks for
        ambiguous regexp literals in the first argument of\na method invocation without
        parentheses.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n# This is interpreted
        as a method invocation with a regexp literal,\n# but it could possibly be
        `/` method invocations.\n# (i.e. `do_something./(pattern)./(i)`)\ndo_something
        /pattern/i\n----\n\n[source,ruby]\n----\n# good\n\n# With parentheses, there's
        no ambiguity.\ndo_something(/pattern/i)\n----\n\n== Lint/AssignmentInCondition\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always (Unsafe)\n| 0.9\n| 1.45\n|===\n\nChecks
        for assignments in the conditions of\nif/while/until.\n\n`AllowSafeAssignment`
        option for safe assignment.\nBy safe assignment we mean putting parentheses
        around\nan assignment to indicate \"I know I'm using an assignment\nas a condition.
        It's not a mistake.\"\n\n=== Safety\n\nThis cop's autocorrection is unsafe
        because it assumes that\nthe author meant to use an assignment result as a
        condition.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif some_var = value\n
        \ do_something\nend\n\n# good\nif some_var == value\n  do_something\nend\n----\n\n====
        AllowSafeAssignment: true (default)\n\n[source,ruby]\n----\n# good\nif (some_var
        = value)\n  do_something\nend\n----\n\n==== AllowSafeAssignment: false\n\n[source,ruby]\n----\n#
        bad\nif (some_var = value)\n  do_something\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| AllowSafeAssignment\n|
        `true`\n| Boolean\n|===\n\n=== References\n\n* https://rubystyle.guide#safe-assignment-in-condition\n\n==
        Lint/BigDecimalNew\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.53\n|
        -\n|===\n\n`BigDecimal.new()` is deprecated since BigDecimal 1.3.3.\nThis
        cop identifies places where `BigDecimal.new()`\ncan be replaced by `BigDecimal()`.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nBigDecimal.new(123.456, 3)\n\n# good\nBigDecimal(123.456,
        3)\n----\n\n== Lint/BinaryOperatorWithIdenticalOperands\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| No\n| No\n| 0.89\n| 1.7\n|===\n\nChecks for places where binary
        operator has identical operands.\n\nIt covers arithmetic operators: `-`, `/`,
        `%`;\ncomparison operators: `==`, `===`, `=~`, `>`, `>=`, `<`, ``<=``;\nbitwise
        operators: `|`, `^`, `&`;\nboolean operators: `&&`, `||`\nand \"spaceship\"
        operator - ``<=>``.\n\nSimple arithmetic operations are allowed by this cop:
        `+`, `*`, `**`, `<<` and `>>`.\nAlthough these can be rewritten in a different
        way, it should not be necessary to\ndo so. This does not include operations
        such as `-` or `/` where the result will\nalways be the same (`x - x` will
        always be 0; `x / x` will always be 1), and\nthus are legitimate offenses.\n\n===
        Safety\n\nThis cop is unsafe as it does not consider side effects when calling
        methods\nand thus can generate false positives, for example:\n\n[source,ruby]\n----\nif
        wr.take_char == '\\0' && wr.take_char == '\\0'\n  # ...\nend\n----\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nx / x\nx.top >= x.top\n\nif a.x !=
        0 && a.x != 0\n  do_something\nend\n\ndef child?\n  left_child || left_child\nend\n\n#
        good\nx + x\n1 << 1\n----\n\n== Lint/BooleanSymbol\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always (Unsafe)\n| 0.50\n| 1.22\n|===\n\nChecks for `:true` and `:false`
        symbols.\nIn most cases it would be a typo.\n\n=== Safety\n\nAutocorrection
        is unsafe for this cop because code relying\non `:true` or `:false` symbols
        will break when those are\nchanged to actual booleans.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n:true\n\n# good\ntrue\n----\n\n[source,ruby]\n----\n# bad\n:false\n\n#
        good\nfalse\n----\n\n== Lint/CircularArgumentReference\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| No\n| 0.33\n| -\n|===\n\nChecks for circular argument references
        in optional keyword\narguments and optional ordinal arguments.\n\nThis cop
        mirrors a warning produced by MRI since 2.2.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\ndef bake(pie: pie)\n  pie.heat_up\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef bake(pie:)\n  pie.refrigerate\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef bake(pie: self.pie)\n  pie.feed_to(user)\nend\n----\n\n[source,ruby]\n----\n#
        bad\n\ndef cook(dry_ingredients = dry_ingredients)\n  dry_ingredients.reduce(&:+)\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef cook(dry_ingredients = self.dry_ingredients)\n  dry_ingredients.combine\nend\n----\n\n==
        Lint/ConstantDefinitionInBlock\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.91\n| 1.3\n|===\n\nDo not define constants within a block, since the block's
        scope does not\nisolate or namespace the constant in any way.\n\nIf you are
        trying to define that constant once, define it outside of\nthe block instead,
        or use a variable or method if defining the constant\nin the outer scope would
        be problematic.\n\nFor meta-programming, use `const_set`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ntask :lint do\n  FILES_TO_LINT = Dir['lib/*.rb']\nend\n\n# bad\ndescribe
        'making a request' do\n  class TestRequest; end\nend\n\n# bad\nmodule M\n
        \ extend ActiveSupport::Concern\n  included do\n    LIST = []\n  end\nend\n\n#
        good\ntask :lint do\n  files_to_lint = Dir['lib/*.rb']\nend\n\n# good\ndescribe
        'making a request' do\n  let(:test_request) { Class.new }\n  # see also `stub_const`
        for RSpec\nend\n\n# good\nmodule M\n  extend ActiveSupport::Concern\n  included
        do\n    const_set(:LIST, [])\n  end\nend\n----\n\n==== AllowedMethods: ['enums']
        (default)\n\n[source,ruby]\n----\n# good\n\n# `enums` for Typed Enums via
        `T::Enum` in Sorbet.\n# https://sorbet.org/docs/tenum\nclass TestEnum < T::Enum\n
        \ enums do\n    Foo = new(\"foo\")\n  end\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedMethods\n| `enums`\n|
        Array\n|===\n\n=== References\n\n* https://rubystyle.guide#no-constant-definition-in-block\n\n==
        Lint/ConstantOverwrittenInRescue\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Pending\n| Yes\n| Always\n|
        1.31\n| -\n|===\n\nChecks for overwriting an exception with an exception result
        by use ``rescue =>``.\n\nYou intended to write as `rescue StandardError`.\nHowever,
        you have written `rescue => StandardError`.\nIn that case, the result of `rescue`
        will overwrite `StandardError`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nbegin\n  something\nrescue => StandardError\nend\n\n# good\nbegin\n  something\nrescue
        StandardError\nend\n----\n\n== Lint/ConstantResolution\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Disabled\n| Yes\n| No\n| 0.86\n| -\n|===\n\nCheck that certain constants are
        fully qualified.\n\nThis is not enabled by default because it would mark a
        lot of offenses\nunnecessarily.\n\nGenerally, gems should fully qualify all
        constants to avoid conflicts with\nthe code that uses the gem. Enable this
        cop without using `Only`/`Ignore`\n\nLarge projects will over time end up
        with one or two constant names that\nare problematic because of a conflict
        with a library or just internally\nusing the same name a namespace and a class.
        To avoid too many unnecessary\noffenses, Enable this cop with `Only: [The,
        Constant, Names, Causing, Issues]`\n\nNOTE: `Style/RedundantConstantBase`
        cop is disabled if this cop is enabled to prevent\nconflicting rules. Because
        it respects user configurations that want to enable\nthis cop which is disabled
        by default.\n\n=== Examples\n\n[source,ruby]\n----\n# By default checks every
        constant\n\n# bad\nUser\n\n# bad\nUser::Login\n\n# good\n::User\n\n# good\n::User::Login\n----\n\n====
        Only: ['Login']\n\n[source,ruby]\n----\n# Restrict this cop to only being
        concerned about certain constants\n\n# bad\nLogin\n\n# good\n::Login\n\n#
        good\nUser::Login\n----\n\n==== Ignore: ['Login']\n\n[source,ruby]\n----\n#
        Restrict this cop not being concerned about certain constants\n\n# bad\nUser\n\n#
        good\n::User::Login\n\n# good\nLogin\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| Only\n| `[]`\n| Array\n\n|
        Ignore\n| `[]`\n| Array\n|===\n\n== Lint/Debugger\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| No\n| 0.14\n| 1.63\n|===\n\nChecks for debug calls (such as `debugger`
        or `binding.pry`) that should\nnot be kept for production code.\n\nThe cop
        can be configured using `DebuggerMethods`. By default, a number of gems\ndebug
        entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `debug.rb`,\n`Pry`,
        `Rails`, `RubyJard`, and `WebConsole`). Additional methods can be added.\n\nSpecific
        default groups can be disabled if necessary:\n\n[source,yaml]\n----\nLint/Debugger:\n
        \ DebuggerMethods:\n    WebConsole: ~\n----\n\nYou can also add your own methods
        by adding a new category:\n\n[source,yaml]\n----\nLint/Debugger:\n  DebuggerMethods:\n
        \   MyDebugger:\n      MyDebugger.debug_this\n----\n\nSome gems also ship
        files that will start a debugging session when required,\nfor example `require
        'debug/start'` from `ruby/debug`. These requires can\nbe configured through
        `DebuggerRequires`. It has the same structure as\n`DebuggerMethods`, which
        you can read about above.\n\n=== Examples\n\n[source,ruby]\n----\n# bad (ok
        during development)\n\n# using pry\ndef some_method\n  binding.pry\n  do_something\nend\n----\n\n[source,ruby]\n----\n#
        bad (ok during development)\n\n# using byebug\ndef some_method\n  byebug\n
        \ do_something\nend\n----\n\n[source,ruby]\n----\n# good\n\ndef some_method\n
        \ do_something\nend\n----\n\n==== DebuggerMethods: [my_debugger]\n\n[source,ruby]\n----\n#
        bad (ok during development)\n\ndef some_method\n  my_debugger\nend\n----\n\n====
        DebuggerRequires: [my_debugger/start]\n\n[source,ruby]\n----\n# bad (ok during
        development)\n\nrequire 'my_debugger/start'\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| DebuggerMethods\n| `{\"Kernel\"=>[\"binding.irb\",
        \"Kernel.binding.irb\"], \"Byebug\"=>[\"byebug\", \"remote_byebug\", \"Kernel.byebug\",
        \"Kernel.remote_byebug\"], \"Capybara\"=>[\"page.save_and_open_page\", \"page.save_and_open_screenshot\",
        \"page.save_page\", \"page.save_screenshot\", \"save_and_open_page\", \"save_and_open_screenshot\",
        \"save_page\", \"save_screenshot\"], \"debug.rb\"=>[\"binding.b\", \"binding.break\",
        \"Kernel.binding.b\", \"Kernel.binding.break\"], \"Pry\"=>[\"binding.pry\",
        \"binding.remote_pry\", \"binding.pry_remote\", \"Kernel.binding.pry\", \"Kernel.binding.remote_pry\",
        \"Kernel.binding.pry_remote\", \"Pry.rescue\", \"pry\"], \"Rails\"=>[\"debugger\",
        \"Kernel.debugger\"], \"RubyJard\"=>[\"jard\"], \"WebConsole\"=>[\"binding.console\"]}`\n|
        \n\n| DebuggerRequires\n| `{\"debug.rb\"=>[\"debug/open\", \"debug/start\"]}`\n|
        \n|===\n\n== Lint/DeprecatedClassMethods\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.19\n| -\n|===\n\nChecks for uses of the deprecated class
        method usages.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nFile.exists?(some_path)\nDir.exists?(some_path)\niterator?\nattr
        :name, true\nattr :name, false\nENV.freeze # Calling `Env.freeze` raises `TypeError`
        since Ruby 2.7.\nENV.clone\nENV.dup # Calling `Env.dup` raises `TypeError`
        since Ruby 3.1.\nSocket.gethostbyname(host)\nSocket.gethostbyaddr(host)\n\n#
        good\nFile.exist?(some_path)\nDir.exist?(some_path)\nblock_given?\nattr_accessor
        :name\nattr_reader :name\nENV # `ENV.freeze` cannot prohibit changes to environment
        variables.\nENV.to_h\nENV.to_h # `ENV.dup` cannot dup `ENV`, use `ENV.to_h`
        to get a copy of `ENV` as a hash.\nAddrinfo.getaddrinfo(nodename, service)\nAddrinfo.tcp(host,
        port).getnameinfo\n----\n\n== Lint/DeprecatedConstants\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Pending\n| Yes\n| Always\n| 1.8\n| 1.40\n|===\n\nChecks for deprecated constants.\n\nIt
        has `DeprecatedConstants` config. If there is an alternative method, you can
        set\nalternative value as `Alternative`. And you can set the deprecated version
        as\n`DeprecatedVersion`. These options can be omitted if they are not needed.\n\n
        \ DeprecatedConstants:\n    'DEPRECATED_CONSTANT':\n      Alternative: 'alternative_value'\n
        \     DeprecatedVersion: 'deprecated_version'\n\nBy default, `NIL`, `TRUE`,
        `FALSE`, `Net::HTTPServerException, `Random::DEFAULT`,\n`Struct::Group`, and
        `Struct::Passwd` are configured.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nNIL\nTRUE\nFALSE\nNet::HTTPServerException\nRandom::DEFAULT # Return
        value of Ruby 2 is `Random` instance, Ruby 3.0 is `Random` class.\nStruct::Group\nStruct::Passwd\n\n#
        good\nnil\ntrue\nfalse\nNet::HTTPClientException\nRandom.new # `::DEFAULT`
        has been deprecated in Ruby 3, `.new` is compatible with Ruby 2.\nEtc::Group\nEtc::Passwd\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        DeprecatedConstants\n| `{\"NIL\"=>{\"Alternative\"=>\"nil\", \"DeprecatedVersion\"=>\"2.4\"},
        \"TRUE\"=>{\"Alternative\"=>\"true\", \"DeprecatedVersion\"=>\"2.4\"}, \"FALSE\"=>{\"Alternative\"=>\"false\",
        \"DeprecatedVersion\"=>\"2.4\"}, \"Net::HTTPServerException\"=>{\"Alternative\"=>\"Net::HTTPClientException\",
        \"DeprecatedVersion\"=>\"2.6\"}, \"Random::DEFAULT\"=>{\"Alternative\"=>\"Random.new\",
        \"DeprecatedVersion\"=>\"3.0\"}, \"Struct::Group\"=>{\"Alternative\"=>\"Etc::Group\",
        \"DeprecatedVersion\"=>\"3.0\"}, \"Struct::Passwd\"=>{\"Alternative\"=>\"Etc::Passwd\",
        \"DeprecatedVersion\"=>\"3.0\"}}`\n| \n|===\n\n== Lint/DeprecatedOpenSSLConstant\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.84\n| -\n|===\n\nAlgorithmic constants
        for `OpenSSL::Cipher` and `OpenSSL::Digest`\ndeprecated since OpenSSL version
        2.2.0. Prefer passing a string\ninstead.\n\n=== Examples\n\n[source,ruby]\n----\n#
        Example for OpenSSL::Cipher instantiation.\n\n# bad\nOpenSSL::Cipher::AES.new(128,
        :GCM)\n\n# good\nOpenSSL::Cipher.new('aes-128-gcm')\n----\n\n[source,ruby]\n----\n#
        Example for OpenSSL::Digest instantiation.\n\n# bad\nOpenSSL::Digest::SHA256.new\n\n#
        good\nOpenSSL::Digest.new('SHA256')\n----\n\n[source,ruby]\n----\n# Example
        for ::Digest inherited class methods.\n\n# bad\nOpenSSL::Digest::SHA256.digest('foo')\n\n#
        good\nOpenSSL::Digest.digest('SHA256', 'foo')\n----\n\n== Lint/DisjunctiveAssignmentInConstructor\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n| 0.62\n| 0.88\n|===\n\nChecks
        constructors for disjunctive assignments (`||=`) that should\nbe plain assignments.\n\nSo
        far, this cop is only concerned with disjunctive assignment of\ninstance variables.\n\nIn
        ruby, an instance variable is nil until a value is assigned, so the\ndisjunction
        is unnecessary. A plain assignment has the same effect.\n\n=== Safety\n\nThis
        cop is unsafe because it can register a false positive when a\nmethod is redefined
        in a subclass that calls super. For example:\n\n[source,ruby]\n----\nclass
        Base\n  def initialize\n    @config ||= 'base'\n  end\nend\n\nclass Derived
        < Base\n  def initialize\n    @config = 'derived'\n    super\n  end\nend\n----\n\nWithout
        the disjunctive assignment, `Derived` will be unable to override\nthe value
        for `@config`.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef initialize\n
        \ @x ||= 1\nend\n\n# good\ndef initialize\n  @x = 1\nend\n----\n\n== Lint/DuplicateBranch\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.3\n| 1.7\n|===\n\nChecks that there
        are no repeated bodies\nwithin `if/unless`, `case-when`, `case-in` and `rescue`
        constructs.\n\nWith `IgnoreLiteralBranches: true`, branches are not registered\nas
        offenses if they return a basic literal value (string, symbol,\ninteger, float,
        rational, complex, `true`, `false`, or `nil`), or\nreturn an array, hash,
        regexp or range that only contains one of\nthe above basic literal values.\n\nWith
        `IgnoreConstantBranches: true`, branches are not registered\nas offenses if
        they return a constant value.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif
        foo\n  do_foo\n  do_something_else\nelsif bar\n  do_foo\n  do_something_else\nend\n\n#
        good\nif foo || bar\n  do_foo\n  do_something_else\nend\n\n# bad\ncase x\nwhen
        foo\n  do_foo\nwhen bar\n  do_foo\nelse\n  do_something_else\nend\n\n# good\ncase
        x\nwhen foo, bar\n  do_foo\nelse\n  do_something_else\nend\n\n# bad\nbegin\n
        \ do_something\nrescue FooError\n  handle_error\nrescue BarError\n  handle_error\nend\n\n#
        good\nbegin\n  do_something\nrescue FooError, BarError\n  handle_error\nend\n----\n\n====
        IgnoreLiteralBranches: true\n\n[source,ruby]\n----\n# good\ncase size\nwhen
        \"small\" then 100\nwhen \"medium\" then 250\nwhen \"large\" then 1000\nelse
        250\nend\n----\n\n==== IgnoreConstantBranches: true\n\n[source,ruby]\n----\n#
        good\ncase size\nwhen \"small\" then SMALL_SIZE\nwhen \"medium\" then MEDIUM_SIZE\nwhen
        \"large\" then LARGE_SIZE\nelse MEDIUM_SIZE\nend\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| IgnoreLiteralBranches\n|
        `false`\n| Boolean\n\n| IgnoreConstantBranches\n| `false`\n| Boolean\n|===\n\n==
        Lint/DuplicateCaseCondition\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.45\n| -\n|===\n\nChecks that there are no repeated conditions\nused in case
        'when' expressions.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\ncase
        x\nwhen 'first'\n  do_something\nwhen 'first'\n  do_something_else\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ncase x\nwhen 'first'\n  do_something\nwhen 'second'\n  do_something_else\nend\n----\n\n==
        Lint/DuplicateElsifCondition\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.88\n| -\n|===\n\nChecks that there are no repeated conditions used in if
        'elsif'.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif x == 1\n  do_something\nelsif
        x == 1\n  do_something_else\nend\n\n# good\nif x == 1\n  do_something\nelsif
        x == 2\n  do_something_else\nend\n----\n\n== Lint/DuplicateHashKey\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.34\n| 0.77\n|===\n\nChecks for duplicated
        keys in hash literals.\nThis cop considers both primitive types and constants
        for the hash keys.\n\nThis cop mirrors a warning in Ruby 2.2.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nhash = { food: 'apple', food: 'orange' }\n----\n\n[source,ruby]\n----\n#
        good\n\nhash = { food: 'apple', other_food: 'orange' }\n----\n\n== Lint/DuplicateMagicComment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.37\n| -\n|===\n\nChecks for duplicated
        magic comments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n# encoding:
        ascii\n# encoding: ascii\n\n# good\n\n# encoding: ascii\n\n# bad\n\n# frozen_string_literal:
        true\n# frozen_string_literal: true\n\n# good\n\n# frozen_string_literal:
        true\n----\n\n== Lint/DuplicateMatchPattern\n\nNOTE: Required Ruby version:
        2.7\n\n|===\n| Enabled by default | Safe | Supports autocorrection | Version
        Added | Version Changed\n\n| Pending\n| Yes\n| No\n| 1.50\n| -\n|===\n\nChecks
        that there are no repeated patterns used in `in` keywords.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ncase x\nin 'first'\n  do_something\nin 'first'\n  do_something_else\nend\n\n#
        good\ncase x\nin 'first'\n  do_something\nin 'second'\n  do_something_else\nend\n\n#
        bad - repeated alternate patterns with the same conditions don't depend on
        the order\ncase x\nin foo | bar\n  first_method\nin bar | foo\n  second_method\nend\n\n#
        good\ncase x\nin foo | bar\n  first_method\nin bar | baz\n  second_method\nend\n\n#
        bad - repeated hash patterns with the same conditions don't depend on the
        order\ncase x\nin foo: a, bar: b\n  first_method\nin bar: b, foo: a\n  second_method\nend\n\n#
        good\ncase x\nin foo: a, bar: b\n  first_method\nin bar: b, baz: c\n  second_method\nend\n\n#
        bad - repeated array patterns with elements in the same order\ncase x\nin
        [foo, bar]\n  first_method\nin [foo, bar]\n  second_method\nend\n\n# good\ncase
        x\nin [foo, bar]\n  first_method\nin [bar, foo]\n  second_method\nend\n\n#
        bad - repeated the same patterns and guard conditions\ncase x\nin foo if bar\n
        \ first_method\nin foo if bar\n  second_method\nend\n\n# good\ncase x\nin
        foo if bar\n  first_method\nin foo if baz\n  second_method\nend\n----\n\n==
        Lint/DuplicateMethods\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.29\n| -\n|===\n\nChecks
        for duplicated instance (or singleton) method\ndefinitions.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\ndef foo\n  1\nend\n\ndef foo\n  2\nend\n----\n\n[source,ruby]\n----\n#
        bad\n\ndef foo\n  1\nend\n\nalias foo bar\n----\n\n[source,ruby]\n----\n#
        good\n\ndef foo\n  1\nend\n\ndef bar\n  2\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef foo\n  1\nend\n\nalias bar foo\n----\n\n== Lint/DuplicateRegexpCharacterClassElement\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.1\n| -\n|===\n\nChecks for duplicate
        elements in Regexp character classes.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nr = /[xyx]/\n\n# bad\nr = /[0-9x0-9]/\n\n# good\nr = /[xy]/\n\n# good\nr
        = /[0-9x]/\n----\n\n== Lint/DuplicateRequire\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always (Unsafe)\n| 0.90\n| 1.28\n|===\n\nChecks for duplicate ``require``s
        and ``require_relative``s.\n\n=== Safety\n\nThis cop's autocorrection is unsafe
        because it may break the dependency order\nof `require`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nrequire 'foo'\nrequire 'bar'\nrequire 'foo'\n\n# good\nrequire 'foo'\nrequire
        'bar'\n\n# good\nrequire 'foo'\nrequire_relative 'foo'\n----\n\n== Lint/DuplicateRescueException\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.89\n| -\n|===\n\nChecks that there
        are no repeated exceptions\nused in 'rescue' expressions.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nbegin\n  something\nrescue FirstException\n  handle_exception\nrescue
        FirstException\n  handle_other_exception\nend\n\n# good\nbegin\n  something\nrescue
        FirstException\n  handle_exception\nrescue SecondException\n  handle_other_exception\nend\n----\n\n==
        Lint/EachWithObjectArgument\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.31\n| -\n|===\n\nChecks if each_with_object is called with an immutable\nargument.
        Since the argument is the object that the given block shall\nmake calls on
        to build something based on the enumerable that\neach_with_object iterates
        over, an immutable argument makes no sense.\nIt's definitely a bug.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\nsum = numbers.each_with_object(0)
        { |e, a| a += e }\n----\n\n[source,ruby]\n----\n# good\n\nnum = 0\nsum = numbers.each_with_object(num)
        { |e, a| a += e }\n----\n\n== Lint/ElseLayout\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.17\n| 1.2\n|===\n\nChecks for odd `else` block layout -
        like\nhaving an expression on the same line as the `else` keyword,\nwhich
        is usually a mistake.\n\nIts autocorrection tweaks layout to keep the syntax.
        So, this autocorrection\nis compatible correction for bad case syntax, but
        if your code makes a mistake\nwith `elsif` and `else`, you will have to correct
        it manually.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nif something\n
        \ # ...\nelse do_this\n  do_that\nend\n----\n\n[source,ruby]\n----\n# good\n\n#
        This code is compatible with the bad case. It will be autocorrected like this.\nif
        something\n  # ...\nelse\n  do_this\n  do_that\nend\n\n# This code is incompatible
        with the bad case.\n# If `do_this` is a condition, `elsif` should be used
        instead of `else`.\nif something\n  # ...\nelsif do_this\n  do_that\nend\n----\n\n==
        Lint/EmptyBlock\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Pending\n| Yes\n| No\n| 1.1\n| 1.15\n|===\n\nChecks
        for blocks without a body.\nSuch empty blocks are typically an oversight or
        we should provide a comment\nto clarify what we're aiming for.\n\nEmpty lambdas
        and procs are ignored by default.\n\nNOTE: For backwards compatibility, the
        configuration that allows/disallows\nempty lambdas and procs is called `AllowEmptyLambdas`,
        even though it also\napplies to procs.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nitems.each { |item| }\n\n# good\nitems.each { |item| puts item }\n----\n\n====
        AllowComments: true (default)\n\n[source,ruby]\n----\n# good\nitems.each do
        |item|\n  # TODO: implement later (inner comment)\nend\n\nitems.each { |item|
        } # TODO: implement later (inline comment)\n----\n\n==== AllowComments: false\n\n[source,ruby]\n----\n#
        bad\nitems.each do |item|\n  # TODO: implement later (inner comment)\nend\n\nitems.each
        { |item| } # TODO: implement later (inline comment)\n----\n\n==== AllowEmptyLambdas:
        true (default)\n\n[source,ruby]\n----\n# good\nallow(subject).to receive(:callable).and_return(->
        {})\n\nplaceholder = lambda do\nend\n(callable || placeholder).call\n\nproc
        { }\n\nProc.new { }\n----\n\n==== AllowEmptyLambdas: false\n\n[source,ruby]\n----\n#
        bad\nallow(subject).to receive(:callable).and_return(-> {})\n\nplaceholder
        = lambda do\nend\n(callable || placeholder).call\n\nproc { }\n\nProc.new {
        }\n----\n\n=== Configurable attributes\n\n|===\n| Name | Default value | Configurable
        values\n\n| AllowComments\n| `true`\n| Boolean\n\n| AllowEmptyLambdas\n| `true`\n|
        Boolean\n|===\n\n== Lint/EmptyClass\n\n|===\n| Enabled by default | Safe |
        Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| No\n| 1.3\n| -\n|===\n\nChecks for classes and metaclasses without
        a body.\nSuch empty classes and metaclasses are typically an oversight or
        we should provide a comment\nto be clearer what we're aiming for.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nclass Foo\nend\n\nclass Bar\n  class << self\n  end\nend\n\nclass <<
        obj\nend\n\n# good\nclass Foo\n  def do_something\n    # ... code\n  end\nend\n\nclass
        Bar\n  class << self\n    attr_reader :bar\n  end\nend\n\nclass << obj\n  attr_reader
        :bar\nend\n----\n\n==== AllowComments: false (default)\n\n[source,ruby]\n----\n#
        bad\nclass Foo\n  # TODO: implement later\nend\n\nclass Bar\n  class << self\n
        \   # TODO: implement later\n  end\nend\n\nclass << obj\n  # TODO: implement
        later\nend\n----\n\n==== AllowComments: true\n\n[source,ruby]\n----\n# good\nclass
        Foo\n  # TODO: implement later\nend\n\nclass Bar\n  class << self\n    # TODO:
        implement later\n  end\nend\n\nclass << obj\n  # TODO: implement later\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowComments\n| `false`\n| Boolean\n|===\n\n== Lint/EmptyConditionalBody\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only (Unsafe)\n| 0.89\n| 1.61\n|===\n\nChecks
        for the presence of `if`, `elsif` and `unless` branches without a body.\n\nNOTE:
        empty `else` branches are handled by `Style/EmptyElse`.\n\n=== Safety\n\nAutocorrection
        for this cop is not safe. The conditions for empty branches that\nthe autocorrection
        removes may have side effects, or the logic in subsequent\nbranches may change
        due to the removal of a previous condition.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nif condition\nend\n\n# bad\nunless condition\nend\n\n# bad\nif condition\n
        \ do_something\nelsif other_condition\nend\n\n# good\nif condition\n  do_something\nend\n\n#
        good\nunless condition\n  do_something\nend\n\n# good\nif condition\n  do_something\nelsif
        other_condition\n  do_something_else\nend\n----\n\n==== AllowComments: true
        (default)\n\n[source,ruby]\n----\n# good\nif condition\n  do_something\nelsif
        other_condition\n  # noop\nend\n----\n\n==== AllowComments: false\n\n[source,ruby]\n----\n#
        bad\nif condition\n  do_something\nelsif other_condition\n  # noop\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowComments\n| `true`\n| Boolean\n|===\n\n== Lint/EmptyEnsure\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only\n| 0.10\n| 1.61\n|===\n\nChecks
        for empty `ensure` blocks\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\ndef
        some_method\n  do_something\nensure\nend\n----\n\n[source,ruby]\n----\n# bad\n\nbegin\n
        \ do_something\nensure\nend\n----\n\n[source,ruby]\n----\n# good\n\ndef some_method\n
        \ do_something\nensure\n  do_something_else\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nbegin\n  do_something\nensure\n  do_something_else\nend\n----\n\n==
        Lint/EmptyExpression\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.45\n| -\n|===\n\nChecks
        for the presence of empty expressions.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nfoo = ()\nif ()\n  bar\nend\n----\n\n[source,ruby]\n----\n# good\n\nfoo
        = (some_expression)\nif (some_expression)\n  bar\nend\n----\n\n== Lint/EmptyFile\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.90\n| -\n|===\n\nEnforces that Ruby
        source files are not empty.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n#
        Empty file\n\n# good\n# File containing non commented source lines\n----\n\n====
        AllowComments: true (default)\n\n[source,ruby]\n----\n# good\n# File consisting
        only of comments\n----\n\n==== AllowComments: false\n\n[source,ruby]\n----\n#
        bad\n# File consisting only of comments\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowComments\n| `true`\n|
        Boolean\n|===\n\n== Lint/EmptyInPattern\n\nNOTE: Required Ruby version: 2.7\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.16\n| -\n|===\n\nChecks for the presence
        of `in` pattern branches without a body.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ncase condition\nin [a]\n  do_something\nin [a, b]\nend\n\n# good\ncase
        condition\nin [a]\n  do_something\nin [a, b]\n  nil\nend\n----\n\n==== AllowComments:
        true (default)\n\n[source,ruby]\n----\n# good\ncase condition\nin [a]\n  do_something\nin
        [a, b]\n  # noop\nend\n----\n\n==== AllowComments: false\n\n[source,ruby]\n----\n#
        bad\ncase condition\nin [a]\n  do_something\nin [a, b]\n  # noop\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowComments\n| `true`\n| Boolean\n|===\n\n== Lint/EmptyInterpolation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only\n| 0.20\n| 1.61\n|===\n\nChecks
        for empty interpolation.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n\"result
        is #{}\"\n----\n\n[source,ruby]\n----\n# good\n\n\"result is #{some_result}\"\n----\n\n==
        Lint/EmptyWhen\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.45\n| 0.83\n|===\n\nChecks
        for the presence of `when` branches without a body.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ncase foo\nwhen bar\n  do_something\nwhen baz\nend\n----\n\n[source,ruby]\n----\n#
        good\ncase condition\nwhen foo\n  do_something\nwhen bar\n  nil\nend\n----\n\n====
        AllowComments: true (default)\n\n[source,ruby]\n----\n# good\ncase condition\nwhen
        foo\n  do_something\nwhen bar\n  # noop\nend\n----\n\n==== AllowComments:
        false\n\n[source,ruby]\n----\n# bad\ncase condition\nwhen foo\n  do_something\nwhen
        bar\n  # do nothing\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| AllowComments\n| `true`\n| Boolean\n|===\n\n==
        Lint/EnsureReturn\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.9\n|
        0.83\n|===\n\nChecks for `return` from an `ensure` block.\n`return` from an
        ensure block is a dangerous code smell as it\nwill take precedence over any
        exception being raised,\nand the exception will be silently thrown away as
        if it were rescued.\n\nIf you want to rescue some (or all) exceptions, best
        to do it explicitly\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\ndef foo\n
        \ do_something\nensure\n  cleanup\n  return self\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef foo\n  do_something\n  self\nensure\n  cleanup\nend\n\n# also
        good\n\ndef foo\n  begin\n    do_something\n  rescue SomeException\n    #
        Let's ignore this exception\n  end\n  self\nensure\n  cleanup\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#no-return-ensure\n\n== Lint/ErbNewArguments\n\nNOTE:
        Required Ruby version: 2.6\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.56\n| -\n|===\n\nEmulates the following Ruby warnings in Ruby 2.6.\n\n[source,console]\n----\n$
        cat example.rb\nERB.new('hi', nil, '-', '@output_buffer')\n$ ruby -rerb example.rb\nexample.rb:1:
        warning: Passing safe_level with the 2nd argument of ERB.new is\ndeprecated.
        Do not use it, and specify other arguments as keyword arguments.\nexample.rb:1:
        warning: Passing trim_mode with the 3rd argument of ERB.new is\ndeprecated.
        Use keyword argument like ERB.new(str, trim_mode:...) instead.\nexample.rb:1:
        warning: Passing eoutvar with the 4th argument of ERB.new is\ndeprecated.
        Use keyword argument like ERB.new(str, eoutvar: ...) instead.\n----\n\nNow
        non-keyword arguments other than first one are softly deprecated\nand will
        be removed when Ruby 2.5 becomes EOL.\n`ERB.new` with non-keyword arguments
        is deprecated since ERB 2.2.0.\nUse `:trim_mode` and `:eoutvar` keyword arguments
        to `ERB.new`.\nThis cop identifies places where `ERB.new(str, trim_mode, eoutvar)`
        can\nbe replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`.\n\n===
        Examples\n\n[source,ruby]\n----\n# Target codes supports Ruby 2.6 and higher
        only\n# bad\nERB.new(str, nil, '-', '@output_buffer')\n\n# good\nERB.new(str,
        trim_mode: '-', eoutvar: '@output_buffer')\n\n# Target codes supports Ruby
        2.5 and lower only\n# good\nERB.new(str, nil, '-', '@output_buffer')\n\n#
        Target codes supports Ruby 2.6, 2.5 and lower\n# bad\nERB.new(str, nil, '-',
        '@output_buffer')\n\n# good\n# Ruby standard library style\n# https://github.com/ruby/ruby/commit/3406c5d\nif
        ERB.instance_method(:initialize).parameters.assoc(:key) # Ruby 2.6+\n  ERB.new(str,
        trim_mode: '-', eoutvar: '@output_buffer')\nelse\n  ERB.new(str, nil, '-',
        '@output_buffer')\nend\n\n# good\n# Use `RUBY_VERSION` style\nif RUBY_VERSION
        >= '2.6'\n  ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')\nelse\n
        \ ERB.new(str, nil, '-', '@output_buffer')\nend\n----\n\n== Lint/FlipFlop\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.16\n| -\n|===\n\nLooks for uses of
        flip-flop operator\nbased on the Ruby Style Guide.\n\nHere is the history
        of flip-flops in Ruby.\nflip-flop operator is deprecated in Ruby 2.6.0 and\nthe
        deprecation has been reverted by Ruby 2.7.0 and\nbackported to Ruby 2.6.\nSee:
        https://bugs.ruby-lang.org/issues/5400\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n(1..20).each do |x|\n  puts x if (x == 5) .. (x == 10)\nend\n\n# good\n(1..20).each
        do |x|\n  puts x if (x >= 5) && (x <= 10)\nend\n----\n\n=== References\n\n*
        https://rubystyle.guide#no-flip-flops\n\n== Lint/FloatComparison\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.89\n| -\n|===\n\nChecks for the presence
        of precise comparison of floating point numbers.\n\nFloating point values
        are inherently inaccurate, and comparing them for exact equality\nis almost
        never the desired semantics. Comparison via the `==/!=` operators checks\nfloating-point
        value representation to be exactly the same, which is very unlikely\nif you
        perform any arithmetic operations involving precision loss.\n\n # good - comparing
        against zero\n  x == 0.0\n  x != 0.0\n\n  # good\n  (x - 0.1).abs < Float::EPSILON\n\n
        \ # good\n  tolerance = 0.0001\n  (x - 0.1).abs < tolerance\n\n  # Or some
        other epsilon based type of comparison:\n  # https://www.embeddeduse.com/2019/08/26/qt-compare-two-floats/\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nx == 0.1\nx != 0.1\n\n# good - using
        BigDecimal\nx.to_d == 0.1.to_d\n----\n\n=== References\n\n* https://rubystyle.guide#float-comparison\n\n==
        Lint/FloatOutOfRange\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.36\n| -\n|===\n\nIdentifies
        Float literals which are, like, really really really\nreally really really
        really really big. Too big. No-one needs Floats\nthat big. If you need a float
        that big, something is wrong with you.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nfloat = 3.0e400\n----\n\n[source,ruby]\n----\n# good\n\nfloat = 42.9\n----\n\n==
        Lint/FormatParameterMismatch\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.33\n| -\n|===\n\nThis lint sees if there is a mismatch between the number
        of\nexpected fields for format/sprintf/#% and what is actually\npassed as
        arguments.\n\nIn addition it checks whether different formats are used in
        the same\nformat string. Do not mix numbered, unnumbered, and named formats
        in\nthe same format string.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nformat('A
        value: %s and another: %i', a_value)\n----\n\n[source,ruby]\n----\n# good\n\nformat('A
        value: %s and another: %i', a_value, another)\n----\n\n[source,ruby]\n----\n#
        bad\n\nformat('Unnumbered format: %s and numbered: %2$s', a_value, another)\n----\n\n[source,ruby]\n----\n#
        good\n\nformat('Numbered format: %1$s and numbered %2$s', a_value, another)\n----\n\n==
        Lint/HashCompareByIdentity\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| No\n| No\n|
        0.93\n| -\n|===\n\nPrefer using `Hash#compare_by_identity` rather than using
        `object_id`\nfor hash keys.\n\nThis cop looks for hashes being keyed by objects'
        `object_id`, using\none of these methods: `key?`, `has_key?`, `fetch`, `[]`
        and `[]=`.\n\n=== Safety\n\nThis cop is unsafe. Although unlikely, the hash
        could store both object\nids and other values that need be compared by value,
        and thus\ncould be a false positive.\n\nFurthermore, this cop cannot guarantee
        that the receiver of one of the\nmethods (`key?`, etc.) is actually a hash.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nhash = {}\nhash[foo.object_id] = :bar\nhash.key?(baz.object_id)\n\n#
        good\nhash = {}.compare_by_identity\nhash[foo] = :bar\nhash.key?(baz)\n----\n\n===
        References\n\n* https://rubystyle.guide#identity-comparison\n\n== Lint/HeredocMethodCallPosition\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always\n| 0.68\n| -\n|===\n\nChecks for the
        ordering of a method call where\nthe receiver of the call is a HEREDOC.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n<<-SQL\n  bar\nSQL\n.strip_indent\n\n<<-SQL\n
        \ bar\nSQL\n.strip_indent\n.trim\n\n# good\n<<~SQL\n  bar\nSQL\n\n<<~SQL.trim\n
        \ bar\nSQL\n----\n\n=== References\n\n* https://rubystyle.guide#heredoc-method-calls\n\n==
        Lint/IdentityComparison\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.91\n|
        -\n|===\n\nPrefer `equal?` over `==` when comparing `object_id`.\n\n`Object#equal?`
        is provided to compare objects for identity, and in contrast\n`Object#==`
        is provided for the purpose of doing value comparison.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nfoo.object_id == bar.object_id\n\n# good\nfoo.equal?(bar)\n----\n\n===
        References\n\n* https://rubystyle.guide#identity-comparison\n\n== Lint/ImplicitStringConcatenation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.36\n| -\n|===\n\nChecks for implicit
        string concatenation of string literals\nwhich are on the same line.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\narray = ['Item 1' 'Item 2']\n----\n\n[source,ruby]\n----\n#
        good\n\narray = ['Item 1Item 2']\narray = ['Item 1' + 'Item 2']\narray = [\n
        \ 'Item 1' \\\n  'Item 2'\n]\n----\n\n== Lint/IncompatibleIoSelectWithFiberScheduler\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always (Unsafe)\n| 1.21\n| 1.24\n|===\n\nChecks
        for `IO.select` that is incompatible with Fiber Scheduler since Ruby 3.0.\n\nWhen
        an array of IO objects waiting for an exception (the third argument of `IO.select`)\nis
        used as an argument, there is no alternative API, so offenses are not registered.\n\nNOTE:
        When the method is successful the return value of `IO.select` is `[[IO]]`,\nand
        the return value of `io.wait_readable` and `io.wait_writable` are `self`.\nThey
        are not autocorrected when assigning a return value because these types are
        different.\nIt's up to user how to handle the return value.\n\n=== Safety\n\nThis
        cop's autocorrection is unsafe because `NoMethodError` occurs\nif `require
        'io/wait'` is not called.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nIO.select([io],
        [], [], timeout)\n\n# good\nio.wait_readable(timeout)\n\n# bad\nIO.select([],
        [io], [], timeout)\n\n# good\nio.wait_writable(timeout)\n----\n\n== Lint/IneffectiveAccessModifier\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.36\n| -\n|===\n\nChecks for `private`
        or `protected` access modifiers which are\napplied to a singleton method.
        These access modifiers do not make\nsingleton methods private/protected. `private_class_method`
        can be\nused for that.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nclass
        C\n  private\n\n  def self.method\n    puts 'hi'\n  end\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nclass C\n  def self.method\n    puts 'hi'\n  end\n\n  private_class_method
        :method\nend\n----\n\n[source,ruby]\n----\n# good\n\nclass C\n  class << self\n
        \   private\n\n    def method\n      puts 'hi'\n    end\n  end\nend\n----\n\n==
        Lint/InheritException\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always (Unsafe)\n|
        0.41\n| 1.26\n|===\n\nLooks for error classes inheriting from `Exception`.\nIt
        is configurable to suggest using either `StandardError` (default) or\n`RuntimeError`
        instead.\n\n=== Safety\n\nThis cop's autocorrection is unsafe because `rescue`
        that omit\nexception class handle `StandardError` and its subclasses,\nbut
        not `Exception` and its subclasses.\n\n=== Examples\n\n==== EnforcedStyle:
        standard_error (default)\n\n[source,ruby]\n----\n# bad\n\nclass C < Exception;
        end\n\nC = Class.new(Exception)\n\n# good\n\nclass C < StandardError; end\n\nC
        = Class.new(StandardError)\n----\n\n==== EnforcedStyle: runtime_error\n\n[source,ruby]\n----\n#
        bad\n\nclass C < Exception; end\n\nC = Class.new(Exception)\n\n# good\n\nclass
        C < RuntimeError; end\n\nC = Class.new(RuntimeError)\n----\n\n=== Configurable
        attributes\n\n|===\n| Name | Default value | Configurable values\n\n| EnforcedStyle\n|
        `standard_error`\n| `standard_error`, `runtime_error`\n|===\n\n== Lint/InterpolationCheck\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always (Unsafe)\n| 0.50\n| 1.40\n|===\n\nChecks
        for interpolation in a single quoted string.\n\n=== Safety\n\nThis cop's autocorrection
        is unsafe because although it always replaces single quotes as\nif it were
        miswritten double quotes, it is not always the case. For example,\n`'#{foo}
        bar'` would be replaced by `\"#{foo} bar\"`, so the replaced code would evaluate\nthe
        expression `foo`.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nfoo = 'something
        with #{interpolation} inside'\n----\n\n[source,ruby]\n----\n# good\n\nfoo
        = \"something with #{interpolation} inside\"\n----\n\n== Lint/ItWithoutArgumentsInBlock\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.59\n| -\n|===\n\nEmulates the following
        Ruby warning in Ruby 3.3.\n\n[source,ruby]\n----\n$ ruby -e '0.times { it
        }'\n-e:1: warning: `it` calls without arguments will refer to the first block
        param in Ruby 3.4;\nuse it() or self.it\n----\n\n`it` calls without arguments
        will refer to the first block param in Ruby 3.4.\nSo use `it()` or `self.it`
        to ensure compatibility.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndo_something
        { it }\n\n# good\ndo_something { it() }\ndo_something { self.it }\n----\n\n===
        References\n\n* https://bugs.ruby-lang.org/issues/18980\n\n== Lint/LambdaWithoutLiteralBlock\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.8\n| -\n|===\n\nChecks uses of
        lambda without a literal block.\nIt emulates the following warning in Ruby
        3.0:\n\n  $ ruby -vwe 'lambda(&proc {})'\n  ruby 3.0.0p0 (2020-12-25 revision
        95aff21468) [x86_64-darwin19]\n  -e:1: warning: lambda without a literal block
        is deprecated; use the proc without\n  lambda instead\n\nThis way, proc object
        is never converted to lambda.\nAutocorrection replaces with compatible proc
        argument.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nlambda(&proc { do_something
        })\nlambda(&Proc.new { do_something })\n\n# good\nproc { do_something }\nProc.new
        { do_something }\nlambda { do_something } # If you use lambda.\n----\n\n==
        Lint/LiteralAsCondition\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.51\n| -\n|===\n\nChecks
        for literals used as the conditions or as\noperands in and/or expressions
        serving as the conditions of\nif/while/until/case-when/case-in.\n\nNOTE: Literals
        in `case-in` condition where the match variable is used in\n`in` are accepted
        as a pattern matching.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif 20\n
        \ do_something\nend\n\n# bad\nif some_var && true\n  do_something\nend\n\n#
        good\nif some_var && some_condition\n  do_something\nend\n\n# good\n# When
        using a boolean value for an infinite loop.\nwhile true\n  break if condition\nend\n----\n\n==
        Lint/LiteralAssignmentInCondition\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Pending\n| Yes\n| No\n|
        1.58\n| -\n|===\n\nChecks for literal assignments in the conditions of `if`,
        `while`, and `until`.\nIt emulates the following Ruby warning:\n\n[source,console]\n----\n$
        ruby -we 'if x = true; end'\n-e:1: warning: found `= literal' in conditional,
        should be ==\n----\n\nAs a lint cop, it cannot be determined if `==` is appropriate
        as intended,\ntherefore this cop does not provide autocorrection.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nif x = 42\n  do_something\nend\n\n# good\nif x == 42\n  do_something\nend\n\n#
        good\nif x = y\n  do_something\nend\n----\n\n== Lint/LiteralInInterpolation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.19\n| 0.32\n|===\n\nChecks for
        interpolated literals.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n\"result
        is #{10}\"\n----\n\n[source,ruby]\n----\n# good\n\n\"result is 10\"\n----\n\n==
        Lint/Loop\n\n|===\n| Enabled by default | Safe | Supports autocorrection |
        Version Added | Version Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n| 0.9\n|
        1.3\n|===\n\nChecks for uses of `begin...end while/until something`.\n\n===
        Safety\n\nThe cop is unsafe because behavior can change in some cases, including\nif
        a local variable inside the loop body is accessed outside of it, or if the\nloop
        body raises a `StopIteration` exception (which `Kernel#loop` rescues).\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\n# using while\nbegin\n  do_something\nend
        while some_condition\n----\n\n[source,ruby]\n----\n# bad\n\n# using until\nbegin\n
        \ do_something\nend until some_condition\n----\n\n[source,ruby]\n----\n# good\n\n#
        while replacement\nloop do\n  do_something\n  break unless some_condition\nend\n----\n\n[source,ruby]\n----\n#
        good\n\n# until replacement\nloop do\n  do_something\n  break if some_condition\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#loop-with-break\n\n== Lint/MissingCopEnableDirective\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.52\n| -\n|===\n\nChecks that there
        is an `# rubocop:enable ...` statement\nafter a `# rubocop:disable ...` statement.
        This will prevent leaving\ncop disables on wide ranges of code, that latter
        contributors to\na file wouldn't be aware of.\n\n=== Examples\n\n[source,ruby]\n----\n#
        Lint/MissingCopEnableDirective:\n#   MaximumRangeSize: .inf\n\n# good\n# rubocop:disable
        Layout/SpaceAroundOperators\nx= 0\n# rubocop:enable Layout/SpaceAroundOperators\n#
        y = 1\n# EOF\n\n# bad\n# rubocop:disable Layout/SpaceAroundOperators\nx= 0\n#
        EOF\n----\n\n[source,ruby]\n----\n# Lint/MissingCopEnableDirective:\n#   MaximumRangeSize:
        2\n\n# good\n# rubocop:disable Layout/SpaceAroundOperators\nx= 0\n# With the
        previous, there are 2 lines on which cop is disabled.\n# rubocop:enable Layout/SpaceAroundOperators\n\n#
        bad\n# rubocop:disable Layout/SpaceAroundOperators\nx= 0\nx += 1\n# Including
        this, that's 3 lines on which the cop is disabled.\n# rubocop:enable Layout/SpaceAroundOperators\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        MaximumRangeSize\n| `Infinity`\n| Float\n|===\n\n== Lint/MissingSuper\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.89\n| 1.4\n|===\n\nChecks for the presence
        of constructors and lifecycle callbacks\nwithout calls to `super`.\n\nThis
        cop does not consider `method_missing` (and `respond_to_missing?`)\nbecause
        in some cases it makes sense to overtake what is considered a\nmissing method.
        In other cases, the theoretical ideal handling could be\nchallenging or verbose
        for no actual gain.\n\nAutocorrection is not supported because the position
        of `super` cannot be\ndetermined automatically.\n\n`Object` and `BasicObject`
        are allowed by this cop because of their\nstateless nature. However, sometimes
        you might want to allow other parent\nclasses from this cop, for example in
        the case of an abstract class that is\nnot meant to be called with `super`.
        In those cases, you can use the\n`AllowedParentClasses` option to specify
        which classes should be allowed\n*in addition to* `Object` and `BasicObject`.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nclass Employee < Person\n  def initialize(name,
        salary)\n    @salary = salary\n  end\nend\n\n# good\nclass Employee < Person\n
        \ def initialize(name, salary)\n    super(name)\n    @salary = salary\n  end\nend\n\n#
        bad\nEmployee = Class.new(Person) do\n  def initialize(name, salary)\n    @salary
        = salary\n  end\nend\n\n# good\nEmployee = Class.new(Person) do\n  def initialize(name,
        salary)\n    super(name)\n    @salary = salary\n  end\nend\n\n# bad\nclass
        Parent\n  def self.inherited(base)\n    do_something\n  end\nend\n\n# good\nclass
        Parent\n  def self.inherited(base)\n    super\n    do_something\n  end\nend\n\n#
        good\nclass ClassWithNoParent\n  def initialize\n    do_something\n  end\nend\n----\n\n====
        AllowedParentClasses: [MyAbstractClass]\n\n[source,ruby]\n----\n# good\nclass
        MyConcreteClass < MyAbstractClass\n  def initialize\n    do_something\n  end\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowedParentClasses\n| `[]`\n| Array\n|===\n\n== Lint/MixedCaseRange\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always (Unsafe)\n| 1.53\n| -\n|===\n\nChecks
        for mixed-case character ranges since they include likely unintended characters.\n\nOffenses
        are registered for regexp character classes like `/[A-z]/`\nas well as range
        objects like `('A'..'z')`.\n\nNOTE: Range objects cannot be autocorrected.\n\n===
        Safety\n\nThe cop autocorrects regexp character classes\nby replacing one
        character range with two: `A-z` becomes `A-Za-z`.\nIn most cases this is probably
        what was originally intended\nbut it changes the regexp to no longer match
        symbols it used to include.\nFor this reason, this cop's autocorrect is unsafe
        (it will\nchange the behavior of the code).\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nr = /[A-z]/\n\n# good\nr = /[A-Za-z]/\n----\n\n== Lint/MixedRegexpCaptureTypes\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.85\n| -\n|===\n\nDo not mix named captures
        and numbered captures in a Regexp literal\nbecause numbered capture is ignored
        if they're mixed.\nReplace numbered captures with non-capturing groupings
        or\nnamed captures.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n/(?<foo>FOO)(BAR)/\n\n#
        good\n/(?<foo>FOO)(?<bar>BAR)/\n\n# good\n/(?<foo>FOO)(?:BAR)/\n\n# good\n/(FOO)(BAR)/\n----\n\n==
        Lint/MultipleComparison\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.47\n|
        1.1\n|===\n\nIn math and Python, we can use `x < y < z` style comparison to
        compare\nmultiple value. However, we can't use the comparison in Ruby. However,\nthe
        comparison is not syntax error. This cop checks the bad usage of\ncomparison
        operators.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nx < y < z\n10 <=
        x <= 20\n\n# good\nx < y && y < z\n10 <= x && x <= 20\n----\n\n== Lint/NestedMethodDefinition\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.32\n| -\n|===\n\nChecks for nested
        method definitions.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n# `bar`
        definition actually produces methods in the same scope\n# as the outer `foo`
        method. Furthermore, the `bar` method\n# will be redefined every time `foo`
        is invoked.\ndef foo\n  def bar\n  end\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef foo\n  bar = -> { puts 'hello' }\n  bar.call\nend\n----\n\n[source,ruby]\n----\n#
        good\n\n# `class_eval`, `instance_eval`, `module_eval`, `class_exec`, `instance_exec`,
        and\n# `module_exec` blocks are allowed by default.\n\ndef foo\n  self.class.class_eval
        do\n    def bar\n    end\n  end\nend\n\ndef foo\n  self.class.module_exec
        do\n    def bar\n    end\n  end\nend\n----\n\n[source,ruby]\n----\n# good\n\ndef
        foo\n  class << self\n    def bar\n    end\n  end\nend\n----\n\n==== AllowedMethods:
        [] (default)\n\n[source,ruby]\n----\n# bad\ndef do_something\n  has_many :articles
        do\n    def find_or_create_by_name(name)\n    end\n  end\nend\n----\n\n====
        AllowedMethods: ['has_many']\n\n[source,ruby]\n----\n# bad\ndef do_something\n
        \ has_many :articles do\n    def find_or_create_by_name(name)\n    end\n  end\nend\n----\n\n====
        AllowedPatterns: [] (default)\n\n[source,ruby]\n----\n# bad\ndef foo(obj)\n
        \ obj.do_baz do\n    def bar\n    end\n  end\nend\n----\n\n==== AllowedPatterns:
        ['baz']\n\n[source,ruby]\n----\n# good\ndef foo(obj)\n  obj.do_baz do\n    def
        bar\n    end\n  end\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| AllowedMethods\n| `[]`\n| Array\n\n|
        AllowedPatterns\n| `[]`\n| Array\n|===\n\n=== References\n\n* https://rubystyle.guide#no-nested-methods\n\n==
        Lint/NestedPercentLiteral\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.52\n| -\n|===\n\nChecks for nested percent literals.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n# The percent literal for nested_attributes is parsed as four tokens,\n#
        yielding the array [:name, :content, :\"%i[incorrectly\", :\"nested]\"].\nattributes
        = {\n  valid_attributes: %i[name content],\n  nested_attributes: %i[name content
        %i[incorrectly nested]]\n}\n\n# good\n\n# Neither is incompatible with the
        bad case, but probably the intended code.\nattributes = {\n  valid_attributes:
        %i[name content],\n  nested_attributes: [:name, :content, %i[incorrectly nested]]\n}\n\nattributes
        = {\n  valid_attributes: %i[name content],\n  nested_attributes: [:name, :content,
        [:incorrectly, :nested]]\n}\n----\n\n== Lint/NextWithoutAccumulator\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.36\n| -\n|===\n\nDon't omit the accumulator
        when calling `next` in a `reduce` block.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nresult = (1..4).reduce(0) do |acc, i|\n  next if i.odd?\n  acc + i\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nresult = (1..4).reduce(0) do |acc, i|\n  next acc if i.odd?\n  acc
        + i\nend\n----\n\n== Lint/NoReturnInBeginEndBlocks\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| No\n| 1.2\n| -\n|===\n\nChecks for the presence of a `return` inside
        a `begin..end` block\nin assignment contexts.\nIn this situation, the `return`
        will result in an exit from the current\nmethod, possibly leading to unexpected
        behavior.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n@some_variable
        ||= begin\n  return some_value if some_condition_is_met\n\n  do_something\nend\n----\n\n[source,ruby]\n----\n#
        good\n\n@some_variable ||= begin\n  if some_condition_is_met\n    some_value\n
        \ else\n    do_something\n  end\nend\n\n# good\n\nsome_variable = if some_condition_is_met\n
        \                 return if another_condition_is_met\n\n                  some_value\n
        \               else\n                  do_something\n                end\n----\n\n==
        Lint/NonAtomicFileOperation\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Pending\n| Yes\n| Always
        (Unsafe)\n| 1.31\n| -\n|===\n\nChecks for non-atomic file operation.\nAnd
        then replace it with a nearly equivalent and atomic method.\n\nThese can cause
        problems that are difficult to reproduce,\nespecially in cases of frequent
        file operations in parallel,\nsuch as test runs with parallel_rspec.\n\nFor
        examples: creating a directory if there is none, has the following problems\n\nAn
        exception occurs when the directory didn't exist at the time of `exist?`,\nbut
        someone else created it before `mkdir` was executed.\n\nSubsequent processes
        are executed without the directory that should be there\nwhen the directory
        existed at the time of `exist?`,\nbut someone else deleted it shortly afterwards.\n\n===
        Safety\n\nThis cop is unsafe, because autocorrection change to atomic processing.\nThe
        atomic processing of the replacement destination is not guaranteed\nto be
        strictly equivalent to that before the replacement.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad - race condition with another process may result in an error in `mkdir`\nunless
        Dir.exist?(path)\n  FileUtils.mkdir(path)\nend\n\n# good - atomic and idempotent
        creation\nFileUtils.mkdir_p(path)\n\n# bad - race condition with another process
        may result in an error in `remove`\nif File.exist?(path)\n  FileUtils.remove(path)\nend\n\n#
        good - atomic and idempotent removal\nFileUtils.rm_f(path)\n----\n\n=== References\n\n*
        https://rubystyle.guide#atomic-file-operations\n\n== Lint/NonDeterministicRequireOrder\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n| 0.78\n| -\n|===\n\n`Dir[...]`
        and `Dir.glob(...)` do not make any guarantees about\nthe order in which files
        are returned. The final order is\ndetermined by the operating system and file
        system.\nThis means that using them in cases where the order matters,\nsuch
        as requiring files, can lead to intermittent failures\nthat are hard to debug.
        To ensure this doesn't happen,\nalways sort the list.\n\n`Dir.glob` and `Dir[]`
        sort globbed results by default in Ruby 3.0.\nSo all bad cases are acceptable
        when Ruby 3.0 or higher are used.\n\nNOTE: This cop will be deprecated and
        removed when supporting only Ruby 3.0 and higher.\n\n=== Safety\n\nThis cop
        is unsafe in the case where sorting files changes existing\nexpected behavior.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nDir[\"./lib/**/*.rb\"].each do |file|\n
        \ require file\nend\n\n# good\nDir[\"./lib/**/*.rb\"].sort.each do |file|\n
        \ require file\nend\n\n# bad\nDir.glob(Rails.root.join(__dir__, 'test', '*.rb'))
        do |file|\n  require file\nend\n\n# good\nDir.glob(Rails.root.join(__dir__,
        'test', '*.rb')).sort.each do |file|\n  require file\nend\n\n# bad\nDir['./lib/**/*.rb'].each(&method(:require))\n\n#
        good\nDir['./lib/**/*.rb'].sort.each(&method(:require))\n\n# bad\nDir.glob(Rails.root.join('test',
        '*.rb'), &method(:require))\n\n# good\nDir.glob(Rails.root.join('test', '*.rb')).sort.each(&method(:require))\n\n#
        good - Respect intent if `sort` keyword option is specified in Ruby 3.0 or
        higher.\nDir.glob(Rails.root.join(__dir__, 'test', '*.rb'), sort: false).each(&method(:require))\n----\n\n==
        Lint/NonLocalExitFromIterator\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.30\n| -\n|===\n\nChecks for non-local exits from iterators without a return\nvalue.
        It registers an offense under these conditions:\n\n* No value is returned,\n*
        the block is preceded by a method chain,\n* the block has arguments,\n* the
        method which receives the block is not `define_method`\nor `define_singleton_method`,\n*
        the return is not contained in an inner scope, e.g. a lambda or a\nmethod
        definition.\n\n=== Examples\n\n[source,ruby]\n----\nclass ItemApi\n  rescue_from
        ValidationError do |e| # non-iteration block with arg\n    return { message:
        'validation error' } unless e.errors # allowed\n    error_array = e.errors.map
        do |error| # block with method chain\n      return if error.suppress? # warned\n
        \     return \"#{error.param}: invalid\" unless error.message # allowed\n
        \     \"#{error.param}: #{error.message}\"\n    end\n    { message: 'validation
        error', errors: error_array }\n  end\n\n  def update_items\n    transaction
        do # block without arguments\n      return unless update_necessary? # allowed\n
        \     find_each do |item| # block without method chain\n        return if
        item.stock == 0 # false-negative...\n        item.update!(foobar: true)\n
        \     end\n    end\n  end\nend\n----\n\n== Lint/NumberConversion\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Disabled\n| Yes\n| Always (Unsafe)\n| 0.53\n| 1.1\n|===\n\nWarns
        the usage of unsafe number conversions. Unsafe\nnumber conversion can cause
        unexpected error if auto type conversion\nfails. Cop prefer parsing with number
        class instead.\n\nConversion with `Integer`, `Float`, etc. will raise an `ArgumentError`\nif
        given input that is not numeric (eg. an empty string), whereas\n`to_i`, etc.
        will try to convert regardless of input (``''.to_i => 0``).\nAs such, this
        cop is disabled by default because it's not necessarily\nalways correct to
        raise if a value is not numeric.\n\nNOTE: Some values cannot be converted
        properly using one of the `Kernel`\nmethod (for instance, `Time` and `DateTime`
        values are allowed by this\ncop by default). Similarly, Rails' duration methods
        do not work well\nwith `Integer()` and can be allowed with `AllowedMethods`.
        By default,\nthere are no methods to allowed.\n\n=== Safety\n\nAutocorrection
        is unsafe because it is not guaranteed that the\nreplacement `Kernel` methods
        are able to properly handle the\ninput if it is not a standard class.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\n'10'.to_i\n'10.2'.to_f\n'10'.to_c\n'1/3'.to_r\n['1',
        '2', '3'].map(&:to_i)\nfoo.try(:to_f)\nbar.send(:to_c)\n\n# good\n\nInteger('10',
        10)\nFloat('10.2')\nComplex('10')\nRational('1/3')\n['1', '2', '3'].map {
        |i| Integer(i, 10) }\nfoo.try { |i| Float(i) }\nbar.send { |i| Complex(i)
        }\n----\n\n==== AllowedMethods: [] (default)\n\n[source,ruby]\n----\n# bad\n10.minutes.to_i\n----\n\n====
        AllowedMethods: [minutes]\n\n[source,ruby]\n----\n# good\n10.minutes.to_i\n----\n\n====
        AllowedPatterns: [] (default)\n\n[source,ruby]\n----\n# bad\n10.minutes.to_i\n----\n\n====
        AllowedPatterns: ['min*']\n\n[source,ruby]\n----\n# good\n10.minutes.to_i\n----\n\n====
        IgnoredClasses: [Time, DateTime] (default)\n\n[source,ruby]\n----\n# good\nTime.now.to_datetime.to_i\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowedMethods\n| `[]`\n| Array\n\n| AllowedPatterns\n| `[]`\n| Array\n\n|
        IgnoredClasses\n| `Time`, `DateTime`\n| Array\n|===\n\n== Lint/NumberedParameterAssignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.9\n| -\n|===\n\nChecks for uses of
        numbered parameter assignment.\nIt emulates the following warning in Ruby
        2.7:\n\n  $ ruby -ve '_1 = :value'\n  ruby 2.7.2p137 (2020-10-01 revision
        5445e04352) [x86_64-darwin19]\n  -e:1: warning: `_1' is reserved for numbered
        parameter; consider another name\n\nAssigning to a numbered parameter (from
        `_1` to `_9`) causes an error in Ruby 3.0.\n\n  $ ruby -ve '_1 = :value'\n
        \ ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1:
        _1 is reserved for numbered parameter\n\nNOTE: The parametered parameters
        are from `_1` to `_9`. This cop checks `_0`, and over `_10`\nas well to prevent
        confusion.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n_1 = :value\n\n#
        good\nnon_numbered_parameter_name = :value\n----\n\n== Lint/OrAssignmentToConstant\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| No\n| Always (Unsafe)\n| 1.9\n| -\n|===\n\nChecks
        for unintended or-assignment to a constant.\n\nConstants should always be
        assigned in the same location. And its value\nshould always be the same. If
        constants are assigned in multiple\nlocations, the result may vary depending
        on the order of `require`.\n\n=== Safety\n\nThis cop is unsafe because code
        that is already conditionally\nassigning a constant may have its behavior
        changed by autocorrection.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nCONST
        ||= 1\n\n# good\nCONST = 1\n----\n\n== Lint/OrderedMagicComments\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always (Unsafe)\n| 0.53\n| 1.37\n|===\n\nChecks
        the proper ordering of magic comments and whether\na magic comment is not
        placed before a shebang.\n\n=== Safety\n\nThis cop's autocorrection is unsafe
        because file encoding may change.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n# frozen_string_literal: true\n# encoding: ascii\np [''.frozen?, ''.encoding]
        #=> [true, #<Encoding:UTF-8>]\n\n# good\n\n# encoding: ascii\n# frozen_string_literal:
        true\np [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]\n\n# good\n\n#!/usr/bin/env
        ruby\n# encoding: ascii\n# frozen_string_literal: true\np [''.frozen?, ''.encoding]
        #=> [true, #<Encoding:US-ASCII>]\n----\n\n== Lint/OutOfRangeRegexpRef\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| No\n| No\n| 0.89\n| -\n|===\n\nLooks for references
        of Regexp captures that are out of range\nand thus always returns nil.\n\n===
        Safety\n\nThis cop is unsafe because it is naive in how it determines what\nreferences
        are available based on the last encountered regexp, but\nit cannot handle
        some cases, such as conditional regexp matches, which\nleads to false positives,
        such as:\n\n[source,ruby]\n----\nfoo ? /(c)(b)/ =~ str : /(b)/ =~ str\ndo_something
        if $2\n# $2 is defined for the first condition but not the second, however\n#
        the cop will mark this as an offense.\n----\n\nThis might be a good indication
        of code that should be refactored,\nhowever.\n\n=== Examples\n\n[source,ruby]\n----\n/(foo)bar/
        =~ 'foobar'\n\n# bad - always returns nil\n\nputs $2 # => nil\n\n# good\n\nputs
        $1 # => foo\n----\n\n== Lint/ParenthesesAsGroupedExpression\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.12\n| 0.83\n|===\n\nChecks for space between
        the name of a called method and a left\nparenthesis.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndo_something (foo)\n\n# good\ndo_something(foo)\ndo_something (2 + 3)
        * 4\ndo_something (foo * bar).baz\n----\n\n=== References\n\n* https://rubystyle.guide#parens-no-spaces\n\n==
        Lint/PercentStringArray\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n|
        0.41\n| -\n|===\n\nChecks for quotes and commas in %w, e.g. `%w('foo', \"bar\")`\n\nIt
        is more likely that the additional characters are unintended (for\nexample,
        mistranslating an array of literals to percent string notation)\nrather than
        meant to be part of the resulting strings.\n\n=== Safety\n\nThe cop is unsafe
        because the correction changes the values in the array\nand that might have
        been done purposely.\n\n[source,ruby]\n----\n%w('foo', \"bar\") #=> [\"'foo',\",
        '\"bar\"']\n%w(foo bar)      #=> ['foo', 'bar']\n----\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n%w('foo', \"bar\")\n----\n\n[source,ruby]\n----\n# good\n\n%w(foo bar)\n----\n\n==
        Lint/PercentSymbolArray\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.41\n|
        -\n|===\n\nChecks for colons and commas in %i, e.g. `%i(:foo, :bar)`\n\nIt
        is more likely that the additional characters are unintended (for\nexample,
        mistranslating an array of literals to percent string notation)\nrather than
        meant to be part of the resulting symbols.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n%i(:foo, :bar)\n----\n\n[source,ruby]\n----\n# good\n\n%i(foo bar)\n----\n\n==
        Lint/RaiseException\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n|
        0.81\n| 0.86\n|===\n\nChecks for `raise` or `fail` statements which are\nraising
        `Exception` class.\n\nYou can specify a module name that will be an implicit
        namespace\nusing `AllowedImplicitNamespaces` option. The cop cause a false
        positive\nfor namespaced `Exception` when a namespace is omitted. This option
        can\nprevent the false positive by specifying a namespace to be omitted for\n`Exception`.
        Alternatively, make `Exception` a fully qualified class\nname with an explicit
        namespace.\n\n=== Safety\n\nThis cop is unsafe because it will change the
        exception class being\nraised, which is a change in behavior.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nraise Exception, 'Error message here'\n\n# good\nraise StandardError,
        'Error message here'\n----\n\n==== AllowedImplicitNamespaces: ['Gem']\n\n[source,ruby]\n----\n#
        good\nmodule Gem\n  def self.foo\n    raise Exception # This exception means
        `Gem::Exception`.\n  end\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedImplicitNamespaces\n|
        `Gem`\n| Array\n|===\n\n=== References\n\n* https://rubystyle.guide#raise-exception\n\n==
        Lint/RandOne\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.36\n| -\n|===\n\nChecks
        for `rand(1)` calls.\nSuch calls always return `0`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nrand 1\nKernel.rand(-1)\nrand 1.0\nrand(-1.0)\n----\n\n[source,ruby]\n----\n#
        good\n\n0 # just use 0 instead\n----\n\n== Lint/RedundantCopDisableDirective\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.76\n| -\n|===\n\nDetects instances
        of rubocop:disable comments that can be\nremoved without causing any offenses
        to be reported. It's implemented\nas a cop in that it inherits from the Cop
        base class and calls\nadd_offense. The unusual part of its implementation
        is that it doesn't\nhave any on_* methods or an investigate method. This means
        that it\ndoesn't take part in the investigation phase when the other cops
        do\ntheir work. Instead, it waits until it's called in a later stage of the\nexecution.
        The reason it can't be implemented as a normal cop is that\nit depends on
        the results of all other cops to do its work.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n# rubocop:disable Layout/LineLength\nx += 1\n# rubocop:enable Layout/LineLength\n\n#
        good\nx += 1\n----\n\n== Lint/RedundantCopEnableDirective\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.76\n| -\n|===\n\nDetects instances of rubocop:enable
        comments that can be\nremoved.\n\nWhen comment enables all cops at once `rubocop:enable
        all`\nthat cop checks whether any cop was actually enabled.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nfoo = 1\n# rubocop:enable Layout/LineLength\n\n# good\nfoo = 1\n----\n\n[source,ruby]\n----\n#
        bad\n# rubocop:disable Style/StringLiterals\nfoo = \"1\"\n# rubocop:enable
        Style/StringLiterals\nbaz\n# rubocop:enable all\n\n# good\n# rubocop:disable
        Style/StringLiterals\nfoo = \"1\"\n# rubocop:enable all\nbaz\n----\n\n== Lint/RedundantDirGlobSort\n\nNOTE:
        Required Ruby version: 3.0\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Pending\n| Yes\n| Always
        (Unsafe)\n| 1.8\n| 1.26\n|===\n\nSort globbed results by default in Ruby 3.0.\nThis
        cop checks for redundant `sort` method to `Dir.glob` and `Dir[]`.\n\n=== Safety\n\nThis
        cop is unsafe, in case of having a file and a directory with\nidentical names,
        since directory will be loaded before the file, which\nwill break `exe/files.rb`
        that rely on `exe.rb` file.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nDir.glob('./lib/**/*.rb').sort.each
        do |file|\nend\n\nDir['./lib/**/*.rb'].sort.each do |file|\nend\n\n# good\nDir.glob('./lib/**/*.rb').each
        do |file|\nend\n\nDir['./lib/**/*.rb'].each do |file|\nend\n----\n\n== Lint/RedundantRegexpQuantifiers\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| Always\n| 1.53\n| -\n|===\n\nChecks for redundant
        quantifiers inside Regexp literals.\n\nIt is always allowed when interpolation
        is used in a regexp literal,\nbecause it's unknown what kind of string will
        be expanded as a result:\n\n[source,ruby]\n----\n/(?:a*#{interpolation})?/x\n----\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n/(?:x+)+/\n\n# good\n/(?:x)+/\n\n#
        good\n/(?:x+)/\n\n# bad\n/(?:x+)?/\n\n# good\n/(?:x)*/\n\n# good\n/(?:x*)/\n----\n\n==
        Lint/RedundantRequireStatement\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always
        (Unsafe)\n| 0.76\n| 1.57\n|===\n\nChecks for unnecessary `require` statement.\n\nThe
        following features are unnecessary `require` statement because\nthey are already
        loaded. e.g. Ruby 2.2:\n\n  ruby -ve 'p $LOADED_FEATURES.reject { |feature|
        %r|/| =~ feature }'\n  ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]\n
        \ [\"enumerator.so\", \"rational.so\", \"complex.so\", \"thread.rb\"]\n\nBelow
        are the features that each `TargetRubyVersion` targets.\n\n  * 2.0+ ... `enumerator`\n
        \ * 2.1+ ... `thread`\n  * 2.2+ ... Add `rational` and `complex` above\n  *
        2.5+ ... Add `pp` above\n  * 2.7+ ... Add `ruby2_keywords` above\n  * 3.1+
        ... Add `fiber` above\n  * 3.2+ ... `set`\n\nThis cop target those features.\n\n===
        Safety\n\nThis cop's autocorrection is unsafe because if `require 'pp'` is
        removed from one file,\n`NameError` can be encountered when another file uses
        `PP.pp`.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nrequire 'unloaded_feature'\nrequire
        'thread'\n\n# good\nrequire 'unloaded_feature'\n----\n\n== Lint/RedundantSafeNavigation\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n| 0.93\n| -\n|===\n\nChecks
        for redundant safe navigation calls.\nUse cases where a constant, named in
        camel case for classes and modules is `nil` are rare,\nand an offense is not
        detected when the receiver is a constant. The detection also applies\nto literal
        receivers, except for `nil`.\n\nFor all receivers, the `instance_of?`, `kind_of?`,
        `is_a?`, `eql?`, `respond_to?`,\nand `equal?` methods are checked by default.\nThese
        are customizable with `AllowedMethods` option.\n\nThe `AllowedMethods` option
        specifies nil-safe methods,\nin other words, it is a method that is allowed
        to skip safe navigation.\nNote that the `AllowedMethod` option is not an option
        that specifies methods\nfor which to suppress (allow) this cop's check.\n\nIn
        the example below, the safe navigation operator (`&.`) is unnecessary\nbecause
        `NilClass` has methods like `respond_to?` and `is_a?`.\n\n=== Safety\n\nThis
        cop is unsafe, because autocorrection can change the return type of\nthe expression.
        An offending expression that previously could return `nil`\nwill be autocorrected
        to never return `nil`.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nCamelCaseConst&.do_something\n\n#
        bad\ndo_something if attrs&.respond_to?(:[])\n\n# good\ndo_something if attrs.respond_to?(:[])\n\n#
        bad\nwhile node&.is_a?(BeginNode)\n  node = node.parent\nend\n\n# good\nCamelCaseConst.do_something\n\n#
        good\nwhile node.is_a?(BeginNode)\n  node = node.parent\nend\n\n# good - without
        `&.` this will always return `true`\nfoo&.respond_to?(:to_a)\n\n# bad - for
        `nil`s conversion methods return default values for the type\nfoo&.to_h ||
        {}\nfoo&.to_h { |k, v| [k, v] } || {}\nfoo&.to_a || []\nfoo&.to_i || 0\nfoo&.to_f
        || 0.0\nfoo&.to_s || ''\n\n# good\nfoo.to_h\nfoo.to_h { |k, v| [k, v] }\nfoo.to_a\nfoo.to_i\nfoo.to_f\nfoo.to_s\n----\n\n====
        AllowedMethods: [nil_safe_method]\n\n[source,ruby]\n----\n# bad\ndo_something
        if attrs&.nil_safe_method(:[])\n\n# good\ndo_something if attrs.nil_safe_method(:[])\ndo_something
        if attrs&.not_nil_safe_method(:[])\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedMethods\n| `instance_of?`,
        `kind_of?`, `is_a?`, `eql?`, `respond_to?`, `equal?`\n| Array\n|===\n\n==
        Lint/RedundantSplatExpansion\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.76\n| 1.7\n|===\n\nChecks for unneeded usages of splat expansion\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\na = *[1, 2, 3]\na = *'a'\na = *1\n['a',
        'b', *%w(c d e), 'f', 'g']\n\n# good\nc = [1, 2, 3]\na = *c\na, b = *c\na,
        *b = *c\na = *1..10\na = ['a']\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n# bad\ndo_something(*['foo',
        'bar', 'baz'])\n\n# good\ndo_something('foo', 'bar', 'baz')\n\n# bad\nbegin\n
        \ foo\nrescue *[StandardError, ApplicationError]\n  bar\nend\n\n# good\nbegin\n
        \ foo\nrescue StandardError, ApplicationError\n  bar\nend\n\n# bad\ncase foo\nwhen
        *[1, 2, 3]\n  bar\nelse\n  baz\nend\n\n# good\ncase foo\nwhen 1, 2, 3\n  bar\nelse\n
        \ baz\nend\n----\n\n==== AllowPercentLiteralArrayArgument: true (default)\n\n[source,ruby]\n----\n#
        good\ndo_something(*%w[foo bar baz])\n----\n\n==== AllowPercentLiteralArrayArgument:
        false\n\n[source,ruby]\n----\n# bad\ndo_something(*%w[foo bar baz])\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        AllowPercentLiteralArrayArgument\n| `true`\n| Boolean\n|===\n\n== Lint/RedundantStringCoercion\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.19\n| 0.77\n|===\n\nChecks for
        string conversion in string interpolation, `print`, `puts`, and `warn` arguments,\nwhich
        is redundant.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\n\"result is
        #{something.to_s}\"\nprint something.to_s\nputs something.to_s\nwarn something.to_s\n----\n\n[source,ruby]\n----\n#
        good\n\n\"result is #{something}\"\nprint something\nputs something\nwarn
        something\n----\n\n=== References\n\n* https://rubystyle.guide#no-to-s\n\n==
        Lint/RedundantWithIndex\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.50\n|
        -\n|===\n\nChecks for redundant `with_index`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nary.each_with_index do |v|\n  v\nend\n\n# good\nary.each do |v|\n  v\nend\n\n#
        bad\nary.each.with_index do |v|\n  v\nend\n\n# good\nary.each do |v|\n  v\nend\n----\n\n==
        Lint/RedundantWithObject\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.51\n|
        -\n|===\n\nChecks for redundant `with_object`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nary.each_with_object([]) do |v|\n  v\nend\n\n# good\nary.each do |v|\n
        \ v\nend\n\n# bad\nary.each.with_object([]) do |v|\n  v\nend\n\n# good\nary.each
        do |v|\n  v\nend\n----\n\n== Lint/RefinementImportMethods\n\nNOTE: Required
        Ruby version: 3.1\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Pending\n| Yes\n| No\n| 1.27\n| -\n|===\n\nChecks
        if `include` or `prepend` is called in `refine` block.\nThese methods are
        deprecated and should be replaced with `Refinement#import_methods`.\n\nIt
        emulates deprecation warnings in Ruby 3.1.\n\n=== Safety\n\nThis cop's autocorrection
        is unsafe because `include M` will affect the included class\nif any changes
        are made to module `M`.\nOn the other hand, `import_methods M` uses a snapshot
        of method definitions,\nthus it will not be affected if module `M` changes.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nrefine Foo do\n  include Bar\nend\n\n#
        bad\nrefine Foo do\n  prepend Bar\nend\n\n# good\nrefine Foo do\n  import_methods
        Bar\nend\n----\n\n== Lint/RegexpAsCondition\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Always\n| 0.51\n| 0.86\n|===\n\nChecks for regexp literals used as
        `match-current-line`.\nIf a regexp literal is in condition, the regexp matches
        `$_` implicitly.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nif /foo/\n
        \ do_something\nend\n\n# good\nif /foo/ =~ $_\n  do_something\nend\n----\n\n==
        Lint/RequireParentheses\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.18\n| -\n|===\n\nChecks
        for expressions where there is a call to a predicate\nmethod with at least
        one argument, where no parentheses are used around\nthe parameter list, and
        a boolean operator, && or ||, is used in the\nlast argument.\n\nThe idea behind
        warning for these constructs is that the user might\nbe under the impression
        that the return value from the method call is\nan operand of &&/||.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\nif day.is? :tuesday && month ==
        :jan\n  # ...\nend\n----\n\n[source,ruby]\n----\n# good\n\nif day.is?(:tuesday)
        && month == :jan\n  # ...\nend\n----\n\n== Lint/RequireRangeParentheses\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.32\n| -\n|===\n\nChecks that a range
        literal is enclosed in parentheses when the end of the range is\nat a line
        break.\n\nNOTE: The following is maybe intended for `(42..)`. But, compatible
        is `42..do_something`.\nSo, this cop does not provide autocorrection because
        it is left to user.\n\n[source,ruby]\n----\ncase condition\nwhen 42..\n  do_something\nend\n----\n\n===
        Examples\n\n[source,ruby]\n----\n# bad - Represents `(1..42)`, not endless
        range.\n1..\n42\n\n# good - It's incompatible, but your intentions when using
        endless range may be:\n(1..)\n42\n\n# good\n1..42\n\n# good\n(1..42)\n\n#
        good\n(1..\n42)\n----\n\n== Lint/RequireRelativeSelfPath\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Pending\n| Yes\n| Always\n| 1.22\n| -\n|===\n\nChecks for uses a file requiring
        itself with `require_relative`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n# foo.rb\nrequire_relative 'foo'\nrequire_relative 'bar'\n\n# good\n\n#
        foo.rb\nrequire_relative 'bar'\n----\n\n== Lint/RescueException\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.9\n| 0.27\n|===\n\nChecks for `rescue`
        blocks targeting the Exception class.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\nbegin\n  do_something\nrescue Exception\n  handle_exception\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nbegin\n  do_something\nrescue ArgumentError\n  handle_exception\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#no-blind-rescues\n\n== Lint/RescueType\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.49\n| -\n|===\n\nCheck for arguments
        to `rescue` that will result in a `TypeError`\nif an exception is raised.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nbegin\n  bar\nrescue nil\n  baz\nend\n\n#
        bad\ndef foo\n  bar\nrescue 1, 'a', \"#{b}\", 0.0, [], {}\n  baz\nend\n\n#
        good\nbegin\n  bar\nrescue\n  baz\nend\n\n# good\ndef foo\n  bar\nrescue NameError\n
        \ baz\nend\n----\n\n== Lint/ReturnInVoidContext\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| No\n| 0.50\n| -\n|===\n\nChecks for the use of a return with a value
        in a context\nwhere the value will be ignored. (initialize and setter methods)\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\ndef initialize\n  foo\n  return :qux
        if bar?\n  baz\nend\n\ndef foo=(bar)\n  return 42\nend\n----\n\n[source,ruby]\n----\n#
        good\ndef initialize\n  foo\n  return if bar?\n  baz\nend\n\ndef foo=(bar)\n
        \ return\nend\n----\n\n== Lint/SafeNavigationChain\n\nNOTE: Required Ruby
        version: 2.3\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.47\n|
        0.77\n|===\n\nThe safe navigation operator returns nil if the receiver is\nnil.
        If you chain an ordinary method call after a safe\nnavigation operator, it
        raises NoMethodError. We should use a\nsafe navigation operator after a safe
        navigation operator.\nThis cop checks for the problem outlined above.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n\nx&.foo.bar\nx&.foo + bar\nx&.foo[bar]\n----\n\n[source,ruby]\n----\n#
        good\n\nx&.foo&.bar\nx&.foo || bar\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedMethods\n| `present?`,
        `blank?`, `presence`, `try`, `try!`, `in?`\n| Array\n|===\n\n== Lint/SafeNavigationConsistency\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.55\n| 0.77\n|===\n\nCheck to make
        sure that if safe navigation is used for a method\ncall in an `&&` or `||`
        condition that safe navigation is used for all\nmethod calls on that same
        object.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nfoo&.bar && foo.baz\n\n#
        bad\nfoo.bar || foo&.baz\n\n# bad\nfoo&.bar && (foobar.baz || foo.baz)\n\n#
        good\nfoo.bar && foo.baz\n\n# good\nfoo&.bar || foo&.baz\n\n# good\nfoo&.bar
        && (foobar.baz || foo&.baz)\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedMethods\n| `present?`,
        `blank?`, `presence`, `try`, `try!`\n| Array\n|===\n\n== Lint/SafeNavigationWithEmpty\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.62\n| 0.87\n|===\n\nChecks to make
        sure safe navigation isn't used with `empty?` in\na conditional.\n\nWhile
        the safe navigation operator is generally a good idea, when\nchecking `foo&.empty?`
        in a conditional, `foo` being `nil` will actually\ndo the opposite of what
        the author intends.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nreturn
        if foo&.empty?\nreturn unless foo&.empty?\n\n# good\nreturn if foo && foo.empty?\nreturn
        unless foo && foo.empty?\n----\n\n== Lint/ScriptPermission\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.49\n| 0.50\n|===\n\nChecks if a file which has
        a shebang line as\nits first line is granted execute permission.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n# A file which has a shebang line as its first line is not\n# granted
        execute permission.\n\n#!/usr/bin/env ruby\nputs 'hello, world'\n\n# good\n\n#
        A file which has a shebang line as its first line is\n# granted execute permission.\n\n#!/usr/bin/env
        ruby\nputs 'hello, world'\n\n# good\n\n# A file which has not a shebang line
        as its first line is not\n# granted execute permission.\n\nputs 'hello, world'\n----\n\n==
        Lint/SelfAssignment\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.89\n| -\n|===\n\nChecks
        for self-assignments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nfoo =
        foo\nfoo, bar = foo, bar\nFoo = Foo\nhash['foo'] = hash['foo']\nobj.attr =
        obj.attr\n\n# good\nfoo = bar\nfoo, bar = bar, foo\nFoo = Bar\nhash['foo']
        = hash['bar']\nobj.attr = obj.attr2\n\n# good (method calls possibly can return
        different results)\nhash[foo] = hash[foo]\n----\n\n== Lint/SendWithMixinArgument\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.75\n| -\n|===\n\nChecks for `send`,
        `public_send`, and `__send__` methods\nwhen using mix-in.\n\n`include` and
        `prepend` methods were private methods until Ruby 2.0,\nthey were mixed-in
        via `send` method. This cop uses Ruby 2.1 or\nhigher style that can be called
        by public methods.\nAnd `extend` method that was originally a public method
        is also targeted\nfor style unification.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nFoo.send(:include, Bar)\nFoo.send(:prepend, Bar)\nFoo.send(:extend, Bar)\n\n#
        bad\nFoo.public_send(:include, Bar)\nFoo.public_send(:prepend, Bar)\nFoo.public_send(:extend,
        Bar)\n\n# bad\nFoo.__send__(:include, Bar)\nFoo.__send__(:prepend, Bar)\nFoo.__send__(:extend,
        Bar)\n\n# good\nFoo.include Bar\nFoo.prepend Bar\nFoo.extend Bar\n----\n\n==
        Lint/ShadowedArgument\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.52\n| -\n|===\n\nChecks
        for shadowed arguments.\n\nThis cop has `IgnoreImplicitReferences` configuration
        option.\nIt means argument shadowing is used in order to pass parameters\nto
        zero arity `super` when `IgnoreImplicitReferences` is `true`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndo_something do |foo|\n  foo = 42\n  puts foo\nend\n\ndef do_something(foo)\n
        \ foo = 42\n  puts foo\nend\n\n# good\ndo_something do |foo|\n  foo = foo
        + 42\n  puts foo\nend\n\ndef do_something(foo)\n  foo = foo + 42\n  puts foo\nend\n\ndef
        do_something(foo)\n  puts foo\nend\n----\n\n==== IgnoreImplicitReferences:
        false (default)\n\n[source,ruby]\n----\n# bad\ndef do_something(foo)\n  foo
        = 42\n  super\nend\n\ndef do_something(foo)\n  foo = super\n  bar\nend\n----\n\n====
        IgnoreImplicitReferences: true\n\n[source,ruby]\n----\n# good\ndef do_something(foo)\n
        \ foo = 42\n  super\nend\n\ndef do_something(foo)\n  foo = super\n  bar\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        IgnoreImplicitReferences\n| `false`\n| Boolean\n|===\n\n== Lint/ShadowedException\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.41\n| -\n|===\n\nChecks for a rescued
        exception that get shadowed by a\nless specific exception being rescued before
        a more specific\nexception is rescued.\n\nAn exception is considered shadowed
        if it is rescued after its\nancestor is, or if it and its ancestor are both
        rescued in the\nsame `rescue` statement. In both cases, the more specific
        rescue is\nunnecessary because it is covered by rescuing the less specific\nexception.
        (ie. `rescue Exception, StandardError` has the same behavior\nwhether `StandardError`
        is included or not, because all ``StandardError``s\nare rescued by `rescue
        Exception`).\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nbegin\n  something\nrescue
        Exception\n  handle_exception\nrescue StandardError\n  handle_standard_error\nend\n\n#
        bad\nbegin\n  something\nrescue Exception, StandardError\n  handle_error\nend\n\n#
        good\n\nbegin\n  something\nrescue StandardError\n  handle_standard_error\nrescue
        Exception\n  handle_exception\nend\n\n# good, however depending on runtime
        environment.\n#\n# This is a special case for system call errors.\n# System
        dependent error code depends on runtime environment.\n# For example, whether
        `Errno::EAGAIN` and `Errno::EWOULDBLOCK` are\n# the same error code or different
        error code depends on environment.\n# This good case is for `Errno::EAGAIN`
        and `Errno::EWOULDBLOCK` with\n# the same error code.\nbegin\n  something\nrescue
        Errno::EAGAIN, Errno::EWOULDBLOCK\n  handle_standard_error\nend\n----\n\n==
        Lint/ShadowingOuterLocalVariable\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n|
        0.9\n| -\n|===\n\nChecks for the use of local variable names from an outer
        scope\nin block arguments or block-local variables. This mirrors the warning\ngiven
        by `ruby -cw` prior to Ruby 2.6:\n\"shadowing outer local variable - foo\".\n\nNOTE:
        Shadowing of variables in block passed to `Ractor.new` is allowed\nbecause
        `Ractor` should not access outer variables.\neg. following style is encouraged:\n\n
        \ [source,ruby]\n  ----\n  worker_id, pipe = env\n  Ractor.new(worker_id,
        pipe) do |worker_id, pipe|\n  end\n  ----\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\ndef some_method\n  foo = 1\n\n  2.times do |foo| # shadowing outer
        `foo`\n    do_something(foo)\n  end\nend\n----\n\n[source,ruby]\n----\n# good\n\ndef
        some_method\n  foo = 1\n\n  2.times do |bar|\n    do_something(bar)\n  end\nend\n----\n\n==
        Lint/StructNewOverride\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.81\n| -\n|===\n\nChecks
        unexpected overrides of the `Struct` built-in methods\nvia `Struct.new`.\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\nBad = Struct.new(:members, :clone,
        :count)\nb = Bad.new([], true, 1)\nb.members #=> [] (overriding `Struct#members`)\nb.clone
        #=> true (overriding `Object#clone`)\nb.count #=> 1 (overriding `Enumerable#count`)\n\n#
        good\nGood = Struct.new(:id, :name)\ng = Good.new(1, \"foo\")\ng.members #=>
        [:id, :name]\ng.clone #=> #<struct Good id=1, name=\"foo\">\ng.count #=> 2\n----\n\n==
        Lint/SuppressedException\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.9\n| 1.12\n|===\n\nChecks
        for `rescue` blocks with no body.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndef some_method\n  do_something\nrescue\nend\n\n# bad\nbegin\n  do_something\nrescue\nend\n\n#
        good\ndef some_method\n  do_something\nrescue\n  handle_exception\nend\n\n#
        good\nbegin\n  do_something\nrescue\n  handle_exception\nend\n----\n\n====
        AllowComments: true (default)\n\n[source,ruby]\n----\n# good\ndef some_method\n
        \ do_something\nrescue\n  # do nothing\nend\n\n# good\nbegin\n  do_something\nrescue\n
        \ # do nothing\nend\n----\n\n==== AllowComments: false\n\n[source,ruby]\n----\n#
        bad\ndef some_method\n  do_something\nrescue\n  # do nothing\nend\n\n# bad\nbegin\n
        \ do_something\nrescue\n  # do nothing\nend\n----\n\n==== AllowNil: true (default)\n\n[source,ruby]\n----\n#
        good\ndef some_method\n  do_something\nrescue\n  nil\nend\n\n# good\nbegin\n
        \ do_something\nrescue\n  # do nothing\nend\n\n# good\ndo_something rescue
        nil\n----\n\n==== AllowNil: false\n\n[source,ruby]\n----\n# bad\ndef some_method\n
        \ do_something\nrescue\n  nil\nend\n\n# bad\nbegin\n  do_something\nrescue\n
        \ nil\nend\n\n# bad\ndo_something rescue nil\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowComments\n| `true`\n|
        Boolean\n\n| AllowNil\n| `true`\n| Boolean\n|===\n\n=== References\n\n* https://rubystyle.guide#dont-hide-exceptions\n\n==
        Lint/SymbolConversion\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Pending\n| Yes\n| Always\n| 1.9\n|
        1.16\n|===\n\nChecks for uses of literal strings converted to\na symbol where
        a literal symbol could be used instead.\n\nThere are two possible styles for
        this cop.\n`strict` (default) will register an offense for any incorrect usage.\n`consistent`
        additionally requires hashes to use the same style for\nevery symbol key (ie.
        if any symbol key needs to be quoted it requires\nall keys to be quoted).\n\n===
        Examples\n\n[source,ruby]\n----\n# bad\n'string'.to_sym\n:symbol.to_sym\n'underscored_string'.to_sym\n:'underscored_symbol'\n'hyphenated-string'.to_sym\n\"string_#{interpolation}\".to_sym\n\n#
        good\n:string\n:symbol\n:underscored_string\n:underscored_symbol\n:'hyphenated-string'\n:\"string_#{interpolation}\"\n----\n\n====
        EnforcedStyle: strict (default)\n\n[source,ruby]\n----\n# bad\n{\n  'a': 1,\n
        \ \"b\": 2,\n  'c-d': 3\n}\n\n# good (don't quote keys that don't require
        quoting)\n{\n  a: 1,\n  b: 2,\n  'c-d': 3\n}\n----\n\n==== EnforcedStyle:
        consistent\n\n[source,ruby]\n----\n# bad\n{\n  a: 1,\n  'b-c': 2\n}\n\n# good
        (quote all keys if any need quoting)\n{\n  'a': 1,\n  'b-c': 2\n}\n\n# good
        (no quoting required)\n{\n  a: 1,\n  b: 2\n}\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| EnforcedStyle\n| `strict`\n|
        `strict`, `consistent`\n|===\n\n== Lint/Syntax\n\n|===\n| Enabled by default
        | Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| No\n| 0.9\n| -\n|===\n\nRepacks Parser's diagnostics/errors\ninto RuboCop's
        offenses.\n\n== Lint/ToEnumArguments\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| No\n| 1.1\n| -\n|===\n\nEnsures that `to_enum`/`enum_for`, called for
        the current method,\nhas correct arguments.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndef foo(x, y = 1)\n  return to_enum(__callee__, x) # `y` is missing\nend\n\n#
        good\ndef foo(x, y = 1)\n  # Alternatives to `__callee__` are `__method__`
        and `:foo`.\n  return to_enum(__callee__, x, y)\nend\n\n# good\ndef foo(x,
        y = 1)\n  # It is also allowed if it is wrapped in some method like Sorbet.\n
        \ return to_enum(T.must(__callee__), x, y)\nend\n----\n\n== Lint/ToJSON\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Always\n| 0.66\n| -\n|===\n\nChecks to make
        sure `#to_json` includes an optional argument.\nWhen overriding `#to_json`,
        callers may invoke JSON\ngeneration via `JSON.generate(your_obj)`.  Since
        `JSON#generate` allows\nfor an optional argument, your method should too.\n\n===
        Examples\n\n[source,ruby]\n----\nclass Point\n  attr_reader :x, :y\n\n  #
        bad, incorrect arity\n  def to_json\n    JSON.generate([x, y])\n  end\n\n
        \ # good, preserving args\n  def to_json(*args)\n    JSON.generate([x, y],
        *args)\n  end\n\n  # good, discarding args\n  def to_json(*_args)\n    JSON.generate([x,
        y])\n  end\nend\n----\n\n== Lint/TopLevelReturnWithArgument\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Enabled\n| Yes\n| Always\n| 0.89\n| -\n|===\n\nChecks for top level return
        with arguments. If there is a\ntop-level return statement with an argument,
        then the argument is\nalways ignored. This is detected automatically since
        Ruby 2.7.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nreturn 1\n\n# good\nreturn\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        Exclude\n| `+**/*.jb+`\n| Array\n|===\n\n== Lint/TrailingCommaInAttributeDeclaration\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only\n| 0.90\n| 1.61\n|===\n\nChecks
        for trailing commas in attribute declarations, such as\n`#attr_reader`. Leaving
        a trailing comma will nullify the next method\ndefinition by overriding it
        with a getter method.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nclass
        Foo\n  attr_reader :foo,\n\n  def bar\n    puts \"Unreachable.\"\n  end\nend\n\n#
        good\nclass Foo\n  attr_reader :foo\n\n  def bar\n    puts \"No problem!\"\n
        \ end\nend\n----\n\n== Lint/TripleQuotes\n\n|===\n| Enabled by default | Safe
        | Supports autocorrection | Version Added | Version Changed\n\n| Pending\n|
        Yes\n| Always\n| 1.9\n| -\n|===\n\nChecks for \"triple quotes\" (strings delimited
        by any odd number\nof quotes greater than 1).\n\nRuby allows multiple strings
        to be implicitly concatenated by just\nbeing adjacent in a statement (ie.
        `\"foo\"\"bar\" == \"foobar\"`). This sometimes\ngives the impression that
        there is something special about triple quotes, but\nin fact it is just extra
        unnecessary quotes and produces the same string. Each\npair of quotes produces
        an additional concatenated empty string, so the result\nis still only the
        \"actual\" string within the delimiters.\n\nNOTE: Although this cop is called
        triple quotes, the same behavior is present\nfor strings delimited by 5, 7,
        etc. quotation marks.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\"\"\"\n
        \ A string\n\"\"\"\n\n# bad\n'''\n  A string\n'''\n\n# good\n\"\n  A string\n\"\n\n#
        good\n<<STRING\n  A string\nSTRING\n\n# good (but not the same spacing as
        the bad case)\n'A string'\n----\n\n== Lint/UnderscorePrefixedVariableName\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.21\n| -\n|===\n\nChecks for underscore-prefixed
        variables that are actually\nused.\n\nSince block keyword arguments cannot
        be arbitrarily named at call\nsites, the `AllowKeywordBlockArguments` will
        allow use of underscore-\nprefixed block keyword arguments.\n\n=== Examples\n\n====
        AllowKeywordBlockArguments: false (default)\n\n[source,ruby]\n----\n# bad\n\n[1,
        2, 3].each do |_num|\n  do_something(_num)\nend\n\nquery(:sales) do |_id:,
        revenue:, cost:|\n  {_id: _id, profit: revenue - cost}\nend\n\n# good\n\n[1,
        2, 3].each do |num|\n  do_something(num)\nend\n\n[1, 2, 3].each do |_num|\n
        \ do_something # not using `_num`\nend\n----\n\n==== AllowKeywordBlockArguments:
        true\n\n[source,ruby]\n----\n# good\n\nquery(:sales) do |_id:, revenue:, cost:|\n
        \ {_id: _id, profit: revenue - cost}\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowKeywordBlockArguments\n|
        `false`\n| Boolean\n|===\n\n== Lint/UnexpectedBlockArity\n\n|===\n| Enabled
        by default | Safe | Supports autocorrection | Version Added | Version Changed\n\n|
        Pending\n| No\n| No\n| 1.5\n| -\n|===\n\nChecks for a block that is known
        to need more positional\nblock arguments than are given (by default this is
        configured for\n`Enumerable` methods needing 2 arguments). Optional arguments
        are allowed,\nalthough they don't generally make sense as the default value
        will\nbe used. Blocks that have no receiver, or take splatted arguments\n(ie.
        `*args`) are always accepted.\n\nKeyword arguments (including `**kwargs`)
        do not get counted towards\nthis, as they are not used by the methods in question.\n\nMethod
        names and their expected arity can be configured like this:\n\n[source,yaml]\n----\nMethods:\n
        \ inject: 2\n  reduce: 2\n----\n\n=== Safety\n\nThis cop matches for method
        names only and hence cannot tell apart\nmethods with same name in different
        classes, which may lead to a\nfalse positive.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nvalues.reduce {}\nvalues.min { |a| a }\nvalues.sort { |a; b| a + b }\n\n#
        good\nvalues.reduce { |memo, obj| memo << obj }\nvalues.min { |a, b| a <=>
        b }\nvalues.sort { |*x| x[0] <=> x[1] }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| Methods\n| `{\"chunk_while\"=>2,
        \"each_with_index\"=>2, \"each_with_object\"=>2, \"inject\"=>2, \"max\"=>2,
        \"min\"=>2, \"minmax\"=>2, \"reduce\"=>2, \"slice_when\"=>2, \"sort\"=>2}`\n|
        \n|===\n\n== Lint/UnifiedInteger\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n|
        0.43\n| -\n|===\n\nChecks for using Fixnum or Bignum constant.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\n1.is_a?(Fixnum)\n1.is_a?(Bignum)\n----\n\n[source,ruby]\n----\n# good\n\n1.is_a?(Integer)\n----\n\n==
        Lint/UnmodifiedReduceAccumulator\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Pending\n| Yes\n| No\n|
        1.1\n| 1.5\n|===\n\nLooks for `reduce` or `inject` blocks where the value
        returned (implicitly or\nexplicitly) does not include the accumulator. A block
        is considered valid as\nlong as at least one return value includes the accumulator.\n\nIf
        the accumulator is not included in the return value, then the entire\nblock
        will just return a transformation of the last element value, and\ncould be
        rewritten as such without a loop.\n\nAlso catches instances where an index
        of the accumulator is returned, as\nthis may change the type of object being
        retained.\n\nNOTE: For the purpose of reducing false positives, this cop only
        flags\nreturns in `reduce` blocks where the element is the only variable in\nthe
        expression (since we will not be able to tell what other variables\nrelate
        to via static analysis).\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n(1..4).reduce(0)
        do |acc, el|\n  el * 2\nend\n\n# bad, may raise a NoMethodError after the
        first iteration\n%w(a b c).reduce({}) do |acc, letter|\n  acc[letter] = true\nend\n\n#
        good\n(1..4).reduce(0) do |acc, el|\n  acc + el * 2\nend\n\n# good, element
        is returned but modified using the accumulator\nvalues.reduce do |acc, el|\n
        \ el << acc\n  el\nend\n\n# good, returns the accumulator instead of the index\n%w(a
        b c).reduce({}) do |acc, letter|\n  acc[letter] = true\n  acc\nend\n\n# good,
        at least one branch returns the accumulator\nvalues.reduce(nil) do |result,
        value|\n  break result if something?\n  value\nend\n\n# good, recursive\nkeys.reduce(self)
        { |result, key| result[key] }\n\n# ignored as the return value cannot be determined\nenum.reduce
        do |acc, el|\n  x = foo(acc, el)\n  bar(x)\nend\n----\n\n== Lint/UnreachableCode\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.9\n| -\n|===\n\nChecks for unreachable
        code.\nThe check are based on the presence of flow of control\nstatement in
        non-final position in `begin` (implicit) blocks.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\ndef some_method\n  return\n  do_something\nend\n\n# bad\n\ndef some_method\n
        \ if cond\n    return\n  else\n    return\n  end\n  do_something\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef some_method\n  do_something\nend\n----\n\n== Lint/UnreachableLoop\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.89\n| 1.7\n|===\n\nChecks for loops
        that will have at most one iteration.\n\nA loop that can never reach the second
        iteration is a possible error in the code.\nIn rare cases where only one iteration
        (or at most one iteration) is intended behavior,\nthe code should be refactored
        to use `if` conditionals.\n\nNOTE: Block methods that are used with ``Enumerable``s
        are considered to be loops.\n\n`AllowedPatterns` can be used to match against
        the block receiver in order to allow\ncode that would otherwise be registered
        as an offense (eg. `times` used not in an\n`Enumerable` context).\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nwhile node\n  do_something(node)\n  node = node.parent\n  break\nend\n\n#
        good\nwhile node\n  do_something(node)\n  node = node.parent\nend\n\n# bad\ndef
        verify_list(head)\n  item = head\n  begin\n    if verify(item)\n      return
        true\n    else\n      return false\n    end\n  end while(item)\nend\n\n# good\ndef
        verify_list(head)\n  item = head\n  begin\n    if verify(item)\n      item
        = item.next\n    else\n      return false\n    end\n  end while(item)\n\n
        \ true\nend\n\n# bad\ndef find_something(items)\n  items.each do |item|\n
        \   if something?(item)\n      return item\n    else\n      raise NotFoundError\n
        \   end\n  end\nend\n\n# good\ndef find_something(items)\n  items.each do
        |item|\n    if something?(item)\n      return item\n    end\n  end\n  raise
        NotFoundError\nend\n\n# bad\n2.times { raise ArgumentError }\n----\n\n====
        AllowedPatterns: ['(exactly|at_least|at_most)\\(\\d+\\)\\.times'] (default)\n\n[source,ruby]\n----\n#
        good\nexactly(2).times { raise StandardError }\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| AllowedPatterns\n| `(?-mix:(exactly\\|at_least\\|at_most)\\(\\d+\\)\\.times)`\n|
        Array\n|===\n\n== Lint/UnusedBlockArgument\n\n|===\n| Enabled by default |
        Safe | Supports autocorrection | Version Added | Version Changed\n\n| Enabled\n|
        Yes\n| Command-line only\n| 0.21\n| 1.61\n|===\n\nChecks for unused block
        arguments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndo_something do
        |used, unused|\n  puts used\nend\n\ndo_something do |bar|\n  puts :foo\nend\n\ndefine_method(:foo)
        do |bar|\n  puts :baz\nend\n\n# good\ndo_something do |used, _unused|\n  puts
        used\nend\n\ndo_something do\n  puts :foo\nend\n\ndefine_method(:foo) do |_bar|\n
        \ puts :baz\nend\n----\n\n==== IgnoreEmptyBlocks: true (default)\n\n[source,ruby]\n----\n#
        good\ndo_something { |unused| }\n----\n\n==== IgnoreEmptyBlocks: false\n\n[source,ruby]\n----\n#
        bad\ndo_something { |unused| }\n----\n\n==== AllowUnusedKeywordArguments:
        false (default)\n\n[source,ruby]\n----\n# bad\ndo_something do |unused: 42|\n
        \ foo\nend\n----\n\n==== AllowUnusedKeywordArguments: true\n\n[source,ruby]\n----\n#
        good\ndo_something do |unused: 42|\n  foo\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| IgnoreEmptyBlocks\n| `true`\n|
        Boolean\n\n| AllowUnusedKeywordArguments\n| `false`\n| Boolean\n|===\n\n===
        References\n\n* https://rubystyle.guide#underscore-unused-vars\n\n== Lint/UnusedMethodArgument\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only\n| 0.21\n| 1.61\n|===\n\nChecks
        for unused method arguments.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef
        some_method(used, unused, _unused_but_allowed)\n  puts used\nend\n\n# good\ndef
        some_method(used, _unused, _unused_but_allowed)\n  puts used\nend\n----\n\n====
        AllowUnusedKeywordArguments: false (default)\n\n[source,ruby]\n----\n# bad\ndef
        do_something(used, unused: 42)\n  used\nend\n----\n\n==== AllowUnusedKeywordArguments:
        true\n\n[source,ruby]\n----\n# good\ndef do_something(used, unused: 42)\n
        \ used\nend\n----\n\n==== IgnoreEmptyMethods: true (default)\n\n[source,ruby]\n----\n#
        good\ndef do_something(unused)\nend\n----\n\n==== IgnoreEmptyMethods: false\n\n[source,ruby]\n----\n#
        bad\ndef do_something(unused)\nend\n----\n\n==== IgnoreNotImplementedMethods:
        true (default)\n\n[source,ruby]\n----\n# good\ndef do_something(unused)\n
        \ raise NotImplementedError\nend\n\ndef do_something_else(unused)\n  fail
        \"TODO\"\nend\n----\n\n==== IgnoreNotImplementedMethods: false\n\n[source,ruby]\n----\n#
        bad\ndef do_something(unused)\n  raise NotImplementedError\nend\n\ndef do_something_else(unused)\n
        \ fail \"TODO\"\nend\n----\n\n=== Configurable attributes\n\n|===\n| Name
        | Default value | Configurable values\n\n| AllowUnusedKeywordArguments\n|
        `false`\n| Boolean\n\n| IgnoreEmptyMethods\n| `true`\n| Boolean\n\n| IgnoreNotImplementedMethods\n|
        `true`\n| Boolean\n|===\n\n=== References\n\n* https://rubystyle.guide#underscore-unused-vars\n\n==
        Lint/UriEscapeUnescape\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| No\n| 0.50\n| -\n|===\n\nIdentifies
        places where `URI.escape` can be replaced by\n`CGI.escape`, `URI.encode_www_form`,
        or `URI.encode_www_form_component`\ndepending on your specific use case.\nAlso
        this cop identifies places where `URI.unescape` can be replaced by\n`CGI.unescape`,
        `URI.decode_www_form`,\nor `URI.decode_www_form_component` depending on your
        specific use case.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\nURI.escape('http://example.com')\nURI.encode('http://example.com')\n\n#
        good\nCGI.escape('http://example.com')\nURI.encode_www_form([['example', 'param'],
        ['lang', 'en']])\nURI.encode_www_form(page: 10, locale: 'en')\nURI.encode_www_form_component('http://example.com')\n\n#
        bad\nURI.unescape(enc_uri)\nURI.decode(enc_uri)\n\n# good\nCGI.unescape(enc_uri)\nURI.decode_www_form(enc_uri)\nURI.decode_www_form_component(enc_uri)\n----\n\n==
        Lint/UriRegexp\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Always\n| 0.50\n|
        -\n|===\n\nIdentifies places where `URI.regexp` is obsolete and should\nnot
        be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nURI.regexp('http://example.com')\n\n# good\nURI::DEFAULT_PARSER.make_regexp('http://example.com')\n----\n\n==
        Lint/UselessAccessModifier\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| Yes\n| Command-line
        only\n| 0.20\n| 1.61\n|===\n\nChecks for redundant access modifiers, including
        those with no\ncode, those which are repeated, and leading `public` modifiers
        in a\nclass or module body. Conditionally-defined methods are considered as\nalways
        being defined, and thus access modifiers guarding such methods\nare not redundant.\n\nThis
        cop has `ContextCreatingMethods` option. The default setting value\nis an
        empty array that means no method is specified.\nThis setting is an array of
        methods which, when called, are known to\ncreate its own context in the module's
        current access context.\n\nIt also has `MethodCreatingMethods` option. The
        default setting value\nis an empty array that means no method is specified.\nThis
        setting is an array of methods which, when called, are known to\ncreate other
        methods in the module's current access context.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\nclass Foo\n  public # this is redundant (default access is public)\n\n
        \ def method\n  end\nend\n\n# bad\nclass Foo\n  # The following is redundant
        (methods defined on the class'\n  # singleton class are not affected by the
        private modifier)\n  private\n\n  def self.method3\n  end\nend\n\n# bad\nclass
        Foo\n  protected\n\n  define_method(:method2) do\n  end\n\n  protected # this
        is redundant (repeated from previous modifier)\n\n  [1,2,3].each do |i|\n
        \   define_method(\"foo#{i}\") do\n    end\n  end\nend\n\n# bad\nclass Foo\n
        \ private # this is redundant (no following methods are defined)\nend\n\n#
        good\nclass Foo\n  private # this is not redundant (a method is defined)\n\n
        \ def method2\n  end\nend\n\n# good\nclass Foo\n  # The following is not redundant
        (conditionally defined methods are\n  # considered as always defining a method)\n
        \ private\n\n  if condition?\n    def method\n    end\n  end\nend\n\n# good\nclass
        Foo\n  protected # this is not redundant (a method is defined)\n\n  define_method(:method2)
        do\n  end\nend\n----\n\n==== ContextCreatingMethods: concerning\n\n[source,ruby]\n----\n#
        Lint/UselessAccessModifier:\n#   ContextCreatingMethods:\n#     - concerning\n\n#
        good\nrequire 'active_support/concern'\nclass Foo\n  concerning :Bar do\n
        \   def some_public_method\n    end\n\n    private\n\n    def some_private_method\n
        \   end\n  end\n\n  # this is not redundant because `concerning` created its
        own context\n  private\n\n  def some_other_private_method\n  end\nend\n----\n\n====
        MethodCreatingMethods: delegate\n\n[source,ruby]\n----\n# Lint/UselessAccessModifier:\n#
        \  MethodCreatingMethods:\n#     - delegate\n\n# good\nrequire 'active_support/core_ext/module/delegation'\nclass
        Foo\n  # this is not redundant because `delegate` creates methods\n  private\n\n
        \ delegate :method_a, to: :method_b\nend\n----\n\n=== Configurable attributes\n\n|===\n|
        Name | Default value | Configurable values\n\n| ContextCreatingMethods\n|
        `[]`\n| Array\n\n| MethodCreatingMethods\n| `[]`\n| Array\n|===\n\n== Lint/UselessAssignment\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| Command-line only (Unsafe)\n| 0.11\n| 1.61\n|===\n\nChecks
        for every useless assignment to local variable in every\nscope.\nThe basic
        idea for this cop was from the warning of `ruby -cw`:\n\n[source,console]\n----\nassigned
        but unused variable - foo\n----\n\nCurrently this cop has advanced logic that
        detects unreferenced\nreassignments and properly handles varied cases such
        as branch, loop,\nrescue, ensure, etc.\n\nNOTE: Given the assignment `foo
        = 1, bar = 2`, removing unused variables\ncan lead to a syntax error, so this
        case is not autocorrected.\n\n=== Safety\n\nThis cop's autocorrection is unsafe
        because removing assignment from\noperator assignment can cause NameError
        if this assignment has been used to declare\nlocal variable. For example,
        replacing `a ||= 1` to `a || 1` may cause\n\"undefined local variable or method
        `a' for main:Object (NameError)\".\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\n\ndef some_method\n  some_var = 1\n  do_something\nend\n----\n\n[source,ruby]\n----\n#
        good\n\ndef some_method\n  some_var = 1\n  do_something(some_var)\nend\n----\n\n===
        References\n\n* https://rubystyle.guide#underscore-unused-vars\n\n== Lint/UselessElseWithoutRescue\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| Yes\n| No\n| 0.17\n| 1.31\n|===\n\nChecks for useless
        `else` in `begin..end` without `rescue`.\n\nNOTE: This syntax is no longer
        valid on Ruby 2.6 or higher.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\nbegin\n
        \ do_something\nelse\n  do_something_else # This will never be run.\nend\n----\n\n[source,ruby]\n----\n#
        good\n\nbegin\n  do_something\nrescue\n  handle_errors\nelse\n  do_something_else\nend\n----\n\n==
        Lint/UselessMethodDefinition\n\n|===\n| Enabled by default | Safe | Supports
        autocorrection | Version Added | Version Changed\n\n| Enabled\n| No\n| Command-line
        only (Unsafe)\n| 0.90\n| 1.61\n|===\n\nChecks for useless method definitions,
        specifically: empty constructors\nand methods just delegating to `super`.\n\n===
        Safety\n\nThis cop is unsafe as it can register false positives for cases
        when an empty\nconstructor just overrides the parent constructor, which is
        bad anyway.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\ndef initialize\n
        \ super\nend\n\ndef method\n  super\nend\n\n# good - with default arguments\ndef
        initialize(x = Object.new)\n  super\nend\n\n# good\ndef initialize\n  super\n
        \ initialize_internals\nend\n\ndef method(*args)\n  super(:extra_arg, *args)\nend\n----\n\n==
        Lint/UselessRescue\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Pending\n| Yes\n| No\n| 1.43\n| -\n|===\n\nChecks
        for useless `rescue`s, which only reraise rescued exceptions.\n\n=== Examples\n\n[source,ruby]\n----\n#
        bad\ndef foo\n  do_something\nrescue\n  raise\nend\n\n# bad\ndef foo\n  do_something\nrescue
        => e\n  raise # or 'raise e', or 'raise $!', or 'raise $ERROR_INFO'\nend\n\n#
        good\ndef foo\n  do_something\nrescue\n  do_cleanup\n  raise\nend\n\n# bad
        (latest rescue)\ndef foo\n  do_something\nrescue ArgumentError\n  # noop\nrescue\n
        \ raise\nend\n\n# good (not the latest rescue)\ndef foo\n  do_something\nrescue
        ArgumentError\n  raise\nrescue\n  # noop\nend\n----\n\n== Lint/UselessRuby2Keywords\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Pending\n| Yes\n| No\n| 1.23\n| -\n|===\n\nLooks for `ruby2_keywords`
        calls for methods that do not need it.\n\n`ruby2_keywords` should only be
        called on methods that accept an argument splat\n(`\\*args`) but do not explicit
        keyword arguments (`k:` or `k: true`) or\na keyword splat (`**kwargs`).\n\n===
        Examples\n\n[source,ruby]\n----\n# good (splat argument without keyword arguments)\nruby2_keywords
        def foo(*args); end\n\n# bad (no arguments)\nruby2_keywords def foo; end\n\n#
        good\ndef foo; end\n\n# bad (positional argument)\nruby2_keywords def foo(arg);
        end\n\n# good\ndef foo(arg); end\n\n# bad (double splatted argument)\nruby2_keywords
        def foo(**args); end\n\n# good\ndef foo(**args); end\n\n# bad (keyword arguments)\nruby2_keywords
        def foo(i:, j:); end\n\n# good\ndef foo(i:, j:); end\n\n# bad (splat argument
        with keyword arguments)\nruby2_keywords def foo(*args, i:, j:); end\n\n# good\ndef
        foo(*args, i:, j:); end\n\n# bad (splat argument with double splat)\nruby2_keywords
        def foo(*args, **kwargs); end\n\n# good\ndef foo(*args, **kwargs); end\n\n#
        bad (ruby2_keywords given a symbol)\ndef foo; end\nruby2_keywords :foo\n\n#
        good\ndef foo; end\n\n# bad (ruby2_keywords with dynamic method)\ndefine_method(:foo)
        { |arg| }\nruby2_keywords :foo\n\n# good\ndefine_method(:foo) { |arg| }\n----\n\n==
        Lint/UselessSetterCall\n\n|===\n| Enabled by default | Safe | Supports autocorrection
        | Version Added | Version Changed\n\n| Enabled\n| No\n| Always (Unsafe)\n|
        0.13\n| 1.2\n|===\n\nChecks for setter call to local variable as the final\nexpression
        of a function definition.\n\n=== Safety\n\nThere are edge cases in which the
        local variable references a\nvalue that is also accessible outside the local
        scope. This is not\ndetected by the cop, and it can yield a false positive.\n\nAs
        well, autocorrection is unsafe because the method's\nreturn value will be
        changed.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n\ndef something\n
        \ x = Something.new\n  x.attr = 5\nend\n----\n\n[source,ruby]\n----\n# good\n\ndef
        something\n  x = Something.new\n  x.attr = 5\n  x\nend\n----\n\n== Lint/UselessTimes\n\n|===\n|
        Enabled by default | Safe | Supports autocorrection | Version Added | Version
        Changed\n\n| Enabled\n| No\n| Command-line only (Unsafe)\n| 0.91\n| 1.61\n|===\n\nChecks
        for uses of `Integer#times` that will never yield\n(when the integer ``<=
        0``) or that will only ever yield once\n(`1.times`).\n\n=== Safety\n\nThis
        cop is unsafe as `times` returns its receiver, which is\n*usually* OK, but
        might change behavior.\n\n=== Examples\n\n[source,ruby]\n----\n# bad\n-5.times
        { do_something }\n0.times { do_something }\n1.times { do_something  }\n1.times
        { |i| do_something(i) }\n\n# good\ndo_something\ndo_something(1)\n----\n\n==
        Lint/Void\n\n|===\n| Enabled by default | Safe | Supports autocorrection |
        Version Added | Version Changed\n\n| Enabled\n| Yes\n| Command-line only\n|
        0.9\n| 1.61\n|===\n\nChecks for operators, variables, literals, lambda, proc
        and nonmutating\nmethods used in void context.\n\n`each` blocks are allowed
        to prevent false positives.\nFor example, the expression inside the `each`
        block below.\nIt's not void, especially when the receiver is an `Enumerator`:\n\n[source,ruby]\n----\nenumerator
        = [1, 2, 3].filter\nenumerator.each { |item| item >= 2 } #=> [2, 3]\n----\n\n===
        Examples\n\n==== CheckForMethodsWithNoSideEffects: false (default)\n\n[source,ruby]\n----\n#
        bad\ndef some_method\n  some_num * 10\n  do_something\nend\n\ndef some_method(some_var)\n
        \ some_var\n  do_something\nend\n----\n\n==== CheckForMethodsWithNoSideEffects:
        true\n\n[source,ruby]\n----\n# bad\ndef some_method(some_array)\n  some_array.sort\n
        \ do_something(some_array)\nend\n\n# good\ndef some_method\n  do_something\n
        \ some_num * 10\nend\n\ndef some_method(some_var)\n  do_something\n  some_var\nend\n\ndef
        some_method(some_array)\n  some_array.sort!\n  do_something(some_array)\nend\n----\n\n===
        Configurable attributes\n\n|===\n| Name | Default value | Configurable values\n\n|
        CheckForMethodsWithNoSideEffects\n| `false`\n| Boolean\n|===\n"
  recorded_at: Mon, 27 May 2024 05:30:39 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_metrics.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '13548'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"da5d2cd7bddab2f45337636e4a148e7233b630d8247b24b15313a68499fae3eb"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 3E70:4FFFC:131E2A7:144F003:66540534
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:39 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230035-FRA
      X-Cache:
      - HIT
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787839.453521,VS0,VE172
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - c9e55ae5da0ae2bcfb93fba8ea85884b961e2882
      Expires:
      - Mon, 27 May 2024 05:35:39 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Metrics

        == Metrics/AbcSize

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.27
        | 1.5
        |===

        Checks that the ABC size of methods is not higher than the
        configured maximum. The ABC size is based on assignments, branches
        (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric
        and https://en.wikipedia.org/wiki/ABC_Software_Metric.

        Interpreting ABC size:

        * ``<= 17`` satisfactory
        * `18..30` unsatisfactory
        * `>` 30 dangerous

        You can have repeated "attributes" calls count as a single "branch".
        For this purpose, attributes are any method with no argument; no attempt
        is meant to distinguish actual `attr_reader` from other methods.

        This cop also takes into account `AllowedMethods` (defaults to `[]`)
        And `AllowedPatterns` (defaults to `[]`)

        === Examples

        ==== CountRepeatedAttributes: false (default is true)

        [source,ruby]
        ----
        # `model` and `current_user`, referenced 3 times each,
        # are each counted as only 1 branch each if
        # `CountRepeatedAttributes` is set to 'false'

        def search
          @posts = model.active.visible_by(current_user)
                    .search(params[:q])
          @posts = model.some_process(@posts, current_user)
          @posts = model.another_process(@posts, current_user)

          render 'pages/search/page'
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | AllowedMethods
        | `[]`
        | Array

        | AllowedPatterns
        | `[]`
        | Array

        | CountRepeatedAttributes
        | `true`
        | Boolean

        | Max
        | `17`
        | Integer
        |===

        === References

        * http://c2.com/cgi/wiki?AbcMetric
        * https://en.wikipedia.org/wiki/ABC_Software_Metric

        == Metrics/BlockLength

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.44
        | 1.5
        |===

        Checks if the length of a block exceeds some maximum value.
        Comment lines can optionally be ignored.
        The maximum allowed length is configurable.
        The cop can be configured to ignore blocks passed to certain methods.

        You can set constructs you want to fold with `CountAsOne`.
        Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
        will be counted as one line regardless of its actual size.

        NOTE: This cop does not apply for `Struct` definitions.

        NOTE: The `ExcludedMethods` configuration is deprecated and only kept
        for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns`
        instead. By default, there are no methods to allowed.

        === Examples

        ==== CountAsOne: ['array', 'heredoc', 'method_call']

        [source,ruby]
        ----
        something do
          array = [         # +1
            1,
            2
          ]

          hash = {          # +3
            key: 'value'
          }

          msg = <<~HEREDOC  # +1
            Heredoc
            content.
          HEREDOC

          foo(              # +1
            1,
            2
          )
        end                 # 6 points
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | CountComments
        | `false`
        | Boolean

        | Max
        | `25`
        | Integer

        | CountAsOne
        | `[]`
        | Array

        | AllowedMethods
        | `refine`
        | Array

        | AllowedPatterns
        | `[]`
        | Array

        | Exclude
        | `+**/*.gemspec+`
        | Array
        |===

        == Metrics/BlockNesting

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 0.47
        |===

        Checks for excessive nesting of conditional and looping
        constructs.

        You can configure if blocks are considered using the `CountBlocks`
        option. When set to `false` (the default) blocks are not counted
        towards the nesting level. Set to `true` to count blocks as well.

        The maximum level of nesting allowed is configurable.

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | CountBlocks
        | `false`
        | Boolean

        | Max
        | `3`
        | Integer
        |===

        === References

        * https://rubystyle.guide#three-is-the-number-thou-shalt-count

        == Metrics/ClassLength

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 0.87
        |===

        Checks if the length of a class exceeds some maximum value.
        Comment lines can optionally be ignored.
        The maximum allowed length is configurable.

        You can set constructs you want to fold with `CountAsOne`.
        Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
        will be counted as one line regardless of its actual size.

        NOTE: This cop also applies for `Struct` definitions.

        === Examples

        ==== CountAsOne: ['array', 'heredoc', 'method_call']

        [source,ruby]
        ----
        class Foo
          ARRAY = [         # +1
            1,
            2
          ]

          HASH = {          # +3
            key: 'value'
          }

          MSG = <<~HEREDOC  # +1
            Heredoc
            content.
          HEREDOC

          foo(              # +1
            1,
            2
          )
        end                 # 6 points
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | CountComments
        | `false`
        | Boolean

        | Max
        | `100`
        | Integer

        | CountAsOne
        | `[]`
        | Array
        |===

        == Metrics/CollectionLiteralLength

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 1.47
        | -
        |===

        Checks for literals with extremely many entries. This is indicative of
        configuration or data that may be better extracted somewhere else, like
        a database, fetched from an API, or read from a non-code file (CSV,
        JSON, YAML, etc.).

        === Examples

        [source,ruby]
        ----
        # bad
        # Huge Array literal
        [1, 2, '...', 999_999_999]

        # bad
        # Huge Hash literal
        { 1 => 1, 2 => 2, '...' => '...', 999_999_999 => 999_999_999}

        # bad
        # Huge Set "literal"
        Set[1, 2, '...', 999_999_999]

        # good
        # Reasonably sized Array literal
        [1, 2, '...', 10]

        # good
        # Reading huge Array from external data source
        # File.readlines('numbers.txt', chomp: true).map!(&:to_i)

        # good
        # Reasonably sized Hash literal
        { 1 => 1, 2 => 2, '...' => '...', 10 => 10}

        # good
        # Reading huge Hash from external data source
        CSV.foreach('numbers.csv', headers: true).each_with_object({}) do |row, hash|
          hash[row["key"].to_i] = row["value"].to_i
        end

        # good
        # Reasonably sized Set "literal"
        Set[1, 2, '...', 10]

        # good
        # Reading huge Set from external data source
        SomeFramework.config_for(:something)[:numbers].to_set
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | LengthThreshold
        | `250`
        | Integer
        |===

        == Metrics/CyclomaticComplexity

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 0.81
        |===

        Checks that the cyclomatic complexity of methods is not higher
        than the configured maximum. The cyclomatic complexity is the number of
        linearly independent paths through a method. The algorithm counts
        decision points and adds one.

        An if statement (or unless or ?:) increases the complexity by one. An
        else branch does not, since it doesn't add a decision point. The &&
        operator (or keyword and) can be converted to a nested if statement,
        and ||/or is shorthand for a sequence of ifs, so they also add one.
        Loops can be said to have an exit condition, so they add one.
        Blocks that are calls to builtin iteration methods
        (e.g. `ary.map{...}) also add one, others are ignored.

          def each_child_node(*types)               # count begins: 1
            unless block_given?                     # unless: +1
              return to_enum(__method__, *types)

            children.each do |child|                # each{}: +1
              next unless child.is_a?(Node)         # unless: +1

              yield child if types.empty? ||        # if: +1, ||: +1
                             types.include?(child.type)
            end

            self
          end                                       # total: 6

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | AllowedMethods
        | `[]`
        | Array

        | AllowedPatterns
        | `[]`
        | Array

        | Max
        | `7`
        | Integer
        |===

        == Metrics/MethodLength

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 1.5
        |===

        Checks if the length of a method exceeds some maximum value.
        Comment lines can optionally be allowed.
        The maximum allowed length is configurable.

        You can set constructs you want to fold with `CountAsOne`.
        Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
        will be counted as one line regardless of its actual size.

        NOTE: The `ExcludedMethods` and `IgnoredMethods` configuration is
        deprecated and only kept for backwards compatibility.
        Please use `AllowedMethods` and `AllowedPatterns` instead.
        By default, there are no methods to allowed.

        === Examples

        ==== CountAsOne: ['array', 'heredoc', 'method_call']

        [source,ruby]
        ----
        def m
          array = [       # +1
            1,
            2
          ]

          hash = {        # +3
            key: 'value'
          }

          <<~HEREDOC      # +1
            Heredoc
            content.
          HEREDOC

          foo(            # +1
            1,
            2
          )
        end               # 6 points
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | CountComments
        | `false`
        | Boolean

        | Max
        | `10`
        | Integer

        | CountAsOne
        | `[]`
        | Array

        | AllowedMethods
        | `[]`
        | Array

        | AllowedPatterns
        | `[]`
        | Array
        |===

        === References

        * https://rubystyle.guide#short-methods

        == Metrics/ModuleLength

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.31
        | 0.87
        |===

        Checks if the length of a module exceeds some maximum value.
        Comment lines can optionally be ignored.
        The maximum allowed length is configurable.

        You can set constructs you want to fold with `CountAsOne`.
        Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
        will be counted as one line regardless of its actual size.

        === Examples

        ==== CountAsOne: ['array', 'heredoc', 'method_call']

        [source,ruby]
        ----
        module M
          ARRAY = [         # +1
            1,
            2
          ]

          HASH = {          # +3
            key: 'value'
          }

          MSG = <<~HEREDOC  # +1
            Heredoc
            content.
          HEREDOC

          foo(              # +1
            1,
            2
          )
        end                 # 6 points
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | CountComments
        | `false`
        | Boolean

        | Max
        | `100`
        | Integer

        | CountAsOne
        | `[]`
        | Array
        |===

        == Metrics/ParameterLists

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 1.5
        |===

        Checks for methods with too many parameters.

        The maximum number of parameters is configurable.
        Keyword arguments can optionally be excluded from the total count,
        as they add less complexity than positional or optional parameters.

        Any number of arguments for `initialize` method inside a block of
        `Struct.new` and `Data.define` like this is always allowed:

        [source,ruby]
        ----
        Struct.new(:one, :two, :three, :four, :five, keyword_init: true) do
          def initialize(one:, two:, three:, four:, five:)
          end
        end
        ----

        This is because checking the number of arguments of the `initialize` method
        does not make sense.

        NOTE: Explicit block argument `&block` is not counted to prevent
        erroneous change that is avoided by making block argument implicit.

        This cop also checks for the maximum number of optional parameters.
        This can be configured using the `MaxOptionalParameters` config option.

        === Examples

        ==== Max: 3

        [source,ruby]
        ----
        # good
        def foo(a, b, c = 1)
        end
        ----

        ==== Max: 2

        [source,ruby]
        ----
        # bad
        def foo(a, b, c = 1)
        end
        ----

        ==== CountKeywordArgs: true (default)

        [source,ruby]
        ----
        # counts keyword args towards the maximum

        # bad (assuming Max is 3)
        def foo(a, b, c, d: 1)
        end

        # good (assuming Max is 3)
        def foo(a, b, c: 1)
        end
        ----

        ==== CountKeywordArgs: false

        [source,ruby]
        ----
        # don't count keyword args towards the maximum

        # good (assuming Max is 3)
        def foo(a, b, c, d: 1)
        end
        ----

        ==== MaxOptionalParameters: 3 (default)

        [source,ruby]
        ----
        # good
        def foo(a = 1, b = 2, c = 3)
        end
        ----

        ==== MaxOptionalParameters: 2

        [source,ruby]
        ----
        # bad
        def foo(a = 1, b = 2, c = 3)
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Max
        | `5`
        | Integer

        | CountKeywordArgs
        | `true`
        | Boolean

        | MaxOptionalParameters
        | `3`
        | Integer
        |===

        === References

        * https://rubystyle.guide#too-many-params

        == Metrics/PerceivedComplexity

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.25
        | 0.81
        |===

        Tries to produce a complexity score that's a measure of the
        complexity the reader experiences when looking at a method. For that
        reason it considers `when` nodes as something that doesn't add as much
        complexity as an `if` or a `&&`. Except if it's one of those special
        `case`/`when` constructs where there's no expression after `case`. Then
        the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when`
        nodes count. In contrast to the CyclomaticComplexity cop, this cop
        considers `else` nodes as adding complexity.

        === Examples

        [source,ruby]
        ----
        def my_method                   # 1
          if cond                       # 1
            case var                    # 2 (0.8 + 4 * 0.2, rounded)
            when 1 then func_one
            when 2 then func_two
            when 3 then func_three
            when 4..10 then func_other
            end
          else                          # 1
            do_something until a && b   # 2
          end                           # ===
        end                             # 7 complexity points
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | AllowedMethods
        | `[]`
        | Array

        | AllowedPatterns
        | `[]`
        | Array

        | Max
        | `8`
        | Integer
        |===
  recorded_at: Mon, 27 May 2024 05:30:39 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_migration.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '444'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"52f3a7b307b99209c859b7f738228c06d9d10349cff19b62e8f4b2fcc3f925c2"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - A420:7A930:E25BA2:F08CF3:66541A7F
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:39 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230156-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787840.801368,VS0,VE175
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 43c61d8667af1729dcffea095d98ccb33f7485f2
      Expires:
      - Mon, 27 May 2024 05:35:39 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Migration

        == Migration/DepartmentName

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.75
        | -
        |===

        Check that cop names in rubocop:disable comments are given with
        department name.
  recorded_at: Mon, 27 May 2024 05:30:40 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_naming.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '25454'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"0db9525ea2c00c57e2455cb53a10d39e4bd3b4581d00e2751285708d9879e226"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - A3D0:12D701:138EDA7:14C7E59:66541A7F
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:40 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230091-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787840.093654,VS0,VE178
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 782d815a3434cba0eacf79fff1a99f2121f9543d
      Expires:
      - Mon, 27 May 2024 05:35:40 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: !binary |-
        Ly8vLwogIERvIE5PVCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kIGRpcmVjdGx5LCBhcyBpdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC4KCiAgUGxlYXNlIG1ha2UgYW55IG5lY2Vzc2FyeSBjaGFuZ2VzIHRvIHRoZSBjb3AgZG9jdW1lbnRhdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBmaWxlcyB0aGVtc2VsdmVzLgovLy8vCgo9IE5hbWluZwoKPT0gTmFtaW5nL0FjY2Vzc29yTWV0aG9kTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IC0KfD09PQoKTWFrZXMgc3VyZSB0aGF0IGFjY2Vzc29yIG1ldGhvZHMgYXJlIG5hbWVkIHByb3Blcmx5LiBBcHBsaWVzCnRvIGJvdGggaW5zdGFuY2UgYW5kIGNsYXNzIG1ldGhvZHMuCgpOT1RFOiBPZmZlbnNlcyBhcmUgb25seSByZWdpc3RlcmVkIGZvciBtZXRob2RzIHdpdGggdGhlIGV4cGVjdGVkCmFyaXR5LiBHZXR0ZXJzIChgZ2V0X2F0dHJpYnV0ZWApIG11c3QgaGF2ZSBubyBhcmd1bWVudHMgdG8gYmUKcmVnaXN0ZXJlZCwgYW5kIHNldHRlcnMgKGBzZXRfYXR0cmlidXRlKHZhbHVlKWApIG11c3QgaGF2ZSBleGFjdGx5Cm9uZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBzZXRfYXR0cmlidXRlKHZhbHVlKQplbmQKCiMgZ29vZApkZWYgYXR0cmlidXRlPSh2YWx1ZSkKZW5kCgojIGJhZApkZWYgZ2V0X2F0dHJpYnV0ZQplbmQKCiMgZ29vZApkZWYgYXR0cmlidXRlCmVuZAoKIyBhY2NlcHRlZCwgaW5jb3JyZWN0IGFyaXR5IGZvciBnZXR0ZXIKZGVmIGdldF92YWx1ZShhdHRyKQplbmQKCiMgYWNjZXB0ZWQsIGluY29ycmVjdCBhcml0eSBmb3Igc2V0dGVyCmRlZiBzZXRfdmFsdWUKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2FjY2Vzc29yX211dGF0b3JfbWV0aG9kX25hbWVzCgo9PSBOYW1pbmcvQXNjaWlJZGVudGlmaWVycwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IDAuODcKfD09PQoKQ2hlY2tzIGZvciBub24tYXNjaWkgY2hhcmFjdGVycyBpbiBpZGVudGlmaWVyIGFuZCBjb25zdGFudCBuYW1lcy4KSWRlbnRpZmllcnMgYXJlIGFsd2F5cyBjaGVja2VkIGFuZCB3aGV0aGVyIGNvbnN0YW50cyBhcmUgY2hlY2tlZApjYW4gYmUgY29udHJvbGxlZCB1c2luZyBBc2NpaUNvbnN0YW50cyBjb25maWcuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgzrrOsc67zrfOvM61z4HOsSAjIEdyZWVrIGFscGhhYmV0IChub24tYXNjaWkpCmVuZAoKIyBiYWQKZGVmIOOBk+OCk+OBq+OBoeOBr+OBqOiogOOBhiAjIEphcGFuZXNlIGNoYXJhY3RlciAobm9uLWFzY2lpKQplbmQKCiMgYmFkCmRlZiBoZWxsb1/wn42jICMgRW1vamkgKG5vbi1hc2NpaSkKZW5kCgojIGdvb2QKZGVmIHNheV9oZWxsbwplbmQKCiMgYmFkCuyLoOyepSA9IDEwICMgSGFuZ3VsIGNoYXJhY3RlciAobm9uLWFzY2lpKQoKIyBnb29kCmhlaWdodCA9IDEwCgojIGJhZApwYXJhbXNbOti52LHYtl9ndGVxXSAjIEFyYWJpYyBjaGFyYWN0ZXIgKG5vbi1hc2NpaSkKCiMgZ29vZApwYXJhbXNbOndpZHRoX2d0ZXFdCi0tLS0KCj09PT0gQXNjaWlDb25zdGFudHM6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgRm/DtgplbmQKCkZPw5YgPSAiZm9vIgotLS0tCgo9PT09IEFzY2lpQ29uc3RhbnRzOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBGb8O2CmVuZAoKRk/DliA9ICJmb28iCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBc2NpaUNvbnN0YW50cwp8IGB0cnVlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZW5nbGlzaC1pZGVudGlmaWVycwoKPT0gTmFtaW5nL0JpbmFyeU9wZXJhdG9yUGFyYW1ldGVyTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTAKfCAxLjIKfD09PQoKTWFrZXMgc3VyZSB0aGF0IGNlcnRhaW4gYmluYXJ5IG9wZXJhdG9yIG1ldGhvZHMgaGF2ZSB0aGVpcgpzb2xlICBwYXJhbWV0ZXIgbmFtZWQgYG90aGVyYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiArKGFtb3VudCk7IGVuZAoKIyBnb29kCmRlZiArKG90aGVyKTsgZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI290aGVyLWFyZwoKPT0gTmFtaW5nL0Jsb2NrRm9yd2FyZGluZwoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAzLjEKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjI0CnwgLQp8PT09CgpJbiBSdWJ5IDMuMSwgYW5vbnltb3VzIGJsb2NrIGZvcndhcmRpbmcgaGFzIGJlZW4gYWRkZWQuCgpUaGlzIGNvcCBpZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBgZG9fc29tZXRoaW5nKCZibG9jaylgIGNhbiBiZSByZXBsYWNlZApieSBgZG9fc29tZXRoaW5nKCYpYC4KCkl0IGFsc28gc3VwcG9ydHMgdGhlIG9wcG9zaXRlIHN0eWxlIGJ5IGFsdGVybmF0aXZlIGBleHBsaWNpdGAgb3B0aW9uLgpZb3UgY2FuIHNwZWNpZnkgdGhlIGJsb2NrIHZhcmlhYmxlIG5hbWUgZm9yIGF1dG9jb3JyZWN0aW9uIHdpdGggYEJsb2NrRm9yd2FyZGluZ05hbWVgLgpUaGUgZGVmYXVsdCB2YXJpYWJsZSBuYW1lIGlzIGBibG9ja2AuIElmIHRoZSBuYW1lIGlzIGFscmVhZHkgaW4gdXNlLCBpdCB3aWxsIG5vdCBiZQphdXRvY29ycmVjdGVkLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFub255bW91cyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vKCZibG9jaykKICBiYXIoJmJsb2NrKQplbmQKCiMgZ29vZApkZWYgZm9vKCYpCiAgYmFyKCYpCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGV4cGxpY2l0Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvbygmKQogIGJhcigmKQplbmQKCiMgZ29vZApkZWYgZm9vKCZibG9jaykKICBiYXIoJmJsb2NrKQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYW5vbnltb3VzYAp8IGBhbm9ueW1vdXNgLCBgZXhwbGljaXRgCgp8IEJsb2NrRm9yd2FyZGluZ05hbWUKfCBgYmxvY2tgCnwgU3RyaW5nCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2Jsb2NrLWZvcndhcmRpbmcKCj09IE5hbWluZy9CbG9ja1BhcmFtZXRlck5hbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNTMKfCAwLjc3Cnw9PT0KCkNoZWNrcyBibG9jayBwYXJhbWV0ZXIgbmFtZXMgZm9yIGhvdyBkZXNjcmlwdGl2ZSB0aGV5CmFyZS4gSXQgaXMgaGlnaGx5IGNvbmZpZ3VyYWJsZS4KClRoZSBgTWluTmFtZUxlbmd0aGAgY29uZmlnIG9wdGlvbiB0YWtlcyBhbiBpbnRlZ2VyLiBJdCByZXByZXNlbnRzCnRoZSBtaW5pbXVtIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRoZSBuYW1lIG11c3QgYmUuIEl0cyBkZWZhdWx0IGlzIDEuClRoZSBgQWxsb3dOYW1lc0VuZGluZ0luTnVtYmVyc2AgY29uZmlnIG9wdGlvbiB0YWtlcyBhIGJvb2xlYW4uIFdoZW4Kc2V0IHRvIGZhbHNlLCB0aGlzIGNvcCB3aWxsIHJlZ2lzdGVyIG9mZmVuc2VzIGZvciBuYW1lcyBlbmRpbmcgd2l0aApudW1iZXJzLiBJdHMgZGVmYXVsdCBpcyBmYWxzZS4gVGhlIGBBbGxvd2VkTmFtZXNgIGNvbmZpZyBvcHRpb24KdGFrZXMgYW4gYXJyYXkgb2YgcGVybWl0dGVkIG5hbWVzIHRoYXQgd2lsbCBuZXZlciByZWdpc3RlciBhbgpvZmZlbnNlLiBUaGUgYEZvcmJpZGRlbk5hbWVzYCBjb25maWcgb3B0aW9uIHRha2VzIGFuIGFycmF5IG9mCnJlc3RyaWN0ZWQgbmFtZXMgdGhhdCB3aWxsIGFsd2F5cyByZWdpc3RlciBhbiBvZmZlbnNlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYmFyIGRvIHx2YXJPbmUsIHZhclR3b3wKICB2YXJPbmUgKyB2YXJUd28KZW5kCgojIFdpdGggYEFsbG93TmFtZXNFbmRpbmdJbk51bWJlcnNgIHNldCB0byBmYWxzZQpmb28geyB8bnVtMSwgbnVtMnwgbnVtMSAqIG51bTIgfQoKIyBXaXRoIGBNaW5OYW1lTGVuZ3RoYCBzZXQgdG8gbnVtYmVyIGdyZWF0ZXIgdGhhbiAxCmJheiB7IHxhLCBiLCBjfCBkb19zdHVmZihhLCBiLCBjKSB9CgojIGdvb2QKYmFyIGRvIHx0aHVkLCBmcmVkfAogIHRodWQgKyBmcmVkCmVuZAoKZm9vIHsgfHNwZWVkLCBkaXN0YW5jZXwgc3BlZWQgKiBkaXN0YW5jZSB9CgpiYXogeyB8YWdlLCBoZWlnaHQsIGdlbmRlcnwgZG9fc3R1ZmYoYWdlLCBoZWlnaHQsIGdlbmRlcikgfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWluTmFtZUxlbmd0aAp8IGAxYAp8IEludGVnZXIKCnwgQWxsb3dOYW1lc0VuZGluZ0luTnVtYmVycwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dlZE5hbWVzCnwgYFtdYAp8IEFycmF5Cgp8IEZvcmJpZGRlbk5hbWVzCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09IE5hbWluZy9DbGFzc0FuZE1vZHVsZUNhbWVsQ2FzZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IDAuODUKfD09PQoKQ2hlY2tzIGZvciBjbGFzcyBhbmQgbW9kdWxlIG5hbWVzIHdpdGgKYW4gdW5kZXJzY29yZSBpbiB0aGVtLgoKYEFsbG93ZWROYW1lc2AgY29uZmlnIHRha2VzIGFuIGFycmF5IG9mIHBlcm1pdHRlZCBuYW1lcy4KSXRzIGRlZmF1bHQgdmFsdWUgaXMgYFsnbW9kdWxlX3BhcmVudCddYC4KVGhlc2UgbmFtZXMgY2FuIGJlIGZ1bGwgY2xhc3MvbW9kdWxlIG5hbWVzIG9yIHBhcnQgb2YgdGhlIG5hbWUuCmVnLiBBZGRpbmcgYG15X2NsYXNzYCB0byB0aGUgYEFsbG93ZWROYW1lc2AgY29uZmlnIHdpbGwgYWxsb3cgbmFtZXMgbGlrZQpgbXlfY2xhc3NgLCBgbXlfY2xhc3M6OlVzZXJgLCBgQXBwOjpteV9jbGFzc2AsIGBBcHA6Om15X2NsYXNzOjpVc2VyYCwgZXRjLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgTXlfQ2xhc3MKZW5kCm1vZHVsZSBNeV9Nb2R1bGUKZW5kCgojIGdvb2QKY2xhc3MgTXlDbGFzcwplbmQKbW9kdWxlIE15TW9kdWxlCmVuZApjbGFzcyBtb2R1bGVfcGFyZW50OjpNeU1vZHVsZQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWROYW1lcwp8IGBtb2R1bGVfcGFyZW50YAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2NhbWVsY2FzZS1jbGFzc2VzCgo9PSBOYW1pbmcvQ29uc3RhbnROYW1lCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUwCnwgLQp8PT09CgpDaGVja3Mgd2hldGhlciBjb25zdGFudCBuYW1lcyBhcmUgd3JpdHRlbiB1c2luZwpTQ1JFQU1JTkdfU05BS0VfQ0FTRS4KClRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcywgaXQgaWdub3JlcyBjYXNlcyBpbiB3aGljaCB3ZSBjYW5ub3Qga25vdwpmb3IgY2VydGFpbiB0aGUgdHlwZSBvZiB2YWx1ZSB0aGF0IHdvdWxkIGJlIGFzc2lnbmVkIHRvIGEgY29uc3RhbnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApJbmNoSW5DbSA9IDIuNTQKSU5DSGluQ00gPSAyLjU0CkluY2hfSW5fQ20gPSAyLjU0CgojIGdvb2QKSU5DSF9JTl9DTSA9IDIuNTQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc2NyZWFtaW5nLXNuYWtlLWNhc2UKCj09IE5hbWluZy9GaWxlTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IDEuMjMKfD09PQoKTWFrZXMgc3VyZSB0aGF0IFJ1Ynkgc291cmNlIGZpbGVzIGhhdmUgc25ha2VfY2FzZQpuYW1lcy4gUnVieSBzY3JpcHRzIChpLmUuIHNvdXJjZSBmaWxlcyB3aXRoIGEgc2hlYmFuZyBpbiB0aGUKZmlyc3QgbGluZSkgYXJlIGlnbm9yZWQuCgpUaGUgY29wIGFsc28gaWdub3JlcyBgLmdlbXNwZWNgIGZpbGVzLCBiZWNhdXNlIEJ1bmRsZXIKcmVjb21tZW5kcyB1c2luZyBkYXNoZXMgdG8gc2VwYXJhdGUgbmFtZXNwYWNlcyBpbiBuZXN0ZWQgZ2VtcwooaS5lLiBgYnVuZGxlci1jb25zb2xlYCBiZWNvbWVzIGBCdW5kbGVyOjpDb25zb2xlYCkuIEFzIHN1Y2gsIHRoZQpnZW1zcGVjIGlzIHN1cHBvc2VkIHRvIGJlIG5hbWVkIGBidW5kbGVyLWNvbnNvbGUuZ2Vtc3BlY2AuCgpXaGVuIGBFeHBlY3RNYXRjaGluZ0RlZmluaXRpb25gIChkZWZhdWx0OiBgZmFsc2VgKSBpcyBgdHJ1ZWAsIHRoZSBjb3AgcmVxdWlyZXMKZWFjaCBmaWxlIHRvIGhhdmUgYSBjbGFzcywgbW9kdWxlIG9yIGBTdHJ1Y3RgIGRlZmluZWQgaW4gaXQgdGhhdCBtYXRjaGVzCnRoZSBmaWxlbmFtZS4gVGhpcyBjYW4gYmUgZnVydGhlciBjb25maWd1cmVkIHVzaW5nCmBDaGVja0RlZmluaXRpb25QYXRoSGllcmFyY2h5YCAoZGVmYXVsdDogYHRydWVgKSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUKcGF0aCBzaG91bGQgbWF0Y2ggdGhlIG5hbWVzcGFjZSBvZiB0aGUgYWJvdmUgZGVmaW5pdGlvbi4KCldoZW4gYElnbm9yZUV4ZWN1dGFibGVTY3JpcHRzYCAoZGVmYXVsdDogYHRydWVgKSBpcyBgdHJ1ZWAsIGZpbGVzIHRoYXQgc3RhcnQKd2l0aCBhIHNoZWJhbmcgbGluZSBhcmUgbm90IGNvbnNpZGVyZWQgYnkgdGhlIGNvcC4KCldoZW4gYFJlZ2V4YCBpcyBzZXQsIHRoZSBjb3Agd2lsbCBmbGFnIGFueSBmaWxlbmFtZSB0aGF0IGRvZXMgbm90IG1hdGNoCnRoZSByZWd1bGFyIGV4cHJlc3Npb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsaWIvbGF5b3V0TWFuYWdlci5yYgoKYW55dGhpbmcvdXNpbmdDYW1lbENhc2UKCiMgZ29vZApsaWIvbGF5b3V0X21hbmFnZXIucmIKCmFueXRoaW5nL3VzaW5nX3NuYWtlX2Nhc2UucmFrZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRXhjbHVkZQp8IGBSYWtlZmlsZS5yYmAKfCBBcnJheQoKfCBFeHBlY3RNYXRjaGluZ0RlZmluaXRpb24KfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBDaGVja0RlZmluaXRpb25QYXRoSGllcmFyY2h5CnwgYHRydWVgCnwgQm9vbGVhbgoKfCBDaGVja0RlZmluaXRpb25QYXRoSGllcmFyY2h5Um9vdHMKfCBgbGliYCwgYHNwZWNgLCBgdGVzdGAsIGBzcmNgCnwgQXJyYXkKCnwgUmVnZXgKfCBgPG5vbmU+YAp8IAoKfCBJZ25vcmVFeGVjdXRhYmxlU2NyaXB0cwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dlZEFjcm9ueW1zCnwgYENMSWAsIGBEU0xgLCBgQUNMYCwgYEFQSWAsIGBBU0NJSWAsIGBDUFVgLCBgQ1NTYCwgYEROU2AsIGBFT0ZgLCBgR1VJRGAsIGBIVE1MYCwgYEhUVFBgLCBgSFRUUFNgLCBgSURgLCBgSVBgLCBgSlNPTmAsIGBMSFNgLCBgUVBTYCwgYFJBTWAsIGBSSFNgLCBgUlBDYCwgYFNMQWAsIGBTTVRQYCwgYFNRTGAsIGBTU0hgLCBgVENQYCwgYFRMU2AsIGBUVExgLCBgVURQYCwgYFVJYCwgYFVJRGAsIGBVVUlEYCwgYFVSSWAsIGBVUkxgLCBgVVRGOGAsIGBWTWAsIGBYTUxgLCBgWE1QUGAsIGBYU1JGYCwgYFhTU2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNzbmFrZS1jYXNlLWZpbGVzCgo9PSBOYW1pbmcvSGVyZWRvY0RlbGltaXRlckNhc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUwCnwgMS4yCnw9PT0KCkNoZWNrcyB0aGF0IHlvdXIgaGVyZWRvY3MgYXJlIHVzaW5nIHRoZSBjb25maWd1cmVkIGNhc2UuCkJ5IGRlZmF1bHQgaXQgaXMgY29uZmlndXJlZCB0byBlbmZvcmNlIHVwcGVyY2FzZSBoZXJlZG9jcy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiB1cHBlcmNhc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKPDwtc3FsCiAgU0VMRUNUICogRlJPTSBmb28Kc3FsCgojIGdvb2QKPDwtU1FMCiAgU0VMRUNUICogRlJPTSBmb28KU1FMCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogbG93ZXJjYXNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKPDwtU1FMCiAgU0VMRUNUICogRlJPTSBmb28KU1FMCgojIGdvb2QKPDwtc3FsCiAgU0VMRUNUICogRlJPTSBmb28Kc3FsCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHVwcGVyY2FzZWAKfCBgbG93ZXJjYXNlYCwgYHVwcGVyY2FzZWAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjaGVyZWRvYy1kZWxpbWl0ZXJzCgo9PSBOYW1pbmcvSGVyZWRvY0RlbGltaXRlck5hbWluZwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgeW91ciBoZXJlZG9jcyBhcmUgdXNpbmcgbWVhbmluZ2Z1bCBkZWxpbWl0ZXJzLgpCeSBkZWZhdWx0IGl0IGRpc2FsbG93cyBgRU5EYCBhbmQgYEVPKmAsIGFuZCBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoCmZvcmJpZGRlbiBsaXN0aW5nIGFkZGl0aW9uYWwgZGVsaW1pdGVycy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAo8PC1TUUwKICBTRUxFQ1QgKiBGUk9NIGZvbwpTUUwKCiMgYmFkCjw8LUVORAogIFNFTEVDVCAqIEZST00gZm9vCkVORAoKIyBiYWQKPDwtRU9TCiAgU0VMRUNUICogRlJPTSBmb28KRU9TCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBGb3JiaWRkZW5EZWxpbWl0ZXJzCnwgYCg/aS1teDooXlx8XHMpKEVPW0EtWl17MX1cfEVORCkoXHNcfCQpKWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNoZXJlZG9jLWRlbGltaXRlcnMKCj09IE5hbWluZy9JbmNsdXNpdmVMYW5ndWFnZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjE4CnwgMS40OQp8PT09CgpSZWNvbW1lbmRzIHRoZSB1c2Ugb2YgaW5jbHVzaXZlIGxhbmd1YWdlIGluc3RlYWQgb2YgcHJvYmxlbWF0aWMgdGVybXMuClRoZSBjb3AgY2FuIGNoZWNrIHRoZSBmb2xsb3dpbmcgbG9jYXRpb25zIGZvciBvZmZlbnNlczoKCi0gaWRlbnRpZmllcnMKLSBjb25zdGFudHMKLSB2YXJpYWJsZXMKLSBzdHJpbmdzCi0gc3ltYm9scwotIGNvbW1lbnRzCi0gZmlsZSBwYXRocwoKRWFjaCBvZiB0aGVzZSBsb2NhdGlvbnMgY2FuIGJlIGluZGl2aWR1YWxseSBlbmFibGVkL2Rpc2FibGVkIHZpYSBjb25maWd1cmF0aW9uLApmb3IgZXhhbXBsZSBDaGVja0lkZW50aWZpZXJzID0gdHJ1ZS9mYWxzZS4KCkZsYWdnZWQgdGVybXMgYXJlIGNvbmZpZ3VyYWJsZSBmb3IgdGhlIGNvcC4gRm9yIGVhY2ggZmxhZ2dlZCB0ZXJtIGFuIG9wdGlvbmFsClJlZ2V4IGNhbiBiZSBzcGVjaWZpZWQgdG8gaWRlbnRpZnkgb2ZmZW5zZXMuIFN1Z2dlc3Rpb25zIGZvciByZXBsYWNpbmcgYSBmbGFnZ2VkIHRlcm0gY2FuCmJlIGNvbmZpZ3VyZWQgYW5kIHdpbGwgYmUgZGlzcGxheWVkIGFzIHBhcnQgb2YgdGhlIG9mZmVuc2UgbWVzc2FnZS4KQW4gQWxsb3dlZFJlZ2V4IGNhbiBiZSBzcGVjaWZpZWQgZm9yIGEgZmxhZ2dlZCB0ZXJtIHRvIGV4ZW1wdCBhbGxvd2VkIHVzZXMgb2YgdGhlIHRlcm0uCmBXaG9sZVdvcmQ6IHRydWVgIGNhbiBiZSBzZXQgb24gYSBmbGFnZ2VkIHRlcm0gdG8gaW5kaWNhdGUgdGhlIGNvcCBzaG91bGQgb25seSBtYXRjaCB3aGVuCmEgdGVybSBtYXRjaGVzIHRoZSB3aG9sZSB3b3JkIChwYXJ0aWFsIG1hdGNoZXMgd2lsbCBub3QgYmUgb2ZmZW5zZXMpLgoKVGhlIGNvcCBzdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHN1Z2dlc3Rpb24uIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlCnN1Z2dlc3Rpb25zLCB0aGUgYmVzdCBzdWdnZXN0aW9uIGNhbm5vdCBiZSBpZGVudGlmaWVkIGFuZCB3aWxsIG5vdCBiZSBhdXRvY29ycmVjdGVkLgoKPT09IEV4YW1wbGVzCgo9PT09IEZsYWdnZWRUZXJtczogeyB3aGl0ZWxpc3Q6IHsgU3VnZ2VzdGlvbnM6IFsnYWxsb3dsaXN0J10gfSB9Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBTdWdnZXN0IHJlcGxhY2luZyBpZGVudGlmaWVyIHdoaXRlbGlzdCB3aXRoIGFsbG93bGlzdAoKIyBiYWQKd2hpdGVsaXN0X3VzZXJzID0gJXcodXNlcjEgdXNlcjEpCgojIGdvb2QKYWxsb3dsaXN0X3VzZXJzID0gJXcodXNlcjEgdXNlcjIpCi0tLS0KCj09PT0gRmxhZ2dlZFRlcm1zOiB7IG1hc3RlcjogeyBTdWdnZXN0aW9uczogWydtYWluJywgJ3ByaW1hcnknLCAnbGVhZGVyJ10gfSB9Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBTdWdnZXN0IHJlcGxhY2luZyBtYXN0ZXIgaW4gYW4gaW5zdGFuY2UgdmFyaWFibGUgbmFtZSB3aXRoIG1haW4sIHByaW1hcnksIG9yIGxlYWRlcgoKIyBiYWQKQG1hc3Rlcl9ub2RlID0gJ25vZGUxLmV4YW1wbGUuY29tJwoKIyBnb29kCkBwcmltYXJ5X25vZGUgPSAnbm9kZTEuZXhhbXBsZS5jb20nCi0tLS0KCj09PT0gRmxhZ2dlZFRlcm1zOiB7IHdoaXRlbGlzdDogeyBSZWdleDogIXJ1YnkvcmVnZXhwICcvd2hpdGVbLV9cc10/bGlzdCcgfSB9Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBJZGVudGlmeSBwcm9ibGVtYXRpYyB0ZXJtcyB1c2luZyBhIFJlZ2V4cAoKIyBiYWQKd2hpdGVfbGlzdCA9ICV3KHVzZXIxIHVzZXIyKQoKIyBnb29kCmFsbG93X2xpc3QgPSAldyh1c2VyMSB1c2VyMikKLS0tLQoKPT09PSBGbGFnZ2VkVGVybXM6IHsgbWFzdGVyOiB7IEFsbG93ZWRSZWdleDogJ21hc3RlclwnP3MgZGVncmVlJyB9IH0KCltzb3VyY2UscnVieV0KLS0tLQojIFNwZWNpZnkgYWxsb3dlZCB1c2VzIG9mIHRoZSBmbGFnZ2VkIHRlcm0gYXMgYSBzdHJpbmcgb3IgcmVnZXhwLgoKIyBiYWQKIyBUaGV5IGhhZCBhIG1hc3RlcnMKCiMgZ29vZAojIFRoZXkgaGFkIGEgbWFzdGVyJ3MgZGVncmVlCi0tLS0KCj09PT0gRmxhZ2dlZFRlcm1zOiB7IHNsYXZlOiB7IFdob2xlV29yZDogdHJ1ZSB9IH0KCltzb3VyY2UscnVieV0KLS0tLQojIFNwZWNpZnkgdGhhdCBvbmx5IHRlcm1zIHRoYXQgYXJlIGZ1bGwgbWF0Y2hlcyB3aWxsIGJlIGZsYWdnZWQuCgojIGJhZApTbGF2ZQoKIyBnb29kICh3b24ndCBiZSBmbGFnZ2VkIGRlc3BpdGUgY29udGFpbmluZyBgc2xhdmVgKQpUZXNsYVZlaGljbGUKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IENoZWNrSWRlbnRpZmllcnMKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IENoZWNrQ29uc3RhbnRzCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBDaGVja1ZhcmlhYmxlcwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQ2hlY2tTdHJpbmdzCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgQ2hlY2tTeW1ib2xzCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBDaGVja0NvbW1lbnRzCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBDaGVja0ZpbGVwYXRocwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgRmxhZ2dlZFRlcm1zCnwgYHsid2hpdGVsaXN0Ij0+eyJSZWdleCI9Pi93aGl0ZVstX1xzXT9saXN0LywgIlN1Z2dlc3Rpb25zIj0+WyJhbGxvd2xpc3QiLCAicGVybWl0Il19LCAiYmxhY2tsaXN0Ij0+eyJSZWdleCI9Pi9ibGFja1stX1xzXT9saXN0LywgIlN1Z2dlc3Rpb25zIj0+WyJkZW55bGlzdCIsICJibG9jayJdfSwgInNsYXZlIj0+eyJXaG9sZVdvcmQiPT50cnVlLCAiU3VnZ2VzdGlvbnMiPT5bInJlcGxpY2EiLCAic2Vjb25kYXJ5IiwgImZvbGxvd2VyIl19fWAKfCAKfD09PQoKPT0gTmFtaW5nL01lbW9pemVkSW5zdGFuY2VWYXJpYWJsZU5hbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNTMKfCAxLjIKfD09PQoKQ2hlY2tzIGZvciBtZW1vaXplZCBtZXRob2RzIHdob3NlIGluc3RhbmNlIHZhcmlhYmxlIG5hbWUKZG9lcyBub3QgbWF0Y2ggdGhlIG1ldGhvZCBuYW1lLiBBcHBsaWVzIHRvIGJvdGggcmVndWxhciBtZXRob2RzCihkZWZpbmVkIHdpdGggYGRlZmApIGFuZCBkeW5hbWljIG1ldGhvZHMgKGRlZmluZWQgd2l0aApgZGVmaW5lX21ldGhvZGAgb3IgYGRlZmluZV9zaW5nbGV0b25fbWV0aG9kYCkuCgpUaGlzIGNvcCBjYW4gYmUgY29uZmlndXJlZCB3aXRoIHRoZSBFbmZvcmNlZFN0eWxlRm9yTGVhZGluZ1VuZGVyc2NvcmVzCmRpcmVjdGl2ZS4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYWxsb3cgZm9yIG1lbW9pemVkIGluc3RhbmNlIHZhcmlhYmxlcwpwcmVmaXhlZCB3aXRoIGFuIHVuZGVyc2NvcmUuIFByZWZpeGluZyBpdmFycyB3aXRoIGFuIHVuZGVyc2NvcmUgaXMgYQpjb252ZW50aW9uIHRoYXQgaXMgdXNlZCB0byBpbXBsaWNpdGx5IGluZGljYXRlIHRoYXQgYW4gaXZhciBzaG91bGQgbm90CmJlIHNldCBvciByZWZlcmVuY2VkIG91dHNpZGUgb2YgdGhlIG1lbW9pemF0aW9uIG1ldGhvZC4KCj09PSBTYWZldHkKClRoaXMgY29wIHJlbGllcyBvbiB0aGUgcGF0dGVybiBgQGluc3RhbmNlX3ZhciB8fD0gLi4uYCwKYnV0IHRoaXMgaXMgc29tZXRpbWVzIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIHRoYW4gbWVtb2l6YXRpb24Kc28gdGhpcyBjb3AgaXMgY29uc2lkZXJlZCB1bnNhZmUuIEFsc28sIGl0cyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUKYmVjYXVzZSBpdCBtYXkgY29uZmxpY3Qgd2l0aCBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lcyBhbHJlYWR5IGluIHVzZS4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlRm9yTGVhZGluZ1VuZGVyc2NvcmVzOiBkaXNhbGxvd2VkIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgTWV0aG9kIGZvbyBpcyBtZW1vaXplZCB1c2luZyBhbiBpbnN0YW5jZSB2YXJpYWJsZSB0aGF0IGlzCiMgbm90IGBAZm9vYC4gVGhpcyBjYW4gY2F1c2UgY29uZnVzaW9uIGFuZCBidWdzLgpkZWYgZm9vCiAgQHNvbWV0aGluZyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCmRlZiBmb28KICByZXR1cm4gQHNvbWV0aGluZyBpZiBkZWZpbmVkPyhAc29tZXRoaW5nKQogIEBzb21ldGhpbmcgPSBjYWxjdWxhdGVfZXhwZW5zaXZlX3RoaW5nCmVuZAoKIyBnb29kCmRlZiBfZm9vCiAgQGZvbyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgQGZvbyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgQGZvbyB8fD0gYmVnaW4KICAgIGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKICBlbmQKZW5kCgojIGdvb2QKZGVmIGZvbwogIGhlbHBlcl92YXJpYWJsZSA9IHNvbWV0aGluZ193ZV9uZWVkX3RvX2NhbGN1bGF0ZV9mb28KICBAZm9vIHx8PSBjYWxjdWxhdGVfZXhwZW5zaXZlX3RoaW5nKGhlbHBlcl92YXJpYWJsZSkKZW5kCgojIGdvb2QKZGVmaW5lX21ldGhvZCg6Zm9vKSBkbwogIEBmb28gfHw9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCgojIGdvb2QKZGVmaW5lX21ldGhvZCg6Zm9vKSBkbwogIHJldHVybiBAZm9vIGlmIGRlZmluZWQ/KEBmb28pCiAgQGZvbyA9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZUZvckxlYWRpbmdVbmRlcnNjb3JlczogcmVxdWlyZWQKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vCiAgQHNvbWV0aGluZyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgYmFkCmRlZiBmb28KICBAZm9vIHx8PSBjYWxjdWxhdGVfZXhwZW5zaXZlX3RoaW5nCmVuZAoKZGVmIGZvbwogIHJldHVybiBAZm9vIGlmIGRlZmluZWQ/KEBmb28pCiAgQGZvbyA9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCgojIGdvb2QKZGVmIGZvbwogIEBfZm9vIHx8PSBjYWxjdWxhdGVfZXhwZW5zaXZlX3RoaW5nCmVuZAoKIyBnb29kCmRlZiBfZm9vCiAgQF9mb28gfHw9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCgpkZWYgZm9vCiAgcmV0dXJuIEBfZm9vIGlmIGRlZmluZWQ/KEBfZm9vKQogIEBfZm9vID0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWZpbmVfbWV0aG9kKDpmb28pIGRvCiAgQF9mb28gfHw9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCgojIGdvb2QKZGVmaW5lX21ldGhvZCg6Zm9vKSBkbwogIHJldHVybiBAX2ZvbyBpZiBkZWZpbmVkPyhAX2ZvbykKICBAX2ZvbyA9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZUZvckxlYWRpbmdVbmRlcnNjb3JlcyA6b3B0aW9uYWwKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vCiAgQHNvbWV0aGluZyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgQGZvbyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgQF9mb28gfHw9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCgojIGdvb2QKZGVmIF9mb28KICBAX2ZvbyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgcmV0dXJuIEBfZm9vIGlmIGRlZmluZWQ/KEBfZm9vKQogIEBfZm9vID0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWZpbmVfbWV0aG9kKDpmb28pIGRvCiAgQGZvbyB8fD0gY2FsY3VsYXRlX2V4cGVuc2l2ZV90aGluZwplbmQKCiMgZ29vZApkZWZpbmVfbWV0aG9kKDpmb28pIGRvCiAgQF9mb28gfHw9IGNhbGN1bGF0ZV9leHBlbnNpdmVfdGhpbmcKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlRm9yTGVhZGluZ1VuZGVyc2NvcmVzCnwgYGRpc2FsbG93ZWRgCnwgYGRpc2FsbG93ZWRgLCBgcmVxdWlyZWRgLCBgb3B0aW9uYWxgCnw9PT0KCj09IE5hbWluZy9NZXRob2ROYW1lCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUwCnwgLQp8PT09CgpNYWtlcyBzdXJlIHRoYXQgYWxsIG1ldGhvZHMgdXNlIHRoZSBjb25maWd1cmVkIHN0eWxlLApzbmFrZV9jYXNlIG9yIGNhbWVsQ2FzZSwgZm9yIHRoZWlyIG5hbWVzLgoKVGhpcyBjb3AgaGFzIGBBbGxvd2VkUGF0dGVybnNgIGNvbmZpZ3VyYXRpb24gb3B0aW9uLgoKICBOYW1pbmcvTWV0aG9kTmFtZToKICAgIEFsbG93ZWRQYXR0ZXJuczoKICAgICAgLSAnXEFvblNlbGVjdGlvbkJ1bGtDaGFuZ2VceicKICAgICAgLSAnXEFvblNlbGVjdGlvbkNsZWFyZWRceicKCk1ldGhvZCBuYW1lcyBtYXRjaGluZyBwYXR0ZXJucyBhcmUgYWx3YXlzIGFsbG93ZWQuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc25ha2VfY2FzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vQmFyOyBlbmQKCiMgZ29vZApkZWYgZm9vX2JhcjsgZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY2FtZWxDYXNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvb19iYXI7IGVuZAoKIyBnb29kCmRlZiBmb29CYXI7IGVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBzbmFrZV9jYXNlYAp8IGBzbmFrZV9jYXNlYCwgYGNhbWVsQ2FzZWAKCnwgQWxsb3dlZFBhdHRlcm5zCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3NuYWtlLWNhc2Utc3ltYm9scy1tZXRob2RzLXZhcnMKCj09IE5hbWluZy9NZXRob2RQYXJhbWV0ZXJOYW1lCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUzCnwgMC43Nwp8PT09CgpDaGVja3MgbWV0aG9kIHBhcmFtZXRlciBuYW1lcyBmb3IgaG93IGRlc2NyaXB0aXZlIHRoZXkKYXJlLiBJdCBpcyBoaWdobHkgY29uZmlndXJhYmxlLgoKVGhlIGBNaW5OYW1lTGVuZ3RoYCBjb25maWcgb3B0aW9uIHRha2VzIGFuIGludGVnZXIuIEl0IHJlcHJlc2VudHMKdGhlIG1pbmltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgdGhlIG5hbWUgbXVzdCBiZS4gSXRzIGRlZmF1bHQgaXMgMy4KVGhlIGBBbGxvd05hbWVzRW5kaW5nSW5OdW1iZXJzYCBjb25maWcgb3B0aW9uIHRha2VzIGEgYm9vbGVhbi4gV2hlbgpzZXQgdG8gZmFsc2UsIHRoaXMgY29wIHdpbGwgcmVnaXN0ZXIgb2ZmZW5zZXMgZm9yIG5hbWVzIGVuZGluZyB3aXRoCm51bWJlcnMuIEl0cyBkZWZhdWx0IGlzIGZhbHNlLiBUaGUgYEFsbG93ZWROYW1lc2AgY29uZmlnIG9wdGlvbgp0YWtlcyBhbiBhcnJheSBvZiBwZXJtaXR0ZWQgbmFtZXMgdGhhdCB3aWxsIG5ldmVyIHJlZ2lzdGVyIGFuCm9mZmVuc2UuIFRoZSBgRm9yYmlkZGVuTmFtZXNgIGNvbmZpZyBvcHRpb24gdGFrZXMgYW4gYXJyYXkgb2YKcmVzdHJpY3RlZCBuYW1lcyB0aGF0IHdpbGwgYWx3YXlzIHJlZ2lzdGVyIGFuIG9mZmVuc2UuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgYmFyKHZhck9uZSwgdmFyVHdvKQogIHZhck9uZSArIHZhclR3bwplbmQKCiMgV2l0aCBgQWxsb3dOYW1lc0VuZGluZ0luTnVtYmVyc2Agc2V0IHRvIGZhbHNlCmRlZiBmb28obnVtMSwgbnVtMikKICBudW0xICogbnVtMgplbmQKCiMgV2l0aCBgTWluTmFtZUxlbmd0aGAgc2V0IHRvIG51bWJlciBncmVhdGVyIHRoYW4gMQpkZWYgYmF6KGEsIGIsIGMpCiAgZG9fc3R1ZmYoYSwgYiwgYykKZW5kCgojIGdvb2QKZGVmIGJhcih0aHVkLCBmcmVkKQogIHRodWQgKyBmcmVkCmVuZAoKZGVmIGZvbyhzcGVlZCwgZGlzdGFuY2UpCiAgc3BlZWQgKiBkaXN0YW5jZQplbmQKCmRlZiBiYXooYWdlX2EsIGhlaWdodF9iLCBnZW5kZXJfYykKICBkb19zdHVmZihhZ2VfYSwgaGVpZ2h0X2IsIGdlbmRlcl9jKQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE1pbk5hbWVMZW5ndGgKfCBgM2AKfCBJbnRlZ2VyCgp8IEFsbG93TmFtZXNFbmRpbmdJbk51bWJlcnMKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IEFsbG93ZWROYW1lcwp8IGBhc2AsIGBhdGAsIGBieWAsIGBjY2AsIGBkYmAsIGBpZGAsIGBpZmAsIGBpbmAsIGBpb2AsIGBpcGAsIGBvZmAsIGBvbmAsIGBvc2AsIGBwcGAsIGB0b2AKfCBBcnJheQoKfCBGb3JiaWRkZW5OYW1lcwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PSBOYW1pbmcvUHJlZGljYXRlTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MAp8IDAuNzcKfD09PQoKQ2hlY2tzIHRoYXQgcHJlZGljYXRlIG1ldGhvZHMgbmFtZXMgZW5kIHdpdGggYSBxdWVzdGlvbiBtYXJrIGFuZApkbyBub3Qgc3RhcnQgd2l0aCBhIGZvcmJpZGRlbiBwcmVmaXguCgpBIG1ldGhvZCBpcyBkZXRlcm1pbmVkIHRvIGJlIGEgcHJlZGljYXRlIG1ldGhvZCBpZiBpdHMgbmFtZSBzdGFydHMKd2l0aCBvbmUgb2YgdGhlIHByZWZpeGVzIGRlZmluZWQgaW4gdGhlIGBOYW1lUHJlZml4YCBjb25maWd1cmF0aW9uLgpZb3UgY2FuIGNoYW5nZSB3aGF0IHByZWZpeGVzIGFyZSBjb25zaWRlcmVkIGJ5IGNoYW5naW5nIHRoaXMgb3B0aW9uLgpBbnkgbWV0aG9kIG5hbWUgdGhhdCBzdGFydHMgd2l0aCBvbmUgb2YgdGhlc2UgcHJlZml4ZXMgaXMgcmVxdWlyZWQgYnkKdGhlIGNvcCB0byBlbmQgd2l0aCBhIGA/YC4gT3RoZXIgbWV0aG9kcyBjYW4gYmUgYWxsb3dlZCBieSBhZGRpbmcgdG8KdGhlIGBBbGxvd2VkTWV0aG9kc2AgY29uZmlndXJhdGlvbi4KCk5PVEU6IFRoZSBgaXNfYT9gIG1ldGhvZCBpcyBhbGxvd2VkIGJ5IGRlZmF1bHQuCgpJZiBgRm9yYmlkZGVuUHJlZml4ZXNgIGlzIHNldCwgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggdGhlIGNvbmZpZ3VyZWQKcHJlZml4ZXMgd2lsbCBub3QgYmUgYWxsb3dlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGJ5IGF1dG9jb3JyZWN0aW9uLgoKSW4gb3RoZXIgd29yZHMsIGlmIGBGb3JiaWRkZW5QcmVmaXhlc2AgaXMgZW1wdHksIGEgbWV0aG9kIG5hbWVkIGBpc19mb29gCndpbGwgcmVnaXN0ZXIgYW4gb2ZmZW5zZSBvbmx5IGR1ZSB0byB0aGUgbGFjayBvZiBxdWVzdGlvbiBtYXJrIChhbmQgd2lsbCBiZQphdXRvY29ycmVjdGVkIHRvIGBpc19mb28/YCkuIElmIGBGb3JiaWRkZW5QcmVmaXhlc2AgY29udGFpbnMgYGlzX2AsCmBpc19mb29gIHdpbGwgcmVnaXN0ZXIgYW4gb2ZmZW5zZSBib3RoIGJlY2F1c2UgdGhlID8gaXMgbWlzc2luZyBhbmQgYmVjYXVzZSBvZgp0aGUgYGlzX2AgcHJlZml4LCBhbmQgd2lsbCBiZSBjb3JyZWN0ZWQgdG8gYGZvbz9gLgoKTk9URTogYEZvcmJpZGRlblByZWZpeGVzYCBpcyBvbmx5IGFwcGxpZWQgdG8gcHJlZml4ZXMgaW4gYE5hbWVQcmVmaXhgOwphIHByZWZpeCBpbiB0aGUgZm9ybWVyIGJ1dCBub3QgdGhlIGxhdHRlciB3aWxsIG5vdCBiZSBjb25zaWRlcmVkIGJ5CnRoaXMgY29wLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGlzX2V2ZW4odmFsdWUpCmVuZAoKZGVmIGlzX2V2ZW4/KHZhbHVlKQplbmQKCiMgZ29vZApkZWYgZXZlbj8odmFsdWUpCmVuZAoKIyBiYWQKZGVmIGhhc192YWx1ZQplbmQKCmRlZiBoYXNfdmFsdWU/CmVuZAoKIyBnb29kCmRlZiB2YWx1ZT8KZW5kCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFsnaXNfYT8nXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmIGlzX2E/KHZhbHVlKQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE5hbWVQcmVmaXgKfCBgaXNfYCwgYGhhc19gLCBgaGF2ZV9gCnwgQXJyYXkKCnwgRm9yYmlkZGVuUHJlZml4ZXMKfCBgaXNfYCwgYGhhc19gLCBgaGF2ZV9gCnwgQXJyYXkKCnwgQWxsb3dlZE1ldGhvZHMKfCBgaXNfYT9gCnwgQXJyYXkKCnwgTWV0aG9kRGVmaW5pdGlvbk1hY3Jvcwp8IGBkZWZpbmVfbWV0aG9kYCwgYGRlZmluZV9zaW5nbGV0b25fbWV0aG9kYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgK3NwZWMvKiovKitgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYm9vbC1tZXRob2RzLXFtYXJrCgo9PSBOYW1pbmcvUmVzY3VlZEV4Y2VwdGlvbnNWYXJpYWJsZU5hbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjY3CnwgMC42OAp8PT09CgpNYWtlcyBzdXJlIHRoYXQgcmVzY3VlZCBleGNlcHRpb25zIHZhcmlhYmxlcyBhcmUgbmFtZWQgYXMKZXhwZWN0ZWQuCgpUaGUgYFByZWZlcnJlZE5hbWVgIGNvbmZpZyBvcHRpb24gdGFrZXMgYSBgU3RyaW5nYC4gSXQgcmVwcmVzZW50cwp0aGUgcmVxdWlyZWQgbmFtZSBvZiB0aGUgdmFyaWFibGUuIEl0cyBkZWZhdWx0IGlzIGBlYC4KCk5PVEU6IFRoaXMgY29wIGRvZXMgbm90IGNvbnNpZGVyIG5lc3RlZCByZXNjdWVzIGJlY2F1c2UgaXQgY2Fubm90Cmd1YXJhbnRlZSB0aGF0IHRoZSB2YXJpYWJsZSBmcm9tIHRoZSBvdXRlciByZXNjdWUgaXMgbm90IHVzZWQgd2l0aGluCnRoZSBpbm5lciByZXNjdWUgKGluIHdoaWNoIGNhc2UsIGNoYW5naW5nIHRoZSBpbm5lciB2YXJpYWJsZSB3b3VsZApzaGFkb3cgdGhlIG91dGVyIHZhcmlhYmxlKS4KCj09PSBFeGFtcGxlcwoKPT09PSBQcmVmZXJyZWROYW1lOiBlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJlZ2luCiAgIyBkbyBzb21ldGhpbmcKcmVzY3VlIE15RXhjZXB0aW9uID0+IGV4Y2VwdGlvbgogICMgZG8gc29tZXRoaW5nCmVuZAoKIyBnb29kCmJlZ2luCiAgIyBkbyBzb21ldGhpbmcKcmVzY3VlIE15RXhjZXB0aW9uID0+IGUKICAjIGRvIHNvbWV0aGluZwplbmQKCiMgZ29vZApiZWdpbgogICMgZG8gc29tZXRoaW5nCnJlc2N1ZSBNeUV4Y2VwdGlvbiA9PiBfZQogICMgZG8gc29tZXRoaW5nCmVuZAotLS0tCgo9PT09IFByZWZlcnJlZE5hbWU6IGV4Y2VwdGlvbgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJlZ2luCiAgIyBkbyBzb21ldGhpbmcKcmVzY3VlIE15RXhjZXB0aW9uID0+IGUKICAjIGRvIHNvbWV0aGluZwplbmQKCiMgZ29vZApiZWdpbgogICMgZG8gc29tZXRoaW5nCnJlc2N1ZSBNeUV4Y2VwdGlvbiA9PiBleGNlcHRpb24KICAjIGRvIHNvbWV0aGluZwplbmQKCiMgZ29vZApiZWdpbgogICMgZG8gc29tZXRoaW5nCnJlc2N1ZSBNeUV4Y2VwdGlvbiA9PiBfZXhjZXB0aW9uCiAgIyBkbyBzb21ldGhpbmcKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBQcmVmZXJyZWROYW1lCnwgYGVgCnwgU3RyaW5nCnw9PT0KCj09IE5hbWluZy9WYXJpYWJsZU5hbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNTAKfCAxLjgKfD09PQoKTWFrZXMgc3VyZSB0aGF0IGFsbCB2YXJpYWJsZXMgdXNlIHRoZSBjb25maWd1cmVkIHN0eWxlLApzbmFrZV9jYXNlIG9yIGNhbWVsQ2FzZSwgZm9yIHRoZWlyIG5hbWVzLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vQmFyID0gMQoKIyBnb29kCmZvb19iYXIgPSAxCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY2FtZWxDYXNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vX2JhciA9IDEKCiMgZ29vZApmb29CYXIgPSAxCi0tLS0KCj09PT0gQWxsb3dlZElkZW50aWZpZXJzOiBbJ2Zvb0JhciddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kICh3aXRoIEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UpCmZvb0JhciA9IDEKLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnM6IFsnX3ZcZCtceiddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kICh3aXRoIEVuZm9yY2VkU3R5bGU6IGNhbWVsQ2FzZSkKOnJlbGVhc2VfdjEKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc25ha2VfY2FzZWAKfCBgc25ha2VfY2FzZWAsIGBjYW1lbENhc2VgCgp8IEFsbG93ZWRJZGVudGlmaWVycwp8IGBbXWAKfCBBcnJheQoKfCBBbGxvd2VkUGF0dGVybnMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc25ha2UtY2FzZS1zeW1ib2xzLW1ldGhvZHMtdmFycwoKPT0gTmFtaW5nL1ZhcmlhYmxlTnVtYmVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUwCnwgMS40Cnw9PT0KCk1ha2VzIHN1cmUgdGhhdCBhbGwgbnVtYmVyZWQgdmFyaWFibGVzIHVzZSB0aGUKY29uZmlndXJlZCBzdHlsZSwgc25ha2VfY2FzZSwgbm9ybWFsY2FzZSwgb3Igbm9uX2ludGVnZXIsCmZvciB0aGVpciBudW1iZXJpbmcuCgpBZGRpdGlvbmFsbHksIGBDaGVja01ldGhvZE5hbWVzYCBhbmQgYENoZWNrU3ltYm9sc2AgY29uZmlndXJhdGlvbiBvcHRpb25zCmNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgd2hldGhlciBtZXRob2QgbmFtZXMgYW5kIHN5bWJvbHMgc2hvdWxkIGJlIGNoZWNrZWQuCkJvdGggYXJlIGVuYWJsZWQgYnkgZGVmYXVsdC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBub3JtYWxjYXNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCjpzb21lX3N5bV8xCnZhcmlhYmxlXzEgPSAxCgpkZWYgc29tZV9tZXRob2RfMTsgZW5kCgpkZWYgc29tZV9tZXRob2QxKGFyZ18xKTsgZW5kCgojIGdvb2QKOnNvbWVfc3ltMQp2YXJpYWJsZTEgPSAxCgpkZWYgc29tZV9tZXRob2QxOyBlbmQKCmRlZiBzb21lX21ldGhvZDEoYXJnMSk7IGVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo6c29tZV9zeW0xCnZhcmlhYmxlMSA9IDEKCmRlZiBzb21lX21ldGhvZDE7IGVuZAoKZGVmIHNvbWVfbWV0aG9kXzEoYXJnMSk7IGVuZAoKIyBnb29kCjpzb21lX3N5bV8xCnZhcmlhYmxlXzEgPSAxCgpkZWYgc29tZV9tZXRob2RfMTsgZW5kCgpkZWYgc29tZV9tZXRob2RfMShhcmdfMSk7IGVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IG5vbl9pbnRlZ2VyCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKOnNvbWVfc3ltMQo6c29tZV9zeW1fMQoKdmFyaWFibGUxID0gMQp2YXJpYWJsZV8xID0gMQoKZGVmIHNvbWVfbWV0aG9kMTsgZW5kCgpkZWYgc29tZV9tZXRob2RfMTsgZW5kCgpkZWYgc29tZV9tZXRob2RvbmUoYXJnMSk7IGVuZApkZWYgc29tZV9tZXRob2RvbmUoYXJnXzEpOyBlbmQKCiMgZ29vZAo6c29tZV9zeW1vbmUKOnNvbWVfc3ltX29uZQoKdmFyaWFibGVvbmUgPSAxCnZhcmlhYmxlX29uZSA9IDEKCmRlZiBzb21lX21ldGhvZG9uZTsgZW5kCgpkZWYgc29tZV9tZXRob2Rfb25lOyBlbmQKCmRlZiBzb21lX21ldGhvZG9uZShhcmdvbmUpOyBlbmQKZGVmIHNvbWVfbWV0aG9kb25lKGFyZ19vbmUpOyBlbmQKCiMgSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlcywgd2UgYXNzdW1lIGBFbmZvcmNlZFN0eWxlOiBub3JtYWxjYXNlYCAoZGVmYXVsdCkuCi0tLS0KCj09PT0gQ2hlY2tNZXRob2ROYW1lczogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgc29tZV9tZXRob2RfMTsgZW5kCi0tLS0KCj09PT0gQ2hlY2tNZXRob2ROYW1lczogZmFsc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmIHNvbWVfbWV0aG9kXzE7IGVuZAotLS0tCgo9PT09IENoZWNrU3ltYm9sczogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo6c29tZV9zeW1fMQotLS0tCgo9PT09IENoZWNrU3ltYm9sczogZmFsc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKOnNvbWVfc3ltXzEKLS0tLQoKPT09PSBBbGxvd2VkSWRlbnRpZmllcnM6IFtjYXB0dXJlM10KCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZXhwZWN0KE9wZW4zKS50byByZWNlaXZlKDpjYXB0dXJlMykKLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnM6IFsnX3ZcZCtceiddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCjpzb21lX3N5bV92MQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBub3JtYWxjYXNlYAp8IGBzbmFrZV9jYXNlYCwgYG5vcm1hbGNhc2VgLCBgbm9uX2ludGVnZXJgCgp8IENoZWNrTWV0aG9kTmFtZXMKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IENoZWNrU3ltYm9scwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dlZElkZW50aWZpZXJzCnwgYGNhcHR1cmUzYCwgYGlzbzg2MDFgLCBgcmZjMTEyM19kYXRlYCwgYHJmYzgyMmAsIGByZmMyODIyYCwgYHJmYzMzMzlgLCBgeDg2XzY0YAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNzbmFrZS1jYXNlLXN5bWJvbHMtbWV0aG9kcy12YXJzLXdpdGgtbnVtYmVycwo=
  recorded_at: Mon, 27 May 2024 05:30:40 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_security.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '5862'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"1d479cde9ff1cd82db7c45f66de25d54f2e9990eb86386d95c5092a3bece82d6"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 8914:3BC15A:1331F36:146AEF8:66541A80
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:40 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230146-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787840.426651,VS0,VE191
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 1d58771d288e9b159f167f175745fdf13d29392d
      Expires:
      - Mon, 27 May 2024 05:35:40 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Security

        == Security/CompoundHash

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | No
        | 1.28
        | 1.51
        |===

        Checks for implementations of the `hash` method which combine
        values using custom logic instead of delegating to `Array#hash`.

        Manually combining hashes is error prone and hard to follow, especially
        when there are many values. Poor implementations may also introduce
        performance or security concerns if they are prone to collisions.
        Delegating to `Array#hash` is clearer and safer, although it might be slower
        depending on the use case.

        === Safety

        This cop may be unsafe if the application logic depends on the hash
        value, however this is inadvisable anyway.

        === Examples

        [source,ruby]
        ----
        # bad
        def hash
          @foo ^ @bar
        end

        # good
        def hash
          [@foo, @bar].hash
        end
        ----

        == Security/Eval

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.47
        | -
        |===

        Checks for the use of `Kernel#eval` and `Binding#eval`.

        === Examples

        [source,ruby]
        ----
        # bad

        eval(something)
        binding.eval(something)
        ----

        == Security/IoMethods

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | Always (Unsafe)
        | 1.22
        | -
        |===

        Checks for the first argument to `IO.read`, `IO.binread`, `IO.write`, `IO.binwrite`,
        `IO.foreach`, and `IO.readlines`.

        If argument starts with a pipe character (`'|'`) and the receiver is the `IO` class,
        a subprocess is created in the same way as `Kernel#open`, and its output is returned.
        `Kernel#open` may allow unintentional command injection, which is the reason these
        `IO` methods are a security risk.
        Consider to use `File.read` to disable the behavior of subprocess invocation.

        === Safety

        This cop is unsafe because false positive will occur if the variable passed as
        the first argument is a command that is not a file path.

        === Examples

        [source,ruby]
        ----
        # bad
        IO.read(path)
        IO.read('path')

        # good
        File.read(path)
        File.read('path')
        IO.read('| command') # Allow intentional command invocation.
        ----

        == Security/JSONLoad

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.43
        | 1.22
        |===

        Checks for the use of JSON class methods which have potential
        security issues.

        === Safety

        This cop's autocorrection is unsafe because it's potentially dangerous.
        If using a stream, like `JSON.load(open('file'))`, it will need to call
        `#read` manually, like `JSON.parse(open('file').read)`.
        If reading single values (rather than proper JSON objects), like
        `JSON.load('false')`, it will need to pass the `quirks_mode: true`
        option, like `JSON.parse('false', quirks_mode: true)`.
        Other similar issues may apply.

        === Examples

        [source,ruby]
        ----
        # bad
        JSON.load("{}")
        JSON.restore("{}")

        # good
        JSON.parse("{}")
        ----

        === References

        * https://ruby-doc.org/stdlib-2.7.0/libdoc/json/rdoc/JSON.html#method-i-load

        == Security/MarshalLoad

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.47
        | -
        |===

        Checks for the use of Marshal class methods which have
        potential security issues leading to remote code execution when
        loading from an untrusted source.

        === Examples

        [source,ruby]
        ----
        # bad
        Marshal.load("{}")
        Marshal.restore("{}")

        # good
        Marshal.dump("{}")

        # okish - deep copy hack
        Marshal.load(Marshal.dump({}))
        ----

        === References

        * https://ruby-doc.org/core-2.7.0/Marshal.html#module-Marshal-label-Security+considerations

        == Security/Open

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | No
        | 0.53
        | 1.0
        |===

        Checks for the use of `Kernel#open` and `URI.open` with dynamic
        data.

        `Kernel#open` and `URI.open` enable not only file access but also process
        invocation by prefixing a pipe symbol (e.g., `open("| ls")`).
        So, it may lead to a serious security risk by using variable input to
        the argument of `Kernel#open` and `URI.open`. It would be better to use
        `File.open`, `IO.popen` or `URI.parse#open` explicitly.

        NOTE: `open` and `URI.open` with literal strings are not flagged by this
        cop.

        === Safety

        This cop could register false positives if `open` is redefined
        in a class and then used without a receiver in that class.

        === Examples

        [source,ruby]
        ----
        # bad
        open(something)
        open("| #{something}")
        open("| foo")
        URI.open(something)

        # good
        File.open(something)
        IO.popen(something)
        URI.parse(something).open

        # good (literal strings)
        open("foo.text")
        URI.open("http://example.com")
        ----

        == Security/YAMLLoad

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.47
        | -
        |===

        Checks for the use of YAML class methods which have
        potential security issues leading to remote code execution when
        loading from an untrusted source.

        NOTE: Ruby 3.1+ (Psych 4) uses `Psych.load` as `Psych.safe_load` by default.

        === Safety

        The behavior of the code might change depending on what was
        in the YAML payload, since `YAML.safe_load` is more restrictive.

        === Examples

        [source,ruby]
        ----
        # bad
        YAML.load("--- !ruby/object:Foo {}") # Psych 3 is unsafe by default

        # good
        YAML.safe_load("--- !ruby/object:Foo {}", [Foo])                    # Ruby 2.5  (Psych 3)
        YAML.safe_load("--- !ruby/object:Foo {}", permitted_classes: [Foo]) # Ruby 3.0- (Psych 3)
        YAML.load("--- !ruby/object:Foo {}", permitted_classes: [Foo])      # Ruby 3.1+ (Psych 4)
        YAML.dump(foo)
        ----

        === References

        * https://ruby-doc.org/stdlib-2.7.0/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security
  recorded_at: Mon, 27 May 2024 05:30:40 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/docs/modules/ROOT/pages/cops_style.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '263511'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"c2178fd41fc2bf0c45849c11b0779e62a796b17bf24b0a88824453d195c04cc8"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 91BA:3EB50A:FD0093:10C4426:66541A7F
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:41 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230114-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787841.814346,VS0,VE207
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 159af3c927f37095fff9d09fcd35b90bec6b024a
      Expires:
      - Mon, 27 May 2024 05:35:41 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: !binary |-
        Ly8vLwogIERvIE5PVCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kIGRpcmVjdGx5LCBhcyBpdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC4KCiAgUGxlYXNlIG1ha2UgYW55IG5lY2Vzc2FyeSBjaGFuZ2VzIHRvIHRoZSBjb3AgZG9jdW1lbnRhdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBmaWxlcyB0aGVtc2VsdmVzLgovLy8vCgo9IFN0eWxlCgo9PSBTdHlsZS9BY2Nlc3NNb2RpZmllckRlY2xhcmF0aW9ucwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNTcKfCAwLjgxCnw9PT0KCkFjY2VzcyBtb2RpZmllcnMgc2hvdWxkIGJlIGRlY2xhcmVkIHRvIGFwcGx5IHRvIGEgZ3JvdXAgb2YgbWV0aG9kcwpvciBpbmxpbmUgYmVmb3JlIGVhY2ggbWV0aG9kLCBkZXBlbmRpbmcgb24gY29uZmlndXJhdGlvbi4KRW5mb3JjZWRTdHlsZSBjb25maWcgY292ZXJzIG9ubHkgbWV0aG9kIGRlZmluaXRpb25zLgpBcHBsaWNhdGlvbnMgb2YgdmlzaWJpbGl0eSBtZXRob2RzIHRvIHN5bWJvbHMgY2FuIGJlIGNvbnRyb2xsZWQKdXNpbmcgQWxsb3dNb2RpZmllcnNPblN5bWJvbHMgY29uZmlnLgpBbHNvLCB0aGUgdmlzaWJpbGl0eSBvZiBgYXR0cipgIG1ldGhvZHMgY2FuIGJlIGNvbnRyb2xsZWQgdXNpbmcKQWxsb3dNb2RpZmllcnNPbkF0dHJzIGNvbmZpZy4KCkluIFJ1YnkgMy4wLCBgYXR0cipgIG1ldGhvZHMgbm93IHJldHVybiBhbiBhcnJheSBvZiBkZWZpbmVkIG1ldGhvZCBuYW1lcwphcyBzeW1ib2xzLiBTbyB3ZSBjYW4gd3JpdGUgdGhlIG1vZGlmaWVyIGFuZCBgYXR0cipgIGluIGlubGluZSBzdHlsZS4KQWxsb3dNb2RpZmllcnNPbkF0dHJzIGNvbmZpZyBhbGxvd3MgYGF0dHIqYCBtZXRob2RzIHRvIGJlIHdyaXR0ZW4gaW4KaW5saW5lIHN0eWxlIHdpdGhvdXQgbW9kaWZ5aW5nIGFwcGxpY2F0aW9ucyB0aGF0IGhhdmUgYmVlbiBtYWludGFpbmVkCmZvciBhIGxvbmcgdGltZSBpbiBncm91cCBzdHlsZS4gRnVydGhlcm1vcmUsIGRldmVsb3BlcnMgd2hvIGFyZSBub3QgdmVyeQpmYW1pbGlhciB3aXRoIFJ1YnkgbWF5IGtub3cgdGhhdCB0aGUgbW9kaWZpZXIgYXBwbGllcyB0byBgZGVmYCwgYnV0IHRoZXkKbWF5IG5vdCBrbm93IHRoYXQgaXQgYWxzbyBhcHBsaWVzIHRvIGBhdHRyKmAgbWV0aG9kcy4gSXQgd291bGQgYmUgZWFzaWVyCnRvIHVuZGVyc3RhbmQgaWYgd2UgY291bGQgd3JpdGUgYGF0dHIqYCBtZXRob2RzIGluIGlubGluZSBzdHlsZS4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIG5vdCBzYWZlLCBiZWNhdXNlIHRoZSB2aXNpYmlsaXR5IG9mIGR5bmFtaWNhbGx5CmRlZmluZWQgbWV0aG9kcyBjYW4gdmFyeSBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIGRldGVybWluZWQgYnkKdGhlIGdyb3VwIGFjY2VzcyBtb2RpZmllci4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBncm91cCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBGb28KCiAgcHJpdmF0ZSBkZWYgYmFyOyBlbmQKICBwcml2YXRlIGRlZiBiYXo7IGVuZAoKZW5kCgojIGdvb2QKY2xhc3MgRm9vCgogIHByaXZhdGUKCiAgZGVmIGJhcjsgZW5kCiAgZGVmIGJhejsgZW5kCgplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBpbmxpbmUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBGb28KCiAgcHJpdmF0ZQoKICBkZWYgYmFyOyBlbmQKICBkZWYgYmF6OyBlbmQKCmVuZAoKIyBnb29kCmNsYXNzIEZvbwoKICBwcml2YXRlIGRlZiBiYXI7IGVuZAogIHByaXZhdGUgZGVmIGJhejsgZW5kCgplbmQKLS0tLQoKPT09PSBBbGxvd01vZGlmaWVyc09uU3ltYm9sczogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKY2xhc3MgRm9vCgogIHByaXZhdGUgOmJhciwgOmJhegoKZW5kCi0tLS0KCj09PT0gQWxsb3dNb2RpZmllcnNPblN5bWJvbHM6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgRm9vCgogIHByaXZhdGUgOmJhciwgOmJhegoKZW5kCi0tLS0KCj09PT0gQWxsb3dNb2RpZmllcnNPbkF0dHJzOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBGb28KCiAgcHVibGljIGF0dHJfcmVhZGVyIDpiYXIKICBwcm90ZWN0ZWQgYXR0cl93cml0ZXIgOmJhegogIHByaXZhdGUgYXR0cl9hY2Nlc3NvciA6cXV4CiAgcHJpdmF0ZSBhdHRyIDpxdXV4CgogIGRlZiBwdWJsaWNfbWV0aG9kOyBlbmQKCiAgcHJpdmF0ZQoKICBkZWYgcHJpdmF0ZV9tZXRob2Q7IGVuZAoKZW5kCi0tLS0KCj09PT0gQWxsb3dNb2RpZmllcnNPbkF0dHJzOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwoKICBwdWJsaWMgYXR0cl9yZWFkZXIgOmJhcgogIHByb3RlY3RlZCBhdHRyX3dyaXRlciA6YmF6CiAgcHJpdmF0ZSBhdHRyX2FjY2Vzc29yIDpxdXgKICBwcml2YXRlIGF0dHIgOnF1dXgKCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBncm91cGAKfCBgaW5saW5lYCwgYGdyb3VwYAoKfCBBbGxvd01vZGlmaWVyc09uU3ltYm9scwp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dNb2RpZmllcnNPbkF0dHJzCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PSBTdHlsZS9BY2Nlc3Nvckdyb3VwaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC44Nwp8IC0KfD09PQoKQ2hlY2tzIGZvciBncm91cGluZyBvZiBhY2Nlc3NvcnMgaW4gYGNsYXNzYCBhbmQgYG1vZHVsZWAgYm9kaWVzLgpCeSBkZWZhdWx0IGl0IGVuZm9yY2VzIGFjY2Vzc29ycyB0byBiZSBwbGFjZWQgaW4gZ3JvdXBlZCBkZWNsYXJhdGlvbnMsCmJ1dCBpdCBjYW4gYmUgY29uZmlndXJlZCB0byBlbmZvcmNlIHNlcGFyYXRpbmcgdGhlbSBpbiBtdWx0aXBsZSBkZWNsYXJhdGlvbnMuCgpOT1RFOiBJZiB0aGVyZSBpcyBhIG1ldGhvZCBjYWxsIGJlZm9yZSB0aGUgYWNjZXNzb3IgbWV0aG9kIGl0IGlzIGFsd2F5cyBhbGxvd2VkCmFzIGl0IG1pZ2h0IGJlIGludGVuZGVkIGxpa2UgU29yYmV0LgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGdyb3VwZWQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgRm9vCiAgYXR0cl9yZWFkZXIgOmJhcgogIGF0dHJfcmVhZGVyIDpiYXgKICBhdHRyX3JlYWRlciA6YmF6CmVuZAoKIyBnb29kCmNsYXNzIEZvbwogIGF0dHJfcmVhZGVyIDpiYXIsIDpiYXgsIDpiYXoKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgIyBtYXkgYmUgaW50ZW5kZWQgY29tbWVudCBmb3IgYmFyLgogIGF0dHJfcmVhZGVyIDpiYXIKCiAgc2lnIHsgcmV0dXJucyhTdHJpbmcpIH0KICBhdHRyX3JlYWRlciA6YmF4CgogIG1heV9iZV9pbnRlbmRlZF9hbm5vdGF0aW9uIDpiYXoKICBhdHRyX3JlYWRlciA6YmF6CmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNlcGFyYXRlZAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwogIGF0dHJfcmVhZGVyIDpiYXIsIDpiYXoKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgYXR0cl9yZWFkZXIgOmJhcgogIGF0dHJfcmVhZGVyIDpiYXoKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGdyb3VwZWRgCnwgYHNlcGFyYXRlZGAsIGBncm91cGVkYAp8PT09Cgo9PSBTdHlsZS9BbGlhcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuMzYKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBlaXRoZXIgYCNhbGlhc2Agb3IgYCNhbGlhc19tZXRob2RgCmRlcGVuZGluZyBvbiBjb25maWd1cmF0aW9uLgpJdCBhbHNvIGZsYWdzIHVzZXMgb2YgYGFsaWFzIDpzeW1ib2xgIHJhdGhlciB0aGFuIGBhbGlhcyBiYXJld29yZGAuCgpIb3dldmVyLCBpdCB3aWxsIGFsd2F5cyBlbmZvcmNlIGBtZXRob2RfYWxpYXNgIHdoZW4gdXNlZCBgYWxpYXNgCmluIGFuIGluc3RhbmNlIG1ldGhvZCBkZWZpbml0aW9uIGFuZCBpbiBhIHNpbmdsZXRvbiBtZXRob2QgZGVmaW5pdGlvbi4KSWYgdXNlZCBpbiBhIGJsb2NrLCBhbHdheXMgZW5mb3JjZSBgYWxpYXNfbWV0aG9kYAp1bmxlc3MgaXQgaXMgYW4gYGluc3RhbmNlX2V2YWxgIGJsb2NrLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHByZWZlcl9hbGlhcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphbGlhc19tZXRob2QgOmJhciwgOmZvbwphbGlhcyA6YmFyIDpmb28KCiMgZ29vZAphbGlhcyBiYXIgZm9vCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcHJlZmVyX2FsaWFzX21ldGhvZAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFsaWFzIDpiYXIgOmZvbwphbGlhcyBiYXIgZm9vCgojIGdvb2QKYWxpYXNfbWV0aG9kIDpiYXIsIDpmb28KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgcHJlZmVyX2FsaWFzYAp8IGBwcmVmZXJfYWxpYXNgLCBgcHJlZmVyX2FsaWFzX21ldGhvZGAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYWxpYXMtbWV0aG9kLWxleGljYWxseQoKPT0gU3R5bGUvQW5kT3IKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjkKfCAxLjIxCnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiBgYW5kYCBhbmQgYG9yYCwgYW5kIHN1Z2dlc3RzIHVzaW5nIGAmJmAgYW5kCmB8fGAgaW5zdGVhZC4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gY2hlY2sgb25seSBpbiBjb25kaXRpb25zIG9yIGluCmFsbCBjb250ZXh0cy4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIHRoZXJlIGlzIGEgZGlmZmVyZW50IG9wZXJhdG9yIHByZWNlZGVuY2UKYmV0d2VlbiBsb2dpY2FsIG9wZXJhdG9ycyAoYCYmYCBhbmQgYHx8YCkgYW5kIHNlbWFudGljIG9wZXJhdG9ycyAoYGFuZGAgYW5kIGBvcmApLAphbmQgdGhhdCBtaWdodCBjaGFuZ2UgdGhlIGJlaGF2aW9yLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGNvbmRpdGlvbmFscyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiBmb28gYW5kIGJhcgplbmQKCiMgZ29vZApmb28uc2F2ZSAmJiByZXR1cm4KCiMgZ29vZApmb28uc2F2ZSBhbmQgcmV0dXJuCgojIGdvb2QKaWYgZm9vICYmIGJhcgplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBhbHdheXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28uc2F2ZSBhbmQgcmV0dXJuCgojIGJhZAppZiBmb28gYW5kIGJhcgplbmQKCiMgZ29vZApmb28uc2F2ZSAmJiByZXR1cm4KCiMgZ29vZAppZiBmb28gJiYgYmFyCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBjb25kaXRpb25hbHNgCnwgYGFsd2F5c2AsIGBjb25kaXRpb25hbHNgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLWFuZC1vci1vcgoKPT0gU3R5bGUvQXJndW1lbnRzRm9yd2FyZGluZwoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjcKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjEKfCAxLjU4Cnw9PT0KCkluIFJ1YnkgMi43LCBhcmd1bWVudHMgZm9yd2FyZGluZyBoYXMgYmVlbiBhZGRlZC4KClRoaXMgY29wIGlkZW50aWZpZXMgcGxhY2VzIHdoZXJlIGBkb19zb21ldGhpbmcoKmFyZ3MsICZibG9jaylgCmNhbiBiZSByZXBsYWNlZCBieSBgZG9fc29tZXRoaW5nKC4uLilgLgoKSW4gUnVieSAzLjEsIGFub255bW91cyBibG9jayBmb3J3YXJkaW5nIGhhcyBiZWVuIGFkZGVkLgoKVGhpcyBjb3AgaWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYGRvX3NvbWV0aGluZygmYmxvY2spYCBjYW4gYmUgcmVwbGFjZWQKYnkgYGRvX3NvbWV0aGluZygmKWA7IGlmIGRlc2lyZWQsIHRoaXMgZnVuY3Rpb25hbGl0eSBjYW4gYmUgZGlzYWJsZWQKYnkgc2V0dGluZyBgVXNlQW5vbnltb3VzRm9yd2FyZGluZzogZmFsc2VgLgoKSW4gUnVieSAzLjIsIGFub255bW91cyBhcmdzL2t3YXJncyBmb3J3YXJkaW5nIGhhcyBiZWVuIGFkZGVkLgoKVGhpcyBjb3AgYWxzbyBpZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBgdXNlX2FyZ3MoKmFyZ3MpYC9gdXNlX2t3YXJncygqKmt3YXJncylgIGNhbiBiZQpyZXBsYWNlZCBieSBgdXNlX2FyZ3MoKilgL2B1c2Vfa3dhcmdzKCoqKWA7IGlmIGRlc2lyZWQsIHRoaXMgZnVuY3Rpb25hbGl0eSBjYW4gYmUgZGlzYWJsZWQKYnkgc2V0dGluZyBgVXNlQW5vbnltb3VzRm9yd2FyZGluZzogZmFsc2VgLgoKQW5kIHRoaXMgY29wIGhhcyBgUmVkdW5kYW50UmVzdEFyZ3VtZW50TmFtZXNgLCBgUmVkdW5kYW50S2V5d29yZFJlc3RBcmd1bWVudE5hbWVzYCwKYW5kIGBSZWR1bmRhbnRCbG9ja0FyZ3VtZW50TmFtZXNgIG9wdGlvbnMuIFRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGxpc3Qgb2YgcmVkdW5kYW50IG5hbWVzCnRoYXQgYXJlIHN1ZmZpY2llbnQgZm9yIGFub255bWl6aW5nIG1lYW5pbmdsZXNzIG5hbWluZy4KCk1lYW5pbmdsZXNzIG5hbWVzIHRoYXQgYXJlIGNvbW1vbmx5IHVzZWQgY2FuIGJlIGFub255bWl6ZWQgYnkgZGVmYXVsdDoKZS5nLiwgYCphcmdzYCwgYCoqb3B0aW9uc2AsIGAmYmxvY2tgLCBhbmQgc28gb24uCgpOYW1lcyBub3Qgb24gdGhpcyBsaXN0IGFyZSBsaWtlbHkgdG8gYmUgbWVhbmluZ2Z1bCBhbmQgYXJlIGFsbG93ZWQgYnkgZGVmYXVsdC4KClRoaXMgY29wIGhhbmRsZXMgbm90IG9ubHkgbWV0aG9kIGZvcndhcmRpbmcgYnV0IGFsc28gZm9yd2FyZGluZyB0byBgc3VwZXJgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvbygqYXJncywgJmJsb2NrKQogIGJhcigqYXJncywgJmJsb2NrKQplbmQKCiMgYmFkCmRlZiBmb28oKmFyZ3MsICoqa3dhcmdzLCAmYmxvY2spCiAgYmFyKCphcmdzLCAqKmt3YXJncywgJmJsb2NrKQplbmQKCiMgZ29vZApkZWYgZm9vKC4uLikKICBiYXIoLi4uKQplbmQKLS0tLQoKPT09PSBVc2VBbm9ueW1vdXNGb3J3YXJkaW5nOiB0cnVlIChkZWZhdWx0LCBvbmx5IHJlbGV2YW50IGZvciBSdWJ5ID49IDMuMikKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vKCphcmdzLCAqKmt3YXJncywgJmJsb2NrKQogIGFyZ3Nfb25seSgqYXJncykKICBrd2FyZ3Nfb25seSgqKmt3YXJncykKICBibG9ja19vbmx5KCZibG9jaykKZW5kCgojIGdvb2QKZGVmIGZvbygqLCAqKiwgJikKICBhcmdzX29ubHkoKikKICBrd2FyZ3Nfb25seSgqKikKICBibG9ja19vbmx5KCYpCmVuZAotLS0tCgo9PT09IFVzZUFub255bW91c0ZvcndhcmRpbmc6IGZhbHNlIChvbmx5IHJlbGV2YW50IGZvciBSdWJ5ID49IDMuMikKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmIGZvbygqYXJncywgKiprd2FyZ3MsICZibG9jaykKICBhcmdzX29ubHkoKmFyZ3MpCiAga3dhcmdzX29ubHkoKiprd2FyZ3MpCiAgYmxvY2tfb25seSgmYmxvY2spCmVuZAotLS0tCgo9PT09IEFsbG93T25seVJlc3RBcmd1bWVudDogdHJ1ZSAoZGVmYXVsdCwgb25seSByZWxldmFudCBmb3IgUnVieSA8IDMuMikKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmIGZvbygqYXJncykKICBiYXIoKmFyZ3MpCmVuZAoKZGVmIGZvbygqKmt3YXJncykKICBiYXIoKiprd2FyZ3MpCmVuZAotLS0tCgo9PT09IEFsbG93T25seVJlc3RBcmd1bWVudDogZmFsc2UgKG9ubHkgcmVsZXZhbnQgZm9yIFJ1YnkgPCAzLjIpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIyBUaGUgZm9sbG93aW5nIGNvZGUgY2FuIHJlcGxhY2UgdGhlIGFyZ3VtZW50cyB3aXRoIGAuLi5gLAojIGJ1dCBpdCB3aWxsIGNoYW5nZSB0aGUgYmVoYXZpb3IuIEJlY2F1c2UgYC4uLmAgZm9yd2FyZHMgYmxvY2sgYWxzby4KZGVmIGZvbygqYXJncykKICBiYXIoKmFyZ3MpCmVuZAoKZGVmIGZvbygqKmt3YXJncykKICBiYXIoKiprd2FyZ3MpCmVuZAotLS0tCgo9PT09IFJlZHVuZGFudFJlc3RBcmd1bWVudE5hbWVzOiBbJ2FyZ3MnLCAnYXJndW1lbnRzJ10gKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvbygqYXJncykKICBiYXIoKmFyZ3MpCmVuZAoKIyBnb29kCmRlZiBmb28oKikKICBiYXIoKikKZW5kCi0tLS0KCj09PT0gUmVkdW5kYW50S2V5d29yZFJlc3RBcmd1bWVudE5hbWVzOiBbJ2t3YXJncycsICdvcHRpb25zJywgJ29wdHMnXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vKCoqa3dhcmdzKQogIGJhcigqKmt3YXJncykKZW5kCgojIGdvb2QKZGVmIGZvbygqKikKICBiYXIoKiopCmVuZAotLS0tCgo9PT09IFJlZHVuZGFudEJsb2NrQXJndW1lbnROYW1lczogWydibGsnLCAnYmxvY2snLCAncHJvYyddIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gQnV0IGl0IGlzIGdvb2Qgd2l0aCBgRW5mb3JjZWRTdHlsZTogZXhwbGljaXRgIHNldCBmb3IgYE5hbWluZy9CbG9ja0ZvcndhcmRpbmdgLgpkZWYgZm9vKCZibG9jaykKICBiYXIoJmJsb2NrKQplbmQKCiMgZ29vZApkZWYgZm9vKCYpCiAgYmFyKCYpCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dPbmx5UmVzdEFyZ3VtZW50CnwgYHRydWVgCnwgQm9vbGVhbgoKfCBVc2VBbm9ueW1vdXNGb3J3YXJkaW5nCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBSZWR1bmRhbnRSZXN0QXJndW1lbnROYW1lcwp8IGBhcmdzYCwgYGFyZ3VtZW50c2AKfCBBcnJheQoKfCBSZWR1bmRhbnRLZXl3b3JkUmVzdEFyZ3VtZW50TmFtZXMKfCBga3dhcmdzYCwgYG9wdGlvbnNgLCBgb3B0c2AKfCBBcnJheQoKfCBSZWR1bmRhbnRCbG9ja0FyZ3VtZW50TmFtZXMKfCBgYmxrYCwgYGJsb2NrYCwgYHByb2NgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYXJndW1lbnRzLWZvcndhcmRpbmcKCj09IFN0eWxlL0FycmF5Q29lcmNpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjg4CnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGBBcnJheSgpYCBpbnN0ZWFkIG9mIGV4cGxpY2l0IGBBcnJheWAgY2hlY2sgb3IgYFsqdmFyXWAuCgpUaGUgY29wIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgZHVlIHRvIHNhZmV0eSBjb25jZXJucy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGEgZmFsc2UgcG9zaXRpdmUgbWF5IG9jY3VyIGlmCnRoZSBhcmd1bWVudCBvZiBgQXJyYXkoKWAgaXMgKG9yIGNvdWxkIGJlKSBuaWwgb3IgZGVwZW5kaW5nCm9uIGhvdyB0aGUgYXJndW1lbnQgaXMgaGFuZGxlZCBieSBgQXJyYXkoKWAgKHdoaWNoIGNhbiBiZQpkaWZmZXJlbnQgdGhhbiBqdXN0IHdyYXBwaW5nIHRoZSBhcmd1bWVudCBpbiBhbiBhcnJheSkuCgpGb3IgZXhhbXBsZToKCltzb3VyY2UscnVieV0KLS0tLQpbbmlsXSAgICAgICAgICAgICAjPT4gW25pbF0KQXJyYXkobmlsKSAgICAgICAgIz0+IFtdCgpbe2E6ICdiJ31dICAgICAgICAjPSBbe2E6ICdiJ31dCkFycmF5KHthOiAnYid9KSAgICM9PiBbWzphLCAnYiddXQoKW1RpbWUubm93XSAgICAgICAgIz0+IFsjPFRpbWUgLi4uPl0KQXJyYXkoVGltZS5ub3cpICAgIz0+IFsxNCwgMTYsIDE0LCAxNiwgOSwgMjAyMSwgNCwgMjU5LCB0cnVlLCAiRURUIl0KLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcGF0aHMgPSBbcGF0aHNdIHVubGVzcyBwYXRocy5pc19hPyhBcnJheSkKcGF0aHMuZWFjaCB7IHxwYXRofCBkb19zb21ldGhpbmcocGF0aCkgfQoKIyBiYWQgKGFsd2F5cyBjcmVhdGVzIGEgbmV3IEFycmF5IGluc3RhbmNlKQpbKnBhdGhzXS5lYWNoIHsgfHBhdGh8IGRvX3NvbWV0aGluZyhwYXRoKSB9CgojIGdvb2QgKGFuZCBhIGJpdCBtb3JlIHJlYWRhYmxlKQpBcnJheShwYXRocykuZWFjaCB7IHxwYXRofCBkb19zb21ldGhpbmcocGF0aCkgfQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNhcnJheS1jb2VyY2lvbgoKPT0gU3R5bGUvQXJyYXlGaXJzdExhc3QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAxLjU4CnwgLQp8PT09CgpJZGVudGlmaWVzIHVzYWdlcyBvZiBgYXJyWzBdYCBhbmQgYGFyclstMV1gIGFuZCBzdWdnZXN0cyB0byBjaGFuZ2UKdGhlbSB0byB1c2UgYGFyci5maXJzdGAgYW5kIGBhcnIubGFzdGAgaW5zdGVhZC4KClRoZSBjb3AgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCBkdWUgdG8gc2FmZXR5IGNvbmNlcm5zLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgYFswXWAgb3IgYFstMV1gIGNhbiBiZSBjYWxsZWQgb24gYSBIYXNoLAp3aGljaCByZXR1cm5zIGEgdmFsdWUgZm9yIGAwYCBvciBgLTFgIGtleSwgYnV0IGNoYW5naW5nIHRoZXNlIHRvIHVzZQpgLmZpcnN0YCBvciBgLmxhc3RgIHdpbGwgcmV0dXJuIGZpcnN0L2xhc3QgdHVwbGUgaW5zdGVhZC4gQWxzbywgU3RyaW5nCmRvZXMgbm90IGltcGxlbWVudCBgZmlyc3RgL2BsYXN0YCBtZXRob2RzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXJyWzBdCmFyclstMV0KCiMgZ29vZAphcnIuZmlyc3QKYXJyLmxhc3QKYXJyWzBdID0gMgphcnJbMF1bLTJdCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqICNmaXJzdC1hbmQtbGFzdAoKPT0gU3R5bGUvQXJyYXlJbnRlcnNlY3QKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMy4xCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAxLjQwCnwgLQp8PT09CgpJbiBSdWJ5IDMuMSwgYEFycmF5I2ludGVyc2VjdD9gIGhhcyBiZWVuIGFkZGVkLgoKVGhpcyBjb3AgaWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYChhcnJheTEgJiBhcnJheTIpLmFueT9gCmNhbiBiZSByZXBsYWNlZCBieSBgYXJyYXkxLmludGVyc2VjdD8oYXJyYXkyKWAuCgpUaGUgYGFycmF5MS5pbnRlcnNlY3Q/KGFycmF5MilgIG1ldGhvZCBpcyBmYXN0ZXIgdGhhbgpgKGFycmF5MSAmIGFycmF5MikuYW55P2AgYW5kIGlzIG1vcmUgcmVhZGFibGUuCgpJbiBjYXNlcyBsaWtlIHRoZSBmb2xsb3dpbmcsIGNvbXBhdGliaWxpdHkgaXMgbm90IGVuc3VyZWQsCnNvIGl0IHdpbGwgbm90IGJlIGRldGVjdGVkIHdoZW4gdXNpbmcgYmxvY2sgYXJndW1lbnQuCgpbc291cmNlLHJ1YnldCi0tLS0KKFsxXSAmIFsxLDJdKS5hbnk/IHsgfHh8IGZhbHNlIH0gICAgIyA9PiBmYWxzZQpbMV0uaW50ZXJzZWN0PyhbMSwyXSkgeyB8eHwgZmFsc2UgfSAjID0+IHRydWUKLS0tLQoKPT09IFNhZmV0eQoKVGhpcyBjb3AgY2Fubm90IGd1YXJhbnRlZSB0aGF0IGBhcnJheTFgIGFuZCBgYXJyYXkyYCBhcmUKYWN0dWFsbHkgYXJyYXlzIHdoaWxlIG1ldGhvZCBgaW50ZXJzZWN0P2AgaXMgZm9yIGFycmF5cyBvbmx5LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKKGFycmF5MSAmIGFycmF5MikuYW55PwooYXJyYXkxICYgYXJyYXkyKS5lbXB0eT8KCiMgZ29vZAphcnJheTEuaW50ZXJzZWN0PyhhcnJheTIpCiFhcnJheTEuaW50ZXJzZWN0PyhhcnJheTIpCi0tLS0KCj09PT0gQWxsQ29wczpBY3RpdmVTdXBwb3J0RXh0ZW5zaW9uc0VuYWJsZWQ6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAooYXJyYXkxICYgYXJyYXkyKS5wcmVzZW50PwooYXJyYXkxICYgYXJyYXkyKS5ibGFuaz8KLS0tLQoKPT09PSBBbGxDb3BzOkFjdGl2ZVN1cHBvcnRFeHRlbnNpb25zRW5hYmxlZDogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCihhcnJheTEgJiBhcnJheTIpLnByZXNlbnQ/CihhcnJheTEgJiBhcnJheTIpLmJsYW5rPwoKIyBnb29kCmFycmF5MS5pbnRlcnNlY3Q/KGFycmF5MikKIWFycmF5MS5pbnRlcnNlY3Q/KGFycmF5MikKLS0tLQoKPT0gU3R5bGUvQXJyYXlKb2luCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yMAp8IDAuMzEKfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mICIqIiBhcyBhIHN1YnN0aXR1dGUgZm9yIF9qb2luXy4KCk5vdCBhbGwgY2FzZXMgY2FuIHJlbGlhYmx5IGNoZWNrZWQsIGR1ZSB0byBSdWJ5J3MgZHluYW1pYwp0eXBlcywgc28gd2UgY29uc2lkZXIgb25seSBjYXNlcyB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbgphcnJheSBsaXRlcmFsIG9yIHRoZSBzZWNvbmQgaXMgYSBzdHJpbmcgbGl0ZXJhbC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiV3KGZvbyBiYXIgYmF6KSAqICIsIgoKIyBnb29kCiV3KGZvbyBiYXIgYmF6KS5qb2luKCIsIikKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYXJyYXktam9pbgoKPT0gU3R5bGUvQXNjaWlDb21tZW50cwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuOQp8IDEuMjEKfD09PQoKQ2hlY2tzIGZvciBub24tYXNjaWkgKG5vbi1FbmdsaXNoKSBjaGFyYWN0ZXJzCmluIGNvbW1lbnRzLiBZb3UgY291bGQgc2V0IGFuIGFycmF5IG9mIGFsbG93ZWQgbm9uLWFzY2lpIGNoYXJzIGluCmBBbGxvd2VkQ2hhcnNgIGF0dHJpYnV0ZSAoY29weXJpZ2h0IG5vdGljZSAiwqkiIGJ5IGRlZmF1bHQpLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIyBUcmFuc2xhdGVzIGZyb20gRW5nbGlzaCB0byDml6XmnKzoqp7jgIIKCiMgZ29vZAojIFRyYW5zbGF0ZXMgZnJvbSBFbmdsaXNoIHRvIEphcGFuZXNlCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd2VkQ2hhcnMKfCBgwqlgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZW5nbGlzaC1jb21tZW50cwoKPT0gU3R5bGUvQXR0cgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuMTIKfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIE1vZHVsZSNhdHRyLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSBjcmVhdGVzIGEgc2luZ2xlIGF0dHJpYnV0ZSBhY2Nlc3NvciAoZGVwcmVjYXRlZCBpbiBSdWJ5IDEuOSkKYXR0ciA6c29tZXRoaW5nLCB0cnVlCmF0dHIgOm9uZSwgOnR3bywgOnRocmVlICMgYmVoYXZlcyBhcyBhdHRyX3JlYWRlcgoKIyBnb29kCmF0dHJfYWNjZXNzb3IgOnNvbWV0aGluZwphdHRyX3JlYWRlciA6b25lLCA6dHdvLCA6dGhyZWUKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYXR0cgoKPT0gU3R5bGUvQXV0b1Jlc291cmNlQ2xlYW51cAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuMzAKfCAtCnw9PT0KCkNoZWNrcyBmb3IgY2FzZXMgd2hlbiB5b3UgY291bGQgdXNlIGEgYmxvY2sKYWNjZXB0aW5nIHZlcnNpb24gb2YgYSBtZXRob2QgdGhhdCBkb2VzIGF1dG9tYXRpYwpyZXNvdXJjZSBjbGVhbnVwLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZiA9IEZpbGUub3BlbignZmlsZScpCgojIGdvb2QKRmlsZS5vcGVuKCdmaWxlJykgZG8gfGZ8CiAgIyAuLi4KZW5kCgojIGJhZApmID0gVGVtcGZpbGUub3BlbigndGVtcCcpCgojIGdvb2QKVGVtcGZpbGUub3BlbigndGVtcCcpIGRvIHxmfAogICMgLi4uCmVuZAotLS0tCgo9PSBTdHlsZS9CYXJlUGVyY2VudExpdGVyYWxzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yNQp8IC0KfD09PQoKQ2hlY2tzIGlmIHVzYWdlIG9mICUoKSBvciAlUSgpIG1hdGNoZXMgY29uZmlndXJhdGlvbi4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBiYXJlX3BlcmNlbnQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKJVEoSGUgc2FpZDogIiN7Z3JlZXRpbmd9IikKJXF7U2hlIHNhaWQ6ICdIaSd9CgojIGdvb2QKJShIZSBzYWlkOiAiI3tncmVldGluZ30iKQole1NoZSBzYWlkOiAnSGknfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHBlcmNlbnRfcQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiV8SGUgc2FpZDogIiN7Z3JlZXRpbmd9InwKJS9TaGUgc2FpZDogJ0hpJy8KCiMgZ29vZAolUXxIZSBzYWlkOiAiI3tncmVldGluZ30ifAolcS9TaGUgc2FpZDogJ0hpJy8KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYmFyZV9wZXJjZW50YAp8IGBwZXJjZW50X3FgLCBgYmFyZV9wZXJjZW50YAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNwZXJjZW50LXEtc2hvcnRoYW5kCgo9PSBTdHlsZS9CZWdpbkJsb2NrCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgQkVHSU4gYmxvY2tzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKQkVHSU4geyB0ZXN0IH0KLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tQkVHSU4tYmxvY2tzCgo9PSBTdHlsZS9CaXNlY3RlZEF0dHJBY2Nlc3NvcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuODcKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIGBhdHRyX3JlYWRlcmAgYW5kIGBhdHRyX3dyaXRlcmAKZm9yIHRoZSBzYW1lIG1ldGhvZCBjYW4gYmUgY29tYmluZWQgaW50byBzaW5nbGUgYGF0dHJfYWNjZXNzb3JgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgRm9vCiAgYXR0cl9yZWFkZXIgOmJhcgogIGF0dHJfd3JpdGVyIDpiYXIKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgYXR0cl9hY2Nlc3NvciA6YmFyCmVuZAotLS0tCgo9PSBTdHlsZS9CbG9ja0NvbW1lbnRzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC4yMwp8PT09CgpMb29rcyBmb3IgdXNlcyBvZiBibG9jayBjb21tZW50cyAoPWJlZ2luLi4uPWVuZCkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo9YmVnaW4KTXVsdGlwbGUgbGluZXMKb2YgY29tbWVudHMuLi4KPWVuZAoKIyBnb29kCiMgTXVsdGlwbGUgbGluZXMKIyBvZiBjb21tZW50cy4uLgotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1ibG9jay1jb21tZW50cwoKPT0gU3R5bGUvQmxvY2tEZWxpbWl0ZXJzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zMAp8IDAuMzUKfD09PQoKQ2hlY2sgZm9yIHVzZXMgb2YgYnJhY2VzIG9yIGRvL2VuZCBhcm91bmQgc2luZ2xlIGxpbmUgb3IKbXVsdGktbGluZSBibG9ja3MuCgpNZXRob2RzIHRoYXQgY2FuIGJlIGVpdGhlciBwcm9jZWR1cmFsIG9yIGZ1bmN0aW9uYWwgYW5kIGNhbm5vdCBiZQpjYXRlZ29yaXNlZCBmcm9tIHRoZWlyIHVzYWdlIGFsb25lIGlzIGlnbm9yZWQuCmBsYW1iZGFgLCBgcHJvY2AsIGFuZCBgaXRgIGFyZSB0aGVpciBkZWZhdWx0cy4KQWRkaXRpb25hbCBtZXRob2RzIGNhbiBiZSBhZGRlZCB0byB0aGUgYEFsbG93ZWRNZXRob2RzYC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBsaW5lX2NvdW50X2Jhc2VkIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gc2luZ2xlIGxpbmUgYmxvY2sKaXRlbXMuZWFjaCBkbyB8aXRlbXwgaXRlbSAvIDUgZW5kCgojIGdvb2QgLSBzaW5nbGUgbGluZSBibG9jawppdGVtcy5lYWNoIHsgfGl0ZW18IGl0ZW0gLyA1IH0KCiMgYmFkIC0gbXVsdGktbGluZSBibG9jawp0aGluZ3MubWFwIHsgfHRoaW5nfAogIHNvbWV0aGluZyA9IHRoaW5nLnNvbWVfbWV0aG9kCiAgcHJvY2Vzcyhzb21ldGhpbmcpCn0KCiMgZ29vZCAtIG11bHRpLWxpbmUgYmxvY2sKdGhpbmdzLm1hcCBkbyB8dGhpbmd8CiAgc29tZXRoaW5nID0gdGhpbmcuc29tZV9tZXRob2QKICBwcm9jZXNzKHNvbWV0aGluZykKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogc2VtYW50aWMKCltzb3VyY2UscnVieV0KLS0tLQojIFByZWZlciBgZG8uLi5lbmRgIG92ZXIgYHsuLi59YCBmb3IgcHJvY2VkdXJhbCBibG9ja3MuCgojIHJldHVybiB2YWx1ZSBpcyB1c2VkL2Fzc2lnbmVkCiMgYmFkCmZvbyA9IG1hcCBkbyB8eHwKICB4CmVuZApwdXRzIChtYXAgZG8gfHh8CiAgeAplbmQpCgojIHJldHVybiB2YWx1ZSBpcyBub3QgdXNlZCBvdXQgb2Ygc2NvcGUKIyBnb29kCm1hcCBkbyB8eHwKICB4CmVuZAoKIyBQcmVmZXIgYHsuLi59YCBvdmVyIGBkby4uLmVuZGAgZm9yIGZ1bmN0aW9uYWwgYmxvY2tzLgoKIyByZXR1cm4gdmFsdWUgaXMgbm90IHVzZWQgb3V0IG9mIHNjb3BlCiMgYmFkCmVhY2ggeyB8eHwKICB4Cn0KCiMgcmV0dXJuIHZhbHVlIGlzIHVzZWQvYXNzaWduZWQKIyBnb29kCmZvbyA9IG1hcCB7IHx4fAogIHgKfQptYXAgeyB8eHwKICB4Cn0uaW5zcGVjdAoKIyBUaGUgQWxsb3dCcmFjZXNPblByb2NlZHVyYWxPbmVMaW5lcnMgb3B0aW9uIGlzIGFsbG93ZWQgdW5sZXNzIHRoZQojIEVuZm9yY2VkU3R5bGUgaXMgc2V0IHRvIGBzZW1hbnRpY2AuIElmIHNvOgoKIyBJZiB0aGUgQWxsb3dCcmFjZXNPblByb2NlZHVyYWxPbmVMaW5lcnMgb3B0aW9uIGlzIHVuc3BlY2lmaWVkLCBvcgojIHNldCB0byBgZmFsc2VgIG9yIGFueSBvdGhlciBmYWxzZXkgdmFsdWUsIHRoZW4gc2VtYW50aWMgcHVyaXR5IGlzCiMgbWFpbnRhaW5lZCwgc28gb25lLWxpbmUgcHJvY2VkdXJhbCBibG9ja3MgbXVzdCB1c2UgZG8tZW5kLCBub3QKIyBicmFjZXMuCgojIGJhZApjb2xsZWN0aW9uLmVhY2ggeyB8ZWxlbWVudHwgcHV0cyBlbGVtZW50IH0KCiMgZ29vZApjb2xsZWN0aW9uLmVhY2ggZG8gfGVsZW1lbnR8IHB1dHMgZWxlbWVudCBlbmQKCiMgSWYgdGhlIEFsbG93QnJhY2VzT25Qcm9jZWR1cmFsT25lTGluZXJzIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLCBvcgojIGFueSBvdGhlciB0cnV0aHkgdmFsdWUsIHRoZW4gb25lLWxpbmUgcHJvY2VkdXJhbCBibG9ja3MgbWF5IHVzZQojIGVpdGhlciBzdHlsZS4gKFRoZXJlIGlzIG5vIHNldHRpbmcgZm9yIHJlcXVpcmluZyBicmFjZXMgb24gdGhlbS4pCgojIGdvb2QKY29sbGVjdGlvbi5lYWNoIHsgfGVsZW1lbnR8IHB1dHMgZWxlbWVudCB9CgojIGFsc28gZ29vZApjb2xsZWN0aW9uLmVhY2ggZG8gfGVsZW1lbnR8IHB1dHMgZWxlbWVudCBlbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBicmFjZXNfZm9yX2NoYWluaW5nCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKd29yZHMuZWFjaCBkbyB8d29yZHwKICB3b3JkLmZsaXAuZmxvcAplbmQuam9pbigiLSIpCgojIGdvb2QKd29yZHMuZWFjaCB7IHx3b3JkfAogIHdvcmQuZmxpcC5mbG9wCn0uam9pbigiLSIpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYWx3YXlzX2JyYWNlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCndvcmRzLmVhY2ggZG8gfHdvcmR8CiAgd29yZC5mbGlwLmZsb3AKZW5kCgojIGdvb2QKd29yZHMuZWFjaCB7IHx3b3JkfAogIHdvcmQuZmxpcC5mbG9wCn0KLS0tLQoKPT09PSBCcmFjZXNSZXF1aXJlZE1ldGhvZHM6IFsnc2lnJ10KCltzb3VyY2UscnVieV0KLS0tLQojIE1ldGhvZHMgbGlzdGVkIGluIHRoZSBCcmFjZXNSZXF1aXJlZE1ldGhvZHMgbGlzdCwgc3VjaCBhcyAnc2lnJwojIGluIHRoaXMgZXhhbXBsZSwgd2lsbCByZXF1aXJlIGB7Li4ufWAgYnJhY2VzLiBUaGlzIG9wdGlvbiB0YWtlcwojIHByZWNlZGVuY2Ugb3ZlciBhbGwgb3RoZXIgY29uZmlndXJhdGlvbnMgZXhjZXB0IEFsbG93ZWRNZXRob2RzLgoKIyBiYWQKc2lnIGRvCiAgcGFyYW1zKAogICAgZm9vOiBzdHJpbmcsCiAgKS52b2lkCmVuZApkZWYgYmFyKGZvbykKICBwdXRzIGZvbwplbmQKCiMgZ29vZApzaWcgewogIHBhcmFtcygKICAgIGZvbzogc3RyaW5nLAogICkudm9pZAp9CmRlZiBiYXIoZm9vKQogIHB1dHMgZm9vCmVuZAotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbJ2xhbWJkYScsICdwcm9jJywgJ2l0JyBdIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApmb28gPSBsYW1iZGEgZG8gfHh8CiAgcHV0cyAiSGVsbG8sICN7eH0iCmVuZAoKZm9vID0gbGFtYmRhIGRvIHx4fAogIHggKiAxMDAKZW5kCi0tLS0KCj09PT0gQWxsb3dlZFBhdHRlcm5zOiBbXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp0aGluZ3MubWFwIHsgfHRoaW5nfAogIHNvbWV0aGluZyA9IHRoaW5nLnNvbWVfbWV0aG9kCiAgcHJvY2Vzcyhzb21ldGhpbmcpCn0KLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnM6IFsnbWFwJ10KCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKdGhpbmdzLm1hcCB7IHx0aGluZ3wKICBzb21ldGhpbmcgPSB0aGluZy5zb21lX21ldGhvZAogIHByb2Nlc3Moc29tZXRoaW5nKQp9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGxpbmVfY291bnRfYmFzZWRgCnwgYGxpbmVfY291bnRfYmFzZWRgLCBgc2VtYW50aWNgLCBgYnJhY2VzX2Zvcl9jaGFpbmluZ2AsIGBhbHdheXNfYnJhY2VzYAoKfCBQcm9jZWR1cmFsTWV0aG9kcwp8IGBiZW5jaG1hcmtgLCBgYm1gLCBgYm1ibWAsIGBjcmVhdGVgLCBgZWFjaF93aXRoX29iamVjdGAsIGBtZWFzdXJlYCwgYG5ld2AsIGByZWFsdGltZWAsIGB0YXBgLCBgd2l0aF9vYmplY3RgCnwgQXJyYXkKCnwgRnVuY3Rpb25hbE1ldGhvZHMKfCBgbGV0YCwgYGxldCFgLCBgc3ViamVjdGAsIGB3YXRjaGAKfCBBcnJheQoKfCBBbGxvd2VkTWV0aG9kcwp8IGBsYW1iZGFgLCBgcHJvY2AsIGBpdGAKfCBBcnJheQoKfCBBbGxvd2VkUGF0dGVybnMKfCBgW11gCnwgQXJyYXkKCnwgQWxsb3dCcmFjZXNPblByb2NlZHVyYWxPbmVMaW5lcnMKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBCcmFjZXNSZXF1aXJlZE1ldGhvZHMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc2luZ2xlLWxpbmUtYmxvY2tzCgo9PSBTdHlsZS9DYXNlRXF1YWxpdHkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjg5Cnw9PT0KCklmIGBBbGxvd09uU2VsZkNsYXNzYCBvcHRpb24gaXMgZW5hYmxlZCwgdGhlIGNvcCB3aWxsIGlnbm9yZSB2aW9sYXRpb25zIHdoZW4gdGhlIHJlY2VpdmVyIG9mCnRoZSBjYXNlIGVxdWFsaXR5IG9wZXJhdG9yIGlzIGBzZWxmLmNsYXNzYC4gTm90ZSBpbnRlcm1lZGlhdGUgdmFyaWFibGVzIGFyZSBub3QgYWNjZXB0ZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAooMS4uMTAwKSA9PT0gNwovc29tZXRoaW5nLyA9PT0gc29tZV9zdHJpbmcKCiMgZ29vZApzb21ldGhpbmcuaXNfYT8oQXJyYXkpCigxLi4xMDApLmluY2x1ZGU/KDcpCi9zb21ldGhpbmcvLm1hdGNoPyhzb21lX3N0cmluZykKLS0tLQoKPT09PSBBbGxvd09uQ29uc3RhbnQ6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkFycmF5ID09PSBzb21ldGhpbmcKLS0tLQoKPT09PSBBbGxvd09uQ29uc3RhbnQ6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKQXJyYXkgPT09IHNvbWV0aGluZwotLS0tCgo9PT09IEFsbG93T25TZWxmQ2xhc3M6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnNlbGYuY2xhc3MgPT09IHNvbWV0aGluZwotLS0tCgo9PT09IEFsbG93T25TZWxmQ2xhc3M6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKc2VsZi5jbGFzcyA9PT0gc29tZXRoaW5nCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd09uQ29uc3RhbnQKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBBbGxvd09uU2VsZkNsYXNzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tY2FzZS1lcXVhbGl0eQoKPT0gU3R5bGUvQ2FzZUxpa2VJZgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44OAp8IDEuNDgKfD09PQoKSWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYGlmLWVsc2lmYCBjb25zdHJ1Y3Rpb25zCmNhbiBiZSByZXBsYWNlZCB3aXRoIGBjYXNlLXdoZW5gLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlLiBgY2FzZWAgc3RhdGVtZW50cyB1c2UgYD09PWAgZm9yIGVxdWFsaXR5LApzbyBpZiB0aGUgb3JpZ2luYWwgY29uZGl0aW9uYWwgdXNlZCBhIGRpZmZlcmVudCBlcXVhbGl0eSBvcGVyYXRvciwgdGhlCmJlaGF2aW9yIG1heSBiZSBkaWZmZXJlbnQuCgo9PT0gRXhhbXBsZXMKCj09PT0gTWluQnJhbmNoZXNDb3VudDogMyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiBzdGF0dXMgPT0gOmFjdGl2ZQogIHBlcmZvcm1fYWN0aW9uCmVsc2lmIHN0YXR1cyA9PSA6aW5hY3RpdmUgfHwgc3RhdHVzID09IDpoaWJlcm5hdGluZwogIGNoZWNrX3RpbWVvdXQKZWxzaWYgc3RhdHVzID09IDppbnZhbGlkCiAgcmVwb3J0X2ludmFsaWQKZWxzZQogIGZpbmFsX2FjdGlvbgplbmQKCiMgZ29vZApjYXNlIHN0YXR1cwp3aGVuIDphY3RpdmUKICBwZXJmb3JtX2FjdGlvbgp3aGVuIDppbmFjdGl2ZSwgOmhpYmVybmF0aW5nCiAgY2hlY2tfdGltZW91dAp3aGVuIDppbnZhbGlkCiAgcmVwb3J0X2ludmFsaWQKZWxzZQogIGZpbmFsX2FjdGlvbgplbmQKLS0tLQoKPT09PSBNaW5CcmFuY2hlc0NvdW50OiA0Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmlmIHN0YXR1cyA9PSA6YWN0aXZlCiAgcGVyZm9ybV9hY3Rpb24KZWxzaWYgc3RhdHVzID09IDppbmFjdGl2ZSB8fCBzdGF0dXMgPT0gOmhpYmVybmF0aW5nCiAgY2hlY2tfdGltZW91dAplbHNpZiBzdGF0dXMgPT0gOmludmFsaWQKICByZXBvcnRfaW52YWxpZAplbHNlCiAgZmluYWxfYWN0aW9uCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWluQnJhbmNoZXNDb3VudAp8IGAzYAp8IEludGVnZXIKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjY2FzZS12cy1pZi1lbHNlCgo9PSBTdHlsZS9DaGFyYWN0ZXJMaXRlcmFsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgLQp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgdGhlIGNoYXJhY3RlciBsaXRlcmFsID94LgpTdGFydGluZyB3aXRoIFJ1YnkgMS45IGNoYXJhY3RlciBsaXRlcmFscyBhcmUKZXNzZW50aWFsbHkgb25lLWNoYXJhY3RlciBzdHJpbmdzLCBzbyB0aGlzIHN5bnRheAppcyBtb3N0bHkgcmVkdW5kYW50IGF0IHRoaXMgcG9pbnQuCgo/IGNoYXJhY3RlciBsaXRlcmFsIGNhbiBiZSB1c2VkIHRvIGV4cHJlc3MgbWV0YSBhbmQgY29udHJvbCBjaGFyYWN0ZXIuClRoYXQncyBhIGdvb2QgdXNlIGNhc2Ugb2YgPyBsaXRlcmFsIHNvIGl0IGRvZXNuJ3QgY291bnQgaXQgYXMgYW4gb2ZmZW5zZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCj94CgojIGdvb2QKJ3gnCgojIGdvb2QgLSBjb250cm9sICYgbWV0YSBlc2NhcGVzCj9cQy1cTS1kCiJcQy1cTS1kIiAjIHNhbWUgYXMgYWJvdmUKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tY2hhcmFjdGVyLWxpdGVyYWxzCgo9PSBTdHlsZS9DbGFzc0FuZE1vZHVsZUNoaWxkcmVuCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4xOQp8IC0KfD09PQoKQ2hlY2tzIHRoZSBzdHlsZSBvZiBjaGlsZHJlbiBkZWZpbml0aW9ucyBhdCBjbGFzc2VzIGFuZAptb2R1bGVzLiBCYXNpY2FsbHkgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgc3R5bGVzOgoKVGhlIGNvbXBhY3Qgc3R5bGUgaXMgb25seSBmb3JjZWQgZm9yIGNsYXNzZXMvbW9kdWxlcyB3aXRoIG9uZSBjaGlsZC4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZS4KCk1vdmluZyBmcm9tIGNvbXBhY3QgdG8gbmVzdGVkIGNoaWxkcmVuIHJlcXVpcmVzIGtub3dsZWRnZSBvZiB3aGV0aGVyIHRoZQpvdXRlciBwYXJlbnQgaXMgYSBtb2R1bGUgb3IgYSBjbGFzcy4gTW92aW5nIGZyb20gbmVzdGVkIHRvIGNvbXBhY3QgcmVxdWlyZXMKdmVyaWZpY2F0aW9uIHRoYXQgdGhlIG91dGVyIHBhcmVudCBpcyBkZWZpbmVkIGVsc2V3aGVyZS4gUnVib0NvcCBkb2VzIG5vdApoYXZlIHRoZSBrbm93bGVkZ2UgdG8gcGVyZm9ybSBlaXRoZXIgb3BlcmF0aW9uIHNhZmVseSBhbmQgdGh1cyByZXF1aXJlcwptYW51YWwgb3ZlcnNpZ2h0LgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IG5lc3RlZCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKIyBoYXZlIGVhY2ggY2hpbGQgb24gaXRzIG93biBsaW5lCmNsYXNzIEZvbwogIGNsYXNzIEJhcgogIGVuZAplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBjb21wYWN0Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCiMgY29tYmluZSBkZWZpbml0aW9ucyBhcyBtdWNoIGFzIHBvc3NpYmxlCmNsYXNzIEZvbzo6QmFyCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBuZXN0ZWRgCnwgYG5lc3RlZGAsIGBjb21wYWN0YAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuYW1lc3BhY2UtZGVmaW5pdGlvbgoKPT0gU3R5bGUvQ2xhc3NDaGVjawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMjQKfCAtCnw9PT0KCkVuZm9yY2VzIGNvbnNpc3RlbnQgdXNlIG9mIGBPYmplY3QjaXNfYT9gIG9yIGBPYmplY3Qja2luZF9vZj9gLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGlzX2E/IChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnZhci5raW5kX29mPyhEYXRlKQp2YXIua2luZF9vZj8oSW50ZWdlcikKCiMgZ29vZAp2YXIuaXNfYT8oRGF0ZSkKdmFyLmlzX2E/KEludGVnZXIpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZToga2luZF9vZj8KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp2YXIuaXNfYT8oVGltZSkKdmFyLmlzX2E/KFN0cmluZykKCiMgZ29vZAp2YXIua2luZF9vZj8oVGltZSkKdmFyLmtpbmRfb2Y/KFN0cmluZykKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgaXNfYT9gCnwgYGlzX2E/YCwgYGtpbmRfb2Y/YAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNpcy1hLXZzLWtpbmQtb2YKCj09IFN0eWxlL0NsYXNzRXF1YWxpdHlDb21wYXJpc29uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC45Mwp8IDEuNTcKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBgT2JqZWN0I2luc3RhbmNlX29mP2AgaW5zdGVhZCBvZiBjbGFzcyBjb21wYXJpc29uCmZvciBlcXVhbGl0eS4KYD09YCwgYGVxdWFsP2AsIGFuZCBgZXFsP2AgY3VzdG9tIG1ldGhvZCBkZWZpbml0aW9ucyBhcmUgYWxsb3dlZCBieSBkZWZhdWx0LgpUaGVzZSBhcmUgY3VzdG9taXphYmxlIHdpdGggYEFsbG93ZWRNZXRob2RzYCBvcHRpb24uCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0CnRoZSBjb25zdGFudCBgRm9vYCBleGlzdHMgd2hlbiBhdXRvY29ycmVjdGluZyBgdmFyLmNsYXNzLm5hbWUgPT0gJ0ZvbydgIHRvCmB2YXIuaW5zdGFuY2Vfb2Y/KEZvbylgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKdmFyLmNsYXNzID09IERhdGUKdmFyLmNsYXNzLmVxdWFsPyhEYXRlKQp2YXIuY2xhc3MuZXFsPyhEYXRlKQp2YXIuY2xhc3MubmFtZSA9PSAnRGF0ZScKCiMgZ29vZAp2YXIuaW5zdGFuY2Vfb2Y/KERhdGUpCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFsnPT0nLCAnZXF1YWw/JywgJ2VxbD8nXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmID09KG90aGVyKQogIHNlbGYuY2xhc3MgPT0gb3RoZXIuY2xhc3MgJiYgbmFtZSA9PSBvdGhlci5uYW1lCmVuZAoKZGVmIGVxdWFsPyhvdGhlcikKICBzZWxmLmNsYXNzLmVxdWFsPyhvdGhlci5jbGFzcykgJiYgbmFtZS5lcXVhbD8ob3RoZXIubmFtZSkKZW5kCgpkZWYgZXFsPyhvdGhlcikKICBzZWxmLmNsYXNzLmVxbD8ob3RoZXIuY2xhc3MpICYmIG5hbWUuZXFsPyhvdGhlci5uYW1lKQplbmQKLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnM6IFtdIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBlcShvdGhlcikKICBzZWxmLmNsYXNzLmVxKG90aGVyLmNsYXNzKSAmJiBuYW1lLmVxKG90aGVyLm5hbWUpCmVuZAotLS0tCgo9PT09IEFsbG93ZWRQYXR0ZXJuczogWydlcSddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBlcShvdGhlcikKICBzZWxmLmNsYXNzLmVxKG90aGVyLmNsYXNzKSAmJiBuYW1lLmVxKG90aGVyLm5hbWUpCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZE1ldGhvZHMKfCBgPT1gLCBgZXF1YWw/YCwgYGVxbD9gCnwgQXJyYXkKCnwgQWxsb3dlZFBhdHRlcm5zCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2luc3RhbmNlLW9mLXZzLWNsYXNzLWNvbXBhcmlzb24KCj09IFN0eWxlL0NsYXNzTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuMjAKfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIHRoZSBjbGFzcy9tb2R1bGUgbmFtZSBpbnN0ZWFkIG9mCnNlbGYsIHdoZW4gZGVmaW5pbmcgY2xhc3MvbW9kdWxlIG1ldGhvZHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBTb21lQ2xhc3MKICBkZWYgU29tZUNsYXNzLmNsYXNzX21ldGhvZAogICAgIyAuLi4KICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgU29tZUNsYXNzCiAgZGVmIHNlbGYuY2xhc3NfbWV0aG9kCiAgICAjIC4uLgogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZGVmLXNlbGYtY2xhc3MtbWV0aG9kcwoKPT0gU3R5bGUvQ2xhc3NNZXRob2RzRGVmaW5pdGlvbnMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC44OQp8IC0KfD09PQoKRW5mb3JjZXMgdXNpbmcgYGRlZiBzZWxmLm1ldGhvZF9uYW1lYCBvciBgY2xhc3MgPDwgc2VsZmAgdG8gZGVmaW5lIGNsYXNzIG1ldGhvZHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogZGVmX3NlbGYgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgU29tZUNsYXNzCiAgY2xhc3MgPDwgc2VsZgogICAgYXR0cl9hY2Nlc3NvciA6Y2xhc3NfYWNjZXNzb3IKCiAgICBkZWYgY2xhc3NfbWV0aG9kCiAgICAgICMgLi4uCiAgICBlbmQKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgU29tZUNsYXNzCiAgZGVmIHNlbGYuY2xhc3NfbWV0aG9kCiAgICAjIC4uLgogIGVuZAoKICBjbGFzcyA8PCBzZWxmCiAgICBhdHRyX2FjY2Vzc29yIDpjbGFzc19hY2Nlc3NvcgogIGVuZAplbmQKCiMgZ29vZCAtIGNvbnRhaW5zIHByaXZhdGUgbWV0aG9kCmNsYXNzIFNvbWVDbGFzcwogIGNsYXNzIDw8IHNlbGYKICAgIGF0dHJfYWNjZXNzb3IgOmNsYXNzX2FjY2Vzc29yCgogICAgcHJpdmF0ZQoKICAgIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZAogICAgICAjIC4uLgogICAgZW5kCiAgZW5kCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNlbGZfY2xhc3MKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBTb21lQ2xhc3MKICBkZWYgc2VsZi5jbGFzc19tZXRob2QKICAgICMgLi4uCiAgZW5kCmVuZAoKIyBnb29kCmNsYXNzIFNvbWVDbGFzcwogIGNsYXNzIDw8IHNlbGYKICAgIGRlZiBjbGFzc19tZXRob2QKICAgICAgIyAuLi4KICAgIGVuZAogIGVuZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZGVmX3NlbGZgCnwgYGRlZl9zZWxmYCwgYHNlbGZfY2xhc3NgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2RlZi1zZWxmLWNsYXNzLW1ldGhvZHMKCj09IFN0eWxlL0NsYXNzVmFycwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC4xMwp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIGNsYXNzIHZhcmlhYmxlcy4gT2ZmZW5zZXMKYXJlIHNpZ25hbGVkIG9ubHkgb24gYXNzaWdubWVudCB0byBjbGFzcyB2YXJpYWJsZXMgdG8KcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2ZmZW5zZXMgdGhhdCB3b3VsZCBiZSByZXBvcnRlZC4KCllvdSBoYXZlIHRvIGJlIGNhcmVmdWwgd2hlbiBzZXR0aW5nIGEgdmFsdWUgZm9yIGEgY2xhc3MKdmFyaWFibGU7IGlmIGEgY2xhc3MgaGFzIGJlZW4gaW5oZXJpdGVkLCBjaGFuZ2luZyB0aGUKdmFsdWUgb2YgYSBjbGFzcyB2YXJpYWJsZSBhbHNvIGFmZmVjdHMgdGhlIGluaGVyaXRpbmcKY2xhc3Nlcy4gVGhpcyBtZWFucyB0aGF0IGl0J3MgYWxtb3N0IGFsd2F5cyBiZXR0ZXIgdG8KdXNlIGEgY2xhc3MgaW5zdGFuY2UgdmFyaWFibGUgaW5zdGVhZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEEKICBAQHRlc3QgPSAxMAplbmQKCmNsYXNzIEEKICBkZWYgc2VsZi50ZXN0KG5hbWUsIHZhbHVlKQogICAgY2xhc3NfdmFyaWFibGVfc2V0KCJAQCN7bmFtZX0iLCB2YWx1ZSkKICBlbmQKZW5kCgpjbGFzcyBBOyBlbmQKQS5jbGFzc192YXJpYWJsZV9zZXQoOkBAdGVzdCwgMTApCgojIGdvb2QKY2xhc3MgQQogIEB0ZXN0ID0gMTAKZW5kCgpjbGFzcyBBCiAgZGVmIHRlc3QKICAgIEBAdGVzdCAjIHlvdSBjYW4gYWNjZXNzIGNsYXNzIHZhcmlhYmxlIHdpdGhvdXQgb2ZmZW5zZQogIGVuZAplbmQKCmNsYXNzIEEKICBkZWYgc2VsZi50ZXN0KG5hbWUpCiAgICBjbGFzc192YXJpYWJsZV9nZXQoIkBAI3tuYW1lfSIpICMgeW91IGNhbiBhY2Nlc3Mgd2l0aG91dCBvZmZlbnNlCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1jbGFzcy12YXJzCgo9PSBTdHlsZS9Db2xsZWN0aW9uQ29tcGFjdAoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuMgp8IDEuMwp8PT09CgpDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBjdXN0b20gbG9naWMgb24gcmVqZWN0aW9uIG5pbHMgZnJvbSBhcnJheXMKYW5kIGhhc2hlcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBge0FycmF5LEhhc2h9I3tjb21wYWN0LGNvbXBhY3QhfWAuCgo9PT0gU2FmZXR5CgpJdCBpcyB1bnNhZmUgYnkgZGVmYXVsdCBiZWNhdXNlIGZhbHNlIHBvc2l0aXZlcyBtYXkgb2NjdXIgaW4gdGhlCmBuaWxgIGNoZWNrIG9mIGJsb2NrIGFyZ3VtZW50cyB0byB0aGUgcmVjZWl2ZXIgb2JqZWN0LiBBZGRpdGlvbmFsbHksCndlIGNhbid0IGtub3cgdGhlIHR5cGUgb2YgdGhlIHJlY2VpdmVyIG9iamVjdCBmb3Igc3VyZSwgd2hpY2ggbWF5CnJlc3VsdCBpbiBmYWxzZSBwb3NpdGl2ZXMgYXMgd2VsbC4KCkZvciBleGFtcGxlLCBgW1sxLCAyXSwgWzMsIG5pbF1dLnJlamVjdCB7IHxmaXJzdCwgc2Vjb25kfCBzZWNvbmQubmlsPyB9YAphbmQgYFtbMSwgMl0sIFszLCBuaWxdXS5jb21wYWN0YCBhcmUgbm90IGNvbXBhdGlibGUuIFRoaXMgd2lsbCB3b3JrIGZpbmUKd2hlbiB0aGUgcmVjZWl2ZXIgaXMgYSBoYXNoIG9iamVjdC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFycmF5LnJlamVjdCgmOm5pbD8pCmFycmF5LnJlamVjdCB7IHxlfCBlLm5pbD8gfQphcnJheS5zZWxlY3QgeyB8ZXwgIWUubmlsPyB9CmFycmF5LmdyZXBfdihuaWwpCmFycmF5LmdyZXBfdihOaWxDbGFzcykKCiMgZ29vZAphcnJheS5jb21wYWN0CgojIGJhZApoYXNoLnJlamVjdCEoJjpuaWw/KQphcnJheS5kZWxldGVfaWYoJjpuaWw/KQpoYXNoLnJlamVjdCEgeyB8aywgdnwgdi5uaWw/IH0KYXJyYXkuZGVsZXRlX2lmIHsgfGV8IGUubmlsPyB9Cmhhc2guc2VsZWN0ISB7IHxrLCB2fCAhdi5uaWw/IH0KCiMgZ29vZApoYXNoLmNvbXBhY3QhCi0tLS0KCj09PT0gQWxsb3dlZFJlY2VpdmVyczogWydwYXJhbXMnXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApwYXJhbXMucmVqZWN0KCY6bmlsPykKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRSZWNlaXZlcnMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT0gU3R5bGUvQ29sbGVjdGlvbk1ldGhvZHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjkKfCAxLjcKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBjb25zaXN0ZW50IG1ldGhvZCBuYW1lcwpmcm9tIHRoZSBFbnVtZXJhYmxlIG1vZHVsZS4KCllvdSBjYW4gY3VzdG9taXplIHRoZSBtYXBwaW5nIGZyb20gdW5kZXNpcmVkIG1ldGhvZCB0byBkZXNpcmVkIG1ldGhvZC4KCmUuZy4gdG8gdXNlIGBkZXRlY3RgIG92ZXIgYGZpbmRgOgoKICBTdHlsZS9Db2xsZWN0aW9uTWV0aG9kczoKICAgIFByZWZlcnJlZE1ldGhvZHM6CiAgICAgIGZpbmQ6IGRldGVjdAoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgZmluZHMgbWV0aG9kcyBieSBuYW1lLCB3aXRob3V0IGFjdHVhbGx5CmJlaW5nIGFibGUgdG8gZGV0ZXJtaW5lIGlmIHRoZSByZWNlaXZlciBpcyBhbiBFbnVtZXJhYmxlIG9yIG5vdCwgc28KdGhpcyBjb3AgbWF5IHJlZ2lzdGVyIGZhbHNlIHBvc2l0aXZlcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgVGhlc2UgZXhhbXBsZXMgYXJlIGJhc2VkIG9uIHRoZSBkZWZhdWx0IG1hcHBpbmcgZm9yIGBQcmVmZXJyZWRNZXRob2RzYC4KCiMgYmFkCml0ZW1zLmNvbGxlY3QKaXRlbXMuY29sbGVjdCEKaXRlbXMuY29sbGVjdF9jb25jYXQKaXRlbXMuaW5qZWN0Cml0ZW1zLmRldGVjdAppdGVtcy5maW5kX2FsbAppdGVtcy5tZW1iZXI/CgojIGdvb2QKaXRlbXMubWFwCml0ZW1zLm1hcCEKaXRlbXMuZmxhdF9tYXAKaXRlbXMucmVkdWNlCml0ZW1zLmZpbmQKaXRlbXMuc2VsZWN0Cml0ZW1zLmluY2x1ZGU/Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBQcmVmZXJyZWRNZXRob2RzCnwgYHsiY29sbGVjdCI9PiJtYXAiLCAiY29sbGVjdCEiPT4ibWFwISIsICJjb2xsZWN0X2NvbmNhdCI9PiJmbGF0X21hcCIsICJpbmplY3QiPT4icmVkdWNlIiwgImRldGVjdCI9PiJmaW5kIiwgImZpbmRfYWxsIj0+InNlbGVjdCIsICJtZW1iZXI/Ij0+ImluY2x1ZGU/In1gCnwgCgp8IE1ldGhvZHNBY2NlcHRpbmdTeW1ib2wKfCBgaW5qZWN0YCwgYHJlZHVjZWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtYXAtZmluZC1zZWxlY3QtcmVkdWNlLWluY2x1ZGUtc2l6ZQoKPT0gU3R5bGUvQ29sb25NZXRob2RDYWxsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgLQp8PT09CgpDaGVja3MgZm9yIG1ldGhvZHMgaW52b2tlZCB2aWEgdGhlIGA6OmAgb3BlcmF0b3IgaW5zdGVhZApvZiB0aGUgYC5gIG9wZXJhdG9yIChsaWtlIGBGaWxlVXRpbHM6OnJtZGlyYCBpbnN0ZWFkIG9mIGBGaWxlVXRpbHMucm1kaXJgKS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClRpbWVvdXQ6OnRpbWVvdXQoNTAwKSB7IGRvX3NvbWV0aGluZyB9CkZpbGVVdGlsczo6cm1kaXIoZGlyKQpNYXJzaGFsOjpkdW1wKG9iaikKCiMgZ29vZApUaW1lb3V0LnRpbWVvdXQoNTAwKSB7IGRvX3NvbWV0aGluZyB9CkZpbGVVdGlscy5ybWRpcihkaXIpCk1hcnNoYWwuZHVtcChvYmopCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2RvdWJsZS1jb2xvbnMKCj09IFN0eWxlL0NvbG9uTWV0aG9kRGVmaW5pdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgY2xhc3MgbWV0aG9kcyB0aGF0IGFyZSBkZWZpbmVkIHVzaW5nIHRoZSBgOjpgCm9wZXJhdG9yIGluc3RlYWQgb2YgdGhlIGAuYCBvcGVyYXRvci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwogIGRlZiBzZWxmOjpiYXIKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgZGVmIHNlbGYuYmFyCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNjb2xvbi1tZXRob2QtZGVmaW5pdGlvbgoKPT0gU3R5bGUvQ29tYmluYWJsZUxvb3BzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjkwCnwgLQp8PT09CgpDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBsb29wcyBvdmVyIHRoZSBzYW1lIGRhdGEKY2FuIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgbG9vcC4gSXQgaXMgdmVyeSBsaWtlbHkgdGhhdCBjb21iaW5pbmcgdGhlbQp3aWxsIG1ha2UgdGhlIGNvZGUgbW9yZSBlZmZpY2llbnQgYW5kIG1vcmUgY29uY2lzZS4KCj09PSBTYWZldHkKClRoZSBjb3AgaXMgdW5zYWZlLCBiZWNhdXNlIHRoZSBmaXJzdCBsb29wIG1pZ2h0IG1vZGlmeSBzdGF0ZSB0aGF0IHRoZQpzZWNvbmQgbG9vcCBkZXBlbmRzIG9uOyB0aGVzZSB0d28gYXJlbid0IGNvbWJpbmFibGUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgbWV0aG9kCiAgaXRlbXMuZWFjaCBkbyB8aXRlbXwKICAgIGRvX3NvbWV0aGluZyhpdGVtKQogIGVuZAoKICBpdGVtcy5lYWNoIGRvIHxpdGVtfAogICAgZG9fc29tZXRoaW5nX2Vsc2UoaXRlbSkKICBlbmQKZW5kCgojIGdvb2QKZGVmIG1ldGhvZAogIGl0ZW1zLmVhY2ggZG8gfGl0ZW18CiAgICBkb19zb21ldGhpbmcoaXRlbSkKICAgIGRvX3NvbWV0aGluZ19lbHNlKGl0ZW0pCiAgZW5kCmVuZAoKIyBiYWQKZGVmIG1ldGhvZAogIGZvciBpdGVtIGluIGl0ZW1zIGRvCiAgICBkb19zb21ldGhpbmcoaXRlbSkKICBlbmQKCiAgZm9yIGl0ZW0gaW4gaXRlbXMgZG8KICAgIGRvX3NvbWV0aGluZ19lbHNlKGl0ZW0pCiAgZW5kCmVuZAoKIyBnb29kCmRlZiBtZXRob2QKICBmb3IgaXRlbSBpbiBpdGVtcyBkbwogICAgZG9fc29tZXRoaW5nKGl0ZW0pCiAgICBkb19zb21ldGhpbmdfZWxzZShpdGVtKQogIGVuZAplbmQKCiMgZ29vZApkZWYgbWV0aG9kCiAgZWFjaF9zbGljZSgyKSB7IHxzbGljZXwgZG9fc29tZXRoaW5nKHNsaWNlKSB9CiAgZWFjaF9zbGljZSgzKSB7IHxzbGljZXwgZG9fc29tZXRoaW5nKHNsaWNlKSB9CmVuZAotLS0tCgo9PSBTdHlsZS9Db21tYW5kTGl0ZXJhbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzAKfCAtCnw9PT0KCkVuZm9yY2VzIHVzaW5nIGBgIG9yICV4IGFyb3VuZCBjb21tYW5kIGxpdGVyYWxzLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGJhY2t0aWNrcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb2xkZXJzID0gJXgoZmluZCAuIC10eXBlIGQpLnNwbGl0CgojIGJhZAoleCgKICBsbiAtcyBmb28uZXhhbXBsZS55bWwgZm9vLmV4YW1wbGUKICBsbiAtcyBiYXIuZXhhbXBsZS55bWwgYmFyLmV4YW1wbGUKKQoKIyBnb29kCmZvbGRlcnMgPSBgZmluZCAuIC10eXBlIGRgLnNwbGl0CgojIGdvb2QKYAogIGxuIC1zIGZvby5leGFtcGxlLnltbCBmb28uZXhhbXBsZQogIGxuIC1zIGJhci5leGFtcGxlLnltbCBiYXIuZXhhbXBsZQpgCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogbWl4ZWQKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb2xkZXJzID0gJXgoZmluZCAuIC10eXBlIGQpLnNwbGl0CgojIGJhZApgCiAgbG4gLXMgZm9vLmV4YW1wbGUueW1sIGZvby5leGFtcGxlCiAgbG4gLXMgYmFyLmV4YW1wbGUueW1sIGJhci5leGFtcGxlCmAKCiMgZ29vZApmb2xkZXJzID0gYGZpbmQgLiAtdHlwZSBkYC5zcGxpdAoKIyBnb29kCiV4KAogIGxuIC1zIGZvby5leGFtcGxlLnltbCBmb28uZXhhbXBsZQogIGxuIC1zIGJhci5leGFtcGxlLnltbCBiYXIuZXhhbXBsZQopCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcGVyY2VudF94Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9sZGVycyA9IGBmaW5kIC4gLXR5cGUgZGAuc3BsaXQKCiMgYmFkCmAKICBsbiAtcyBmb28uZXhhbXBsZS55bWwgZm9vLmV4YW1wbGUKICBsbiAtcyBiYXIuZXhhbXBsZS55bWwgYmFyLmV4YW1wbGUKYAoKIyBnb29kCmZvbGRlcnMgPSAleChmaW5kIC4gLXR5cGUgZCkuc3BsaXQKCiMgZ29vZAoleCgKICBsbiAtcyBmb28uZXhhbXBsZS55bWwgZm9vLmV4YW1wbGUKICBsbiAtcyBiYXIuZXhhbXBsZS55bWwgYmFyLmV4YW1wbGUKKQotLS0tCgo9PT09IEFsbG93SW5uZXJCYWNrdGlja3M6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgSWYgYGZhbHNlYCwgdGhlIGNvcCB3aWxsIGFsd2F5cyByZWNvbW1lbmQgdXNpbmcgYCV4YCBpZiBvbmUgb3IgbW9yZQojIGJhY2t0aWNrcyBhcmUgZm91bmQgaW4gdGhlIGNvbW1hbmQgc3RyaW5nLgoKIyBiYWQKYGVjaG8gXGBsc1xgYAoKIyBnb29kCiV4KGVjaG8gYGxzYCkKLS0tLQoKPT09PSBBbGxvd0lubmVyQmFja3RpY2tzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmBlY2hvIFxgbHNcYGAKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYmFja3RpY2tzYAp8IGBiYWNrdGlja3NgLCBgcGVyY2VudF94YCwgYG1peGVkYAoKfCBBbGxvd0lubmVyQmFja3RpY2tzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjcGVyY2VudC14Cgo9PSBTdHlsZS9Db21tZW50QW5ub3RhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTAKfCAxLjIwCnw9PT0KCkNoZWNrcyB0aGF0IGNvbW1lbnQgYW5ub3RhdGlvbiBrZXl3b3JkcyBhcmUgd3JpdHRlbiBhY2NvcmRpbmcKdG8gZ3VpZGVsaW5lcy4KCkFubm90YXRpb24ga2V5d29yZHMgY2FuIGJlIHNwZWNpZmllZCBieSBvdmVycmlkaW5nIHRoZSBjb3AncyBgS2V5d29yZHNgCmNvbmZpZ3VyYXRpb24uIEtleXdvcmRzIGFyZSBhbGxvd2VkIHRvIGJlIHNpbmdsZSB3b3JkcyBvciBwaHJhc2VzLgoKTk9URTogV2l0aCBhIG11bHRpbGluZSBjb21tZW50IGJsb2NrICh3aGVyZSBlYWNoIGxpbmUgaXMgb25seSBhCmNvbW1lbnQpLCBvbmx5IHRoZSBmaXJzdCBsaW5lIHdpbGwgYmUgYWJsZSB0byByZWdpc3RlciBhbiBvZmZlbnNlLCBldmVuCmlmIGFuIGFubm90YXRpb24ga2V5d29yZCBzdGFydHMgYW5vdGhlciBsaW5lLiBUaGlzIGlzIGRvbmUgdG8gcHJldmVudAppbmNvcnJlY3QgcmVnaXN0ZXJpbmcgb2Yga2V5d29yZHMgKGVnLiBgcmV2aWV3YCkgaW5zaWRlIGEgcGFyYWdyYXBoIGFzIGFuCmFubm90YXRpb24uCgo9PT0gRXhhbXBsZXMKCj09PT0gUmVxdWlyZUNvbG9uOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgVE9ETyBtYWtlIGJldHRlcgoKIyBnb29kCiMgVE9ETzogbWFrZSBiZXR0ZXIKCiMgYmFkCiMgVE9ETzptYWtlIGJldHRlcgoKIyBnb29kCiMgVE9ETzogbWFrZSBiZXR0ZXIKCiMgYmFkCiMgZml4bWU6IGRvZXMgbm90IHdvcmsKCiMgZ29vZAojIEZJWE1FOiBkb2VzIG5vdCB3b3JrCgojIGJhZAojIE9wdGltaXplIGRvZXMgbm90IHdvcmsKCiMgZ29vZAojIE9QVElNSVpFOiBkb2VzIG5vdCB3b3JrCi0tLS0KCj09PT0gUmVxdWlyZUNvbG9uOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgVE9ETzogbWFrZSBiZXR0ZXIKCiMgZ29vZAojIFRPRE8gbWFrZSBiZXR0ZXIKCiMgYmFkCiMgZml4bWUgZG9lcyBub3Qgd29yawoKIyBnb29kCiMgRklYTUUgZG9lcyBub3Qgd29yawoKIyBiYWQKIyBPcHRpbWl6ZSBkb2VzIG5vdCB3b3JrCgojIGdvb2QKIyBPUFRJTUlaRSBkb2VzIG5vdCB3b3JrCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBLZXl3b3Jkcwp8IGBUT0RPYCwgYEZJWE1FYCwgYE9QVElNSVpFYCwgYEhBQ0tgLCBgUkVWSUVXYCwgYE5PVEVgCnwgQXJyYXkKCnwgUmVxdWlyZUNvbG9uCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNhbm5vdGF0ZS1rZXl3b3JkcwoKPT0gU3R5bGUvQ29tbWVudGVkS2V5d29yZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNTEKfCAxLjE5Cnw9PT0KCkNoZWNrcyBmb3IgY29tbWVudHMgcHV0IG9uIHRoZSBzYW1lIGxpbmUgYXMgc29tZSBrZXl3b3Jkcy4KVGhlc2Uga2V5d29yZHMgYXJlOiBgY2xhc3NgLCBgbW9kdWxlYCwgYGRlZmAsIGBiZWdpbmAsIGBlbmRgLgoKTm90ZSB0aGF0IHNvbWUgY29tbWVudHMKKGA6bm9kb2M6YCwgYDp5aWVsZHM6YCwgYHJ1Ym9jb3A6ZGlzYWJsZWAgYW5kIGBydWJvY29wOnRvZG9gKQphcmUgYWxsb3dlZC4KCkF1dG9jb3JyZWN0aW9uIHJlbW92ZXMgY29tbWVudHMgZnJvbSBgZW5kYCBrZXl3b3JkIGFuZCBrZWVwcyBjb21tZW50cwpmb3IgYGNsYXNzYCwgYG1vZHVsZWAsIGBkZWZgIGFuZCBgYmVnaW5gIGFib3ZlIHRoZSBrZXl3b3JkLgoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaXQgbWF5IHJlbW92ZSBhIGNvbW1lbnQgdGhhdCBpcwptZWFuaW5nZnVsLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVuZCAjIGVuZCBpZgoKIyBiYWQKY2xhc3MgWCAjIGNvbW1lbnQKICBzdGF0ZW1lbnQKZW5kCgojIGJhZApkZWYgeDsgZW5kICMgY29tbWVudAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKCiMgZ29vZApjbGFzcyBYICMgOm5vZG9jOgogIHkKZW5kCi0tLS0KCj09IFN0eWxlL0NvbXBhcmFibGVDbGFtcAoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjQ0CnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGBDb21wYXJhYmxlI2NsYW1wYCBpbnN0ZWFkIG9mIGNvbXBhcmlzb24gYnkgbWluaW11bSBhbmQgbWF4aW11bS4KClRoaXMgY29wIHN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIGZvciBgaWYvZWxzaWYvZWxzZWAgYmFkIHN0eWxlIG9ubHkuCkJlY2F1c2UgYEFyZ3VtZW50RXJyb3JgIG9jY3VycyBpZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBgY2xhbXBgIGFyZ3VtZW50cyBhcmUgcmV2ZXJzZWQuCldoZW4gdGhlc2UgYXJlIHZhcmlhYmxlcywgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGljaCBpcyB0aGUgbWluaW11bSBhbmQgbWF4aW11bToKCltzb3VyY2UscnVieV0KLS0tLQpbMSwgWzIsIDNdLm1heF0ubWluICMgPT4gMQoxLmNsYW1wKDMsIDEpICAgICAgICMgPT4gbWluIGFyZ3VtZW50IG11c3QgYmUgc21hbGxlciB0aGFuIG1heCBhcmd1bWVudCAoQXJndW1lbnRFcnJvcikKLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKW1t4LCBsb3ddLm1heCwgaGlnaF0ubWluCgojIGJhZAppZiB4IDwgbG93CiAgbG93CmVsc2lmIGhpZ2ggPCB4CiAgaGlnaAplbHNlCiAgeAplbmQKCiMgZ29vZAp4LmNsYW1wKGxvdywgaGlnaCkKLS0tLQoKPT0gU3R5bGUvQ29uY2F0QXJyYXlMaXRlcmFscwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS40MQp8IC0KfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBgQXJyYXkjcHVzaChpdGVtKWAgaW5zdGVhZCBvZiBgQXJyYXkjY29uY2F0KFtpdGVtXSlgCnRvIGF2b2lkIHJlZHVuZGFudCBhcnJheSBsaXRlcmFscy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSwgYXMgaXQgY2FuIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIGlmIHRoZSByZWNlaXZlcgppcyBub3QgYW4gYEFycmF5YCBvYmplY3QuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsaXN0LmNvbmNhdChbZm9vXSkKbGlzdC5jb25jYXQoW2JhciwgYmF6XSkKbGlzdC5jb25jYXQoW3F1eCwgcXV1eF0sIFtjb3JnZV0pCgojIGdvb2QKbGlzdC5wdXNoKGZvbykKbGlzdC5wdXNoKGJhciwgYmF6KQpsaXN0LnB1c2gocXV4LCBxdXV4LCBjb3JnZSkKLS0tLQoKPT0gU3R5bGUvQ29uZGl0aW9uYWxBc3NpZ25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zNgp8IDAuNDcKfD09PQoKQ2hlY2sgZm9yIGBpZmAgYW5kIGBjYXNlYCBzdGF0ZW1lbnRzIHdoZXJlIGVhY2ggYnJhbmNoIGlzIHVzZWQgZm9yCmJvdGggdGhlIGFzc2lnbm1lbnQgYW5kIGNvbXBhcmlzb24gb2YgdGhlIHNhbWUgdmFyaWFibGUKd2hlbiB1c2luZyB0aGUgcmV0dXJuIG9mIHRoZSBjb25kaXRpb24gY2FuIGJlIHVzZWQgaW5zdGVhZC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBhc3NpZ25fdG9fY29uZGl0aW9uIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGZvbwogIGJhciA9IDEKZWxzZQogIGJhciA9IDIKZW5kCgpjYXNlIGZvbwp3aGVuICdhJwogIGJhciArPSAxCmVsc2UKICBiYXIgKz0gMgplbmQKCmlmIGZvbwogIHNvbWVfbWV0aG9kCiAgYmFyID0gMQplbHNlCiAgc29tZV9vdGhlcl9tZXRob2QKICBiYXIgPSAyCmVuZAoKIyBnb29kCmJhciA9IGlmIGZvbwogICAgICAgIDEKICAgICAgZWxzZQogICAgICAgIDIKICAgICAgZW5kCgpiYXIgKz0gY2FzZSBmb28KICAgICAgIHdoZW4gJ2EnCiAgICAgICAgIDEKICAgICAgIGVsc2UKICAgICAgICAgMgogICAgICAgZW5kCgpiYXIgPDwgaWYgZm9vCiAgICAgICAgIHNvbWVfbWV0aG9kCiAgICAgICAgIDEKICAgICAgIGVsc2UKICAgICAgICAgc29tZV9vdGhlcl9tZXRob2QKICAgICAgICAgMgogICAgICAgZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYXNzaWduX2luc2lkZV9jb25kaXRpb24KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApiYXIgPSBpZiBmb28KICAgICAgICAxCiAgICAgIGVsc2UKICAgICAgICAyCiAgICAgIGVuZAoKYmFyICs9IGNhc2UgZm9vCiAgICAgICB3aGVuICdhJwogICAgICAgICAxCiAgICAgICBlbHNlCiAgICAgICAgIDIKICAgICAgIGVuZAoKYmFyIDw8IGlmIGZvbwogICAgICAgICBzb21lX21ldGhvZAogICAgICAgICAxCiAgICAgICBlbHNlCiAgICAgICAgIHNvbWVfb3RoZXJfbWV0aG9kCiAgICAgICAgIDIKICAgICAgIGVuZAoKIyBnb29kCmlmIGZvbwogIGJhciA9IDEKZWxzZQogIGJhciA9IDIKZW5kCgpjYXNlIGZvbwp3aGVuICdhJwogIGJhciArPSAxCmVsc2UKICBiYXIgKz0gMgplbmQKCmlmIGZvbwogIHNvbWVfbWV0aG9kCiAgYmFyID0gMQplbHNlCiAgc29tZV9vdGhlcl9tZXRob2QKICBiYXIgPSAyCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBhc3NpZ25fdG9fY29uZGl0aW9uYAp8IGBhc3NpZ25fdG9fY29uZGl0aW9uYCwgYGFzc2lnbl9pbnNpZGVfY29uZGl0aW9uYAoKfCBTaW5nbGVMaW5lQ29uZGl0aW9uc09ubHkKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IEluY2x1ZGVUZXJuYXJ5RXhwcmVzc2lvbnMKfCBgdHJ1ZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL0NvbnN0YW50VmlzaWJpbGl0eQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuNjYKfCAxLjEwCnw9PT0KCkNoZWNrcyB0aGF0IGNvbnN0YW50cyBkZWZpbmVkIGluIGNsYXNzZXMgYW5kIG1vZHVsZXMgaGF2ZQphbiBleHBsaWNpdCB2aXNpYmlsaXR5IGRlY2xhcmF0aW9uLiBCeSBkZWZhdWx0LCBSdWJ5IG1ha2VzIGFsbCBjbGFzcy0KYW5kIG1vZHVsZSBjb25zdGFudHMgcHVibGljLCB3aGljaCBsaXR0ZXJzIHRoZSBwdWJsaWMgQVBJIG9mIHRoZQpjbGFzcyBvciBtb2R1bGUuIEV4cGxpY2l0bHkgZGVjbGFyaW5nIGEgdmlzaWJpbGl0eSBtYWtlcyBpbnRlbnQgbW9yZQpjbGVhciwgYW5kIHByZXZlbnRzIG91dHNpZGUgYWN0b3JzIGZyb20gdG91Y2hpbmcgcHJpdmF0ZSBzdGF0ZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwogIEJBUiA9IDQyCiAgQkFaID0gNDMKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgQkFSID0gNDIKICBwcml2YXRlX2NvbnN0YW50IDpCQVIKCiAgQkFaID0gNDMKICBwdWJsaWNfY29uc3RhbnQgOkJBWgplbmQKLS0tLQoKPT09PSBJZ25vcmVNb2R1bGVzOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBGb28KICBNeUNsYXNzID0gU3RydWN0Lm5ldygpCmVuZAoKIyBnb29kCmNsYXNzIEZvbwogIE15Q2xhc3MgPSBTdHJ1Y3QubmV3KCkKICBwdWJsaWNfY29uc3RhbnQgOk15Q2xhc3MKZW5kCi0tLS0KCj09PT0gSWdub3JlTW9kdWxlczogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBGb28KICBNeUNsYXNzID0gU3RydWN0Lm5ldygpCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSWdub3JlTW9kdWxlcwp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL0NvcHlyaWdodAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjMwCnwgLQp8PT09CgpDaGVjayB0aGF0IGEgY29weXJpZ2h0IG5vdGljZSB3YXMgZ2l2ZW4gaW4gZWFjaCBzb3VyY2UgZmlsZS4KClRoZSBkZWZhdWx0IHJlZ2V4cCBmb3IgYW4gYWNjZXB0YWJsZSBjb3B5cmlnaHQgbm90aWNlIGNhbiBiZSBmb3VuZCBpbgpjb25maWcvZGVmYXVsdC55bWwuIFRoZSBkZWZhdWx0IGNhbiBiZSBjaGFuZ2VkIGFzIGZvbGxvd3M6Cgpbc291cmNlLHlhbWxdCi0tLS0KU3R5bGUvQ29weXJpZ2h0OgogIE5vdGljZTogJ15Db3B5cmlnaHQgKFwoY1wpICk/MlxkezN9IEFjbWUgSW5jJwotLS0tCgpUaGlzIHJlZ2V4IHN0cmluZyBpcyB0cmVhdGVkIGFzIGFuIHVuYW5jaG9yZWQgcmVnZXguIEZvciBlYWNoIGZpbGUKdGhhdCBSdWJvQ29wIHNjYW5zLCBhIGNvbW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgcmVnZXggbXVzdCBiZSBmb3VuZCBvcgphbiBvZmZlbnNlIGlzIHJlcG9ydGVkLgoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE5vdGljZQp8IGBeQ29weXJpZ2h0IChcKGNcKSApPzJbMC05XXszfSAuK2AKfCBTdHJpbmcKCnwgQXV0b2NvcnJlY3ROb3RpY2UKfCBgYAp8IFN0cmluZwp8PT09Cgo9PSBTdHlsZS9EYXRhSW5oZXJpdGFuY2UKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMy4yCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMS40OQp8IDEuNTEKfD09PQoKQ2hlY2tzIGZvciBpbmhlcml0YW5jZSBmcm9tIGBEYXRhLmRlZmluZWAgdG8gYXZvaWQgY3JlYXRpbmcgdGhlIGFub255bW91cyBwYXJlbnQgY2xhc3MuCgo9PT0gU2FmZXR5CgpBdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBpdCB3aWxsIGNoYW5nZSB0aGUgaW5oZXJpdGFuY2UKdHJlZSAoZS5nLiByZXR1cm4gdmFsdWUgb2YgYE1vZHVsZSNhbmNlc3RvcnNgKSBvZiB0aGUgY29uc3RhbnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBQZXJzb24gPCBEYXRhLmRlZmluZSg6Zmlyc3RfbmFtZSwgOmxhc3RfbmFtZSkKICBkZWYgYWdlCiAgICA0MgogIGVuZAplbmQKCiMgZ29vZApQZXJzb24gPSBEYXRhLmRlZmluZSg6Zmlyc3RfbmFtZSwgOmxhc3RfbmFtZSkgZG8KICBkZWYgYWdlCiAgICA0MgogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tZXh0ZW5kLWRhdGEtZGVmaW5lCgo9PSBTdHlsZS9EYXRlVGltZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjUxCnwgMC45Mgp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgdXNhZ2Ugb2YgdGhlIGBEYXRlVGltZWAgY2xhc3Mgb3ZlciB0aGUKYFRpbWVgIGNsYXNzLiBUaGlzIGNvcCBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IHNpbmNlIHRoZXNlIGNsYXNzZXMsCmFsdGhvdWdoIGhpZ2hseSBvdmVybGFwcGluZywgaGF2ZSBwYXJ0aWN1bGFyaXRpZXMgdGhhdCBtYWtlIHRoZW0gbm90CnJlcGxhY2VhYmxlIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB3aGVuIGRlYWxpbmcgd2l0aCBtdWx0aXBsZSB0aW1lem9uZXMKYW5kL29yIERTVC4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIG5vdCBzYWZlLCBiZWNhdXNlIGBEYXRlVGltZWAgYW5kIGBUaW1lYCBkbyBub3QgaGF2ZQpleGFjdGx5IHRoZSBzYW1lIGJlaGF2aW9yLCBhbHRob3VnaCBpbiBtb3N0IGNhc2VzIHRoZSBhdXRvY29ycmVjdGlvbgp3aWxsIGJlIGZpbmUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZCAtIHVzZXMgYERhdGVUaW1lYCBmb3IgY3VycmVudCB0aW1lCkRhdGVUaW1lLm5vdwoKIyBnb29kIC0gdXNlcyBgVGltZWAgZm9yIGN1cnJlbnQgdGltZQpUaW1lLm5vdwoKIyBiYWQgLSB1c2VzIGBEYXRlVGltZWAgZm9yIG1vZGVybiBkYXRlCkRhdGVUaW1lLmlzbzg2MDEoJzIwMTYtMDYtMjknKQoKIyBnb29kIC0gdXNlcyBgVGltZWAgZm9yIG1vZGVybiBkYXRlClRpbWUuaXNvODYwMSgnMjAxNi0wNi0yOScpCgojIGdvb2QgLSB1c2VzIGBEYXRlVGltZWAgd2l0aCBzdGFydCBhcmd1bWVudCBmb3IgaGlzdG9yaWNhbCBkYXRlCkRhdGVUaW1lLmlzbzg2MDEoJzE3NTEtMDQtMjMnLCBEYXRlOjpFTkdMQU5EKQotLS0tCgo9PT09IEFsbG93Q29lcmNpb246IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gY29lcmNlcyB0byBgRGF0ZVRpbWVgCnNvbWV0aGluZy50b19kYXRldGltZQoKIyBnb29kIC0gY29lcmNlcyB0byBgVGltZWAKc29tZXRoaW5nLnRvX3RpbWUKLS0tLQoKPT09PSBBbGxvd0NvZXJjaW9uOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCnNvbWV0aGluZy50b19kYXRldGltZQoKIyBnb29kCnNvbWV0aGluZy50b190aW1lCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd0NvZXJjaW9uCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZGF0ZS10aW1lCgo9PSBTdHlsZS9EZWZXaXRoUGFyZW50aGVzZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjEyCnw9PT0KCkNoZWNrcyBmb3IgcGFyZW50aGVzZXMgaW4gdGhlIGRlZmluaXRpb24gb2YgYSBtZXRob2QsCnRoYXQgZG9lcyBub3QgdGFrZSBhbnkgYXJndW1lbnRzLiBCb3RoIGluc3RhbmNlIGFuZApjbGFzcy9zaW5nbGV0b24gbWV0aG9kcyBhcmUgY2hlY2tlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28oKQogIGRvX3NvbWV0aGluZwplbmQKCiMgZ29vZApkZWYgZm9vCiAgZG9fc29tZXRoaW5nCmVuZAoKIyBiYWQKZGVmIGZvbygpID0gZG9fc29tZXRoaW5nCgojIGdvb2QKZGVmIGZvbyA9IGRvX3NvbWV0aGluZwoKIyBnb29kICh3aXRob3V0IHBhcmVudGhlc2VzIGl0J3MgYSBzeW50YXggZXJyb3IpCmRlZiBmb28oKSBkb19zb21ldGhpbmcgZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgQmF6LmZvbygpCiAgZG9fc29tZXRoaW5nCmVuZAoKIyBnb29kCmRlZiBCYXouZm9vCiAgZG9fc29tZXRoaW5nCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtZXRob2QtcGFyZW5zCgo9PSBTdHlsZS9EaXIKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMi4wCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41MAp8IC0KfD09PQoKQ2hlY2tzIGZvciBwbGFjZXMgd2hlcmUgdGhlIGAjXF9cX2RpclxfXF9gIG1ldGhvZCBjYW4gcmVwbGFjZSBtb3JlCmNvbXBsZXggY29uc3RydWN0cyB0byByZXRyaWV2ZSBhIGNhbm9uaWNhbGl6ZWQgYWJzb2x1dGUgcGF0aCB0byB0aGUKY3VycmVudCBmaWxlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcGF0aCA9IEZpbGUuZXhwYW5kX3BhdGgoRmlsZS5kaXJuYW1lKF9fRklMRV9fKSkKCiMgYmFkCnBhdGggPSBGaWxlLmRpcm5hbWUoRmlsZS5yZWFscGF0aChfX0ZJTEVfXykpCgojIGdvb2QKcGF0aCA9IF9fZGlyX18KLS0tLQoKPT0gU3R5bGUvRGlyRW1wdHkKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMi40Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS40OAp8IC0KfD09PQoKUHJlZmVyIHRvIHVzZSBgRGlyLmVtcHR5PygncGF0aC90by9kaXInKWAgd2hlbiBjaGVja2luZyBpZiBhIGRpcmVjdG9yeSBpcyBlbXB0eS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkRpci5lbnRyaWVzKCdwYXRoL3RvL2RpcicpLnNpemUgPT0gMgpEaXIuY2hpbGRyZW4oJ3BhdGgvdG8vZGlyJykuZW1wdHk/CkRpci5jaGlsZHJlbigncGF0aC90by9kaXInKS5zaXplID09IDAKRGlyLmVhY2hfY2hpbGQoJ3BhdGgvdG8vZGlyJykubm9uZT8KCiMgZ29vZApEaXIuZW1wdHk/KCdwYXRoL3RvL2RpcicpCi0tLS0KCj09IFN0eWxlL0Rpc2FibGVDb3BzV2l0aGluU291cmNlQ29kZURpcmVjdGl2ZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjgyCnwgMS45Cnw9PT0KCkRldGVjdHMgY29tbWVudHMgdG8gZW5hYmxlL2Rpc2FibGUgUnVib0NvcC4KVGhpcyBpcyB1c2VmdWwgaWYgd2FudCB0byBtYWtlIHN1cmUgdGhhdCBldmVyeSBSdWJvQ29wIGVycm9yIGdldHMgZml4ZWQKYW5kIG5vdCBxdWlja2x5IGRpc2FibGVkIHdpdGggYSBjb21tZW50LgoKU3BlY2lmaWMgY29wcyBjYW4gYmUgYWxsb3dlZCB3aXRoIHRoZSBgQWxsb3dlZENvcHNgIGNvbmZpZ3VyYXRpb24uIE5vdGUgdGhhdAppZiB0aGlzIGNvbmZpZ3VyYXRpb24gaXMgc2V0LCBgcnVib2NvcDpkaXNhYmxlIGFsbGAgaXMgc3RpbGwgZGlzYWxsb3dlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgcnVib2NvcDpkaXNhYmxlIE1ldHJpY3MvQWJjU2l6ZQpkZWYgZm9vCmVuZAojIHJ1Ym9jb3A6ZW5hYmxlIE1ldHJpY3MvQWJjU2l6ZQoKIyBnb29kCmRlZiBmb28KZW5kCi0tLS0KCj09PT0gQWxsb3dlZENvcHM6IFtNZXRyaWNzL0FiY1NpemVdCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCiMgcnVib2NvcDpkaXNhYmxlIE1ldHJpY3MvQWJjU2l6ZQpkZWYgZm9vCmVuZAojIHJ1Ym9jb3A6ZW5hYmxlIE1ldHJpY3MvQWJjU2l6ZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZENvcHMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT0gU3R5bGUvRG9jdW1lbnREeW5hbWljRXZhbERlZmluaXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDEuMQp8IDEuMwp8PT09CgpXaGVuIHVzaW5nIGBjbGFzc19ldmFsYCAob3Igb3RoZXIgYGV2YWxgKSB3aXRoIHN0cmluZyBpbnRlcnBvbGF0aW9uLAphZGQgYSBjb21tZW50IGJsb2NrIHNob3dpbmcgaXRzIGFwcGVhcmFuY2UgaWYgaW50ZXJwb2xhdGVkIChhIHByYWN0aWNlIHVzZWQgaW4gUmFpbHMgY29kZSkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGZyb20gYWN0aXZlc3VwcG9ydC9saWIvYWN0aXZlX3N1cHBvcnQvY29yZV9leHQvc3RyaW5nL291dHB1dF9zYWZldHkucmIKCiMgYmFkClVOU0FGRV9TVFJJTkdfTUVUSE9EUy5lYWNoIGRvIHx1bnNhZmVfbWV0aG9kfAogIGlmICdTdHJpbmcnLnJlc3BvbmRfdG8/KHVuc2FmZV9tZXRob2QpCiAgICBjbGFzc19ldmFsIDw8LUVPVCwgX19GSUxFX18sIF9fTElORV9fICsgMQogICAgICBkZWYgI3t1bnNhZmVfbWV0aG9kfSgqcGFyYW1zLCAmYmxvY2spCiAgICAgICAgdG9fc3RyLiN7dW5zYWZlX21ldGhvZH0oKnBhcmFtcywgJmJsb2NrKQogICAgICBlbmQKCiAgICAgIGRlZiAje3Vuc2FmZV9tZXRob2R9ISgqcGFyYW1zKQogICAgICAgIEBkaXJ0eSA9IHRydWUKICAgICAgICBzdXBlcgogICAgICBlbmQKICAgIEVPVAogIGVuZAplbmQKCiMgZ29vZCwgaW5saW5lIGNvbW1lbnRzIGluIGhlcmVkb2MKVU5TQUZFX1NUUklOR19NRVRIT0RTLmVhY2ggZG8gfHVuc2FmZV9tZXRob2R8CiAgaWYgJ1N0cmluZycucmVzcG9uZF90bz8odW5zYWZlX21ldGhvZCkKICAgIGNsYXNzX2V2YWwgPDwtRU9ULCBfX0ZJTEVfXywgX19MSU5FX18gKyAxCiAgICAgIGRlZiAje3Vuc2FmZV9tZXRob2R9KCpwYXJhbXMsICZibG9jaykgICAgICAgIyBkZWYgY2FwaXRhbGl6ZSgqcGFyYW1zLCAmYmxvY2spCiAgICAgICAgdG9fc3RyLiN7dW5zYWZlX21ldGhvZH0oKnBhcmFtcywgJmJsb2NrKSAgIyAgIHRvX3N0ci5jYXBpdGFsaXplKCpwYXJhbXMsICZibG9jaykKICAgICAgZW5kICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGVuZAoKICAgICAgZGVmICN7dW5zYWZlX21ldGhvZH0hKCpwYXJhbXMpICAgICAgICAgICAgICAjIGRlZiBjYXBpdGFsaXplISgqcGFyYW1zKQogICAgICAgIEBkaXJ0eSA9IHRydWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgICBAZGlydHkgPSB0cnVlCiAgICAgICAgc3VwZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAgIHN1cGVyCiAgICAgIGVuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBlbmQKICAgIEVPVAogIGVuZAplbmQKCiMgZ29vZCwgYmxvY2sgY29tbWVudHMgaW4gaGVyZWRvYwpjbGFzc19ldmFsIDw8LUVPVCwgX19GSUxFX18sIF9fTElORV9fICsgMQogICMgZGVmIGNhcGl0YWxpemUhKCpwYXJhbXMpCiAgIyAgIEBkaXJ0eSA9IHRydWUKICAjICAgc3VwZXIKICAjIGVuZAoKICBkZWYgI3t1bnNhZmVfbWV0aG9kfSEoKnBhcmFtcykKICAgIEBkaXJ0eSA9IHRydWUKICAgIHN1cGVyCiAgZW5kCkVPVAoKIyBnb29kLCBibG9jayBjb21tZW50cyBiZWZvcmUgaGVyZWRvYwpjbGFzc19ldmFsKAogICMgZGVmIGNhcGl0YWxpemUhKCpwYXJhbXMpCiAgIyAgIEBkaXJ0eSA9IHRydWUKICAjICAgc3VwZXIKICAjIGVuZAoKICA8PC1FT1QsIF9fRklMRV9fLCBfX0xJTkVfXyArIDEKICAgIGRlZiAje3Vuc2FmZV9tZXRob2R9ISgqcGFyYW1zKQogICAgICBAZGlydHkgPSB0cnVlCiAgICAgIHN1cGVyCiAgICBlbmQKICBFT1QKKQoKIyBiYWQgLSBpbnRlcnBvbGF0ZWQgc3RyaW5nIHdpdGhvdXQgY29tbWVudApjbGFzc19ldmFsKCJkZWYgI3t1bnNhZmVfbWV0aG9kfSEoKnBhcmFtcyk7IGVuZCIpCgojIGdvb2QgLSB3aXRoIGlubGluZSBjb21tZW50IG9yIHJlcGxhY2UgaXQgd2l0aCBibG9jayBjb21tZW50IHVzaW5nIGhlcmVkb2MKY2xhc3NfZXZhbCgiZGVmICN7dW5zYWZlX21ldGhvZH0hKCpwYXJhbXMpOyBlbmQgIyBkZWYgY2FwaXRhbGl6ZSEoKnBhcmFtcyk7IGVuZCIpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2V2YWwtY29tbWVudC1kb2NzCgo9PSBTdHlsZS9Eb2N1bWVudGF0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgbWlzc2luZyB0b3AtbGV2ZWwgZG9jdW1lbnRhdGlvbiBvZiBjbGFzc2VzIGFuZAptb2R1bGVzLiBDbGFzc2VzIHdpdGggbm8gYm9keSBhcmUgZXhlbXB0IGZyb20gdGhlIGNoZWNrIGFuZCBzbyBhcmUKbmFtZXNwYWNlIG1vZHVsZXMgLSBtb2R1bGVzIHRoYXQgaGF2ZSBub3RoaW5nIGluIHRoZWlyIGJvZGllcyBleGNlcHQKY2xhc3Nlcywgb3RoZXIgbW9kdWxlcywgY29uc3RhbnQgZGVmaW5pdGlvbnMgb3IgY29uc3RhbnQgdmlzaWJpbGl0eQpkZWNsYXJhdGlvbnMuCgpUaGUgZG9jdW1lbnRhdGlvbiByZXF1aXJlbWVudCBpcyBhbm51bGxlZCBpZiB0aGUgY2xhc3Mgb3IgbW9kdWxlIGhhcwphIGAjOm5vZG9jOmAgY29tbWVudCBuZXh0IHRvIGl0LiBMaWtld2lzZSwgYCM6bm9kb2M6IGFsbGAgZG9lcyB0aGUKc2FtZSBmb3IgYWxsIGl0cyBjaGlsZHJlbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFBlcnNvbgogICMgLi4uCmVuZAoKbW9kdWxlIE1hdGgKZW5kCgojIGdvb2QKIyBEZXNjcmlwdGlvbi9FeHBsYW5hdGlvbiBvZiBQZXJzb24gY2xhc3MKY2xhc3MgUGVyc29uCiAgIyAuLi4KZW5kCgojIGFsbG93ZWQKICAjIENsYXNzIHdpdGhvdXQgYm9keQogIGNsYXNzIFBlcnNvbgogIGVuZAoKICAjIE5hbWVzcGFjZSAtIEEgbmFtZXNwYWNlIGNhbiBiZSBhIGNsYXNzIG9yIGEgbW9kdWxlCiAgIyBDb250YWluaW5nIGEgY2xhc3MKICBtb2R1bGUgTmFtZXNwYWNlCiAgICAjIERlc2NyaXB0aW9uL0V4cGxhbmF0aW9uIG9mIFBlcnNvbiBjbGFzcwogICAgY2xhc3MgUGVyc29uCiAgICAgICMgLi4uCiAgICBlbmQKICBlbmQKCiAgIyBDb250YWluaW5nIGNvbnN0YW50IHZpc2liaWxpdHkgZGVjbGFyYXRpb24KICBtb2R1bGUgTmFtZXNwYWNlCiAgICBjbGFzcyBQcml2YXRlCiAgICBlbmQKCiAgICBwcml2YXRlX2NvbnN0YW50IDpQcml2YXRlCiAgZW5kCgogICMgQ29udGFpbmluZyBjb25zdGFudCBkZWZpbml0aW9uCiAgbW9kdWxlIE5hbWVzcGFjZQogICAgUHVibGljID0gQ2xhc3MubmV3CiAgZW5kCgogICMgTWFjcm8gY2FsbHMKICBtb2R1bGUgTmFtZXNwYWNlCiAgICBleHRlbmQgRm9vCiAgZW5kCi0tLS0KCj09PT0gQWxsb3dlZENvbnN0YW50czogWydDbGFzc01ldGhvZHMnXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAptb2R1bGUgQQogIG1vZHVsZSBDbGFzc01ldGhvZHMKICAgICMgLi4uCiAgZW5kCiBlbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRDb25zdGFudHMKfCBgW11gCnwgQXJyYXkKCnwgRXhjbHVkZQp8IGArc3BlYy8qKi8qK2AsIGArdGVzdC8qKi8qK2AKfCBBcnJheQp8PT09Cgo9PSBTdHlsZS9Eb2N1bWVudGF0aW9uTWV0aG9kCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMC40Mwp8IC0KfD09PQoKQ2hlY2tzIGZvciBtaXNzaW5nIGRvY3VtZW50YXRpb24gY29tbWVudCBmb3IgcHVibGljIG1ldGhvZHMuCkl0IGNhbiBvcHRpb25hbGx5IGJlIGNvbmZpZ3VyZWQgdG8gYWxzbyByZXF1aXJlIGRvY3VtZW50YXRpb24gZm9yCm5vbi1wdWJsaWMgbWV0aG9kcy4KCk5PVEU6IFRoaXMgY29wIGFsbG93cyBgaW5pdGlhbGl6ZWAgbWV0aG9kIGJlY2F1c2UgYGluaXRpYWxpemVgIGlzCmEgc3BlY2lhbCBtZXRob2QgY2FsbGVkIGZyb20gYG5ld2AuIEluIHNvbWUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzCnRoZXkgYXJlIGNhbGxlZCBjb25zdHJ1Y3RvciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIG1ldGhvZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCgpjbGFzcyBGb28KICBkZWYgYmFyCiAgICBwdXRzIGJhegogIGVuZAplbmQKCm1vZHVsZSBGb28KICBkZWYgYmFyCiAgICBwdXRzIGJhegogIGVuZAplbmQKCmRlZiBmb28uYmFyCiAgcHV0cyBiYXoKZW5kCgojIGdvb2QKCmNsYXNzIEZvbwogICMgRG9jdW1lbnRhdGlvbgogIGRlZiBiYXIKICAgIHB1dHMgYmF6CiAgZW5kCmVuZAoKbW9kdWxlIEZvbwogICMgRG9jdW1lbnRhdGlvbgogIGRlZiBiYXIKICAgIHB1dHMgYmF6CiAgZW5kCmVuZAoKIyBEb2N1bWVudGF0aW9uCmRlZiBmb28uYmFyCiAgcHV0cyBiYXoKZW5kCi0tLS0KCj09PT0gUmVxdWlyZUZvck5vblB1YmxpY01ldGhvZHM6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBGb28KICBwcm90ZWN0ZWQKICBkZWYgZG9fc29tZXRoaW5nCiAgZW5kCmVuZAoKY2xhc3MgRm9vCiAgcHJpdmF0ZQogIGRlZiBkb19zb21ldGhpbmcKICBlbmQKZW5kCi0tLS0KCj09PT0gUmVxdWlyZUZvck5vblB1YmxpY01ldGhvZHM6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBGb28KICBwcm90ZWN0ZWQKICBkZWYgZG9fc29tZXRoaW5nCiAgZW5kCmVuZAoKY2xhc3MgRm9vCiAgcHJpdmF0ZQogIGRlZiBkb19zb21ldGhpbmcKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgcHJvdGVjdGVkCiAgIyBEb2N1bWVudGF0aW9uCiAgZGVmIGRvX3NvbWV0aGluZwogIGVuZAplbmQKCmNsYXNzIEZvbwogIHByaXZhdGUKICAjIERvY3VtZW50YXRpb24KICBkZWYgZG9fc29tZXRoaW5nCiAgZW5kCmVuZAotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbJ21ldGhvZF9taXNzaW5nJywgJ3Jlc3BvbmRfdG9fbWlzc2luZz8nXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBGb28KICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MpCiAgZW5kCgogIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KHN5bWJvbCwgaW5jbHVkZV9wcml2YXRlKQogIGVuZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgK3NwZWMvKiovKitgLCBgK3Rlc3QvKiovKitgCnwgQXJyYXkKCnwgUmVxdWlyZUZvck5vblB1YmxpY01ldGhvZHMKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PSBTdHlsZS9Eb3VibGVDb3BEaXNhYmxlRGlyZWN0aXZlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC43Mwp8IC0KfD09PQoKRGV0ZWN0cyBkb3VibGUgZGlzYWJsZSBjb21tZW50cyBvbiBvbmUgbGluZS4gVGhpcyBpcyBtb3N0bHkgdG8gY2F0Y2gKYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY29tbWVudHMgdGhhdCBuZWVkIHRvIGJlIHJlZ2VuZXJhdGVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGYgIyBydWJvY29wOmRpc2FibGUgU3R5bGUvRm9yICMgcnVib2NvcDpkaXNhYmxlIE1ldHJpY3MvQWJjU2l6ZQplbmQKCiMgZ29vZAojIHJ1Ym9jb3A6ZGlzYWJsZSBNZXRyaWNzL0FiY1NpemUKZGVmIGYgIyBydWJvY29wOmRpc2FibGUgU3R5bGUvRm9yCmVuZAojIHJ1Ym9jb3A6ZW5hYmxlIE1ldHJpY3MvQWJjU2l6ZQoKIyBpZiBib3RoIGZpdCBvbiBvbmUgbGluZQpkZWYgZiAjIHJ1Ym9jb3A6ZGlzYWJsZSBTdHlsZS9Gb3IsIE1ldHJpY3MvQWJjU2l6ZQplbmQKLS0tLQoKPT0gU3R5bGUvRG91YmxlTmVnYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjE5CnwgMS4yCnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiBkb3VibGUgbmVnYXRpb24gKGAhIWApIHRvIGNvbnZlcnQgc29tZXRoaW5nIHRvIGEgYm9vbGVhbiB2YWx1ZS4KCldoZW4gdXNpbmcgYEVuZm9yY2VkU3R5bGU6IGFsbG93ZWRfaW5fcmV0dXJuc2AsIGFsbG93IGRvdWJsZSBuZWdhdGlvbiBpbiBjb250ZXh0cwp0aGF0IHVzZSBib29sZWFuIGFzIGEgcmV0dXJuIHZhbHVlLiBXaGVuIHVzaW5nIGBFbmZvcmNlZFN0eWxlOiBmb3JiaWRkZW5gLCBkb3VibGUgbmVnYXRpb24Kc2hvdWxkIGJlIGZvcmJpZGRlbiBhbHdheXMuCgpOT1RFOiB3aGVuIGBzb21ldGhpbmdgIGlzIGEgYm9vbGVhbiB2YWx1ZQpgISFzb21ldGhpbmdgIGFuZCBgIXNvbWV0aGluZy5uaWw/YCBhcmUgbm90IHRoZSBzYW1lIHRoaW5nLgpBcyB5b3UncmUgdW5saWtlbHkgdG8gd3JpdGUgY29kZSB0aGF0IGNhbiBhY2NlcHQgdmFsdWVzIG9mIGFueSB0eXBlCnRoaXMgaXMgcmFyZWx5IGEgcHJvYmxlbSBpbiBwcmFjdGljZS4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSB3aGVuIHRoZSB2YWx1ZSBpcyBgZmFsc2VgLCBiZWNhdXNlIHRoZSByZXN1bHQKb2YgdGhlIGV4cHJlc3Npb24gd2lsbCBjaGFuZ2UuCgpbc291cmNlLHJ1YnldCi0tLS0KISFmYWxzZSAgICAgIz0+IGZhbHNlCiFmYWxzZS5uaWw/ICM9PiB0cnVlCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiEhc29tZXRoaW5nCgojIGdvb2QKIXNvbWV0aGluZy5uaWw/Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYWxsb3dlZF9pbl9yZXR1cm5zIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgZm9vPwogICEhcmV0dXJuX3ZhbHVlCmVuZAoKZGVmaW5lX21ldGhvZCA6Zm9vPyBkbwogICEhcmV0dXJuX3ZhbHVlCmVuZAoKZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QgOmZvbz8gZG8KICAhIXJldHVybl92YWx1ZQplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBmb3JiaWRkZW4KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vPwogICEhcmV0dXJuX3ZhbHVlCmVuZAoKZGVmaW5lX21ldGhvZCA6Zm9vPyBkbwogICEhcmV0dXJuX3ZhbHVlCmVuZAoKZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QgOmZvbz8gZG8KICAhIXJldHVybl92YWx1ZQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYWxsb3dlZF9pbl9yZXR1cm5zYAp8IGBhbGxvd2VkX2luX3JldHVybnNgLCBgZm9yYmlkZGVuYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1iYW5nLWJhbmcKCj09IFN0eWxlL0VhY2hGb3JTaW1wbGVMb29wCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC40MQp8IC0KfD09PQoKQ2hlY2tzIGZvciBsb29wcyB3aGljaCBpdGVyYXRlIGEgY29uc3RhbnQgbnVtYmVyIG9mIHRpbWVzLAp1c2luZyBhIFJhbmdlIGxpdGVyYWwgYW5kIGAjZWFjaGAuIFRoaXMgY2FuIGJlIGRvbmUgbW9yZSByZWFkYWJseSB1c2luZwpgSW50ZWdlciN0aW1lc2AuCgpUaGlzIGNoZWNrIG9ubHkgYXBwbGllcyBpZiB0aGUgYmxvY2sgdGFrZXMgbm8gcGFyYW1ldGVycy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCigxLi41KS5lYWNoIHsgfQoKIyBnb29kCjUudGltZXMgeyB9Ci0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAooMC4uLjEwKS5lYWNoIHt9CgojIGdvb2QKMTAudGltZXMge30KLS0tLQoKPT0gU3R5bGUvRWFjaFdpdGhPYmplY3QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjIyCnwgMC40Mgp8PT09CgpMb29rcyBmb3IgaW5qZWN0IC8gcmVkdWNlIGNhbGxzIHdoZXJlIHRoZSBwYXNzZWQgaW4gb2JqZWN0IGlzCnJldHVybmVkIGF0IHRoZSBlbmQgYW5kIHNvIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGVhY2hfd2l0aF9vYmplY3Qgd2l0aG91dAp0aGUgbmVlZCB0byByZXR1cm4gdGhlIG9iamVjdCBhdCB0aGUgZW5kLgoKSG93ZXZlciwgd2UgY2FuJ3QgcmVwbGFjZSB3aXRoIGVhY2hfd2l0aF9vYmplY3QgaWYgdGhlIGFjY3VtdWxhdG9yCnBhcmFtZXRlciBpcyBhc3NpZ25lZCB0byB3aXRoaW4gdGhlIGJsb2NrLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKWzEsIDJdLmluamVjdCh7fSkgeyB8YSwgZXwgYVtlXSA9IGU7IGEgfQoKIyBnb29kClsxLCAyXS5lYWNoX3dpdGhfb2JqZWN0KHt9KSB7IHxlLCBhfCBhW2VdID0gZSB9Ci0tLS0KCj09IFN0eWxlL0VtcHR5QmxvY2tQYXJhbWV0ZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUyCnwgLQp8PT09CgpDaGVja3MgZm9yIHBpcGVzIGZvciBlbXB0eSBibG9jayBwYXJhbWV0ZXJzLiBQaXBlcyBmb3IgZW1wdHkKYmxvY2sgcGFyYW1ldGVycyBkbyBub3QgY2F1c2Ugc3ludGF4IGVycm9ycywgYnV0IHRoZXkgYXJlIHJlZHVuZGFudC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgZG8gfHwKICBkb19zb21ldGhpbmcKZW5kCgojIGJhZAphIHsgfHwgZG9fc29tZXRoaW5nIH0KCiMgZ29vZAphIGRvCmVuZAoKIyBnb29kCmEgeyBkb19zb21ldGhpbmcgfQotLS0tCgo9PSBTdHlsZS9FbXB0eUNhc2VDb25kaXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQwCnwgLQp8PT09CgpDaGVja3MgZm9yIGNhc2Ugc3RhdGVtZW50cyB3aXRoIGFuIGVtcHR5IGNvbmRpdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkOgpjYXNlCndoZW4geCA9PSAwCiAgcHV0cyAneCBpcyAwJwp3aGVuIHkgPT0gMAogIHB1dHMgJ3kgaXMgMCcKZWxzZQogIHB1dHMgJ25laXRoZXIgaXMgMCcKZW5kCgojIGdvb2Q6CmlmIHggPT0gMAogIHB1dHMgJ3ggaXMgMCcKZWxzaWYgeSA9PSAwCiAgcHV0cyAneSBpcyAwJwplbHNlCiAgcHV0cyAnbmVpdGhlciBpcyAwJwplbmQKCiMgZ29vZDogKHRoZSBjYXNlIGNvbmRpdGlvbiBub2RlIGlzIG5vdCBlbXB0eSkKY2FzZSBuCndoZW4gMAogIHB1dHMgJ3plcm8nCndoZW4gMQogIHB1dHMgJ29uZScKZWxzZQogIHB1dHMgJ21vcmUnCmVuZAotLS0tCgo9PSBTdHlsZS9FbXB0eUVsc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBDb21tYW5kLWxpbmUgb25seQp8IDAuMjgKfCAxLjYxCnw9PT0KCkNoZWNrcyBmb3IgZW1wdHkgZWxzZS1jbGF1c2VzLCBwb3NzaWJseSBpbmNsdWRpbmcgY29tbWVudHMgYW5kL29yIGFuCmV4cGxpY2l0IGBuaWxgIGRlcGVuZGluZyBvbiB0aGUgRW5mb3JjZWRTdHlsZS4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBib3RoIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2FybiBvbiBlbXB0eSBlbHNlIGFuZCBlbHNlIHdpdGggbmlsIGluIGl0CgojIGJhZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZWxzZQogIG5pbAplbmQKCiMgYmFkCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgc3RhdGVtZW50CmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBlbXB0eQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2FybiBvbmx5IG9uIGVtcHR5IGVsc2UKCiMgYmFkCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgbmlsCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgc3RhdGVtZW50CmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBuaWwKCltzb3VyY2UscnVieV0KLS0tLQojIHdhcm4gb24gZWxzZSB3aXRoIG5pbCBpbiBpdAoKIyBiYWQKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVsc2UKICBuaWwKZW5kCgojIGdvb2QKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVsc2UKZW5kCgojIGdvb2QKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVsc2UKICBzdGF0ZW1lbnQKZW5kCgojIGdvb2QKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVuZAotLS0tCgo9PT09IEFsbG93Q29tbWVudHM6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgIyBzb21ldGhpbmcgY29tbWVudAogIG5pbAplbmQKCiMgYmFkCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgIyBzb21ldGhpbmcgY29tbWVudAplbmQKLS0tLQoKPT09PSBBbGxvd0NvbW1lbnRzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgIyBzb21ldGhpbmcgY29tbWVudAogIG5pbAplbmQKCiMgZ29vZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZWxzZQogICMgc29tZXRoaW5nIGNvbW1lbnQKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGJvdGhgCnwgYGVtcHR5YCwgYG5pbGAsIGBib3RoYAoKfCBBbGxvd0NvbW1lbnRzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT0gU3R5bGUvRW1wdHlIZXJlZG9jCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQ29tbWFuZC1saW5lIG9ubHkKfCAxLjMyCnwgMS42MQp8PT09CgpDaGVja3MgZm9yIHVzaW5nIGVtcHR5IGhlcmVkb2MgdG8gcmVkdWNlIHJlZHVuZGFuY3kuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo8PH5FT1MKRU9TCgo8PC1FT1MKRU9TCgo8PEVPUwpFT1MKCiMgZ29vZAonJwoKIyBiYWQKZG9fc29tZXRoaW5nKDw8fkVPUykKRU9TCgpkb19zb21ldGhpbmcoPDwtRU9TKQpFT1MKCmRvX3NvbWV0aGluZyg8PEVPUykKRU9TCgojIGdvb2QKZG9fc29tZXRoaW5nKCcnKQotLS0tCgo9PSBTdHlsZS9FbXB0eUxhbWJkYVBhcmFtZXRlcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcGFyZW50aGVzZXMgZm9yIGVtcHR5IGxhbWJkYSBwYXJhbWV0ZXJzLiBQYXJlbnRoZXNlcwpmb3IgZW1wdHkgbGFtYmRhIHBhcmFtZXRlcnMgZG8gbm90IGNhdXNlIHN5bnRheCBlcnJvcnMsIGJ1dCB0aGV5IGFyZQpyZWR1bmRhbnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAotPiAoKSB7IGRvX3NvbWV0aGluZyB9CgojIGdvb2QKLT4geyBkb19zb21ldGhpbmcgfQoKIyBnb29kCi0+IChhcmcpIHsgZG9fc29tZXRoaW5nKGFyZykgfQotLS0tCgo9PSBTdHlsZS9FbXB0eUxpdGVyYWwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjEyCnw9PT0KCkNoZWNrcyBmb3IgdGhlIHVzZSBvZiBhIG1ldGhvZCwgdGhlIHJlc3VsdCBvZiB3aGljaAp3b3VsZCBiZSBhIGxpdGVyYWwsIGxpa2UgYW4gZW1wdHkgYXJyYXksIGhhc2gsIG9yIHN0cmluZy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgPSBBcnJheS5uZXcKaCA9IEhhc2gubmV3CnMgPSBTdHJpbmcubmV3CgojIGdvb2QKYSA9IFtdCmggPSB7fQpzID0gJycKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbGl0ZXJhbC1hcnJheS1oYXNoCgo9PSBTdHlsZS9FbXB0eU1ldGhvZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IENvbW1hbmQtbGluZSBvbmx5CnwgMC40Ngp8IDEuNjEKfD09PQoKQ2hlY2tzIGZvciB0aGUgZm9ybWF0dGluZyBvZiBlbXB0eSBtZXRob2QgZGVmaW5pdGlvbnMuCkJ5IGRlZmF1bHQgaXQgZW5mb3JjZXMgZW1wdHkgbWV0aG9kIGRlZmluaXRpb25zIHRvIGdvIG9uIGEgc2luZ2xlCmxpbmUgKGNvbXBhY3Qgc3R5bGUpLCBidXQgaXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gZW5mb3JjZSB0aGUgYGVuZGAKdG8gZ28gb24gaXRzIG93biBsaW5lIChleHBhbmRlZCBzdHlsZSkuCgpOT1RFOiBBIG1ldGhvZCBkZWZpbml0aW9uIGlzIG5vdCBjb25zaWRlcmVkIGVtcHR5IGlmIGl0IGNvbnRhaW5zCmNvbW1lbnRzLgoKTk9URTogQXV0b2NvcnJlY3Rpb24gd2lsbCBub3QgYmUgYXBwbGllZCBmb3IgdGhlIGBjb21wYWN0YCBzdHlsZQppZiB0aGUgcmVzdWx0aW5nIGNvZGUgaXMgbG9uZ2VyIHRoYW4gdGhlIGBNYXhgIGNvbmZpZ3VyYXRpb24gZm9yCmBMYXlvdXQvTGluZUxlbmd0aGAsIGJ1dCBhbiBvZmZlbnNlIHdpbGwgc3RpbGwgYmUgcmVnaXN0ZXJlZC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBjb21wYWN0IChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28oYmFyKQplbmQKCmRlZiBzZWxmLmZvbyhiYXIpCmVuZAoKIyBnb29kCmRlZiBmb28oYmFyKTsgZW5kCgpkZWYgZm9vKGJhcikKICAjIGJhegplbmQKCmRlZiBzZWxmLmZvbyhiYXIpOyBlbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBleHBhbmRlZAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28oYmFyKTsgZW5kCgpkZWYgc2VsZi5mb28oYmFyKTsgZW5kCgojIGdvb2QKZGVmIGZvbyhiYXIpCmVuZAoKZGVmIHNlbGYuZm9vKGJhcikKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGNvbXBhY3RgCnwgYGNvbXBhY3RgLCBgZXhwYW5kZWRgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLXNpbmdsZS1saW5lLW1ldGhvZHMKCj09IFN0eWxlL0VuY29kaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC41MAp8PT09CgpDaGVja3MgZW5zdXJlcyBzb3VyY2UgZmlsZXMgaGF2ZSBubyB1dGYtOCBlbmNvZGluZyBjb21tZW50cy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgZW5jb2Rpbmc6IFVURi04CiMgY29kaW5nOiBVVEYtOAojIC0qLSBjb2Rpbmc6IFVURi04IC0qLQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSN1dGYtOAoKPT0gU3R5bGUvRW5kQmxvY2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjgxCnw9PT0KCkNoZWNrcyBmb3IgRU5EIGJsb2Nrcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkVORCB7IHB1dHMgJ0dvb2RieWUhJyB9CgojIGdvb2QKYXRfZXhpdCB7IHB1dHMgJ0dvb2RieWUhJyB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLUVORC1ibG9ja3MKCj09IFN0eWxlL0VuZGxlc3NNZXRob2QKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMy4wCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS44CnwgLQp8PT09CgpDaGVja3MgZm9yIGVuZGxlc3MgbWV0aG9kcy4KCkl0IGNhbiBlbmZvcmNlIGVpdGhlciB0aGUgdXNlIG9mIGVuZGxlc3MgbWV0aG9kcyBkZWZpbml0aW9ucwpmb3Igc2luZ2xlLWxpbmVkIG1ldGhvZCBib2RpZXMsIG9yIGRpc2FsbG93IGVuZGxlc3MgbWV0aG9kcy4KCk90aGVyIG1ldGhvZCBkZWZpbml0aW9uIHR5cGVzIGFyZSBub3QgY29uc2lkZXJlZCBieSB0aGlzIGNvcC4KClRoZSBzdXBwb3J0ZWQgc3R5bGVzIGFyZToKCiogYWxsb3dfc2luZ2xlX2xpbmUgKGRlZmF1bHQpIC0gb25seSBzaW5nbGUgbGluZSBlbmRsZXNzIG1ldGhvZCBkZWZpbml0aW9ucyBhcmUgYWxsb3dlZC4KKiBhbGxvd19hbHdheXMgLSBhbGwgZW5kbGVzcyBtZXRob2QgZGVmaW5pdGlvbnMgYXJlIGFsbG93ZWQuCiogZGlzYWxsb3cgLSBhbGwgZW5kbGVzcyBtZXRob2QgZGVmaW5pdGlvbnMgYXJlIGRpc2FsbG93ZWQuCgpOT1RFOiBJbmNvcnJlY3QgZW5kbGVzcyBtZXRob2QgZGVmaW5pdGlvbnMgd2lsbCBhbHdheXMgYmUKY29ycmVjdGVkIHRvIGEgbXVsdGktbGluZSBkZWZpbml0aW9uLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFsbG93X3NpbmdsZV9saW5lIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgbXlfbWV0aG9kKCkgPSB4CgojIGJhZCwgbXVsdGktbGluZSBlbmRsZXNzIG1ldGhvZApkZWYgbXlfbWV0aG9kKCkgPSB4LmZvbwogICAgICAgICAgICAgICAgICAgLmJhcgogICAgICAgICAgICAgICAgICAgLmJhegotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFsbG93X2Fsd2F5cwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgbXlfbWV0aG9kKCkgPSB4CgojIGdvb2QKZGVmIG15X21ldGhvZCgpID0geC5mb28KICAgICAgICAgICAgICAgICAgIC5iYXIKICAgICAgICAgICAgICAgICAgIC5iYXoKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBkaXNhbGxvdwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBteV9tZXRob2QoKSA9IHgKCiMgYmFkCmRlZiBteV9tZXRob2QoKSA9IHguZm9vCiAgICAgICAgICAgICAgICAgICAuYmFyCiAgICAgICAgICAgICAgICAgICAuYmF6Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGFsbG93X3NpbmdsZV9saW5lYAp8IGBhbGxvd19zaW5nbGVfbGluZWAsIGBhbGxvd19hbHdheXNgLCBgZGlzYWxsb3dgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2VuZGxlc3MtbWV0aG9kcwoKPT0gU3R5bGUvRW52SG9tZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4yOQp8IC0KfD09PQoKQ2hlY2tzIGZvciBjb25zaXN0ZW50IHVzYWdlIG9mIGBFTlZbJ0hPTUUnXWAuIElmIGBuaWxgIGlzIHVzZWQgYXMKdGhlIHNlY29uZCBhcmd1bWVudCBvZiBgRU5WLmZldGNoYCwgaXQgaXMgdHJlYXRlZCBhcyBhIGJhZCBjYXNlIGxpa2UgYEVOVltdYC4KCj09PSBTYWZldHkKClRoZSBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgdGhlIHJlc3VsdCB3aGVuIGBuaWxgIGlzIGFzc2lnbmVkIHRvIGBFTlZbJ0hPTUUnXWAgY2hhbmdlczoKCltzb3VyY2UscnVieV0KLS0tLQpFTlZbJ0hPTUUnXSA9IG5pbApFTlZbJ0hPTUUnXSAjID0+IG5pbApEaXIuaG9tZSAgICAjID0+ICcvaG9tZS9mb28nCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkVOVlsnSE9NRSddCkVOVi5mZXRjaCgnSE9NRScsIG5pbCkKCiMgZ29vZApEaXIuaG9tZQoKIyBnb29kCkVOVi5mZXRjaCgnSE9NRScsIGRlZmF1bHQpCi0tLS0KCj09IFN0eWxlL0V2YWxXaXRoTG9jYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUyCnwgLQp8PT09CgpFbnN1cmVzIHRoYXQgZXZhbCBtZXRob2RzIChgZXZhbGAsIGBpbnN0YW5jZV9ldmFsYCwgYGNsYXNzX2V2YWxgCmFuZCBgbW9kdWxlX2V2YWxgKSBhcmUgZ2l2ZW4gZmlsZW5hbWUgYW5kIGxpbmUgbnVtYmVyIHZhbHVlcyAoYFxfXF9GSUxFXF9cX2AKYW5kIGBcX1xfTElORVxfXF9gKS4gVGhpcyBkYXRhIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYW55IGVycm9ycyByYWlzZWQKd2l0aGluIHRoZSBldmFsdWF0ZWQgY29kZSB3aWxsIGJlIGdpdmVuIHRoZSBjb3JyZWN0IGlkZW50aWZpY2F0aW9uCmluIGEgYmFja3RyYWNlLgoKVGhlIGNvcCBhbHNvIGNoZWNrcyB0aGF0IHRoZSBsaW5lIG51bWJlciBnaXZlbiByZWxhdGl2ZSB0byBgXF9cX0xJTkVcX1xfYCBpcwpjb3JyZWN0LgoKVGhpcyBjb3Agd2lsbCBhdXRvY29ycmVjdCBpbmNvcnJlY3Qgb3IgbWlzc2luZyBmaWxlbmFtZSBhbmQgbGluZSBudW1iZXIKdmFsdWVzLiBIb3dldmVyLCBpZiBgZXZhbGAgaXMgY2FsbGVkIHdpdGhvdXQgYSBiaW5kaW5nIGFyZ3VtZW50LCB0aGUgY29wCndpbGwgbm90IGF0dGVtcHQgdG8gYXV0b21hdGljYWxseSBhZGQgYSBiaW5kaW5nLCBvciBhZGQgZmlsZW5hbWUgYW5kCmxpbmUgdmFsdWVzLgoKVGhpcyBjb3Agd29ya3Mgb25seSB3aGVuIGEgc3RyaW5nIGxpdGVyYWwgaXMgZ2l2ZW4gYXMgYSBjb2RlIHN0cmluZy4KTm8gb2ZmZW5zZSBpcyByZXBvcnRlZCBpZiBhIHN0cmluZyB2YXJpYWJsZSBpcyBnaXZlbiBhcyBiZWxvdzoKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV2YWwgPDwtUlVCWQogIGRlZiBkb19zb21ldGhpbmcKICBlbmQKUlVCWQoKIyBiYWQKQy5jbGFzc19ldmFsIDw8LVJVQlkKICBkZWYgZG9fc29tZXRoaW5nCiAgZW5kClJVQlkKCiMgZ29vZApldmFsIDw8LVJVQlksIGJpbmRpbmcsIF9fRklMRV9fLCBfX0xJTkVfXyArIDEKICBkZWYgZG9fc29tZXRoaW5nCiAgZW5kClJVQlkKCiMgZ29vZApDLmNsYXNzX2V2YWwgPDwtUlVCWSwgX19GSUxFX18sIF9fTElORV9fICsgMQogIGRlZiBkb19zb21ldGhpbmcKICBlbmQKUlVCWQotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBub3QgY2hlY2tlZApjb2RlID0gPDwtUlVCWQogIGRlZiBkb19zb21ldGhpbmcKICBlbmQKUlVCWQpldmFsIGNvZGUKLS0tLQoKPT0gU3R5bGUvRXZlbk9kZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTIKfCAwLjI5Cnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIGBJbnRlZ2VyI2V2ZW4/YCBvciBgSW50ZWdlciNvZGQ/YApjYW4gYmUgdXNlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIHggJSAyID09IDAKZW5kCgojIGdvb2QKaWYgeC5ldmVuPwplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjcHJlZGljYXRlLW1ldGhvZHMKCj09IFN0eWxlL0V4YWN0UmVnZXhwTWF0Y2gKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjUxCnwgLQp8PT09CgpDaGVja3MgZm9yIGV4YWN0IHJlZ2V4cCBtYXRjaCBpbnNpZGUgUmVnZXhwIGxpdGVyYWxzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3RyaW5nID1+IC9cQXN0cmluZ1x6LwpzdHJpbmcgPT09IC9cQXN0cmluZ1x6LwpzdHJpbmcubWF0Y2goL1xBc3RyaW5nXHovKQpzdHJpbmcubWF0Y2g/KC9cQXN0cmluZ1x6LykKCiMgZ29vZApzdHJpbmcgPT0gJ3N0cmluZycKCiMgYmFkCnN0cmluZyAhfiAvXEFzdHJpbmdcei8KCiMgZ29vZApzdHJpbmcgIT0gJ3N0cmluZycKLS0tLQoKPT0gU3R5bGUvRXhwYW5kUGF0aEFyZ3VtZW50cwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdXNlIG9mIHRoZSBgRmlsZS5leHBhbmRfcGF0aGAgYXJndW1lbnRzLgpMaWtld2lzZSwgaXQgYWxzbyBjaGVja3MgZm9yIHRoZSBgUGF0aG5hbWUubmV3YCBhcmd1bWVudC4KCkNvbnRyYXN0aXZlIGJhZCBjYXNlIGFuZCBnb29kIGNhc2UgYXJlIGFsdGVybmF0ZWx5IHNob3duIGluCnRoZSBmb2xsb3dpbmcgZXhhbXBsZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApGaWxlLmV4cGFuZF9wYXRoKCcuLicsIF9fRklMRV9fKQoKIyBnb29kCkZpbGUuZXhwYW5kX3BhdGgoX19kaXJfXykKCiMgYmFkCkZpbGUuZXhwYW5kX3BhdGgoJy4uLy4uJywgX19GSUxFX18pCgojIGdvb2QKRmlsZS5leHBhbmRfcGF0aCgnLi4nLCBfX2Rpcl9fKQoKIyBiYWQKRmlsZS5leHBhbmRfcGF0aCgnLicsIF9fRklMRV9fKQoKIyBnb29kCkZpbGUuZXhwYW5kX3BhdGgoX19GSUxFX18pCgojIGJhZApQYXRobmFtZShfX0ZJTEVfXykucGFyZW50LmV4cGFuZF9wYXRoCgojIGdvb2QKUGF0aG5hbWUoX19kaXJfXykuZXhwYW5kX3BhdGgKCiMgYmFkClBhdGhuYW1lLm5ldyhfX0ZJTEVfXykucGFyZW50LmV4cGFuZF9wYXRoCgojIGdvb2QKUGF0aG5hbWUubmV3KF9fZGlyX18pLmV4cGFuZF9wYXRoCi0tLS0KCj09IFN0eWxlL0V4cGxpY2l0QmxvY2tBcmd1bWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuODkKfCAxLjgKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBleHBsaWNpdCBibG9jayBhcmd1bWVudCB0byBhdm9pZCB3cml0aW5nCmJsb2NrIGxpdGVyYWwgdGhhdCBqdXN0IHBhc3NlcyBpdHMgYXJndW1lbnRzIHRvIGFub3RoZXIgYmxvY2suCgpOT1RFOiBUaGlzIGNvcCBvbmx5IHJlZ2lzdGVycyBhbiBvZmZlbnNlIGlmIHRoZSBibG9jayBhcmdzIG1hdGNoIHRoZQp5aWVsZCBhcmdzIGV4YWN0bHkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgd2l0aF90bXBfZGlyCiAgRGlyLm1rdG1wZGlyIGRvIHx0bXBfZGlyfAogICAgRGlyLmNoZGlyKHRtcF9kaXIpIHsgfGRpcnwgeWllbGQgZGlyIH0gIyBibG9jayBqdXN0IHBhc3NlcyBhcmd1bWVudHMKICBlbmQKZW5kCgojIGJhZApkZWYgbmluZV90aW1lcwogIDkudGltZXMgeyB5aWVsZCB9CmVuZAoKIyBnb29kCmRlZiB3aXRoX3RtcF9kaXIoJmJsb2NrKQogIERpci5ta3RtcGRpciBkbyB8dG1wX2RpcnwKICAgIERpci5jaGRpcih0bXBfZGlyLCAmYmxvY2spCiAgZW5kCmVuZAoKd2l0aF90bXBfZGlyIGRvIHxkaXJ8CiAgcHV0cyAiZGlyIGlzIGFjY2Vzc2libGUgYXMgYSBwYXJhbWV0ZXIgYW5kIHB3ZCBpcyBzZXQ6ICN7ZGlyfSIKZW5kCgojIGdvb2QKZGVmIG5pbmVfdGltZXMoJmJsb2NrKQogIDkudGltZXMoJmJsb2NrKQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYmxvY2stYXJndW1lbnQKCj09IFN0eWxlL0V4cG9uZW50aWFsTm90YXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuODIKfCAtCnw9PT0KCkVuZm9yY2VzIGNvbnNpc3RlbmN5IHdoZW4gdXNpbmcgZXhwb25lbnRpYWwgbm90YXRpb24KZm9yIG51bWJlcnMgaW4gdGhlIGNvZGUgKGVnIDEuMmU0KS4gRGlmZmVyZW50IHN0eWxlcyBhcmUgc3VwcG9ydGVkOgoKKiBgc2NpZW50aWZpY2Agd2hpY2ggZW5mb3JjZXMgYSBtYW50aXNzYSBiZXR3ZWVuIDEgKGluY2x1c2l2ZSkgYW5kIDEwIChleGNsdXNpdmUpLgoqIGBlbmdpbmVlcmluZ2Agd2hpY2ggZW5mb3JjZXMgdGhlIGV4cG9uZW50IHRvIGJlIGEgbXVsdGlwbGUgb2YgMyBhbmQgdGhlIG1hbnRpc3NhCiAgdG8gYmUgYmV0d2VlbiAwLjEgKGluY2x1c2l2ZSkgYW5kIDEwIChleGNsdXNpdmUpLgoqIGBpbnRlZ3JhbGAgd2hpY2ggZW5mb3JjZXMgdGhlIG1hbnRpc3NhIHRvIGFsd2F5cyBiZSBhIHdob2xlIG51bWJlciB3aXRob3V0CiAgdHJhaWxpbmcgemVyb2VzLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNjaWVudGlmaWMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBFbmZvcmNlcyBhIG1hbnRpc3NhIGJldHdlZW4gMSAoaW5jbHVzaXZlKSBhbmQgMTAgKGV4Y2x1c2l2ZSkuCgojIGJhZAoxMGU2CjAuM2U0CjExLjdlNQozLjE0ZTAKCiMgZ29vZAoxZTcKM2UzCjEuMTdlNgozLjE0Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogZW5naW5lZXJpbmcKCltzb3VyY2UscnVieV0KLS0tLQojIEVuZm9yY2VzIHVzaW5nIG11bHRpcGxlIG9mIDMgZXhwb25lbnRzLAojIG1hbnRpc3NhIHNob3VsZCBiZSBiZXR3ZWVuIDAuMSAoaW5jbHVzaXZlKSBhbmQgMTAwMCAoZXhjbHVzaXZlKQoKIyBiYWQKMy4yZTcKMC4xZTUKMTJlNQoxMjMyZTYKCiMgZ29vZAozMmU2CjEwZTMKMS4yZTYKMS4yMzJlOQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGludGVncmFsCgpbc291cmNlLHJ1YnldCi0tLS0KIyBFbmZvcmNlcyB0aGUgbWFudGlzc2EgdG8gaGF2ZSBubyBkZWNpbWFsIHBhcnQgYW5kIG5vCiMgdHJhaWxpbmcgemVyb2VzLgoKIyBiYWQKMy4yZTcKMC4xZTUKMTIwZTQKCiMgZ29vZAozMmU2CjFlNAoxMmU1Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHNjaWVudGlmaWNgCnwgYHNjaWVudGlmaWNgLCBgZW5naW5lZXJpbmdgLCBgaW50ZWdyYWxgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2V4cG9uZW50aWFsLW5vdGF0aW9uCgo9PSBTdHlsZS9GZXRjaEVudlZhcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuMjgKfCAtCnw9PT0KClN1Z2dlc3RzIGBFTlYuZmV0Y2hgIGZvciB0aGUgcmVwbGFjZW1lbnQgb2YgYEVOVltdYC4KYEVOVltdYCBzaWxlbnRseSBmYWlscyBhbmQgcmV0dXJucyBgbmlsYCB3aGVuIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyB1bnNldCwKd2hpY2ggbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzIHdoZW4gdGhlIGRldmVsb3BlciBmb3JnZXRzIHRvIHNldCBpdC4KT24gdGhlIG90aGVyIGhhbmQsIGBFTlYuZmV0Y2hgIHJhaXNlcyBLZXlFcnJvciBvciByZXR1cm5zIHRoZSBleHBsaWNpdGx5CnNwZWNpZmllZCBkZWZhdWx0IHZhbHVlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRU5WWydYJ10KeCA9IEVOVlsnWCddCgojIGdvb2QKRU5WLmZldGNoKCdYJykKeCA9IEVOVi5mZXRjaCgnWCcpCgojIGFsc28gZ29vZAohRU5WWydYJ10KRU5WWydYJ10uc29tZV9tZXRob2QgIyAoZS5nLiBgLm5pbD9gKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZFZhcnMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUvI2hhc2gtZmV0Y2gtZGVmYXVsdHMKCj09IFN0eWxlL0ZpbGVFbXB0eQoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNDgKfCAtCnw9PT0KClByZWZlciB0byB1c2UgYEZpbGUuZW1wdHk/KCdwYXRoL3RvL2ZpbGUnKWAgd2hlbiBjaGVja2luZyBpZiBhIGZpbGUgaXMgZW1wdHkuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUsIGJlY2F1c2UgYEZpbGUuc2l6ZWAsIGBGaWxlLnJlYWRgLCBhbmQgYEZpbGUuYmlucmVhZGAKcmFpc2UgYEVOT0VOVGAgZXhjZXB0aW9uIHdoZW4gdGhlcmUgaXMgbm8gZmlsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXRoLAp3aGlsZSBgRmlsZS5lbXB0eT9gIGRvZXMgbm90IHJhaXNlIGFuIGV4Y2VwdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkZpbGUuemVybz8oJ3BhdGgvdG8vZmlsZScpCkZpbGUuc2l6ZSgncGF0aC90by9maWxlJykgPT0gMApGaWxlLnNpemUoJ3BhdGgvdG8vZmlsZScpID49IDAKRmlsZS5zaXplKCdwYXRoL3RvL2ZpbGUnKS56ZXJvPwpGaWxlLnJlYWQoJ3BhdGgvdG8vZmlsZScpLmVtcHR5PwpGaWxlLmJpbnJlYWQoJ3BhdGgvdG8vZmlsZScpID09ICcnCkZpbGVUZXN0Lnplcm8/KCdwYXRoL3RvL2ZpbGUnKQoKIyBnb29kCkZpbGUuZW1wdHk/KCdwYXRoL3RvL2ZpbGUnKQpGaWxlVGVzdC5lbXB0eT8oJ3BhdGgvdG8vZmlsZScpCi0tLS0KCj09IFN0eWxlL0ZpbGVSZWFkCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS4yNAp8IC0KfD09PQoKRmF2b3IgYEZpbGUuKGJpbilyZWFkYCBjb252ZW5pZW5jZSBtZXRob2RzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyMgdGV4dCBtb2RlCiMgYmFkCkZpbGUub3BlbihmaWxlbmFtZSkucmVhZApGaWxlLm9wZW4oZmlsZW5hbWUsICY6cmVhZCkKRmlsZS5vcGVuKGZpbGVuYW1lKSB7IHxmfCBmLnJlYWQgfQpGaWxlLm9wZW4oZmlsZW5hbWUpIGRvIHxmfAogIGYucmVhZAplbmQKRmlsZS5vcGVuKGZpbGVuYW1lLCAncicpLnJlYWQKRmlsZS5vcGVuKGZpbGVuYW1lLCAncicsICY6cmVhZCkKRmlsZS5vcGVuKGZpbGVuYW1lLCAncicpIGRvIHxmfAogIGYucmVhZAplbmQKCiMgZ29vZApGaWxlLnJlYWQoZmlsZW5hbWUpCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIyBiaW5hcnkgbW9kZQojIGJhZApGaWxlLm9wZW4oZmlsZW5hbWUsICdyYicpLnJlYWQKRmlsZS5vcGVuKGZpbGVuYW1lLCAncmInLCAmOnJlYWQpCkZpbGUub3BlbihmaWxlbmFtZSwgJ3JiJykgZG8gfGZ8CiAgZi5yZWFkCmVuZAoKIyBnb29kCkZpbGUuYmlucmVhZChmaWxlbmFtZSkKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZmlsZS1yZWFkCgo9PSBTdHlsZS9GaWxlV3JpdGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjI0CnwgLQp8PT09CgpGYXZvciBgRmlsZS4oYmluKXdyaXRlYCBjb252ZW5pZW5jZSBtZXRob2RzLgoKTk9URTogVGhlcmUgYXJlIGRpZmZlcmVudCBtZXRob2Qgc2lnbmF0dXJlcyBiZXR3ZWVuIGBGaWxlLndyaXRlYCAoY2xhc3MgbWV0aG9kKQphbmQgYEZpbGUjd3JpdGVgIChpbnN0YW5jZSBtZXRob2QpLiBUaGUgZm9sbG93aW5nIGNhc2Ugd2lsbCBiZSBhbGxvd2VkIGJlY2F1c2UKc3RhdGljIGFuYWx5c2lzIGRvZXMgbm90IGtub3cgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGxhdCBhcmd1bWVudDoKCltzb3VyY2UscnVieV0KLS0tLQpGaWxlLm9wZW4oZmlsZW5hbWUsICd3JykgZG8gfGZ8CiAgZi53cml0ZSgqb2JqZWN0cykKZW5kCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMjIHRleHQgbW9kZQojIGJhZApGaWxlLm9wZW4oZmlsZW5hbWUsICd3Jykud3JpdGUoY29udGVudCkKRmlsZS5vcGVuKGZpbGVuYW1lLCAndycpIGRvIHxmfAogIGYud3JpdGUoY29udGVudCkKZW5kCgojIGdvb2QKRmlsZS53cml0ZShmaWxlbmFtZSwgY29udGVudCkKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMjIGJpbmFyeSBtb2RlCiMgYmFkCkZpbGUub3BlbihmaWxlbmFtZSwgJ3diJykud3JpdGUoY29udGVudCkKRmlsZS5vcGVuKGZpbGVuYW1lLCAnd2InKSBkbyB8ZnwKICBmLndyaXRlKGNvbnRlbnQpCmVuZAoKIyBnb29kCkZpbGUuYmlud3JpdGUoZmlsZW5hbWUsIGNvbnRlbnQpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2ZpbGUtd3JpdGUKCj09IFN0eWxlL0Zsb2F0RGl2aXNpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNzIKfCAxLjkKfD09PQoKQ2hlY2tzIGZvciBkaXZpc2lvbiB3aXRoIGludGVnZXJzIGNvZXJjZWQgdG8gZmxvYXRzLgpJdCBpcyByZWNvbW1lbmRlZCB0byBlaXRoZXIgYWx3YXlzIHVzZSBgZmRpdmAgb3IgY29lcmNlIG9uZSBzaWRlIG9ubHkuClRoaXMgY29wIGFsc28gcHJvdmlkZXMgb3RoZXIgb3B0aW9ucyBmb3IgY29kZSBjb25zaXN0ZW5jeS4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSwgYmVjYXVzZSBpZiB0aGUgb3BlcmFuZCB2YXJpYWJsZSBpcyBhIHN0cmluZyBvYmplY3QKdGhlbiBgLnRvX2ZgIHdpbGwgYmUgcmVtb3ZlZCBhbmQgYW4gZXJyb3Igd2lsbCBvY2N1ci4KCltzb3VyY2UscnVieV0KLS0tLQphID0gJzEuMicKYiA9ICczLjQnCmEudG9fZiAvIGIudG9fZiAjIEJvdGggYHRvX2ZgIGNhbGxzIGFyZSByZXF1aXJlZCBoZXJlCi0tLS0KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBzaW5nbGVfY29lcmNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEudG9fZiAvIGIudG9fZgoKIyBnb29kCmEudG9fZiAvIGIKYSAvIGIudG9fZgotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGxlZnRfY29lcmNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSAvIGIudG9fZgphLnRvX2YgLyBiLnRvX2YKCiMgZ29vZAphLnRvX2YgLyBiCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmlnaHRfY29lcmNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYS50b19mIC8gYgphLnRvX2YgLyBiLnRvX2YKCiMgZ29vZAphIC8gYi50b19mCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogZmRpdgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgLyBiLnRvX2YKYS50b19mIC8gYgphLnRvX2YgLyBiLnRvX2YKCiMgZ29vZAphLmZkaXYoYikKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2luZ2xlX2NvZXJjZWAKfCBgbGVmdF9jb2VyY2VgLCBgcmlnaHRfY29lcmNlYCwgYHNpbmdsZV9jb2VyY2VgLCBgZmRpdmAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZmxvYXQtZGl2aXNpb24KKiBodHRwczovL2Jsb2cucnVieXN0eWxlLmd1aWRlL3J1YnkvMjAxOS8wNi8yMS9mbG9hdC1kaXZpc2lvbi5odG1sCgo9PSBTdHlsZS9Gb3IKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjEzCnwgMS4yNgp8PT09CgpMb29rcyBmb3IgdXNlcyBvZiB0aGUgYGZvcmAga2V5d29yZCBvciBgZWFjaGAgbWV0aG9kLiBUaGUKcHJlZmVycmVkIGFsdGVybmF0aXZlIGlzIHNldCBpbiB0aGUgRW5mb3JjZWRTdHlsZSBjb25maWd1cmF0aW9uCnBhcmFtZXRlci4gQW4gYGVhY2hgIGNhbGwgd2l0aCBhIGJsb2NrIG9uIGEgc2luZ2xlIGxpbmUgaXMgYWx3YXlzCmFsbG93ZWQuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIHRoZSBzY29wZSBvZgp2YXJpYWJsZXMgaXMgZGlmZmVyZW50IGJldHdlZW4gYGVhY2hgIGFuZCBgZm9yYC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBlYWNoIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28KICBmb3IgbiBpbiBbMSwgMiwgM10gZG8KICAgIHB1dHMgbgogIGVuZAplbmQKCiMgZ29vZApkZWYgZm9vCiAgWzEsIDIsIDNdLmVhY2ggZG8gfG58CiAgICBwdXRzIG4KICBlbmQKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogZm9yCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvbwogIFsxLCAyLCAzXS5lYWNoIGRvIHxufAogICAgcHV0cyBuCiAgZW5kCmVuZAoKIyBnb29kCmRlZiBmb28KICBmb3IgbiBpbiBbMSwgMiwgM10gZG8KICAgIHB1dHMgbgogIGVuZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZWFjaGAKfCBgZWFjaGAsIGBmb3JgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLWZvci1sb29wcwoKPT0gU3R5bGUvRm9ybWF0U3RyaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xOQp8IDAuNDkKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBhIHNpbmdsZSBzdHJpbmcgZm9ybWF0dGluZyB1dGlsaXR5LgpWYWxpZCBvcHRpb25zIGluY2x1ZGUgYEtlcm5lbCNmb3JtYXRgLCBgS2VybmVsI3NwcmludGZgLCBhbmQgYFN0cmluZyMlYC4KClRoZSBkZXRlY3Rpb24gb2YgYFN0cmluZyMlYCBjYW5ub3QgYmUgaW1wbGVtZW50ZWQgaW4gYSByZWxpYWJsZQptYW5uZXIgZm9yIGFsbCBjYXNlcywgc28gb25seSB0d28gc2NlbmFyaW9zIGFyZSBjb25zaWRlcmVkIC0KaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIGlmIHRoZSBzZWNvbmQKYXJndW1lbnQgaXMgYW4gYXJyYXkgbGl0ZXJhbC4KCkF1dG9jb3JyZWN0aW9uIHdpbGwgYmUgYXBwbGllZCB3aGVuIHVzaW5nIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbCBvciBrbm93biBidWlsdC1pbiBjb252ZXJzaW9uCm1ldGhvZHMgc3VjaCBhcyBgdG9fZGAsIGB0b19mYCwgYHRvX2hgLCBgdG9faWAsIGB0b19yYCwgYHRvX3NgLCBhbmQgYHRvX3N5bWAgb24gdmFyaWFibGVzLApwcm92aWRlZCB0aGF0IHRoZWlyIHJldHVybiB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuIEZvciBleGFtcGxlLCB3aGVuIHVzaW5nIGB0b19zYCwKYCclcycgJSBbMSwgMiwgM10udG9fc2AgY2FuIGJlIGF1dG9jb3JyZWN0ZWQgd2l0aG91dCBhbnkgaW5jb21wYXRpYmlsaXR5OgoKW3NvdXJjZSxydWJ5XQotLS0tCiclcycgJSBbMSwgMiwgM10gICAgICAgICM9PiAnMScKZm9ybWF0KCclcycsIFsxLCAyLCAzXSkgIz0+ICdbMSwgMiwgM10nCiclcycgJSBbMSwgMiwgM10udG9fcyAgICM9PiAnWzEsIDIsIDNdJwotLS0tCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogZm9ybWF0IChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnB1dHMgc3ByaW50ZignJTEwcycsICdmb28nKQpwdXRzICclMTBzJyAlICdmb28nCgojIGdvb2QKcHV0cyBmb3JtYXQoJyUxMHMnLCAnZm9vJykKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBzcHJpbnRmCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcHV0cyBmb3JtYXQoJyUxMHMnLCAnZm9vJykKcHV0cyAnJTEwcycgJSAnZm9vJwoKIyBnb29kCnB1dHMgc3ByaW50ZignJTEwcycsICdmb28nKQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHBlcmNlbnQKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApwdXRzIGZvcm1hdCgnJTEwcycsICdmb28nKQpwdXRzIHNwcmludGYoJyUxMHMnLCAnZm9vJykKCiMgZ29vZApwdXRzICclMTBzJyAlICdmb28nCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGZvcm1hdGAKfCBgZm9ybWF0YCwgYHNwcmludGZgLCBgcGVyY2VudGAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc3ByaW50ZgoKPT0gU3R5bGUvRm9ybWF0U3RyaW5nVG9rZW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ5CnwgMS4wCnw9PT0KClVzZSBhIGNvbnNpc3RlbnQgc3R5bGUgZm9yIG5hbWVkIGZvcm1hdCBzdHJpbmcgdG9rZW5zLgoKTk9URTogYHVuYW5ub3RhdGVkYCBzdHlsZSBjb3Agb25seSB3b3JrcyBmb3Igc3RyaW5ncwp3aGljaCBhcmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byB0aG9zZSBtZXRob2RzOgpgcHJpbnRmYCwgYHNwcmludGZgLCBgZm9ybWF0YCwgYCVgLgpUaGUgcmVhc29uIGlzIHRoYXQgX3VuYW5ub3RhdGVkXyBmb3JtYXQgaXMgdmVyeSBzaW1pbGFyCnRvIGVuY29kZWQgVVJMcyBvciBEYXRlL1RpbWUgZm9ybWF0dGluZyBzdHJpbmdzLgoKVGhpcyBjb3AgY2FuIGJlIGN1c3RvbWl6ZWQgYWxsb3dlZCBtZXRob2RzIHdpdGggYEFsbG93ZWRNZXRob2RzYC4KQnkgZGVmYXVsdCwgdGhlcmUgYXJlIG5vIG1ldGhvZHMgdG8gYWxsb3dlZC4KCkl0IGlzIGFsbG93ZWQgdG8gY29udGFpbiB1bmFubm90YXRlZCB0b2tlbgppZiB0aGUgbnVtYmVyIG9mIHRoZW0gaXMgbGVzcyB0aGFuIG9yIGVxdWFscyB0bwpgTWF4VW5hbm5vdGF0ZWRQbGFjZWhvbGRlcnNBbGxvd2VkYC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBhbm5vdGF0ZWQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9ybWF0KCcle2dyZWV0aW5nfScsIGdyZWV0aW5nOiAnSGVsbG8nKQpmb3JtYXQoJyVzJywgJ0hlbGxvJykKCiMgZ29vZApmb3JtYXQoJyU8Z3JlZXRpbmc+cycsIGdyZWV0aW5nOiAnSGVsbG8nKQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHRlbXBsYXRlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9ybWF0KCclPGdyZWV0aW5nPnMnLCBncmVldGluZzogJ0hlbGxvJykKZm9ybWF0KCclcycsICdIZWxsbycpCgojIGdvb2QKZm9ybWF0KCcle2dyZWV0aW5nfScsIGdyZWV0aW5nOiAnSGVsbG8nKQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHVuYW5ub3RhdGVkCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9ybWF0KCclPGdyZWV0aW5nPnMnLCBncmVldGluZzogJ0hlbGxvJykKZm9ybWF0KCcle2dyZWV0aW5nfScsIGdyZWV0aW5nOiAnSGVsbG8nKQoKIyBnb29kCmZvcm1hdCgnJXMnLCAnSGVsbG8nKQotLS0tCgo9PT09IE1heFVuYW5ub3RhdGVkUGxhY2Vob2xkZXJzQWxsb3dlZDogMAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvcm1hdCgnJTA2ZCcsIDEwKQpmb3JtYXQoJyVzICVzLicsICdIZWxsbycsICd3b3JsZCcpCgojIGdvb2QKZm9ybWF0KCclPG51bWJlcj4wNmQnLCBudW1iZXI6IDEwKQotLS0tCgo9PT09IE1heFVuYW5ub3RhdGVkUGxhY2Vob2xkZXJzQWxsb3dlZDogMSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb3JtYXQoJyVzICVzLicsICdIZWxsbycsICd3b3JsZCcpCgojIGdvb2QKZm9ybWF0KCclMDZkJywgMTApCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFtdIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnJlZGlyZWN0KCdmb28vJXtiYXJfaWR9JykKLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogW3JlZGlyZWN0XQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApyZWRpcmVjdCgnZm9vLyV7YmFyX2lkfScpCi0tLS0KCj09PT0gQWxsb3dlZFBhdHRlcm5zOiBbXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApyZWRpcmVjdCgnZm9vLyV7YmFyX2lkfScpCi0tLS0KCj09PT0gQWxsb3dlZFBhdHRlcm5zOiBbJ3JlZGlyZWN0J10KCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKcmVkaXJlY3QoJ2Zvby8le2Jhcl9pZH0nKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBhbm5vdGF0ZWRgCnwgYGFubm90YXRlZGAsIGB0ZW1wbGF0ZWAsIGB1bmFubm90YXRlZGAKCnwgTWF4VW5hbm5vdGF0ZWRQbGFjZWhvbGRlcnNBbGxvd2VkCnwgYDFgCnwgSW50ZWdlcgoKfCBBbGxvd2VkTWV0aG9kcwp8IGBbXWAKfCBBcnJheQoKfCBBbGxvd2VkUGF0dGVybnMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT0gU3R5bGUvRnJvemVuU3RyaW5nTGl0ZXJhbENvbW1lbnQKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMi4zCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4zNgp8IDAuNzkKfD09PQoKSGVscHMgeW91IHRyYW5zaXRpb24gZnJvbSBtdXRhYmxlIHN0cmluZyBsaXRlcmFscwp0byBmcm96ZW4gc3RyaW5nIGxpdGVyYWxzLgpJdCB3aWxsIGFkZCB0aGUgYCMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlYCBtYWdpYyBjb21tZW50IHRvIHRoZSB0b3AKb2YgZmlsZXMgdG8gZW5hYmxlIGZyb3plbiBzdHJpbmcgbGl0ZXJhbHMuIEZyb3plbiBzdHJpbmcgbGl0ZXJhbHMgbWF5IGJlCmRlZmF1bHQgaW4gZnV0dXJlIFJ1YnkuIFRoZSBjb21tZW50IHdpbGwgYmUgYWRkZWQgYmVsb3cgYSBzaGViYW5nIGFuZAplbmNvZGluZyBjb21tZW50LiBUaGUgZnJvemVuIHN0cmluZyBsaXRlcmFsIGNvbW1lbnQgaXMgb25seSB2YWxpZCBpbiBSdWJ5IDIuMysuCgpOb3RlIHRoYXQgdGhlIGNvcCB3aWxsIGFjY2VwdCBmaWxlcyB3aGVyZSB0aGUgY29tbWVudCBleGlzdHMgYnV0IGlzIHNldAp0byBgZmFsc2VgIGluc3RlYWQgb2YgYHRydWVgLgoKVG8gcmVxdWlyZSBhIGJsYW5rIGxpbmUgYWZ0ZXIgdGhpcyBjb21tZW50LCBwbGVhc2Ugc2VlCmBMYXlvdXQvRW1wdHlMaW5lQWZ0ZXJNYWdpY0NvbW1lbnRgIGNvcC4KCj09PSBTYWZldHkKClRoaXMgY29wJ3MgYXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIHNpbmNlIGFueSBzdHJpbmdzIG11dGF0aW9ucyB3aWxsCmNoYW5nZSBmcm9tIGJlaW5nIGFjY2VwdGVkIHRvIHJhaXNpbmcgYEZyb3plbkVycm9yYCwgYXMgYWxsIHN0cmluZ3MKd2lsbCBiZWNvbWUgZnJvemVuIGJ5IGRlZmF1bHQsIGFuZCB3aWxsIG5lZWQgdG8gYmUgbWFudWFsbHkgcmVmYWN0b3JlZC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBhbHdheXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYGFsd2F5c2Agc3R5bGUgd2lsbCBhbHdheXMgYWRkIHRoZSBmcm96ZW4gc3RyaW5nIGxpdGVyYWwgY29tbWVudAojIHRvIGEgZmlsZSwgcmVnYXJkbGVzcyBvZiB0aGUgUnVieSB2ZXJzaW9uIG9yIGlmIGBmcmVlemVgIG9yIGA8PGAgYXJlCiMgY2FsbGVkIG9uIGEgc3RyaW5nIGxpdGVyYWwuCiMgYmFkCm1vZHVsZSBCYXIKICAjIC4uLgplbmQKCiMgZ29vZAojIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZQoKbW9kdWxlIEJhcgogICMgLi4uCmVuZAoKIyBnb29kCiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiBmYWxzZQoKbW9kdWxlIEJhcgogICMgLi4uCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IG5ldmVyCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYG5ldmVyYCB3aWxsIGVuZm9yY2UgdGhhdCB0aGUgZnJvemVuIHN0cmluZyBsaXRlcmFsIGNvbW1lbnQgZG9lcwojIG5vdCBleGlzdCBpbiBhIGZpbGUuCiMgYmFkCiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlCgptb2R1bGUgQmF6CiAgIyAuLi4KZW5kCgojIGdvb2QKbW9kdWxlIEJhegogICMgLi4uCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFsd2F5c190cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYGFsd2F5c190cnVlYCBzdHlsZSBlbmZvcmNlcyB0aGF0IHRoZSBmcm96ZW4gc3RyaW5nIGxpdGVyYWwKIyBjb21tZW50IGlzIHNldCB0byBgdHJ1ZWAuIFRoaXMgaXMgYSBzdHJpY3RlciBvcHRpb24gdGhhbiBgYWx3YXlzYAojIGFuZCBmb3JjZXMgcHJvamVjdHMgdG8gdXNlIGZyb3plbiBzdHJpbmcgbGl0ZXJhbHMuCiMgYmFkCiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiBmYWxzZQoKbW9kdWxlIEJhegogICMgLi4uCmVuZAoKIyBiYWQKbW9kdWxlIEJhegogICMgLi4uCmVuZAoKIyBnb29kCiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlCgptb2R1bGUgQmFyCiAgIyAuLi4KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGFsd2F5c2AKfCBgYWx3YXlzYCwgYGFsd2F5c190cnVlYCwgYG5ldmVyYAp8PT09Cgo9PSBTdHlsZS9HbG9iYWxTdGRTdHJlYW0KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjg5CnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGAkc3Rkb3V0LyRzdGRlcnIvJHN0ZGluYCBpbnN0ZWFkIG9mIGBTVERPVVQvU1RERVJSL1NURElOYC4KYFNURE9VVC9TVERFUlIvU1RESU5gIGFyZSBjb25zdGFudHMsIGFuZCB3aGlsZSB5b3UgY2FuIGFjdHVhbGx5CnJlYXNzaWduIChwb3NzaWJseSB0byByZWRpcmVjdCBzb21lIHN0cmVhbSkgY29uc3RhbnRzIGluIFJ1YnksIHlvdSdsbCBnZXQKYW4gaW50ZXJwcmV0ZXIgd2FybmluZyBpZiB5b3UgZG8gc28uCgo9PT0gU2FmZXR5CgpBdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBgU1RET1VUYCBhbmQgYCRzdGRvdXRgIG1heSBwb2ludCB0byBkaWZmZXJlbnQKb2JqZWN0cywgZm9yIGV4YW1wbGUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApTVERPVVQucHV0cygnaGVsbG8nKQoKaGFzaCA9IHsgb3V0OiBTVERPVVQsIGtleTogdmFsdWUgfQoKZGVmIG0ob3V0ID0gU1RET1VUKQogIG91dC5wdXRzKCdoZWxsbycpCmVuZAoKIyBnb29kCiRzdGRvdXQucHV0cygnaGVsbG8nKQoKaGFzaCA9IHsgb3V0OiAkc3Rkb3V0LCBrZXk6IHZhbHVlIH0KCmRlZiBtKG91dCA9ICRzdGRvdXQpCiAgb3V0LnB1dHMoJ2hlbGxvJykKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2dsb2JhbC1zdGRvdXQKCj09IFN0eWxlL0dsb2JhbFZhcnMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuMTMKfCAtCnw9PT0KCkxvb2tzIGZvciB1c2VzIG9mIGdsb2JhbCB2YXJpYWJsZXMuCkl0IGRvZXMgbm90IHJlcG9ydCBvZmZlbnNlcyBmb3IgYnVpbHQtaW4gZ2xvYmFsIHZhcmlhYmxlcy4KQnVpbHQtaW4gZ2xvYmFsIHZhcmlhYmxlcyBhcmUgYWxsb3dlZCBieSBkZWZhdWx0LiBBZGRpdGlvbmFsbHkKdXNlcnMgY2FuIGFsbG93IGFkZGl0aW9uYWwgdmFyaWFibGVzIHZpYSB0aGUgQWxsb3dlZFZhcmlhYmxlcyBvcHRpb24uCgpOb3RlIHRoYXQgYmFja3JlZmVyZW5jZXMgbGlrZSAkMSwgJDIsIGV0YyBhcmUgbm90IGdsb2JhbCB2YXJpYWJsZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAokZm9vID0gMgpiYXIgPSAkZm9vICsgNQoKIyBnb29kCkZPTyA9IDIKZm9vID0gMgokc3RkaW4ucmVhZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZFZhcmlhYmxlcwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNpbnN0YW5jZS12YXJzCiogaHR0cHM6Ly93d3cuemVuc3BpZGVyLmNvbS9ydWJ5L3F1aWNrcmVmLmh0bWwKCj09IFN0eWxlL0d1YXJkQ2xhdXNlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yMAp8IDEuMzEKfD09PQoKVXNlIGEgZ3VhcmQgY2xhdXNlIGluc3RlYWQgb2Ygd3JhcHBpbmcgdGhlIGNvZGUgaW5zaWRlIGEgY29uZGl0aW9uYWwKZXhwcmVzc2lvbgoKQSBjb25kaXRpb24gd2l0aCBhbiBgZWxzaWZgIG9yIGBlbHNlYCBicmFuY2ggaXMgYWxsb3dlZCB1bmxlc3MKb25lIG9mIGByZXR1cm5gLCBgYnJlYWtgLCBgbmV4dGAsIGByYWlzZWAsIG9yIGBmYWlsYCBpcyB1c2VkCmluIHRoZSBib2R5IG9mIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uLgoKTk9URTogQXV0b2NvcnJlY3Qgd29ya3MgaW4gbW9zdCBjYXNlcyBleGNlcHQgd2l0aCBpZi1lbHNlIHN0YXRlbWVudHMKICB0aGF0IGNvbnRhaW4gbG9naWNhbCBvcGVyYXRvcnMgc3VjaCBhcyBgZm9vIHx8IHJhaXNlKCdleGNlcHRpb24nKWAKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiB0ZXN0CiAgaWYgc29tZXRoaW5nCiAgICB3b3JrCiAgZW5kCmVuZAoKIyBnb29kCmRlZiB0ZXN0CiAgcmV0dXJuIHVubGVzcyBzb21ldGhpbmcKCiAgd29yawplbmQKCiMgYWxzbyBnb29kCmRlZiB0ZXN0CiAgd29yayBpZiBzb21ldGhpbmcKZW5kCgojIGJhZAppZiBzb21ldGhpbmcKICByYWlzZSAnZXhjZXB0aW9uJwplbHNlCiAgb2sKZW5kCgojIGdvb2QKcmFpc2UgJ2V4Y2VwdGlvbicgaWYgc29tZXRoaW5nCm9rCgojIGJhZAppZiBzb21ldGhpbmcKICBmb28gfHwgcmFpc2UoJ2V4Y2VwdGlvbicpCmVsc2UKICBvawplbmQKCiMgZ29vZApmb28gfHwgcmFpc2UoJ2V4Y2VwdGlvbicpIGlmIHNvbWV0aGluZwpvawoKIyBiYWQKZGVmaW5lX21ldGhvZCg6dGVzdCkgZG8KICBpZiBzb21ldGhpbmcKICAgIHdvcmsKICBlbmQKZW5kCgojIGdvb2QKZGVmaW5lX21ldGhvZCg6dGVzdCkgZG8KICByZXR1cm4gdW5sZXNzIHNvbWV0aGluZwoKICB3b3JrCmVuZAoKIyBhbHNvIGdvb2QKZGVmaW5lX21ldGhvZCg6dGVzdCkgZG8KICB3b3JrIGlmIHNvbWV0aGluZwplbmQKLS0tLQoKPT09PSBBbGxvd0NvbnNlY3V0aXZlQ29uZGl0aW9uYWxzOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgdGVzdAogIGlmIGZvbz8KICAgIHdvcmsKICBlbmQKCiAgaWYgYmFyPyAgIyA8LSByZXBvcnRzIGFuIG9mZmVuc2UKICAgIHdvcmsKICBlbmQKZW5kCi0tLS0KCj09PT0gQWxsb3dDb25zZWN1dGl2ZUNvbmRpdGlvbmFsczogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgdGVzdAogIGlmIGZvbz8KICAgIHdvcmsKICBlbmQKCiAgaWYgYmFyPwogICAgd29yawogIGVuZAplbmQKCiMgYmFkCmRlZiB0ZXN0CiAgaWYgZm9vPwogICAgd29yawogIGVuZAoKICBkb19zb21ldGhpbmcKCiAgaWYgYmFyPyAgIyA8LSByZXBvcnRzIGFuIG9mZmVuc2UKICAgIHdvcmsKICBlbmQKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBNaW5Cb2R5TGVuZ3RoCnwgYDFgCnwgSW50ZWdlcgoKfCBBbGxvd0NvbnNlY3V0aXZlQ29uZGl0aW9uYWxzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tbmVzdGVkLWNvbmRpdGlvbmFscwoKPT0gU3R5bGUvSGFzaEFzTGFzdEFycmF5SXRlbQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuODgKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBicmFjZXMgYXJvdW5kIGhhc2ggbGl0ZXJhbCBhcyBhIGxhc3QKYXJyYXkgaXRlbSBkZXBlbmRpbmcgb24gY29uZmlndXJhdGlvbi4KCk5PVEU6IFRoaXMgY29wIHdpbGwgaWdub3JlIGFycmF5cyB3aGVyZSBhbGwgaXRlbXMgYXJlIGhhc2hlcywgcmVnYXJkbGVzcyBvZgpFbmZvcmNlZFN0eWxlLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGJyYWNlcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApbMSwgMiwgb25lOiAxLCB0d286IDJdCgojIGdvb2QKWzEsIDIsIHsgb25lOiAxLCB0d286IDIgfV0KCiMgZ29vZApbeyBvbmU6IDEgfSwgeyB0d286IDIgfV0KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBub19icmFjZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApbMSwgMiwgeyBvbmU6IDEsIHR3bzogMiB9XQoKIyBnb29kClsxLCAyLCBvbmU6IDEsIHR3bzogMl0KCiMgZ29vZApbeyBvbmU6IDEgfSwgeyB0d286IDIgfV0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYnJhY2VzYAp8IGBicmFjZXNgLCBgbm9fYnJhY2VzYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNoYXNoLWxpdGVyYWwtYXMtbGFzdC1hcnJheS1pdGVtCgo9PSBTdHlsZS9IYXNoQ29udmVyc2lvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuMTAKfCAxLjU1Cnw9PT0KCkNoZWNrcyB0aGUgdXNhZ2Ugb2YgcHJlLTIuMSBgSGFzaFthcmdzXWAgbWV0aG9kIG9mIGNvbnZlcnRpbmcgZW51bWVyYWJsZXMgYW5kCnNlcXVlbmNlcyBvZiB2YWx1ZXMgdG8gaGFzaGVzLgoKQ29ycmVjdGlvbiBjb2RlIGZyb20gc3BsYXQgYXJndW1lbnQgKGBIYXNoWyphcnldYCkgaXMgbm90IHNpbXBseSBkZXRlcm1pbmVkLiBGb3IgZXhhbXBsZSwKYEhhc2hbKmFyeV1gIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBhcnkuZWFjaF9zbGljZSgyKS50b19oYCBidXQgaXQgd2lsbCBiZSBjb21wbGljYXRlZC4KU28sIGBBbGxvd1NwbGF0QXJndW1lbnRgIG9wdGlvbiBpcyB0cnVlIGJ5IGRlZmF1bHQgdG8gYWxsb3cgc3BsYXQgYXJndW1lbnQgZm9yIHNpbXBsZSBjb2RlLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBgQXJndW1lbnRFcnJvcmAgb2NjdXJzCmlmIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkOgoKW3NvdXJjZSxydWJ5XQotLS0tCkhhc2hbW1sxLCAyXSwgWzNdXV0gIz0+IHsxPT4yLCAzPT5uaWx9CltbMSwgMl0sIFs1XV0udG9faCAgIz0+IHdyb25nIGFycmF5IGxlbmd0aCBhdCAxIChleHBlY3RlZCAyLCB3YXMgMSkgKEFyZ3VtZW50RXJyb3IpCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkhhc2hbYXJ5XQoKIyBnb29kCmFyeS50b19oCgojIGJhZApIYXNoW2tleTEsIHZhbHVlMSwga2V5MiwgdmFsdWUyXQoKIyBnb29kCntrZXkxID0+IHZhbHVlMSwga2V5MiA9PiB2YWx1ZTJ9Ci0tLS0KCj09PT0gQWxsb3dTcGxhdEFyZ3VtZW50OiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApIYXNoWyphcnldCi0tLS0KCj09PT0gQWxsb3dTcGxhdEFyZ3VtZW50OiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkhhc2hbKmFyeV0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93U3BsYXRBcmd1bWVudAp8IGB0cnVlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYXZvaWQtaGFzaC1jb25zdHJ1Y3RvcgoKPT0gU3R5bGUvSGFzaEVhY2hNZXRob2RzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjgwCnwgMS4xNgp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgYGVhY2hfa2V5YCBhbmQgYGVhY2hfdmFsdWVgIEhhc2ggbWV0aG9kcy4KCk5PVEU6IElmIHlvdSBoYXZlIGFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cywgeW91IGNhbiBwdXQKICBwYXJlbnRoZXNlcyBhcm91bmQgdGhlIGJsb2NrIGFyZ3VtZW50cyB0byBpbmRpY2F0ZSB0aGF0IHlvdSdyZSBub3QKICB3b3JraW5nIHdpdGggYSBoYXNoLCBhbmQgc3VwcHJlc3MgUnVib0NvcCBvZmZlbnNlcy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBndWFyYW50ZWVkIHRoYXQgdGhlIHJlY2VpdmVyCmlzIGEgYEhhc2hgLiBUaGUgYEFsbG93ZWRSZWNlaXZlcnNgIGNvbmZpZ3VyYXRpb24gY2FuIG1pdGlnYXRlLApidXQgbm90IGZ1bGx5IHJlc29sdmUsIHRoaXMgc2FmZXR5IGlzc3VlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaGFzaC5rZXlzLmVhY2ggeyB8a3wgcCBrIH0KaGFzaC5lYWNoIHsgfGssIHVudXNlZF92YWx1ZXwgcCBrIH0KCiMgZ29vZApoYXNoLmVhY2hfa2V5IHsgfGt8IHAgayB9CgojIGJhZApoYXNoLnZhbHVlcy5lYWNoIHsgfHZ8IHAgdiB9Cmhhc2guZWFjaCB7IHx1bnVzZWRfa2V5LCB2fCBwIHYgfQoKIyBnb29kCmhhc2guZWFjaF92YWx1ZSB7IHx2fCBwIHYgfQotLS0tCgo9PT09IEFsbG93ZWRSZWNlaXZlcnM6IFsnZXhlY3V0ZSddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmV4ZWN1dGUoc3FsKS5rZXlzLmVhY2ggeyB8dnwgcCB2IH0KZXhlY3V0ZShzcWwpLnZhbHVlcy5lYWNoIHsgfHZ8IHAgdiB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd2VkUmVjZWl2ZXJzCnwgYFRocmVhZC5jdXJyZW50YAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2hhc2gtZWFjaAoKPT0gU3R5bGUvSGFzaEV4Y2VwdAoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAzLjAKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNwp8IDEuMzkKfD09PQoKQ2hlY2tzIGZvciB1c2FnZXMgb2YgYEhhc2gjcmVqZWN0YCwgYEhhc2gjc2VsZWN0YCwgYW5kIGBIYXNoI2ZpbHRlcmAgbWV0aG9kcwp0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGBIYXNoI2V4Y2VwdGAgbWV0aG9kLgoKVGhpcyBjb3Agc2hvdWxkIG9ubHkgYmUgZW5hYmxlZCBvbiBSdWJ5IHZlcnNpb24gMy4wIG9yIGhpZ2hlci4KKGBIYXNoI2V4Y2VwdGAgd2FzIGFkZGVkIGluIFJ1YnkgMy4wLikKCkZvciBzYWZlIGRldGVjdGlvbiwgaXQgaXMgbGltaXRlZCB0byBjb21tb25seSB1c2VkIHN0cmluZyBhbmQgc3ltYm9sIGNvbXBhcmlzb25zCndoZW4gdXNlZCBgPT1gLgpBbmQgZG8gbm90IGNoZWNrIGBIYXNoI2RlbGV0ZV9pZmAgYW5kIGBIYXNoI2tlZXBfaWZgIHRvIGNoYW5nZSByZWNlaXZlciBvYmplY3QuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IHRoZSByZWNlaXZlcgppcyBhIGBIYXNoYCBvciByZXNwb25kcyB0byB0aGUgcmVwbGFjZW1lbnQgbWV0aG9kLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LnJlamVjdCB7fGssIHZ8IGsgPT0gOmJhciB9Cntmb286IDEsIGJhcjogMiwgYmF6OiAzfS5zZWxlY3Qge3xrLCB2fCBrICE9IDpiYXIgfQp7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30uZmlsdGVyIHt8aywgdnwgayAhPSA6YmFyIH0Ke2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LnJlamVjdCB7fGssIHZ8ICVpW2ZvbyBiYXJdLmluY2x1ZGU/KGspIH0Ke2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LnNlbGVjdCB7fGssIHZ8ICElaVtmb28gYmFyXS5pbmNsdWRlPyhrKSB9Cntmb286IDEsIGJhcjogMiwgYmF6OiAzfS5maWx0ZXIge3xrLCB2fCAhJWlbZm9vIGJhcl0uaW5jbHVkZT8oaykgfQoKIyBnb29kCntmb286IDEsIGJhcjogMiwgYmF6OiAzfS5leGNlcHQoOmJhcikKLS0tLQoKPT0gU3R5bGUvSGFzaExpa2VDYXNlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjg4CnwgLQp8PT09CgpDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBgY2FzZS13aGVuYCByZXByZXNlbnRzIGEgc2ltcGxlIDE6MQptYXBwaW5nIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIGhhc2ggbG9va3VwLgoKPT09IEV4YW1wbGVzCgo9PT09IE1pbkJyYW5jaGVzQ291bnQ6IDMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2FzZSBjb3VudHJ5CndoZW4gJ2V1cm9wZScKICAnaHR0cDovL2V1LmV4YW1wbGUuY29tJwp3aGVuICdhbWVyaWNhJwogICdodHRwOi8vdXMuZXhhbXBsZS5jb20nCndoZW4gJ2F1c3RyYWxpYScKICAnaHR0cDovL2F1LmV4YW1wbGUuY29tJwplbmQKCiMgZ29vZApTSVRFUyA9IHsKICAnZXVyb3BlJyAgICA9PiAnaHR0cDovL2V1LmV4YW1wbGUuY29tJywKICAnYW1lcmljYScgICA9PiAnaHR0cDovL3VzLmV4YW1wbGUuY29tJywKICAnYXVzdHJhbGlhJyA9PiAnaHR0cDovL2F1LmV4YW1wbGUuY29tJwp9ClNJVEVTW2NvdW50cnldCi0tLS0KCj09PT0gTWluQnJhbmNoZXNDb3VudDogNAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjYXNlIGNvdW50cnkKd2hlbiAnZXVyb3BlJwogICdodHRwOi8vZXUuZXhhbXBsZS5jb20nCndoZW4gJ2FtZXJpY2EnCiAgJ2h0dHA6Ly91cy5leGFtcGxlLmNvbScKd2hlbiAnYXVzdHJhbGlhJwogICdodHRwOi8vYXUuZXhhbXBsZS5jb20nCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWluQnJhbmNoZXNDb3VudAp8IGAzYAp8IEludGVnZXIKfD09PQoKPT0gU3R5bGUvSGFzaFN5bnRheAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDEuMjQKfD09PQoKQ2hlY2tzIGhhc2ggbGl0ZXJhbCBzeW50YXguCgpJdCBjYW4gZW5mb3JjZSBlaXRoZXIgdGhlIHVzZSBvZiB0aGUgY2xhc3MgaGFzaCByb2NrZXQgc3ludGF4IG9yCnRoZSB1c2Ugb2YgdGhlIG5ld2VyIFJ1YnkgMS45IHN5bnRheCAod2hlbiBhcHBsaWNhYmxlKS4KCkEgc2VwYXJhdGUgb2ZmZW5zZSBpcyByZWdpc3RlcmVkIGZvciBlYWNoIHByb2JsZW1hdGljIHBhaXIuCgpUaGUgc3VwcG9ydGVkIHN0eWxlcyBhcmU6CgoqIHJ1YnkxOSAtIGZvcmNlcyB1c2Ugb2YgdGhlIDEuOSBzeW50YXggKGUuZy4gYHthOiAxfWApIHdoZW4gaGFzaGVzIGhhdmUKYWxsIHN5bWJvbHMgZm9yIGtleXMKKiBoYXNoX3JvY2tldHMgLSBmb3JjZXMgdXNlIG9mIGhhc2ggcm9ja2V0cyBmb3IgYWxsIGhhc2hlcwoqIG5vX21peGVkX2tleXMgLSBzaW1wbHkgY2hlY2tzIGZvciBoYXNoZXMgd2l0aCBtaXhlZCBzeW50YXhlcwoqIHJ1YnkxOV9ub19taXhlZF9rZXlzIC0gZm9yY2VzIHVzZSBvZiBydWJ5IDEuOSBzeW50YXggYW5kIGZvcmJpZHMgbWl4ZWQKc3ludGF4IGhhc2hlcwoKVGhpcyBjb3AgaGFzIGBFbmZvcmNlZFNob3J0aGFuZFN5bnRheGAgb3B0aW9uLgpJdCBjYW4gZW5mb3JjZSBlaXRoZXIgdGhlIHVzZSBvZiB0aGUgZXhwbGljaXQgaGFzaCB2YWx1ZSBzeW50YXggb3IKdGhlIHVzZSBvZiBSdWJ5IDMuMSdzIGhhc2ggdmFsdWUgc2hvcnRoYW5kIHN5bnRheC4KClRoZSBzdXBwb3J0ZWQgc3R5bGVzIGFyZToKCiogYWx3YXlzIC0gZm9yY2VzIHVzZSBvZiB0aGUgMy4xIHN5bnRheCAoZS5nLiB7Zm9vOn0pCiogbmV2ZXIgLSBmb3JjZXMgdXNlIG9mIGV4cGxpY2l0IGhhc2ggbGl0ZXJhbCB2YWx1ZQoqIGVpdGhlciAtIGFjY2VwdHMgYm90aCBzaG9ydGhhbmQgYW5kIGV4cGxpY2l0IHVzZSBvZiBoYXNoIGxpdGVyYWwgdmFsdWUKKiBjb25zaXN0ZW50IC0gZm9yY2VzIHVzZSBvZiB0aGUgMy4xIHN5bnRheCBvbmx5IGlmIGFsbCB2YWx1ZXMgY2FuIGJlIG9taXR0ZWQgaW4gdGhlIGhhc2gKKiBlaXRoZXJfY29uc2lzdGVudCAtIGFjY2VwdHMgYm90aCBzaG9ydGhhbmQgYW5kIGV4cGxpY2l0IHVzZSBvZiBoYXNoIGxpdGVyYWwgdmFsdWUsCiAgICAgICAgICAgICAgICAgICAgICBidXQgdGhleSBtdXN0IGJlIGNvbnNpc3RlbnQKCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBydWJ5MTkgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKezphID0+IDJ9CntiOiAxLCA6YyA9PiAyfQoKIyBnb29kCnthOiAyLCBiOiAxfQp7OmMgPT4gMiwgJ2QnID0+IDJ9ICMgYWNjZXB0YWJsZSBzaW5jZSAnZCcgaXNuJ3QgYSBzeW1ib2wKe2Q6IDEsICdlJyA9PiAyfSAjIHRlY2huaWNhbGx5IG5vdCBmb3JiaWRkZW4KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBoYXNoX3JvY2tldHMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp7YTogMSwgYjogMn0Ke2M6IDEsICdkJyA9PiA1fQoKIyBnb29kCns6YSA9PiAxLCA6YiA9PiAyfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IG5vX21peGVkX2tleXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp7OmEgPT4gMSwgYjogMn0Ke2M6IDEsICdkJyA9PiAyfQoKIyBnb29kCns6YSA9PiAxLCA6YiA9PiAyfQp7YzogMSwgZDogMn0KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBydWJ5MTlfbm9fbWl4ZWRfa2V5cwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCns6YSA9PiAxLCA6YiA9PiAyfQp7YzogMiwgJ2QnID0+IDN9ICMgc2hvdWxkIGp1c3QgdXNlIGhhc2ggcm9ja2V0cwoKIyBnb29kCnthOiAxLCBiOiAyfQp7OmMgPT4gMywgJ2QnID0+IDR9Ci0tLS0KCj09PT0gRW5mb3JjZWRTaG9ydGhhbmRTeW50YXg6IGFsd2F5cyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp7Zm9vOiBmb28sIGJhcjogYmFyfQoKIyBnb29kCntmb286LCBiYXI6fQotLS0tCgo9PT09IEVuZm9yY2VkU2hvcnRoYW5kU3ludGF4OiBuZXZlcgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCntmb286LCBiYXI6fQoKIyBnb29kCntmb286IGZvbywgYmFyOiBiYXJ9Ci0tLS0KCj09PT0gRW5mb3JjZWRTaG9ydGhhbmRTeW50YXg6IGVpdGhlcgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAp7Zm9vOiBmb28sIGJhcjogYmFyfQoKIyBnb29kCntmb286IGZvbywgYmFyOn0KCiMgZ29vZAp7Zm9vOiwgYmFyOn0KLS0tLQoKPT09PSBFbmZvcmNlZFNob3J0aGFuZFN5bnRheDogY29uc2lzdGVudAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gYGZvb2AgYW5kIGBiYXJgIHZhbHVlcyBjYW4gYmUgb21pdHRlZAp7Zm9vOiBmb28sIGJhcjogYmFyfQoKIyBiYWQgLSBgYmFyYCB2YWx1ZSBjYW4gYmUgb21pdHRlZAp7Zm9vOiwgYmFyOiBiYXJ9CgojIGJhZCAtIG1peGVkIHN5bnRheGVzCntmb286LCBiYXI6IGJhen0KCiMgZ29vZAp7Zm9vOiwgYmFyOn0KCiMgZ29vZCAtIGNhbid0IG9taXQgYGJhemAKe2ZvbzogZm9vLCBiYXI6IGJhen0KLS0tLQoKPT09PSBFbmZvcmNlZFNob3J0aGFuZFN5bnRheDogZWl0aGVyX2NvbnNpc3RlbnQKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QgLSBgZm9vYCBhbmQgYGJhcmAgdmFsdWVzIGNhbiBiZSBvbWl0dGVkLCBidXQgdGhleSBhcmUgY29uc2lzdGVudCwgc28gaXQncyBhY2NlcHRlZAp7Zm9vOiBmb28sIGJhcjogYmFyfQoKIyBiYWQgLSBgYmFyYCB2YWx1ZSBjYW4gYmUgb21pdHRlZAp7Zm9vOiwgYmFyOiBiYXJ9CgojIGJhZCAtIG1peGVkIHN5bnRheGVzCntmb286LCBiYXI6IGJhen0KCiMgZ29vZAp7Zm9vOiwgYmFyOn0KCiMgZ29vZCAtIGNhbid0IG9taXQgYGJhemAKe2ZvbzogZm9vLCBiYXI6IGJhen0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgcnVieTE5YAp8IGBydWJ5MTlgLCBgaGFzaF9yb2NrZXRzYCwgYG5vX21peGVkX2tleXNgLCBgcnVieTE5X25vX21peGVkX2tleXNgCgp8IEVuZm9yY2VkU2hvcnRoYW5kU3ludGF4CnwgYGFsd2F5c2AKfCBgYWx3YXlzYCwgYG5ldmVyYCwgYGVpdGhlcmAsIGBjb25zaXN0ZW50YCwgYGVpdGhlcl9jb25zaXN0ZW50YAoKfCBVc2VIYXNoUm9ja2V0c1dpdGhTeW1ib2xWYWx1ZXMKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBQcmVmZXJIYXNoUm9ja2V0c0Zvck5vbkFsbnVtRW5kaW5nU3ltYm9scwp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2hhc2gtbGl0ZXJhbHMKCj09IFN0eWxlL0hhc2hUcmFuc2Zvcm1LZXlzCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuNQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44MAp8IDAuOTAKfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgYFxfLmVhY2hfd2l0aF9vYmplY3Qoe30pIHsuLi59YCwKYFxfLm1hcCB7Li4ufS50b19oYCwgYW5kIGBIYXNoW1xfLm1hcCB7Li4ufV1gIHRoYXQgYXJlIGFjdHVhbGx5IGp1c3QKdHJhbnNmb3JtaW5nIHRoZSBrZXlzIG9mIGEgaGFzaCwgYW5kIHRyaWVzIHRvIHVzZSBhIHNpbXBsZXIgJiBmYXN0ZXIKY2FsbCB0byBgdHJhbnNmb3JtX2tleXNgIGluc3RlYWQuCkl0IHNob3VsZCBvbmx5IGJlIGVuYWJsZWQgb24gUnVieSB2ZXJzaW9uIDIuNSBvciBuZXdlci4KKGB0cmFuc2Zvcm1fa2V5c2Agd2FzIGFkZGVkIGluIFJ1YnkgMi41LikKCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSwgYXMgaXQgY2FuIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIGlmIHdlIGFyZQp0cmFuc2Zvcm1pbmcgYW4gZW51bWVyYWJsZSBvZiBrZXktdmFsdWUtbGlrZSBwYWlycyB0aGF0IGlzbid0IGFjdHVhbGx5CmEgaGFzaCwgZS5nLjogYFtbazEsIHYxXSwgW2syLCB2Ml0sIC4uLl1gCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp7YTogMSwgYjogMn0uZWFjaF93aXRoX29iamVjdCh7fSkgeyB8KGssIHYpLCBofCBoW2ZvbyhrKV0gPSB2IH0KSGFzaFt7YTogMSwgYjogMn0uY29sbGVjdCB7IHxrLCB2fCBbZm9vKGspLCB2XSB9XQp7YTogMSwgYjogMn0ubWFwIHsgfGssIHZ8IFtrLnRvX3MsIHZdIH0udG9faAp7YTogMSwgYjogMn0udG9faCB7IHxrLCB2fCBbay50b19zLCB2XSB9CgojIGdvb2QKe2E6IDEsIGI6IDJ9LnRyYW5zZm9ybV9rZXlzIHsgfGt8IGZvbyhrKSB9CnthOiAxLCBiOiAyfS50cmFuc2Zvcm1fa2V5cyB7IHxrfCBrLnRvX3MgfQotLS0tCgo9PSBTdHlsZS9IYXNoVHJhbnNmb3JtVmFsdWVzCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuNAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44MAp8IDAuOTAKfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgYFxfLmVhY2hfd2l0aF9vYmplY3Qoe30pIHsuLi59YCwKYFxfLm1hcCB7Li4ufS50b19oYCwgYW5kIGBIYXNoW1xfLm1hcCB7Li4ufV1gIHRoYXQgYXJlIGFjdHVhbGx5IGp1c3QKdHJhbnNmb3JtaW5nIHRoZSB2YWx1ZXMgb2YgYSBoYXNoLCBhbmQgdHJpZXMgdG8gdXNlIGEgc2ltcGxlciAmIGZhc3RlcgpjYWxsIHRvIGB0cmFuc2Zvcm1fdmFsdWVzYCBpbnN0ZWFkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlLCBhcyBpdCBjYW4gcHJvZHVjZSBmYWxzZSBwb3NpdGl2ZXMgaWYgd2UgYXJlCnRyYW5zZm9ybWluZyBhbiBlbnVtZXJhYmxlIG9mIGtleS12YWx1ZS1saWtlIHBhaXJzIHRoYXQgaXNuJ3QgYWN0dWFsbHkKYSBoYXNoLCBlLmcuOiBgW1trMSwgdjFdLCBbazIsIHYyXSwgLi4uXWAKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnthOiAxLCBiOiAyfS5lYWNoX3dpdGhfb2JqZWN0KHt9KSB7IHwoaywgdiksIGh8IGhba10gPSBmb28odikgfQpIYXNoW3thOiAxLCBiOiAyfS5jb2xsZWN0IHsgfGssIHZ8IFtrLCBmb28odildIH1dCnthOiAxLCBiOiAyfS5tYXAgeyB8aywgdnwgW2ssIHYgKiB2XSB9LnRvX2gKe2E6IDEsIGI6IDJ9LnRvX2ggeyB8aywgdnwgW2ssIHYgKiB2XSB9CgojIGdvb2QKe2E6IDEsIGI6IDJ9LnRyYW5zZm9ybV92YWx1ZXMgeyB8dnwgZm9vKHYpIH0Ke2E6IDEsIGI6IDJ9LnRyYW5zZm9ybV92YWx1ZXMgeyB8dnwgdiAqIHYgfQotLS0tCgo9PSBTdHlsZS9JZGVudGljYWxDb25kaXRpb25hbEJyYW5jaGVzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4zNgp8IDEuMTkKfD09PQoKQ2hlY2tzIGZvciBpZGVudGljYWwgZXhwcmVzc2lvbnMgYXQgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YKZWFjaCBicmFuY2ggb2YgYSBjb25kaXRpb25hbCBleHByZXNzaW9uLiBTdWNoIGV4cHJlc3Npb25zIHNob3VsZCBub3JtYWxseQpiZSBwbGFjZWQgb3V0c2lkZSB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiAtIGJlZm9yZSBvciBhZnRlciBpdC4KCk5PVEU6IFRoZSBjb3AgaXMgcG9vcmx5IG5hbWVkIGFuZCBzb21lIHBlb3BsZSBtaWdodCB0aGluayB0aGF0IGl0IGFjdHVhbGx5CmNoZWNrcyBmb3IgZHVwbGljYXRlZCBjb25kaXRpb25hbCBicmFuY2hlcy4gVGhlIG5hbWUgd2lsbCBwcm9iYWJseSBiZSBjaGFuZ2VkCmluIGEgZnV0dXJlIG1ham9yIFJ1Ym9Db3AgcmVsZWFzZS4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGNoYW5naW5nIHRoZSBvcmRlciBvZiBtZXRob2QgaW52b2NhdGlvbnMKbWF5IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGNvZGUuIEZvciBleGFtcGxlOgoKW3NvdXJjZSxydWJ5XQotLS0tCmlmIG1ldGhvZF90aGF0X21vZGlmaWVzX2dsb2JhbF9zdGF0ZSAjIDEKICBtZXRob2RfdGhhdF9yZWxpZXNfb25fZ2xvYmFsX3N0YXRlICMgMgogIGZvbyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAzCmVsc2UKICBtZXRob2RfdGhhdF9yZWxpZXNfb25fZ2xvYmFsX3N0YXRlICMgMgogIGJhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyAzCmVuZAotLS0tCgpJbiB0aGlzIGV4YW1wbGUsIGBtZXRob2RfdGhhdF9yZWxpZXNfb25fZ2xvYmFsX3N0YXRlYCB3aWxsIGJlIG1vdmVkIGJlZm9yZQpgbWV0aG9kX3RoYXRfbW9kaWZpZXNfZ2xvYmFsX3N0YXRlYCwgd2hpY2ggY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIHByb2dyYW0uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiBjb25kaXRpb24KICBkb194CiAgZG9fegplbHNlCiAgZG9feQogIGRvX3oKZW5kCgojIGdvb2QKaWYgY29uZGl0aW9uCiAgZG9feAplbHNlCiAgZG9feQplbmQKZG9fegoKIyBiYWQKaWYgY29uZGl0aW9uCiAgZG9fegogIGRvX3gKZWxzZQogIGRvX3oKICBkb195CmVuZAoKIyBnb29kCmRvX3oKaWYgY29uZGl0aW9uCiAgZG9feAplbHNlCiAgZG9feQplbmQKCiMgYmFkCmNhc2UgZm9vCndoZW4gMQogIGRvX3gKd2hlbiAyCiAgZG9feAplbHNlCiAgZG9feAplbmQKCiMgZ29vZApjYXNlIGZvbwp3aGVuIDEKICBkb194CiAgZG9feQp3aGVuIDIKICAjIG5vdGhpbmcKZWxzZQogIGRvX3gKICBkb196CmVuZAoKIyBiYWQKY2FzZSBmb28KaW4gMQogIGRvX3gKaW4gMgogIGRvX3gKZWxzZQogIGRvX3gKZW5kCgojIGdvb2QKY2FzZSBmb28KaW4gMQogIGRvX3gKICBkb195CmluIDIKICAjIG5vdGhpbmcKZWxzZQogIGRvX3gKICBkb196CmVuZAotLS0tCgo9PSBTdHlsZS9JZkluc2lkZUVsc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjM2CnwgMS4zCnw9PT0KCklmIHRoZSBgZWxzZWAgYnJhbmNoIG9mIGEgY29uZGl0aW9uYWwgY29uc2lzdHMgc29sZWx5IG9mIGFuIGBpZmAgbm9kZSwKaXQgY2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGBlbHNlYCB0byBiZWNvbWUgYW4gYGVsc2lmYC4KVGhpcyBoZWxwcyB0byBrZWVwIHRoZSBuZXN0aW5nIGxldmVsIGZyb20gZ2V0dGluZyB0b28gZGVlcC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGNvbmRpdGlvbl9hCiAgYWN0aW9uX2EKZWxzZQogIGlmIGNvbmRpdGlvbl9iCiAgICBhY3Rpb25fYgogIGVsc2UKICAgIGFjdGlvbl9jCiAgZW5kCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbl9hCiAgYWN0aW9uX2EKZWxzaWYgY29uZGl0aW9uX2IKICBhY3Rpb25fYgplbHNlCiAgYWN0aW9uX2MKZW5kCi0tLS0KCj09PT0gQWxsb3dJZk1vZGlmaWVyOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiBjb25kaXRpb25fYQogIGFjdGlvbl9hCmVsc2UKICBhY3Rpb25fYiBpZiBjb25kaXRpb25fYgplbmQKCiMgZ29vZAppZiBjb25kaXRpb25fYQogIGFjdGlvbl9hCmVsc2lmIGNvbmRpdGlvbl9iCiAgYWN0aW9uX2IKZW5kCi0tLS0KCj09PT0gQWxsb3dJZk1vZGlmaWVyOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmlmIGNvbmRpdGlvbl9hCiAgYWN0aW9uX2EKZWxzZQogIGFjdGlvbl9iIGlmIGNvbmRpdGlvbl9iCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbl9hCiAgYWN0aW9uX2EKZWxzaWYgY29uZGl0aW9uX2IKICBhY3Rpb25fYgplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93SWZNb2RpZmllcgp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL0lmVW5sZXNzTW9kaWZpZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjMwCnw9PT0KCkNoZWNrcyBmb3IgYGlmYCBhbmQgYHVubGVzc2Agc3RhdGVtZW50cyB0aGF0IHdvdWxkIGZpdCBvbiBvbmUgbGluZSBpZgp3cml0dGVuIGFzIG1vZGlmaWVyIGBpZmAvYHVubGVzc2AuIFRoZSBjb3AgYWxzbyBjaGVja3MgZm9yIG1vZGlmaWVyCmBpZmAvYHVubGVzc2AgbGluZXMgdGhhdCBleGNlZWQgdGhlIG1heGltdW0gbGluZSBsZW5ndGguCgpUaGUgbWF4aW11bSBsaW5lIGxlbmd0aCBpcyBjb25maWd1cmVkIGluIHRoZSBgTGF5b3V0L0xpbmVMZW5ndGhgCmNvcC4gVGhlIHRhYiBzaXplIGlzIGNvbmZpZ3VyZWQgaW4gdGhlIGBJbmRlbnRhdGlvbldpZHRoYCBvZiB0aGUKYExheW91dC9JbmRlbnRhdGlvblN0eWxlYCBjb3AuCgpPbmUtbGluZSBwYXR0ZXJuIG1hdGNoaW5nIGlzIGFsd2F5cyBhbGxvd2VkLiBUbyBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgZmV3IGNhc2VzCndoZXJlIHRoZSBtYXRjaCB2YXJpYWJsZSBpcyBub3QgdXNlZCwgYW5kIHRvIHByZXZlbnQgb3ZlcnNpZ2h0cy4gVGhlIHZhcmlhYmxlIGB4YApiZWNvbWVzIHVuZGVmaW5lZCBhbmQgcmFpc2VzIGBOYW1lRXJyb3JgIHdoZW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIGlzIGNoYW5nZWQgdG8KdGhlIG1vZGlmaWVyIGZvcm06Cgpbc291cmNlLHJ1YnldCi0tLS0KaWYgWzQyXSBpbiBbeF0KICB4ICMgYHhgIGlzIHVuZGVmaW5lZCB3aGVuIHVzaW5nIG1vZGlmaWVyIGZvcm0uCmVuZAotLS0tCgpOT1RFOiBJdCBpcyBhbGxvd2VkIHdoZW4gYGRlZmluZWQ/YCBhcmd1bWVudCBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlLApiZWNhdXNlIHVzaW5nIHRoZSBtb2RpZmllciBmb3JtIGNhdXNlcyB0aGUgZm9sbG93aW5nIGluY29tcGF0aWJpbGl0eToKCltzb3VyY2UscnVieV0KLS0tLQp1bmxlc3MgZGVmaW5lZD8odW5kZWZpbmVkX2ZvbykKICB1bmRlZmluZWRfZm9vID0gJ2RlZmF1bHRfdmFsdWUnCmVuZAp1bmRlZmluZWRfZm9vICMgPT4gJ2RlZmF1bHRfdmFsdWUnCgp1bmRlZmluZWRfYmFyID0gJ2RlZmF1bHRfdmFsdWUnIHVubGVzcyBkZWZpbmVkPyh1bmRlZmluZWRfYmFyKQp1bmRlZmluZWRfYmFyICMgPT4gbmlsCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGNvbmRpdGlvbgogIGRvX3N0dWZmKGJhcikKZW5kCgp1bmxlc3MgcXV4LmVtcHR5PwogIEZvby5kb19zb21ldGhpbmcKZW5kCgpkb19zb21ldGhpbmdfd2l0aF9hX2xvbmdfbmFtZShhcmcpIGlmIGxvbmdfY29uZGl0aW9uX3RoYXRfcHJldmVudHNfY29kZV9maXRfb25fc2luZ2xlX2xpbmUKCiMgZ29vZApkb19zdHVmZihiYXIpIGlmIGNvbmRpdGlvbgpGb28uZG9fc29tZXRoaW5nIHVubGVzcyBxdXguZW1wdHk/CgppZiBsb25nX2NvbmRpdGlvbl90aGF0X3ByZXZlbnRzX2NvZGVfZml0X29uX3NpbmdsZV9saW5lCiAgZG9fc29tZXRoaW5nX3dpdGhfYV9sb25nX25hbWUoYXJnKQplbmQKCmlmIHNob3J0X2NvbmRpdGlvbiAjIGEgbG9uZyBjb21tZW50IHRoYXQgbWFrZXMgaXQgdG9vIGxvbmcgaWYgaXQgd2VyZSBqdXN0IGEgc2luZ2xlIGxpbmUKICBkb19zb21ldGhpbmcKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2lmLWFzLWEtbW9kaWZpZXIKCj09IFN0eWxlL0lmVW5sZXNzTW9kaWZpZXJPZklmVW5sZXNzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zOQp8IDAuODcKfD09PQoKQ2hlY2tzIGZvciBpZiBhbmQgdW5sZXNzIHN0YXRlbWVudHMgdXNlZCBhcyBtb2RpZmllcnMgb2Ygb3RoZXIgaWYgb3IKdW5sZXNzIHN0YXRlbWVudHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp0aXJlZD8gPyAnc3RvcCcgOiAnZ28gZmFzdGVyJyBpZiBydW5uaW5nPwoKIyBiYWQKaWYgdGlyZWQ/CiAgInBsZWFzZSBzdG9wIgplbHNlCiAgImtlZXAgZ29pbmciCmVuZCBpZiBydW5uaW5nPwoKIyBnb29kCmlmIHJ1bm5pbmc/CiAgdGlyZWQ/ID8gJ3N0b3AnIDogJ2dvIGZhc3RlcicKZW5kCi0tLS0KCj09IFN0eWxlL0lmV2l0aEJvb2xlYW5MaXRlcmFsQnJhbmNoZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAxLjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcmVkdW5kYW50IGBpZmAgd2l0aCBib29sZWFuIGxpdGVyYWwgYnJhbmNoZXMuCkl0IGNoZWNrcyBvbmx5IGNvbmRpdGlvbnMgdG8gcmV0dXJuIGJvb2xlYW4gdmFsdWUgKGB0cnVlYCBvciBgZmFsc2VgKSBmb3Igc2FmZSBkZXRlY3Rpb24uClRoZSBjb25kaXRpb25zIHRvIGJlIGNoZWNrZWQgYXJlIGNvbXBhcmlzb24gbWV0aG9kcywgcHJlZGljYXRlIG1ldGhvZHMsIGFuZApkb3VibGUgbmVnYXRpb24gKCEhKS4KYG5vbnplcm8/YCBtZXRob2QgaXMgYWxsb3dlZCBieSBkZWZhdWx0LgpUaGVzZSBhcmUgY3VzdG9taXphYmxlIHdpdGggYEFsbG93ZWRNZXRob2RzYCBvcHRpb24uCgpUaGlzIGNvcCB0YXJnZXRzIG9ubHkgYGlmYHMgd2l0aCBhIHNpbmdsZSBgZWxzaWZgIG9yIGBlbHNlYCBicmFuY2guIFRoZSBmb2xsb3dpbmcKY29kZSB3aWxsIGJlIGFsbG93ZWQsIGJlY2F1c2UgaXQgaGFzIHR3byBgZWxzaWZgIGJyYW5jaGVzOgoKW3NvdXJjZSxydWJ5XQotLS0tCmlmIGZvbwogIHRydWUKZWxzaWYgYmFyID4gYmF6CiAgdHJ1ZQplbHNpZiBxdXggPiBxdXV4ICMgU2luZ2xlIGBlbHNpZmAgaXMgd2FybmVkLCBidXQgdHdvIG9yIG1vcmUgYGVsc2lmYHMgYXJlIG5vdC4KICB0cnVlCmVsc2UKICBmYWxzZQplbmQKLS0tLQoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYWxsIHByZWRpY2F0ZSBtZXRob2RzCndpbGwgcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS4gVGhvc2UgbWV0aG9kcyBjYW4gYmUgYWxsb3dlZCB3aXRoIGBBbGxvd2VkTWV0aG9kc2AgY29uZmlnLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgZm9vID09IGJhcgogIHRydWUKZWxzZQogIGZhbHNlCmVuZAoKIyBiYWQKZm9vID09IGJhciA/IHRydWUgOiBmYWxzZQoKIyBnb29kCmZvbyA9PSBiYXIKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGZvby5kb19zb21ldGhpbmc/CiAgdHJ1ZQplbHNlCiAgZmFsc2UKZW5kCgojIGdvb2QgKGJ1dCBwb3RlbnRpYWxseSBhbiB1bnNhZmUgY29ycmVjdGlvbikKZm9vLmRvX3NvbWV0aGluZz8KLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogWydub256ZXJvPyddIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApudW0ubm9uemVybz8gPyB0cnVlIDogZmFsc2UKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYG5vbnplcm8/YAp8IEFycmF5Cnw9PT0KCj09IFN0eWxlL0lmV2l0aFNlbWljb2xvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuODMKfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIHNlbWljb2xvbiBpbiBpZiBzdGF0ZW1lbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVzdWx0ID0gaWYgc29tZV9jb25kaXRpb247IHNvbWV0aGluZyBlbHNlIGFub3RoZXJfdGhpbmcgZW5kCgojIGdvb2QKcmVzdWx0ID0gc29tZV9jb25kaXRpb24gPyBzb21ldGhpbmcgOiBhbm90aGVyX3RoaW5nCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLXNlbWljb2xvbi1pZnMKCj09IFN0eWxlL0ltcGxpY2l0UnVudGltZUVycm9yCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMC40MQp8IC0KfD09PQoKQ2hlY2tzIGZvciBgcmFpc2VgIG9yIGBmYWlsYCBzdGF0ZW1lbnRzIHdoaWNoIGRvIG5vdCBzcGVjaWZ5IGFuCmV4cGxpY2l0IGV4Y2VwdGlvbiBjbGFzcy4gKFRoaXMgcmFpc2VzIGEgYFJ1bnRpbWVFcnJvcmAuIFNvbWUgcHJvamVjdHMKbWlnaHQgcHJlZmVyIHRvIHVzZSBleGNlcHRpb24gY2xhc3NlcyB3aGljaCBtb3JlIHByZWNpc2VseSBpZGVudGlmeSB0aGUKbmF0dXJlIG9mIHRoZSBlcnJvci4pCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApyYWlzZSAnRXJyb3IgbWVzc2FnZSBoZXJlJwoKIyBnb29kCnJhaXNlIEFyZ3VtZW50RXJyb3IsICdFcnJvciBtZXNzYWdlIGhlcmUnCi0tLS0KCj09IFN0eWxlL0luUGF0dGVyblRoZW4KCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMi43Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS4xNgp8IC0KfD09PQoKQ2hlY2tzIGZvciBgaW47YCB1c2VzIGluIGBjYXNlYCBleHByZXNzaW9ucy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNhc2UgZXhwcmVzc2lvbgppbiBwYXR0ZXJuX2E7IGZvbwppbiBwYXR0ZXJuX2I7IGJhcgplbmQKCiMgZ29vZApjYXNlIGV4cHJlc3Npb24KaW4gcGF0dGVybl9hIHRoZW4gZm9vCmluIHBhdHRlcm5fYiB0aGVuIGJhcgplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8taW4tcGF0dGVybi1zZW1pY29sb25zCgo9PSBTdHlsZS9JbmZpbml0ZUxvb3AKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuMjYKfCAwLjYxCnw9PT0KClVzZSBgS2VybmVsI2xvb3BgIGZvciBpbmZpbml0ZSBsb29wcy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBhcyB0aGUgcnVsZSBzaG91bGQgbm90IG5lY2Vzc2FyaWx5IGFwcGx5IGlmIHRoZSBsb29wCmJvZHkgbWlnaHQgcmFpc2UgYSBgU3RvcEl0ZXJhdGlvbmAgZXhjZXB0aW9uOyBjb250cmFyeSB0byBvdGhlciBpbmZpbml0ZQpsb29wcywgYEtlcm5lbCNsb29wYCBzaWxlbnRseSByZXNjdWVzIHRoYXQgYW5kIHJldHVybnMgYG5pbGAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp3aGlsZSB0cnVlCiAgd29yawplbmQKCiMgZ29vZApsb29wIGRvCiAgd29yawplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjaW5maW5pdGUtbG9vcAoKPT0gU3R5bGUvSW5saW5lQ29tbWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuMjMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdHJhaWxpbmcgaW5saW5lIGNvbW1lbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmZvby5lYWNoIGRvIHxmfAogICMgU3RhbmRhbG9uZSBjb21tZW50CiAgZi5iYXIKZW5kCgojIGJhZApmb28uZWFjaCBkbyB8ZnwKICBmLmJhciAjIFRyYWlsaW5nIGlubGluZSBjb21tZW50CmVuZAotLS0tCgo9PSBTdHlsZS9JbnZlcnNlTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC40OAp8IC0KfD09PQoKQ2hlY2sgZm9yIHVzYWdlcyBvZiBub3QgKGBub3RgIG9yIGAhYCkgY2FsbGVkIG9uIGEgbWV0aG9kCndoZW4gYW4gaW52ZXJzZSBvZiB0aGF0IG1ldGhvZCBjYW4gYmUgdXNlZCBpbnN0ZWFkLgoKTWV0aG9kcyB0aGF0IGNhbiBiZSBpbnZlcnRlZCBieSBhIG5vdCAoYG5vdGAgb3IgYCFgKSBzaG91bGQgYmUgZGVmaW5lZAppbiBgSW52ZXJzZU1ldGhvZHNgLgoKTWV0aG9kcyB0aGF0IGFyZSBpbnZlcnRlZCBieSBpbnZlcnRpbmcgdGhlIHJldHVybgpvZiB0aGUgYmxvY2sgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBzaG91bGQgYmUgZGVmaW5lZCBpbgpgSW52ZXJzZUJsb2Nrc2AuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IHRoZSBtZXRob2QKYW5kIGl0cyBpbnZlcnNlIG1ldGhvZCBhcmUgYm90aCBkZWZpbmVkIG9uIHJlY2VpdmVyLCBhbmQgYWxzbyBhcmUKYWN0dWFsbHkgaW52ZXJzZSBvZiBlYWNoIG90aGVyLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIWZvby5ub25lPwohZm9vLmFueT8geyB8ZnwgZi5ldmVuPyB9CiFmb28uYmxhbms/CiEoZm9vID09IGJhcikKZm9vLnNlbGVjdCB7IHxmfCAhZi5ldmVuPyB9CmZvby5yZWplY3QgeyB8ZnwgZiAhPSA3IH0KCiMgZ29vZApmb28ubm9uZT8KZm9vLmJsYW5rPwpmb28uYW55PyB7IHxmfCBmLmV2ZW4/IH0KZm9vICE9IGJhcgpmb28gPT0gYmFyCiEhKCdmb28nID1+IC9eXHcrJC8pCiEoZm9vLmNsYXNzIDwgTnVtZXJpYykgIyBDaGVja2luZyBjbGFzcyBoaWVyYXJjaHkgaXMgYWxsb3dlZAojIEJsb2NrcyB3aXRoIGd1YXJkIGNsYXVzZXMgYXJlIGlnbm9yZWQ6CmZvby5zZWxlY3QgZG8gfGZ8CiAgbmV4dCBpZiBmLnplcm8/CiAgZiAhPSAxCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW52ZXJzZU1ldGhvZHMKfCBgezphbnk/PT46bm9uZT8sIDpldmVuPz0+Om9kZD8sIDo9PT0+OiE9LCA6PX49PjohfiwgOjw9Pjo+PSwgOj49Pjo8PX1gCnwgCgp8IEludmVyc2VCbG9ja3MKfCBgezpzZWxlY3Q9PjpyZWplY3QsIDpzZWxlY3QhPT46cmVqZWN0IX1gCnwgCnw9PT0KCj09IFN0eWxlL0ludmVydGlibGVVbmxlc3NDb25kaXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAxLjQ0CnwgMS41MAp8PT09CgpDaGVja3MgZm9yIHVzYWdlcyBvZiBgdW5sZXNzYCB3aGljaCBjYW4gYmUgcmVwbGFjZWQgYnkgYGlmYCB3aXRoIGludmVydGVkIGNvbmRpdGlvbi4KQ29kZSB3aXRob3V0IGB1bmxlc3NgIGlzIGVhc2llciB0byByZWFkLCBidXQgdGhhdCBpcyBzdWJqZWN0aXZlLCBzbyB0aGlzIGNvcAppcyBkaXNhYmxlZCBieSBkZWZhdWx0LgoKTWV0aG9kcyB0aGF0IGNhbiBiZSBpbnZlcnRlZCBzaG91bGQgYmUgZGVmaW5lZCBpbiBgSW52ZXJzZU1ldGhvZHNgLiBOb3RlIHRoYXQKdGhlIHJlbGF0aW9uc2hpcCBvZiBpbnZlcnNlIG1ldGhvZHMgbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBib3RoIGRpcmVjdGlvbnMuCkZvciBleGFtcGxlLAoKW3NvdXJjZSx5YW1sXQotLS0tCkludmVyc2VNZXRob2RzOgogIDohPTogOj09CiAgOmV2ZW4/OiA6b2RkPwogIDpvZGQ/OiA6ZXZlbj8KLS0tLQoKd2lsbCBzdWdnZXN0IGJvdGggYGV2ZW4/YCBhbmQgYG9kZD9gIHRvIGJlIGludmVydGVkLCBidXQgb25seSBgIT1gIChhbmQgbm90IGA9PWApLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdCB0aGUgbWV0aG9kCmFuZCBpdHMgaW52ZXJzZSBtZXRob2QgYXJlIGJvdGggZGVmaW5lZCBvbiByZWNlaXZlciwgYW5kIGFsc28gYXJlCmFjdHVhbGx5IGludmVyc2Ugb2YgZWFjaCBvdGhlci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIChzaW1wbGUgY29uZGl0aW9uKQpmb28gdW5sZXNzICFiYXIKZm9vIHVubGVzcyB4ICE9IHkKZm9vIHVubGVzcyB4ID49IDEwCmZvbyB1bmxlc3MgeC5ldmVuPwpmb28gdW5sZXNzIG9kZD8KCiMgZ29vZApmb28gaWYgYmFyCmZvbyBpZiB4ID09IHkKZm9vIGlmIHggPCAxMApmb28gaWYgeC5vZGQ/CmZvbyBpZiBldmVuPwoKIyBiYWQgKGNvbXBsZXggY29uZGl0aW9uKQpmb28gdW5sZXNzIHggIT0geSB8fCB4LmV2ZW4/CgojIGdvb2QKZm9vIGlmIHggPT0geSAmJiB4Lm9kZD8KCiMgZ29vZCAoaWYpCmZvbyBpZiAhY29uZGl0aW9uCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbnZlcnNlTWV0aG9kcwp8IGB7OiE9PT46PT0sIDo+PT46PD0sIDo8PT0+Oj4sIDo8PT46Pj0sIDo+PT0+OjwsIDohfj0+Oj1+LCA6emVybz89Pjpub256ZXJvPywgOm5vbnplcm8/PT46emVybz8sIDphbnk/PT46bm9uZT8sIDpub25lPz0+OmFueT8sIDpldmVuPz0+Om9kZD8sIDpvZGQ/PT46ZXZlbj99YAp8IAp8PT09Cgo9PSBTdHlsZS9JcEFkZHJlc3NlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuNTgKfCAwLjkxCnw9PT0KCkNoZWNrcyBmb3IgaGFyZGNvZGVkIElQIGFkZHJlc3Nlcywgd2hpY2ggY2FuIG1ha2UgY29kZQpicml0dGxlLiBJUCBhZGRyZXNzZXMgYXJlIGxpa2VseSB0byBuZWVkIHRvIGJlIGNoYW5nZWQgd2hlbiBjb2RlCmlzIGRlcGxveWVkIHRvIGEgZGlmZmVyZW50IHNlcnZlciBvciBlbnZpcm9ubWVudCwgd2hpY2ggbWF5IGJyZWFrCmEgZGVwbG95bWVudCBpZiBmb3Jnb3R0ZW4uIFByZWZlciBzZXR0aW5nIElQIGFkZHJlc3NlcyBpbiBFTlYgb3IKb3RoZXIgY29uZmlndXJhdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlwX2FkZHJlc3MgPSAnMTI3LjU5LjI0MS4yOScKCiMgZ29vZAppcF9hZGRyZXNzID0gRU5WWydERVBMT1lNRU5UX0lQX0FERFJFU1MnXQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZEFkZHJlc3Nlcwp8IGA6OmAKfCBBcnJheQoKfCBFeGNsdWRlCnwgYCsqKi8qLmdlbWZpbGUrYCwgYCsqKi9HZW1maWxlK2AsIGArKiovZ2Vtcy5yYitgLCBgKyoqLyouZ2Vtc3BlYytgCnwgQXJyYXkKfD09PQoKPT0gU3R5bGUvS2V5d29yZFBhcmFtZXRlcnNPcmRlcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOTAKfCAxLjcKfD09PQoKRW5mb3JjZXMgdGhhdCBvcHRpb25hbCBrZXl3b3JkIHBhcmFtZXRlcnMgYXJlIHBsYWNlZCBhdCB0aGUKZW5kIG9mIHRoZSBwYXJhbWV0ZXJzIGxpc3QuCgpUaGlzIGltcHJvdmVzIHJlYWRhYmlsaXR5LCBiZWNhdXNlIHdoZW4gbG9va2luZyB0aHJvdWdoIHRoZSBzb3VyY2UsCml0IGlzIGV4cGVjdGVkIHRvIGZpbmQgcmVxdWlyZWQgcGFyYW1ldGVycyBhdCB0aGUgYmVnaW5uaW5nIG9mIHBhcmFtZXRlcnMgbGlzdAphbmQgb3B0aW9uYWwgcGFyYW1ldGVycyBhdCB0aGUgZW5kLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHNvbWVfbWV0aG9kKGZpcnN0OiBmYWxzZSwgc2Vjb25kOiwgdGhpcmQ6IDEwKQogICMgYm9keSBvbWl0dGVkCmVuZAoKIyBnb29kCmRlZiBzb21lX21ldGhvZChzZWNvbmQ6LCBmaXJzdDogZmFsc2UsIHRoaXJkOiAxMCkKICAjIGJvZHkgb21pdHRlZAplbmQKCiMgYmFkCmRvX3NvbWV0aGluZyBkbyB8Zmlyc3Q6IGZhbHNlLCBzZWNvbmQ6LCB0aGlyZDogMTB8CiAgIyBib2R5IG9taXR0ZWQKZW5kCgojIGdvb2QKZG9fc29tZXRoaW5nIGRvIHxzZWNvbmQ6LCBmaXJzdDogZmFsc2UsIHRoaXJkOiAxMHwKICAjIGJvZHkgb21pdHRlZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUja2V5d29yZC1wYXJhbWV0ZXJzLW9yZGVyCgo9PSBTdHlsZS9MYW1iZGEKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjQwCnw9PT0KCihieSBkZWZhdWx0KSBjaGVja3MgZm9yIHVzZXMgb2YgdGhlIGxhbWJkYSBsaXRlcmFsIHN5bnRheCBmb3IKc2luZ2xlIGxpbmUgbGFtYmRhcywgYW5kIHRoZSBtZXRob2QgY2FsbCBzeW50YXggZm9yIG11bHRpbGluZSBsYW1iZGFzLgpJdCBpcyBjb25maWd1cmFibGUgdG8gZW5mb3JjZSBvbmUgb2YgdGhlIHN0eWxlcyBmb3IgYm90aCBzaW5nbGUgbGluZQphbmQgbXVsdGlsaW5lIGxhbWJkYXMgYXMgd2VsbC4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBsaW5lX2NvdW50X2RlcGVuZGVudCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmID0gbGFtYmRhIHsgfHh8IHggfQpmID0gLT4oeCkgZG8KICAgICAgeAogICAgZW5kCgojIGdvb2QKZiA9IC0+KHgpIHsgeCB9CmYgPSBsYW1iZGEgZG8gfHh8CiAgICAgIHgKICAgIGVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGxhbWJkYQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmYgPSAtPih4KSB7IHggfQpmID0gLT4oeCkgZG8KICAgICAgeAogICAgZW5kCgojIGdvb2QKZiA9IGxhbWJkYSB7IHx4fCB4IH0KZiA9IGxhbWJkYSBkbyB8eHwKICAgICAgeAogICAgZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogbGl0ZXJhbAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmYgPSBsYW1iZGEgeyB8eHwgeCB9CmYgPSBsYW1iZGEgZG8gfHh8CiAgICAgIHgKICAgIGVuZAoKIyBnb29kCmYgPSAtPih4KSB7IHggfQpmID0gLT4oeCkgZG8KICAgICAgeAogICAgZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGxpbmVfY291bnRfZGVwZW5kZW50YAp8IGBsaW5lX2NvdW50X2RlcGVuZGVudGAsIGBsYW1iZGFgLCBgbGl0ZXJhbGAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbGFtYmRhLW11bHRpLWxpbmUKCj09IFN0eWxlL0xhbWJkYUNhbGwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjEzCnwgMC4xNAp8PT09CgpDaGVja3MgZm9yIHVzZSBvZiB0aGUgbGFtYmRhLihhcmdzKSBzeW50YXguCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogY2FsbCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsYW1iZGEuKHgsIHkpCgojIGdvb2QKbGFtYmRhLmNhbGwoeCwgeSkKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBicmFjZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsYW1iZGEuY2FsbCh4LCB5KQoKIyBnb29kCmxhbWJkYS4oeCwgeSkKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgY2FsbGAKfCBgY2FsbGAsIGBicmFjZXNgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3Byb2MtY2FsbAoKPT0gU3R5bGUvTGluZUVuZENvbmNhdGVuYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjE4CnwgMC42NAp8PT09CgpDaGVja3MgZm9yIHN0cmluZyBsaXRlcmFsIGNvbmNhdGVuYXRpb24gYXQKdGhlIGVuZCBvZiBhIGxpbmUuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IHRoZQpyZWNlaXZlciBpcyBhIHN0cmluZywgaW4gd2hpY2ggY2FzZSByZXBsYWNpbmcgYDw8YCB3aXRoIGBcYAp3b3VsZCByZXN1bHQgaW4gYSBzeW50YXggZXJyb3IuCgpGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBiZSBhIGZhbHNlIHBvc2l0aXZlOgpbc291cmNlLHJ1YnldCi0tLS0KYXJyYXkgPDwgJ2ZvbycgPDwKICAgICAgICAgJ2JhcicgPDwKICAgICAgICAgJ2JheicKLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc29tZV9zdHIgPSAnYWxhJyArCiAgICAgICAgICAgJ2JhbGEnCgpzb21lX3N0ciA9ICdhbGEnIDw8CiAgICAgICAgICAgJ2JhbGEnCgojIGdvb2QKc29tZV9zdHIgPSAnYWxhJyBcCiAgICAgICAgICAgJ2JhbGEnCi0tLS0KCj09IFN0eWxlL01hZ2ljQ29tbWVudEZvcm1hdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuMzUKfCAtCnw9PT0KCkVuc3VyZXMgbWFnaWMgY29tbWVudHMgYXJlIHdyaXR0ZW4gY29uc2lzdGVudGx5IHRocm91Z2hvdXQgeW91ciBjb2RlIGJhc2UuCkxvb2tzIGZvciBkaXNjcmVwYW5jaWVzIGluIHNlcGFyYXRvcnMgKGAtYCB2cyBgX2ApIGFuZCBjYXBpdGFsaXphdGlvbiBmb3IKYm90aCBtYWdpYyBjb21tZW50IGRpcmVjdGl2ZXMgYW5kIHZhbHVlcy4KClJlcXVpcmVkIGNhcGl0YWxpemF0aW9uIGNhbiBiZSBzZXQgd2l0aCB0aGUgYERpcmVjdGl2ZUNhcGl0YWxpemF0aW9uYCBhbmQKYFZhbHVlQ2FwaXRhbGl6YXRpb25gIGNvbmZpZ3VyYXRpb24ga2V5cy4KCk5PVEU6IElmIG9uZSBvZiB0aGVzZSBjb25maWd1cmF0aW9uIGlzIHNldCB0byBuaWwsIGFueSBjYXBpdGFsaXphdGlvbiBpcyBhbGxvd2VkLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYHNuYWtlX2Nhc2VgIHN0eWxlIHdpbGwgZW5mb3JjZSB0aGF0IHRoZSBmcm96ZW4gc3RyaW5nIGxpdGVyYWwKIyBjb21tZW50IGlzIHdyaXR0ZW4gaW4gc25ha2UgY2FzZS4gKFdvcmRzIHNlcGFyYXRlZCBieSB1bmRlcnNjb3JlcykKIyBiYWQKIyBmcm96ZW4tc3RyaW5nLWxpdGVyYWw6IHRydWUKCm1vZHVsZSBCYXIKICAjIC4uLgplbmQKCiMgZ29vZAojIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogZmFsc2UKCm1vZHVsZSBCYXIKICAjIC4uLgplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBrZWJhYl9jYXNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYGtlYmFiX2Nhc2VgIHN0eWxlIHdpbGwgZW5mb3JjZSB0aGF0IHRoZSBmcm96ZW4gc3RyaW5nIGxpdGVyYWwKIyBjb21tZW50IGlzIHdyaXR0ZW4gaW4ga2ViYWIgY2FzZS4gKFdvcmRzIHNlcGFyYXRlZCBieSBoeXBoZW5zKQojIGJhZAojIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZQoKbW9kdWxlIEJhegogICMgLi4uCmVuZAoKIyBnb29kCiMgZnJvemVuLXN0cmluZy1saXRlcmFsOiB0cnVlCgptb2R1bGUgQmF6CiAgIyAuLi4KZW5kCi0tLS0KCj09PT0gRGlyZWN0aXZlQ2FwaXRhbGl6YXRpb246IGxvd2VyY2FzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAojIEZST1pFTi1TVFJJTkctTElURVJBTDogdHJ1ZQoKIyBnb29kCiMgZnJvemVuLXN0cmluZy1saXRlcmFsOiB0cnVlCi0tLS0KCj09PT0gRGlyZWN0aXZlQ2FwaXRhbGl6YXRpb246IHVwcGVyY2FzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgZnJvemVuLXN0cmluZy1saXRlcmFsOiB0cnVlCgojIGdvb2QKIyBGUk9aRU4tU1RSSU5HLUxJVEVSQUw6IHRydWUKLS0tLQoKPT09PSBEaXJlY3RpdmVDYXBpdGFsaXphdGlvbjogbmlsCgpbc291cmNlLHJ1YnldCi0tLS0KIyBhbnkgY2FwaXRhbGl6YXRpb24gaXMgYWNjZXB0ZWQKCiMgZ29vZAojIGZyb3plbi1zdHJpbmctbGl0ZXJhbDogdHJ1ZQoKIyBnb29kCiMgRlJPWkVOLVNUUklORy1MSVRFUkFMOiB0cnVlCi0tLS0KCj09PT0gVmFsdWVDYXBpdGFsaXphdGlvbjogbmlsIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYW55IGNhcGl0YWxpemF0aW9uIGlzIGFjY2VwdGVkCgojIGdvb2QKIyBmcm96ZW4tc3RyaW5nLWxpdGVyYWw6IHRydWUKCiMgZ29vZAojIGZyb3plbi1zdHJpbmctbGl0ZXJhbDogVFJVRQotLS0tCgo9PT09IFZhbHVlQ2FwaXRhbGl6YXRpb246IGxvd2VyY2FzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2hlbiBhIHZhbHVlIGlzIG5vdCBnaXZlbiwgYW55IGNhcGl0YWxpemF0aW9uIGlzIGFjY2VwdGVkCgojIGJhZAojIGZyb3plbi1zdHJpbmctbGl0ZXJhbDogVFJVRQoKIyBnb29kCiMgZnJvemVuLXN0cmluZy1saXRlcmFsOiBUUlVFCi0tLS0KCj09PT0gVmFsdWVDYXBpdGFsaXphdGlvbjogdXBwZXJjYXNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIyBmcm96ZW4tc3RyaW5nLWxpdGVyYWw6IHRydWUKCiMgZ29vZAojIGZyb3plbi1zdHJpbmctbGl0ZXJhbDogVFJVRQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBzbmFrZV9jYXNlYAp8IGBzbmFrZV9jYXNlYCwgYGtlYmFiX2Nhc2VgCgp8IERpcmVjdGl2ZUNhcGl0YWxpemF0aW9uCnwgYGxvd2VyY2FzZWAKfCBTdHJpbmcKCnwgVmFsdWVDYXBpdGFsaXphdGlvbgp8IGA8bm9uZT5gCnwgCnw9PT0KCj09IFN0eWxlL01hcENvbXBhY3RXaXRoQ29uZGl0aW9uYWxCbG9jawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuMzAKfCAtCnw9PT0KClByZWZlciBgc2VsZWN0YCBvciBgcmVqZWN0YCBvdmVyIGBtYXAgeyAuLi4gfS5jb21wYWN0YC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFycmF5Lm1hcCB7IHxlfCBzb21lX2NvbmRpdGlvbj8gPyBlIDogbmV4dCB9LmNvbXBhY3QKCiMgYmFkCmFycmF5Lm1hcCBkbyB8ZXwKICBpZiBzb21lX2NvbmRpdGlvbj8KICAgIGUKICBlbHNlCiAgICBuZXh0CiAgZW5kCmVuZC5jb21wYWN0CgojIGJhZAphcnJheS5tYXAgZG8gfGV8CiAgbmV4dCBpZiBzb21lX2NvbmRpdGlvbj8KCiAgZQplbmQuY29tcGFjdAoKIyBiYWQKYXJyYXkubWFwIGRvIHxlfAogIGUgaWYgc29tZV9jb25kaXRpb24/CmVuZC5jb21wYWN0CgojIGdvb2QKYXJyYXkuc2VsZWN0IHsgfGV8IHNvbWVfY29uZGl0aW9uPyB9CgojIGdvb2QKYXJyYXkucmVqZWN0IHsgfGV8IHNvbWVfY29uZGl0aW9uPyB9Ci0tLS0KCj09IFN0eWxlL01hcEludG9BcnJheQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS42Mwp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2FnZXMgb2YgYGVhY2hgIHdpdGggYDw8YCwgYHB1c2hgLCBvciBgYXBwZW5kYCB3aGljaApjYW4gYmUgcmVwbGFjZWQgYnkgYG1hcGAuCgpJZiBgUHJlZmVycmVkTWV0aG9kc2AgaXMgY29uZmlndXJlZCBmb3IgYG1hcGAgaW4gYFN0eWxlL0NvbGxlY3Rpb25NZXRob2RzYCwKdGhpcyBjb3AgdXNlcyB0aGUgc3BlY2lmaWVkIG1ldGhvZCBmb3IgcmVwbGFjZW1lbnQuCgpOT1RFOiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBFbnVtZXJhYmxlI2VhY2hgIGlzIGBzZWxmYCwgd2hlcmVhcyB0aGUKcmV0dXJuIHZhbHVlIG9mIGBFbnVtZXJhYmxlI21hcGAgaXMgYW4gYEFycmF5YC4gVGhleSBhcmUgbm90IGF1dG9jb3JyZWN0ZWQKd2hlbiBhIHJldHVybiB2YWx1ZSBjb3VsZCBiZSB1c2VkIGJlY2F1c2UgdGhlc2UgdHlwZXMgZGlmZmVyLgoKTk9URTogSXQgb25seSBkZXRlY3RzIHdoZW4gdGhlIG1hcHBpbmcgZGVzdGluYXRpb24gaXMgYSBsb2NhbCB2YXJpYWJsZQppbml0aWFsaXplZCBhcyBhbiBlbXB0eSBhcnJheSBhbmQgcmVmZXJyZWQgdG8gb25seSBieSB0aGUgcHVzaGluZyBvcGVyYXRpb24uClRoaXMgaXMgYmVjYXVzZSwgaWYgbm90LCBpdCdzIGNoYWxsZW5naW5nIHRvIHN0YXRpY2FsbHkgZ3VhcmFudGVlIHRoYXQgdGhlCm1hcHBpbmcgZGVzdGluYXRpb24gdmFyaWFibGUgcmVtYWlucyBhbiBlbXB0eSBhcnJheToKCltzb3VyY2UscnVieV0KLS0tLQpyZXQgPSBbXQpzcmMuZWFjaCB7IHxlfCByZXQgPDwgZSAqIDIgfSAjIGA8PGAgbWV0aG9kIG1heSBtdXRhdGUgYHJldGAKCmRlc3QgPSBbXQpzcmMuZWFjaCB7IHxlfCBkZXN0IDw8IHRyYW5zZm9ybShlLCBkZXN0KSB9ICMgYHRyYW5zZm9ybWAgbWV0aG9kIG1heSBtdXRhdGUgYGRlc3RgCi0tLS0KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIG5vdCBhbGwgb2JqZWN0cyB0aGF0IGhhdmUgYW4gYGVhY2hgCm1ldGhvZCBhbHNvIGhhdmUgYSBgbWFwYCBtZXRob2QgKGUuZy4gYEVOVmApLiBBZGRpdGlvbmFsbHksIGZvciBjYWxscwp3aXRoIGEgYmxvY2ssIG5vdCBhbGwgb2JqZWN0cyB0aGF0IGhhdmUgYSBgbWFwYCBtZXRob2QgcmV0dXJuIGFuIGFycmF5CihlLmcuIGBFbnVtZXJhdG9yOjpMYXp5YCkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXN0ID0gW10Kc3JjLmVhY2ggeyB8ZXwgZGVzdCA8PCBlICogMiB9CmRlc3QKCiMgZ29vZApkZXN0ID0gc3JjLm1hcCB7IHxlfCBlICogMiB9CgojIGdvb2QgLSBjb250YWlucyBhbm90aGVyIG9wZXJhdGlvbgpkZXN0ID0gW10Kc3JjLmVhY2ggeyB8ZXwgZGVzdCA8PCBlICogMjsgcHV0cyBlIH0KZGVzdAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNmdW5jdGlvbmFsLWNvZGUKCj09IFN0eWxlL01hcFRvSGFzaAoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjYKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuMjQKfCAtCnw9PT0KCkxvb2tzIGZvciB1c2VzIG9mIGBtYXAudG9faGAgb3IgYGNvbGxlY3QudG9faGAgdGhhdCBjb3VsZCBiZQp3cml0dGVuIHdpdGgganVzdCBgdG9faGAgaW4gUnVieSA+PSAyLjYuCgpOT1RFOiBgU3R5bGUvSGFzaFRyYW5zZm9ybUtleXNgIGFuZCBgU3R5bGUvSGFzaFRyYW5zZm9ybVZhbHVlc2Agd2lsbAphbHNvIGNoYW5nZSB0aGlzIHBhdHRlcm4gaWYgb25seSBoYXNoIGtleXMgb3IgaGFzaCB2YWx1ZXMgYXJlIGJlaW5nCnRyYW5zZm9ybWVkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlLCBhcyBpdCBjYW4gcHJvZHVjZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGhlIHJlY2VpdmVyCmlzIG5vdCBhbiBgRW51bWVyYWJsZWAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzb21ldGhpbmcubWFwIHsgfHZ8IFt2LCB2ICogMl0gfS50b19oCgojIGdvb2QKc29tZXRoaW5nLnRvX2ggeyB8dnwgW3YsIHYgKiAyXSB9CgojIGJhZAp7Zm9vOiBiYXJ9LmNvbGxlY3QgeyB8aywgdnwgW2sudG9fcywgdi5kb19zb21ldGhpbmddIH0udG9faAoKIyBnb29kCntmb286IGJhcn0udG9faCB7IHxrLCB2fCBbay50b19zLCB2LmRvX3NvbWV0aGluZ10gfQotLS0tCgo9PSBTdHlsZS9NYXBUb1NldAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS40Mgp8IC0KfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgYG1hcC50b19zZXRgIG9yIGBjb2xsZWN0LnRvX3NldGAgdGhhdCBjb3VsZCBiZQp3cml0dGVuIHdpdGgganVzdCBgdG9fc2V0YC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSwgYXMgaXQgY2FuIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIGlmIHRoZSByZWNlaXZlcgppcyBub3QgYW4gYEVudW1lcmFibGVgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc29tZXRoaW5nLm1hcCB7IHxpfCBpICogMiB9LnRvX3NldAoKIyBnb29kCnNvbWV0aGluZy50b19zZXQgeyB8aXwgaSAqIDIgfQoKIyBiYWQKWzEsIDIsIDNdLmNvbGxlY3QgeyB8aXwgaS50b19zIH0udG9fc2V0CgojIGdvb2QKWzEsIDIsIDNdLnRvX3NldCB7IHxpfCBpLnRvX3MgfQotLS0tCgo9PSBTdHlsZS9NZXRob2RDYWxsV2l0aEFyZ3NQYXJlbnRoZXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ3CnwgMS43Cnw9PT0KCkVuZm9yY2VzIHRoZSBwcmVzZW5jZSAoZGVmYXVsdCkgb3IgYWJzZW5jZSBvZiBwYXJlbnRoZXNlcyBpbgptZXRob2QgY2FsbHMgY29udGFpbmluZyBwYXJhbWV0ZXJzLgoKSW4gdGhlIGRlZmF1bHQgc3R5bGUgKHJlcXVpcmVfcGFyZW50aGVzZXMpLCBtYWNybyBtZXRob2RzIGFyZSBhbGxvd2VkLgpBZGRpdGlvbmFsIG1ldGhvZHMgY2FuIGJlIGFkZGVkIHRvIHRoZSBgQWxsb3dlZE1ldGhvZHNgIG9yCmBBbGxvd2VkUGF0dGVybnNgIGxpc3QuIFRoZXNlIG9wdGlvbnMgYXJlIHZhbGlkIG9ubHkgaW4gdGhlIGRlZmF1bHQKc3R5bGUuIE1hY3JvcyBjYW4gYmUgaW5jbHVkZWQgYnkgZWl0aGVyIHNldHRpbmcgYElnbm9yZU1hY3Jvc2AgdG8gZmFsc2UKb3IgYWRkaW5nIHNwZWNpZmljIG1hY3JvcyB0byB0aGUgYEluY2x1ZGVkTWFjcm9zYCBsaXN0LgoKUHJlY2VkZW5jZSBvZiBvcHRpb25zIGlzIGFzIGZvbGxvd3M6CgoxLiBgQWxsb3dlZE1ldGhvZHNgCjIuIGBBbGxvd2VkUGF0dGVybnNgCjMuIGBJbmNsdWRlZE1hY3Jvc2AKCklmIGEgbWV0aG9kIGlzIGxpc3RlZCBpbiBib3RoIGBJbmNsdWRlZE1hY3Jvc2AgYW5kIGBBbGxvd2VkTWV0aG9kc2AsCnRoZW4gdGhlIGxhdHRlciB0YWtlcyBwcmVjZWRlbmNlICh0aGF0IGlzLCB0aGUgbWV0aG9kIGlzIGFsbG93ZWQpLgoKSW4gdGhlIGFsdGVybmF0aXZlIHN0eWxlIChvbWl0X3BhcmVudGhlc2VzKSwgdGhlcmUgYXJlIHRocmVlIGFkZGl0aW9uYWwKb3B0aW9ucy4KCjEuIGBBbGxvd1BhcmVudGhlc2VzSW5DaGFpbmluZ2AgaXMgYGZhbHNlYCBieSBkZWZhdWx0LiBTZXR0aW5nIGl0IHRvCiAgIGB0cnVlYCBhbGxvd3MgdGhlIHByZXNlbmNlIG9mIHBhcmVudGhlc2VzIGluIHRoZSBsYXN0IGNhbGwgZHVyaW5nCiAgIG1ldGhvZCBjaGFpbmluZy4KCjIuIGBBbGxvd1BhcmVudGhlc2VzSW5NdWx0aWxpbmVDYWxsYCBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldHRpbmcgaXQKICAgIHRvIGB0cnVlYCBhbGxvd3MgdGhlIHByZXNlbmNlIG9mIHBhcmVudGhlc2VzIGluIG11bHRpLWxpbmUgbWV0aG9kCiAgICBjYWxscy4KCjMuIGBBbGxvd1BhcmVudGhlc2VzSW5DYW1lbENhc2VNZXRob2RgIGlzIGBmYWxzZWAgYnkgZGVmYXVsdC4gVGhpcwogICAgYWxsb3dzIHRoZSBwcmVzZW5jZSBvZiBwYXJlbnRoZXNlcyB3aGVuIGNhbGxpbmcgYSBtZXRob2Qgd2hvc2UgbmFtZQogICAgYmVnaW5zIHdpdGggYSBjYXBpdGFsIGxldHRlciBhbmQgd2hpY2ggaGFzIG5vIGFyZ3VtZW50cy4gU2V0dGluZyBpdAogICAgdG8gYHRydWVgIGFsbG93cyB0aGUgcHJlc2VuY2Ugb2YgcGFyZW50aGVzZXMgaW4gc3VjaCBhIG1ldGhvZCBjYWxsCiAgICBldmVuIHdpdGggYXJndW1lbnRzLgoKTk9URTogVGhlIHN0eWxlIG9mIGBvbWl0X3BhcmVudGhlc2VzYCBhbGxvd3MgcGFyZW50aGVzZXMgaW4gY2FzZXMgd2hlcmUKb21pdHRpbmcgdGhlbSByZXN1bHRzIGluIGFtYmlndW91cyBvciBzeW50YWN0aWNhbGx5IGluY29ycmVjdCBjb2RlLgoKTm9uLWV4aGF1c3RpdmUgbGlzdCBvZiBleGFtcGxlczoKCi0gUGFyZW50aGVzZXMgYXJlIHJlcXVpcmVkIGFsbG93ZWQgaW4gbWV0aG9kIGNhbGxzIHdpdGggYXJndW1lbnRzIGluc2lkZQogIGxpdGVyYWxzLCBsb2dpY2FsIG9wZXJhdG9ycywgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBpbiBwb3NpdGlvbiBhbmQKICBrZXl3b3JkIGFyZ3VtZW50cywgY2hhaW5pbmcgYW5kIG1vcmUuCi0gUGFyZW50aGVzZXMgYXJlIGFsbG93ZWQgaW4gbWV0aG9kIGNhbGxzIHdpdGggYXJndW1lbnRzIGluc2lkZQogIG9wZXJhdG9ycyB0byBhdm9pZCBhbWJpZ3VpdHkuCiAgdHJpcGxlLWRvdCBzeW50YXggaW50cm9kdWNlZCBpbiBSdWJ5IDIuNyBhcyBvbWl0dGluZyB0aGVtIHN0YXJ0cyBhbgogIGVuZGxlc3MgcmFuZ2UuCi0gUGFyZW50aGVzZXMgYXJlIGFsbG93ZWQgd2hlbiBmb3J3YXJkaW5nIGFyZ3VtZW50cyB3aXRoIHRoZQogIHRyaXBsZS1kb3Qgc3ludGF4IGludHJvZHVjZWQgaW4gUnVieSAyLjcgYXMgb21pdHRpbmcgdGhlbSBzdGFydHMgYW4KICBlbmRsZXNzIHJhbmdlLgotIFBhcmVudGhlc2VzIGFyZSByZXF1aXJlZCBpbiBjYWxscyB3aXRoIGFyZ3VtZW50cyB3aGVuIGluc2lkZSBhbgogIGVuZGxlc3MgbWV0aG9kIGRlZmluaXRpb24gaW50cm9kdWNlZCBpbiBSdWJ5IDMuMC4KLSBSdWJ5IDMuMSdzIGhhc2ggb21pc3Npb24gc3ludGF4IGFsbG93cyBwYXJlbnRoZXNlcyBpZiB0aGUgbWV0aG9kIGNhbGwKICBpcyBpbiBjb25kaXRpb25hbHMgYW5kIHJlcXVpcmVzIHBhcmVudGhlc2VzIGlmIHRoZSBjYWxsCiAgaXMgbm90IHRoZSB2YWx1ZS1yZXR1cm5pbmcgZXhwcmVzc2lvbi4gU2VlCiAgaHR0cHM6Ly9idWdzLnJ1YnktbGFuZy5vcmcvaXNzdWVzLzE4Mzk2LgotIFBhcmVudGhlc2VzIGFyZSByZXF1aXJlZCBpbiBhbm9ueW1vdXMgYXJndW1lbnRzLCBrZXl3b3JkIGFyZ3VtZW50cwogIGFuZCBibG9jayBwYXNzaW5nIGluIFJ1YnkgMy4yLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfcGFyZW50aGVzZXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXJyYXkuZGVsZXRlIGUKCiMgZ29vZAphcnJheS5kZWxldGUoZSkKCiMgZ29vZAojIE9wZXJhdG9ycyBkb24ndCBuZWVkIHBhcmVucwpmb28gPT0gYmFyCgojIGdvb2QKIyBTZXR0ZXIgbWV0aG9kcyBkb24ndCBuZWVkIHBhcmVucwpmb28uYmFyID0gYmF6CgojIG9rYXkgd2l0aCBgcHV0c2AgbGlzdGVkIGluIGBBbGxvd2VkTWV0aG9kc2AKcHV0cyAndGVzdCcKCiMgb2theSB3aXRoIGBeYXNzZXJ0YCBsaXN0ZWQgaW4gYEFsbG93ZWRQYXR0ZXJuc2AKYXNzZXJ0X2VxdWFsICd0ZXN0JywgeAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IG9taXRfcGFyZW50aGVzZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphcnJheS5kZWxldGUoZSkKCiMgZ29vZAphcnJheS5kZWxldGUgZQoKIyBiYWQKYWN0aW9uLmVuZm9yY2Uoc3RyaWN0OiB0cnVlKQoKIyBnb29kCmFjdGlvbi5lbmZvcmNlIHN0cmljdDogdHJ1ZQoKIyBnb29kCiMgUGFyZW50aGVzZXMgYXJlIGFsbG93ZWQgZm9yIGNvZGUgdGhhdCBjYW4gYmUgYW1iaWd1b3VzIHdpdGhvdXQKIyB0aGVtLgphY3Rpb24uZW5mb3JjZShjb25kaXRpb24pIHx8IG90aGVyX2NvbmRpdGlvbgoKIyBnb29kCiMgUGFyZW50aGVzZXMgYXJlIGFsbG93ZWQgZm9yIGNhbGxzIHRoYXQgd29uJ3QgcHJvZHVjZSB2YWxpZCBSdWJ5CiMgd2l0aG91dCB0aGVtLgp5aWVsZCBwYXRoLCBGaWxlLmJhc2VuYW1lKHBhdGgpCgojIGdvb2QKIyBPbWl0dGluZyB0aGUgcGFyZW50aGVzZXMgaW4gUnVieSAzLjEgaGFzaCBvbWlzc2lvbiBzeW50YXggY2FuIGxlYWQKIyB0byBhbWJpZ3VvdXMgY29kZS4gV2UgYWxsb3cgdGhlbSBpbiBjb25kaXRpb25hbHMgYW5kIG5vbi1sYXN0CiMgZXhwcmVzc2lvbnMuIFNlZSBodHRwczovL2J1Z3MucnVieS1sYW5nLm9yZy9pc3N1ZXMvMTgzOTYKaWYgbWVldHMoY3JpdGVyaWE6LCBhY3Rpb246KQogIHNhZmVfYWN0aW9uKGFjdGlvbikgfHwgZGFuZ2Vyb3VzX2FjdGlvbihhY3Rpb24pCmVuZAotLS0tCgo9PT09IElnbm9yZU1hY3JvczogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKY2xhc3MgRm9vCiAgYmFyIDpiYXoKZW5kCi0tLS0KCj09PT0gSWdub3JlTWFjcm9zOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwogIGJhciA6YmF6CmVuZAotLS0tCgo9PT09IEFsbG93UGFyZW50aGVzZXNJbk11bHRpbGluZUNhbGw6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby5lbmZvcmNlKAogIHN0cmljdDogdHJ1ZQopCgojIGdvb2QKZm9vLmVuZm9yY2UgXAogIHN0cmljdDogdHJ1ZQotLS0tCgo9PT09IEFsbG93UGFyZW50aGVzZXNJbk11bHRpbGluZUNhbGw6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZm9vLmVuZm9yY2UoCiAgc3RyaWN0OiB0cnVlCikKCiMgZ29vZApmb28uZW5mb3JjZSBcCiAgc3RyaWN0OiB0cnVlCi0tLS0KCj09PT0gQWxsb3dQYXJlbnRoZXNlc0luQ2hhaW5pbmc6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvbygpLmJhcigxKQoKIyBnb29kCmZvbygpLmJhciAxCi0tLS0KCj09PT0gQWxsb3dQYXJlbnRoZXNlc0luQ2hhaW5pbmc6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZm9vKCkuYmFyKDEpCgojIGdvb2QKZm9vKCkuYmFyIDEKLS0tLQoKPT09PSBBbGxvd1BhcmVudGhlc2VzSW5DYW1lbENhc2VNZXRob2Q6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkFycmF5KDEpCgojIGdvb2QKQXJyYXkgMQotLS0tCgo9PT09IEFsbG93UGFyZW50aGVzZXNJbkNhbWVsQ2FzZU1ldGhvZDogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApBcnJheSgxKQoKIyBnb29kCkFycmF5IDEKLS0tLQoKPT09PSBBbGxvd1BhcmVudGhlc2VzSW5TdHJpbmdJbnRlcnBvbGF0aW9uOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAoiI3t0KCd0aGlzLmlzLmJhZCcpfSIKCiMgZ29vZAoiI3t0ICd0aGlzLmlzLmJldHRlcid9IgotLS0tCgo9PT09IEFsbG93UGFyZW50aGVzZXNJblN0cmluZ0ludGVycG9sYXRpb246IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKIiN7dCgndGhpcy5pcy5nb29kJyl9IgoKIyBnb29kCiIje3QgJ3RoaXMuaXMuYWxzby5nb29kJ30iCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJZ25vcmVNYWNyb3MKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQoKfCBJbmNsdWRlZE1hY3Jvcwp8IGBbXWAKfCBBcnJheQoKfCBBbGxvd1BhcmVudGhlc2VzSW5NdWx0aWxpbmVDYWxsCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgQWxsb3dQYXJlbnRoZXNlc0luQ2hhaW5pbmcKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBBbGxvd1BhcmVudGhlc2VzSW5DYW1lbENhc2VNZXRob2QKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBBbGxvd1BhcmVudGhlc2VzSW5TdHJpbmdJbnRlcnBvbGF0aW9uCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgRW5mb3JjZWRTdHlsZQp8IGByZXF1aXJlX3BhcmVudGhlc2VzYAp8IGByZXF1aXJlX3BhcmVudGhlc2VzYCwgYG9taXRfcGFyZW50aGVzZXNgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI21ldGhvZC1pbnZvY2F0aW9uLXBhcmVucwoKPT0gU3R5bGUvTWV0aG9kQ2FsbFdpdGhvdXRBcmdzUGFyZW50aGVzZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ3CnwgMC41NQp8PT09CgpDaGVja3MgZm9yIHVud2FudGVkIHBhcmVudGhlc2VzIGluIHBhcmFtZXRlcmxlc3MgbWV0aG9kIGNhbGxzLgoKVGhpcyBjb3AgY2FuIGJlIGN1c3RvbWl6ZWQgYWxsb3dlZCBtZXRob2RzIHdpdGggYEFsbG93ZWRNZXRob2RzYC4KQnkgZGVmYXVsdCwgdGhlcmUgYXJlIG5vIG1ldGhvZHMgdG8gYWxsb3dlZC4KCk5PVEU6IFRoaXMgY29wIGFsbG93cyB0aGUgdXNlIG9mIGBpdCgpYCB3aXRob3V0IGFyZ3VtZW50cyBpbiBibG9ja3MsCmFzIGluIGAwLnRpbWVzIHsgaXQoKSB9YCwgZm9sbG93aW5nIGBMaW50L0l0V2l0aG91dEFyZ3VtZW50c0luQmxvY2tgIGNvcC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm9iamVjdC5zb21lX21ldGhvZCgpCgojIGdvb2QKb2JqZWN0LnNvbWVfbWV0aG9kCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFtdIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm9iamVjdC5mb28oKQotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbZm9vXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApvYmplY3QuZm9vKCkKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtZXRob2QtaW52b2NhdGlvbi1wYXJlbnMKCj09IFN0eWxlL01ldGhvZENhbGxlZE9uRG9FbmRCbG9jawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDAuMTQKfCAtCnw9PT0KCkNoZWNrcyBmb3IgbWV0aG9kcyBjYWxsZWQgb24gYSBkby4uLmVuZCBibG9jay4gVGhlIHBvaW50IG9mCnRoaXMgY2hlY2sgaXMgdGhhdCBpdCdzIGVhc3kgdG8gbWlzcyB0aGUgY2FsbCB0YWNrZWQgb24gdG8gdGhlIGJsb2NrCndoZW4gcmVhZGluZyBjb2RlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSBkbwogIGIKZW5kLmMKCiMgZ29vZAphIHsgYiB9LmMKCiMgZ29vZApmb28gPSBhIGRvCiAgYgplbmQKZm9vLmMKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc2luZ2xlLWxpbmUtYmxvY2tzCgo9PSBTdHlsZS9NZXRob2REZWZQYXJlbnRoZXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTYKfCAxLjcKfD09PQoKQ2hlY2tzIGZvciBwYXJlbnRoZXNlcyBhcm91bmQgdGhlIGFyZ3VtZW50cyBpbiBtZXRob2QKZGVmaW5pdGlvbnMuIEJvdGggaW5zdGFuY2UgYW5kIGNsYXNzL3NpbmdsZXRvbiBtZXRob2RzIGFyZSBjaGVja2VkLgoKUmVnYXJkbGVzcyBvZiBzdHlsZSwgcGFyZW50aGVzZXMgYXJlIG5lY2Vzc2FyeSBmb3I6CgoxLiBFbmRsZXNzIG1ldGhvZHMKMi4gQXJndW1lbnQgbGlzdHMgY29udGFpbmluZyBhIGBmb3J3YXJkLWFyZ2AgKGAuLi5gKQozLiBBcmd1bWVudCBsaXN0cyBjb250YWluaW5nIGFuIGFub255bW91cyByZXN0IGFyZ3VtZW50cyBmb3J3YXJkaW5nIChgKmApCjQuIEFyZ3VtZW50IGxpc3RzIGNvbnRhaW5pbmcgYW4gYW5vbnltb3VzIGtleXdvcmQgcmVzdCBhcmd1bWVudHMgZm9yd2FyZGluZyAoYCoqYCkKNS4gQXJndW1lbnQgbGlzdHMgY29udGFpbmluZyBhbiBhbm9ueW1vdXMgYmxvY2sgZm9yd2FyZGluZyAoYCZgKQoKUmVtb3ZpbmcgdGhlIHBhcmVucyB3b3VsZCBiZSBhIHN5bnRheCBlcnJvciBoZXJlLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfcGFyZW50aGVzZXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYHJlcXVpcmVfcGFyZW50aGVzZXNgIHN0eWxlIHJlcXVpcmVzIG1ldGhvZCBkZWZpbml0aW9ucwojIHRvIGFsd2F5cyB1c2UgcGFyZW50aGVzZXMKCiMgYmFkCmRlZiBiYXIgbnVtMSwgbnVtMgogIG51bTEgKyBudW0yCmVuZAoKZGVmIGZvbyBkZXNjcmlwdGl2ZV92YXJfbmFtZSwKICAgICAgICBhbm90aGVyX2Rlc2NyaXB0aXZlX3Zhcl9uYW1lLAogICAgICAgIGxhc3RfZGVzY3JpcHRpdmVfdmFyX25hbWUKICBkb19zb21ldGhpbmcKZW5kCgojIGdvb2QKZGVmIGJhcihudW0xLCBudW0yKQogIG51bTEgKyBudW0yCmVuZAoKZGVmIGZvbyhkZXNjcmlwdGl2ZV92YXJfbmFtZSwKICAgICAgICBhbm90aGVyX2Rlc2NyaXB0aXZlX3Zhcl9uYW1lLAogICAgICAgIGxhc3RfZGVzY3JpcHRpdmVfdmFyX25hbWUpCiAgZG9fc29tZXRoaW5nCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfbm9fcGFyZW50aGVzZXMKCltzb3VyY2UscnVieV0KLS0tLQojIFRoZSBgcmVxdWlyZV9ub19wYXJlbnRoZXNlc2Agc3R5bGUgcmVxdWlyZXMgbWV0aG9kIGRlZmluaXRpb25zCiMgdG8gbmV2ZXIgdXNlIHBhcmVudGhlc2VzCgojIGJhZApkZWYgYmFyKG51bTEsIG51bTIpCiAgbnVtMSArIG51bTIKZW5kCgpkZWYgZm9vKGRlc2NyaXB0aXZlX3Zhcl9uYW1lLAogICAgICAgIGFub3RoZXJfZGVzY3JpcHRpdmVfdmFyX25hbWUsCiAgICAgICAgbGFzdF9kZXNjcmlwdGl2ZV92YXJfbmFtZSkKICBkb19zb21ldGhpbmcKZW5kCgojIGdvb2QKZGVmIGJhciBudW0xLCBudW0yCiAgbnVtMSArIG51bTIKZW5kCgpkZWYgZm9vIGRlc2NyaXB0aXZlX3Zhcl9uYW1lLAogICAgICAgIGFub3RoZXJfZGVzY3JpcHRpdmVfdmFyX25hbWUsCiAgICAgICAgbGFzdF9kZXNjcmlwdGl2ZV92YXJfbmFtZQogIGRvX3NvbWV0aGluZwplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiByZXF1aXJlX25vX3BhcmVudGhlc2VzX2V4Y2VwdF9tdWx0aWxpbmUKCltzb3VyY2UscnVieV0KLS0tLQojIFRoZSBgcmVxdWlyZV9ub19wYXJlbnRoZXNlc19leGNlcHRfbXVsdGlsaW5lYCBzdHlsZSBwcmVmZXJzIG5vCiMgcGFyZW50aGVzZXMgd2hlbiBtZXRob2QgZGVmaW5pdGlvbiBhcmd1bWVudHMgZml0IG9uIHNpbmdsZSBsaW5lLAojIGJ1dCBwcmVmZXJzIHBhcmVudGhlc2VzIHdoZW4gYXJndW1lbnRzIHNwYW4gbXVsdGlwbGUgbGluZXMuCgojIGJhZApkZWYgYmFyKG51bTEsIG51bTIpCiAgbnVtMSArIG51bTIKZW5kCgpkZWYgZm9vIGRlc2NyaXB0aXZlX3Zhcl9uYW1lLAogICAgICAgIGFub3RoZXJfZGVzY3JpcHRpdmVfdmFyX25hbWUsCiAgICAgICAgbGFzdF9kZXNjcmlwdGl2ZV92YXJfbmFtZQogIGRvX3NvbWV0aGluZwplbmQKCiMgZ29vZApkZWYgYmFyIG51bTEsIG51bTIKICBudW0xICsgbnVtMgplbmQKCmRlZiBmb28oZGVzY3JpcHRpdmVfdmFyX25hbWUsCiAgICAgICAgYW5vdGhlcl9kZXNjcmlwdGl2ZV92YXJfbmFtZSwKICAgICAgICBsYXN0X2Rlc2NyaXB0aXZlX3Zhcl9uYW1lKQogIGRvX3NvbWV0aGluZwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgcmVxdWlyZV9wYXJlbnRoZXNlc2AKfCBgcmVxdWlyZV9wYXJlbnRoZXNlc2AsIGByZXF1aXJlX25vX3BhcmVudGhlc2VzYCwgYHJlcXVpcmVfbm9fcGFyZW50aGVzZXNfZXhjZXB0X211bHRpbGluZWAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbWV0aG9kLXBhcmVucwoKPT0gU3R5bGUvTWluTWF4Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41MAp8IC0KfD09PQoKQ2hlY2tzIGZvciBwb3RlbnRpYWwgdXNlcyBvZiBgRW51bWVyYWJsZSNtaW5tYXhgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYmFyID0gW2Zvby5taW4sIGZvby5tYXhdCnJldHVybiBmb28ubWluLCBmb28ubWF4CgojIGdvb2QKYmFyID0gZm9vLm1pbm1heApyZXR1cm4gZm9vLm1pbm1heAotLS0tCgo9PSBTdHlsZS9NaW5NYXhDb21wYXJpc29uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAxLjQyCnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGBtYXhgIG9yIGBtaW5gIGluc3RlYWQgb2YgY29tcGFyaXNvbiBmb3IgZ3JlYXRlciBvciBsZXNzLgoKTk9URTogSXQgY2FuIGJlIHVzZWQgaWYgeW91IHdhbnQgdG8gcHJlc2VudCBsaW1pdCBvciB0aHJlc2hvbGQgaW4gUnVieSAyLjcrLgpUaGF0IGl0IGlzIHNsb3cgdGhvdWdoLiBTbyBhdXRvY29ycmVjdGlvbiB3aWxsIGFwcGx5IGdlbmVyaWMgYG1heGAgb3IgYG1pbmA6Cgpbc291cmNlLHJ1YnldCi0tLS0KYS5jbGFtcChiLi4pICMgU2FtZSBhcyBgW2EsIGJdLm1heGAKYS5jbGFtcCguLmIpICMgU2FtZSBhcyBgW2EsIGJdLm1pbmAKLS0tLQoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgZXZlbiBpZiBhIHZhbHVlIGhhcyBgPGAgb3IgYD5gIG1ldGhvZCwKaXQgaXMgbm90IG5lY2Vzc2FyaWx5IGBDb21wYXJhYmxlYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgPiBiID8gYSA6IGIKYSA+PSBiID8gYSA6IGIKCiMgZ29vZApbYSwgYl0ubWF4CgojIGJhZAphIDwgYiA/IGEgOiBiCmEgPD0gYiA/IGEgOiBiCgojIGdvb2QKW2EsIGJdLm1pbgotLS0tCgo9PSBTdHlsZS9NaXNzaW5nRWxzZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjMwCnwgMC4zOAp8PT09CgpDaGVja3MgZm9yIGBpZmAgZXhwcmVzc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhbiBgZWxzZWAgYnJhbmNoLgoKTk9URTogUGF0dGVybiBtYXRjaGluZyBpcyBhbGxvd2VkIHRvIGhhdmUgbm8gYGVsc2VgIGJyYW5jaCBiZWNhdXNlIHVubGlrZSBgaWZgIGFuZCBgY2FzZWAsCml0IHJhaXNlcyBgTm9NYXRjaGluZ1BhdHRlcm5FcnJvcmAgaWYgdGhlIHBhdHRlcm4gZG9lc24ndCBtYXRjaCBhbmQgd2l0aG91dCBoYXZpbmcgYGVsc2VgLgoKU3VwcG9ydGVkIHN0eWxlcyBhcmU6IGlmLCBjYXNlLCBib3RoLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGJvdGggKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyB3YXJuIHdoZW4gYW4gYGlmYCBvciBgY2FzZWAgZXhwcmVzc2lvbiBpcyBtaXNzaW5nIGFuIGBlbHNlYCBicmFuY2guCgojIGJhZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZW5kCgojIGJhZApjYXNlIHZhcgp3aGVuIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKCiMgZ29vZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZWxzZQogICMgdGhlIGNvbnRlbnQgb2YgYGVsc2VgIGJyYW5jaCB3aWxsIGJlIGRldGVybWluZWQgYnkgU3R5bGUvRW1wdHlFbHNlCmVuZAoKIyBnb29kCmNhc2UgdmFyCndoZW4gY29uZGl0aW9uCiAgc3RhdGVtZW50CmVsc2UKICAjIHRoZSBjb250ZW50IG9mIGBlbHNlYCBicmFuY2ggd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IFN0eWxlL0VtcHR5RWxzZQplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBpZgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2FybiB3aGVuIGFuIGBpZmAgZXhwcmVzc2lvbiBpcyBtaXNzaW5nIGFuIGBlbHNlYCBicmFuY2guCgojIGJhZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZW5kCgojIGdvb2QKaWYgY29uZGl0aW9uCiAgc3RhdGVtZW50CmVsc2UKICAjIHRoZSBjb250ZW50IG9mIGBlbHNlYCBicmFuY2ggd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IFN0eWxlL0VtcHR5RWxzZQplbmQKCiMgZ29vZApjYXNlIHZhcgp3aGVuIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKCiMgZ29vZApjYXNlIHZhcgp3aGVuIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbHNlCiAgIyB0aGUgY29udGVudCBvZiBgZWxzZWAgYnJhbmNoIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBTdHlsZS9FbXB0eUVsc2UKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY2FzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2FybiB3aGVuIGEgYGNhc2VgIGV4cHJlc3Npb24gaXMgbWlzc2luZyBhbiBgZWxzZWAgYnJhbmNoLgoKIyBiYWQKY2FzZSB2YXIKd2hlbiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZW5kCgojIGdvb2QKY2FzZSB2YXIKd2hlbiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZWxzZQogICMgdGhlIGNvbnRlbnQgb2YgYGVsc2VgIGJyYW5jaCB3aWxsIGJlIGRldGVybWluZWQgYnkgU3R5bGUvRW1wdHlFbHNlCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbgogIHN0YXRlbWVudAplbmQKCiMgZ29vZAppZiBjb25kaXRpb24KICBzdGF0ZW1lbnQKZWxzZQogICMgdGhlIGNvbnRlbnQgb2YgYGVsc2VgIGJyYW5jaCB3aWxsIGJlIGRldGVybWluZWQgYnkgU3R5bGUvRW1wdHlFbHNlCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBib3RoYAp8IGBpZmAsIGBjYXNlYCwgYGJvdGhgCnw9PT0KCj09IFN0eWxlL01pc3NpbmdSZXNwb25kVG9NaXNzaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjU2CnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSBwcmVzZW5jZSBvZiBgbWV0aG9kX21pc3NpbmdgIHdpdGhvdXQgYWxzbwpkZWZpbmluZyBgcmVzcG9uZF90b19taXNzaW5nP2AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MpCiAgIyAuLi4KZW5kCgojIGdvb2QKZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9wcml2YXRlKQogICMgLi4uCmVuZAoKZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzKQogICMgLi4uCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1tZXRob2QtbWlzc2luZwoKPT0gU3R5bGUvTWl4aW5Hcm91cGluZwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNDgKfCAwLjQ5Cnw9PT0KCkNoZWNrcyBmb3IgZ3JvdXBpbmcgb2YgbWl4aW5zIGluIGBjbGFzc2AgYW5kIGBtb2R1bGVgIGJvZGllcy4KQnkgZGVmYXVsdCBpdCBlbmZvcmNlcyBtaXhpbnMgdG8gYmUgcGxhY2VkIGluIHNlcGFyYXRlIGRlY2xhcmF0aW9ucywKYnV0IGl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGVuZm9yY2UgZ3JvdXBpbmcgdGhlbSBpbiBvbmUgZGVjbGFyYXRpb24uCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2VwYXJhdGVkIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbwogIGluY2x1ZGUgQmFyLCBRb3gKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgaW5jbHVkZSBRb3gKICBpbmNsdWRlIEJhcgplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBncm91cGVkCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgRm9vCiAgZXh0ZW5kIEJhcgogIGV4dGVuZCBRb3gKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgZXh0ZW5kIFFveCwgQmFyCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBzZXBhcmF0ZWRgCnwgYHNlcGFyYXRlZGAsIGBncm91cGVkYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtaXhpbi1ncm91cGluZwoKPT0gU3R5bGUvTWl4aW5Vc2FnZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC41MQp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgYGluY2x1ZGVgLCBgZXh0ZW5kYCBhbmQgYHByZXBlbmRgIHN0YXRlbWVudHMgYXBwZWFyCmluc2lkZSBjbGFzc2VzIGFuZCBtb2R1bGVzLCBub3QgYXQgdGhlIHRvcCBsZXZlbCwgc28gYXMgdG8gbm90IGFmZmVjdAp0aGUgYmVoYXZpb3Igb2YgYE9iamVjdGAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppbmNsdWRlIE0KCmNsYXNzIEMKZW5kCgojIGJhZApleHRlbmQgTQoKY2xhc3MgQwplbmQKCiMgYmFkCnByZXBlbmQgTQoKY2xhc3MgQwplbmQKCiMgZ29vZApjbGFzcyBDCiAgaW5jbHVkZSBNCmVuZAoKIyBnb29kCmNsYXNzIEMKICBleHRlbmQgTQplbmQKCiMgZ29vZApjbGFzcyBDCiAgcHJlcGVuZCBNCmVuZAotLS0tCgo9PSBTdHlsZS9Nb2R1bGVGdW5jdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuMTEKfCAwLjY1Cnw9PT0KCkNoZWNrcyBmb3IgdXNlIG9mIGBleHRlbmQgc2VsZmAgb3IgYG1vZHVsZV9mdW5jdGlvbmAgaW4gYSBtb2R1bGUuCgpTdXBwb3J0ZWQgc3R5bGVzIGFyZTogYG1vZHVsZV9mdW5jdGlvbmAgKGRlZmF1bHQpLCBgZXh0ZW5kX3NlbGZgIGFuZCBgZm9yYmlkZGVuYC4KCkEgY291cGxlIG9mIHRoaW5ncyB0byBrZWVwIGluIG1pbmQ6CgotIGBmb3JiaWRkZW5gIHN0eWxlIHByb2hpYml0cyB0aGUgdXNhZ2Ugb2YgYm90aCBzdHlsZXMKLSBpbiBkZWZhdWx0IG1vZGUgKGBtb2R1bGVfZnVuY3Rpb25gKSwgdGhlIGNvcCB3b24ndCBiZSBhY3RpdmF0ZWQgd2hlbiB0aGUgbW9kdWxlCiAgY29udGFpbnMgYW55IHByaXZhdGUgbWV0aG9kcwoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIChhbmQgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCkgYmVjYXVzZSBgZXh0ZW5kIHNlbGZgCmFuZCBgbW9kdWxlX2Z1bmN0aW9uYCBkbyBub3QgYmVoYXZlIGV4YWN0bHkgdGhlIHNhbWUuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogbW9kdWxlX2Z1bmN0aW9uIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm1vZHVsZSBUZXN0CiAgZXh0ZW5kIHNlbGYKICAjIC4uLgplbmQKCiMgZ29vZAptb2R1bGUgVGVzdAogIG1vZHVsZV9mdW5jdGlvbgogICMgLi4uCmVuZAoKIyBnb29kCm1vZHVsZSBUZXN0CiAgZXh0ZW5kIHNlbGYKICAjIC4uLgogIHByaXZhdGUKICAjIC4uLgplbmQKCiMgZ29vZAptb2R1bGUgVGVzdAogIGNsYXNzIDw8IHNlbGYKICAgICMgLi4uCiAgZW5kCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGV4dGVuZF9zZWxmCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbW9kdWxlIFRlc3QKICBtb2R1bGVfZnVuY3Rpb24KICAjIC4uLgplbmQKCiMgZ29vZAptb2R1bGUgVGVzdAogIGV4dGVuZCBzZWxmCiAgIyAuLi4KZW5kCgojIGdvb2QKbW9kdWxlIFRlc3QKICBjbGFzcyA8PCBzZWxmCiAgICAjIC4uLgogIGVuZAplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBmb3JiaWRkZW4KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAptb2R1bGUgVGVzdAogIG1vZHVsZV9mdW5jdGlvbgogICMgLi4uCmVuZAoKIyBiYWQKbW9kdWxlIFRlc3QKICBleHRlbmQgc2VsZgogICMgLi4uCmVuZAoKIyBiYWQKbW9kdWxlIFRlc3QKICBleHRlbmQgc2VsZgogICMgLi4uCiAgcHJpdmF0ZQogICMgLi4uCmVuZAoKIyBnb29kCm1vZHVsZSBUZXN0CiAgY2xhc3MgPDwgc2VsZgogICAgIyAuLi4KICBlbmQKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYG1vZHVsZV9mdW5jdGlvbmAKfCBgbW9kdWxlX2Z1bmN0aW9uYCwgYGV4dGVuZF9zZWxmYCwgYGZvcmJpZGRlbmAKCnwgQXV0b2NvcnJlY3QKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtb2R1bGUtZnVuY3Rpb24KCj09IFN0eWxlL011bHRpbGluZUJsb2NrQ2hhaW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuMTMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgY2hhaW5pbmcgb2YgYSBibG9jayBhZnRlciBhbm90aGVyIGJsb2NrIHRoYXQgc3BhbnMKbXVsdGlwbGUgbGluZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApUaHJlYWQubGlzdC5zZWxlY3QgZG8gfHR8CiAgdC5hbGl2ZT8KZW5kLm1hcCBkbyB8dHwKICB0Lm9iamVjdF9pZAplbmQKCiMgZ29vZAphbGl2ZV90aHJlYWRzID0gVGhyZWFkLmxpc3Quc2VsZWN0IGRvIHx0fAogIHQuYWxpdmU/CmVuZAphbGl2ZV90aHJlYWRzLm1hcCBkbyB8dHwKICB0Lm9iamVjdF9pZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc2luZ2xlLWxpbmUtYmxvY2tzCgo9PSBTdHlsZS9NdWx0aWxpbmVJZk1vZGlmaWVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC40NQp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIGlmL3VubGVzcyBtb2RpZmllcnMgd2l0aCBtdWx0aXBsZS1saW5lcyBib2RpZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp7CiAgcmVzdWx0OiAndGhpcyBzaG91bGQgbm90IGhhcHBlbicKfSB1bmxlc3MgY29uZAoKIyBnb29kCnsgcmVzdWx0OiAnb2snIH0gaWYgY29uZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1tdWx0aWxpbmUtaWYtbW9kaWZpZXJzCgo9PSBTdHlsZS9NdWx0aWxpbmVJZlRoZW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjI2Cnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiB0aGUgYHRoZW5gIGtleXdvcmQgaW4gbXVsdGktbGluZSBpZiBzdGF0ZW1lbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIyBUaGlzIGlzIGNvbnNpZGVyZWQgYmFkIHByYWN0aWNlLgppZiBjb25kIHRoZW4KZW5kCgojIGdvb2QKIyBJZiBzdGF0ZW1lbnRzIGNhbiBjb250YWluIGB0aGVuYCBvbiB0aGUgc2FtZSBsaW5lLgppZiBjb25kIHRoZW4gYQplbHNpZiBjb25kIHRoZW4gYgplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tdGhlbgoKPT0gU3R5bGUvTXVsdGlsaW5lSW5QYXR0ZXJuVGhlbgoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjcKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjE2CnwgLQp8PT09CgpDaGVja3MgdXNlcyBvZiB0aGUgYHRoZW5gIGtleXdvcmQgaW4gbXVsdGktbGluZSBgaW5gIHN0YXRlbWVudC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNhc2UgZXhwcmVzc2lvbgppbiBwYXR0ZXJuIHRoZW4KZW5kCgojIGdvb2QKY2FzZSBleHByZXNzaW9uCmluIHBhdHRlcm4KZW5kCgojIGdvb2QKY2FzZSBleHByZXNzaW9uCmluIHBhdHRlcm4gdGhlbiBkb19zb21ldGhpbmcKZW5kCgojIGdvb2QKY2FzZSBleHByZXNzaW9uCmluIHBhdHRlcm4gdGhlbiBkb19zb21ldGhpbmcoYXJnMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcyKQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tdGhlbgoKPT0gU3R5bGUvTXVsdGlsaW5lTWVtb2l6YXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ0CnwgMC40OAp8PT09CgpDaGVja3MgZXhwcmVzc2lvbnMgd3JhcHBpbmcgc3R5bGVzIGZvciBtdWx0aWxpbmUgbWVtb2l6YXRpb24uCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZToga2V5d29yZCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gfHw9ICgKICBiYXIKICBiYXoKKQoKIyBnb29kCmZvbyB8fD0gYmVnaW4KICBiYXIKICBiYXoKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYnJhY2VzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vIHx8PSBiZWdpbgogIGJhcgogIGJhegplbmQKCiMgZ29vZApmb28gfHw9ICgKICBiYXIKICBiYXoKKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBrZXl3b3JkYAp8IGBrZXl3b3JkYCwgYGJyYWNlc2AKfD09PQoKPT0gU3R5bGUvTXVsdGlsaW5lTWV0aG9kU2lnbmF0dXJlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTkKfCAxLjcKfD09PQoKQ2hlY2tzIGZvciBtZXRob2Qgc2lnbmF0dXJlcyB0aGF0IHNwYW4gbXVsdGlwbGUgbGluZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKCmRlZiBmb28oYmFyLCBiYXopCmVuZAoKIyBiYWQKCmRlZiBmb28oYmFyLAogICAgICAgIGJheikKZW5kCi0tLS0KCj09IFN0eWxlL011bHRpbGluZVRlcm5hcnlPcGVyYXRvcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuODYKfD09PQoKQ2hlY2tzIGZvciBtdWx0aS1saW5lIHRlcm5hcnkgb3AgZXhwcmVzc2lvbnMuCgpOT1RFOiBgcmV0dXJuIGlmIC4uLiBlbHNlIC4uLiBlbmRgIGlzIHN5bnRheCBlcnJvci4gSWYgYHJldHVybmAgaXMgdXNlZCBiZWZvcmUKbXVsdGlsaW5lIHRlcm5hcnkgb3BlcmF0b3IgZXhwcmVzc2lvbiwgaXQgd2lsbCBiZSBhdXRvY29ycmVjdGVkIHRvIHNpbmdsZS1saW5lCnRlcm5hcnkgb3BlcmF0b3IuIFRoZSBzYW1lIGlzIHRydWUgZm9yIGBicmVha2AsIGBuZXh0YCwgYW5kIG1ldGhvZCBjYWxsLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSA9IGNvbmQgPwogIGIgOiBjCmEgPSBjb25kID8gYiA6CiAgICBjCmEgPSBjb25kID8KICAgIGIgOgogICAgYwoKcmV0dXJuIGNvbmQgPwogICAgICAgYiA6CiAgICAgICBjCgojIGdvb2QKYSA9IGNvbmQgPyBiIDogYwphID0gaWYgY29uZAogIGIKZWxzZQogIGMKZW5kCgpyZXR1cm4gY29uZCA/IGIgOiBjCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLW11bHRpbGluZS10ZXJuYXJ5Cgo9PSBTdHlsZS9NdWx0aWxpbmVXaGVuVGhlbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNzMKfCAtCnw9PT0KCkNoZWNrcyB1c2VzIG9mIHRoZSBgdGhlbmAga2V5d29yZAppbiBtdWx0aS1saW5lIHdoZW4gc3RhdGVtZW50cy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNhc2UgZm9vCndoZW4gYmFyIHRoZW4KZW5kCgojIGdvb2QKY2FzZSBmb28Kd2hlbiBiYXIKZW5kCgojIGdvb2QKY2FzZSBmb28Kd2hlbiBiYXIgdGhlbiBkb19zb21ldGhpbmcKZW5kCgojIGdvb2QKY2FzZSBmb28Kd2hlbiBiYXIgdGhlbiBkb19zb21ldGhpbmcoYXJnMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMikKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLXRoZW4KCj09IFN0eWxlL011bHRpcGxlQ29tcGFyaXNvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNDkKfCAxLjEKfD09PQoKQ2hlY2tzIGFnYWluc3QgY29tcGFyaW5nIGEgdmFyaWFibGUgd2l0aCBtdWx0aXBsZSBpdGVtcywgd2hlcmUKYEFycmF5I2luY2x1ZGU/YCwgYFNldCNpbmNsdWRlP2Agb3IgYSBgY2FzZWAgY291bGQgYmUgdXNlZCBpbnN0ZWFkCnRvIGF2b2lkIGNvZGUgcmVwZXRpdGlvbi4KSXQgYWNjZXB0cyBjb21wYXJpc29ucyBvZiBtdWx0aXBsZSBtZXRob2QgY2FsbHMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgbWV0aG9kIGNhbGxzCmJ5IGRlZmF1bHQuIEl0IGNhbiBiZSBjb25maWd1cmVkIGJ5IGBBbGxvd01ldGhvZENvbXBhcmlzb25gIG9wdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgPSAnYScKZm9vIGlmIGEgPT0gJ2EnIHx8IGEgPT0gJ2InIHx8IGEgPT0gJ2MnCgojIGdvb2QKYSA9ICdhJwpmb28gaWYgWydhJywgJ2InLCAnYyddLmluY2x1ZGU/KGEpCgpWQUxVRVMgPSBTZXRbJ2EnLCAnYicsICdjJ10uZnJlZXplCiMgZWxzZXdoZXJlLi4uCmZvbyBpZiBWQUxVRVMuaW5jbHVkZT8oYSkKCmNhc2UgZm9vCndoZW4gJ2EnLCAnYicsICdjJyB0aGVuIGZvbwojIC4uLgplbmQKCiMgYWNjZXB0ZWQgKGJ1dCBjb25zaWRlciBgY2FzZWAgYXMgYWJvdmUpCmZvbyBpZiBhID09IGIubGlnaHR3ZWlnaHQgfHwgYSA9PSBiLmhlYXZ5d2VpZ2h0Ci0tLS0KCj09PT0gQWxsb3dNZXRob2RDb21wYXJpc29uOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApmb28gaWYgYSA9PSBiLmxpZ2h0d2VpZ2h0IHx8IGEgPT0gYi5oZWF2eXdlaWdodAotLS0tCgo9PT09IEFsbG93TWV0aG9kQ29tcGFyaXNvbjogZmFsc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gaWYgYSA9PSBiLmxpZ2h0d2VpZ2h0IHx8IGEgPT0gYi5oZWF2eXdlaWdodAoKIyBnb29kCmZvbyBpZiBbYi5saWdodHdlaWdodCwgYi5oZWF2eXdlaWdodF0uaW5jbHVkZT8oYSkKLS0tLQoKPT09PSBDb21wYXJpc29uc1RocmVzaG9sZDogMiAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gaWYgYSA9PSAnYScgfHwgYSA9PSAnYicKLS0tLQoKPT09PSBDb21wYXJpc29uc1RocmVzaG9sZDogMwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApmb28gaWYgYSA9PSAnYScgfHwgYSA9PSAnYicKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93TWV0aG9kQ29tcGFyaXNvbgp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQ29tcGFyaXNvbnNUaHJlc2hvbGQKfCBgMmAKfCBJbnRlZ2VyCnw9PT0KCj09IFN0eWxlL011dGFibGVDb25zdGFudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuMzQKfCAxLjgKfD09PQoKQ2hlY2tzIHdoZXRoZXIgc29tZSBjb25zdGFudCB2YWx1ZSBpc24ndCBhCm11dGFibGUgbGl0ZXJhbCAoZS5nLiBhcnJheSBvciBoYXNoKS4KClN0cmljdCBtb2RlIGNhbiBiZSB1c2VkIHRvIGZyZWV6ZSBhbGwgY29uc3RhbnRzLCByYXRoZXIgdGhhbgpqdXN0IGxpdGVyYWxzLgpTdHJpY3QgbW9kZSBpcyBjb25zaWRlcmVkIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiBJdCBoYXMgbm90IGJlZW4KdXBkYXRlZCB3aXRoIGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBhbGwgbWV0aG9kcyB0aGF0IHdpbGwgcHJvZHVjZQpmcm96ZW4gb2JqZWN0cyBzbyB0aGVyZSBpcyBhIGRlY2VudCBjaGFuY2Ugb2YgZ2V0dGluZyBzb21lIGZhbHNlCnBvc2l0aXZlcy4gTHVja2lseSwgdGhlcmUgaXMgbm8gaGFybSBpbiBmcmVlemluZyBhbiBhbHJlYWR5CmZyb3plbiBvYmplY3QuCgpGcm9tIFJ1YnkgMy4wLCB0aGlzIGNvcCBob25vdXJzIHRoZSBtYWdpYyBjb21tZW50CidzaGFyZWFibGVfY29uc3RhbnRfdmFsdWUnLiBXaGVuIHRoaXMgbWFnaWMgY29tbWVudCBpcyBzZXQgdG8gYW55CmFjY2VwdGFibGUgdmFsdWUgb3RoZXIgdGhhbiBub25lLCBpdCB3aWxsIHN1cHByZXNzIHRoZSBvZmZlbnNlcwpyYWlzZWQgYnkgdGhpcyBjb3AuIEl0IGVuZm9yY2VzIGZyb3plbiBzdGF0ZS4KCk5PVEU6IFJlZ2V4cCBhbmQgUmFuZ2UgbGl0ZXJhbHMgYXJlIGZyb3plbiBvYmplY3RzIHNpbmNlIFJ1YnkgMy4wLgoKTk9URTogRnJvbSBSdWJ5IDMuMCwgaW50ZXJwb2xhdGVkIHN0cmluZ3MgYXJlIG5vdCBmcm96ZW4gd2hlbgpgIyBmcm96ZW4tc3RyaW5nLWxpdGVyYWw6IHRydWVgIGlzIHVzZWQsIHNvIHRoaXMgY29wIGVuZm9yY2VzIGV4cGxpY2l0CmZyZWV6aW5nIGZvciBzdWNoIHN0cmluZ3MuCgpOT1RFOiBGcm9tIFJ1YnkgMy4wLCB0aGlzIGNvcCBhbGxvd3MgZXhwbGljaXQgZnJlZXppbmcgb2YgY29uc3RhbnRzIHdoZW4KdGhlIGBzaGFyZWFibGVfY29uc3RhbnRfdmFsdWVgIGRpcmVjdGl2ZSBpcyB1c2VkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgc2luY2UgYW55IG11dGF0aW9ucyBvbiBvYmplY3RzIHRoYXQKYXJlIG1hZGUgZnJvemVuIHdpbGwgY2hhbmdlIGZyb20gYmVpbmcgYWNjZXB0ZWQgdG8gcmFpc2luZyBgRnJvemVuRXJyb3JgLAphbmQgd2lsbCBuZWVkIHRvIGJlIG1hbnVhbGx5IHJlZmFjdG9yZWQuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogbGl0ZXJhbHMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKQ09OU1QgPSBbMSwgMiwgM10KCiMgZ29vZApDT05TVCA9IFsxLCAyLCAzXS5mcmVlemUKCiMgZ29vZApDT05TVCA9IDw8flRFU1RJTkcuZnJlZXplCiAgVGhpcyBpcyBhIGhlcmVkb2MKVEVTVElORwoKIyBnb29kCkNPTlNUID0gU29tZXRoaW5nLm5ldwotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHN0cmljdAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkNPTlNUID0gU29tZXRoaW5nLm5ldwoKIyBiYWQKQ09OU1QgPSBTdHJ1Y3QubmV3IGRvCiAgZGVmIGZvbwogICAgcHV0cyAxCiAgZW5kCmVuZAoKIyBnb29kCkNPTlNUID0gU29tZXRoaW5nLm5ldy5mcmVlemUKCiMgZ29vZApDT05TVCA9IFN0cnVjdC5uZXcgZG8KICBkZWYgZm9vCiAgICBwdXRzIDEKICBlbmQKZW5kLmZyZWV6ZQotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBNYWdpYyBjb21tZW50IC0gc2hhcmVhYmxlX2NvbnN0YW50X3ZhbHVlOiBsaXRlcmFsCgojIGJhZApDT05TVCA9IFsxLCAyLCAzXQoKIyBnb29kCiMgc2hhcmVhYmxlX2NvbnN0YW50X3ZhbHVlOiBsaXRlcmFsCkNPTlNUID0gWzEsIDIsIDNdCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGxpdGVyYWxzYAp8IGBsaXRlcmFsc2AsIGBzdHJpY3RgCnw9PT0KCj09IFN0eWxlL05lZ2F0ZWRJZgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMjAKfCAwLjQ4Cnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiBpZiB3aXRoIGEgbmVnYXRlZCBjb25kaXRpb24uIE9ubHkgaWZzCndpdGhvdXQgZWxzZSBhcmUgY29uc2lkZXJlZC4gVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzdHlsZXM6CgoqIGJvdGgKKiBwcmVmaXgKKiBwb3N0Zml4Cgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogYm90aCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGVuZm9yY2VzIGB1bmxlc3NgIGZvciBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIGNvbmRpdGlvbmFscwoKIyBiYWQKCmlmICFmb28KICBiYXIKZW5kCgojIGdvb2QKCnVubGVzcyBmb28KICBiYXIKZW5kCgojIGJhZAoKYmFyIGlmICFmb28KCiMgZ29vZAoKYmFyIHVubGVzcyBmb28KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBwcmVmaXgKCltzb3VyY2UscnVieV0KLS0tLQojIGVuZm9yY2VzIGB1bmxlc3NgIGZvciBqdXN0IGBwcmVmaXhgIGNvbmRpdGlvbmFscwoKIyBiYWQKCmlmICFmb28KICBiYXIKZW5kCgojIGdvb2QKCnVubGVzcyBmb28KICBiYXIKZW5kCgojIGdvb2QKCmJhciBpZiAhZm9vCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcG9zdGZpeAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZW5mb3JjZXMgYHVubGVzc2AgZm9yIGp1c3QgYHBvc3RmaXhgIGNvbmRpdGlvbmFscwoKIyBiYWQKCmJhciBpZiAhZm9vCgojIGdvb2QKCmJhciB1bmxlc3MgZm9vCgojIGdvb2QKCmlmICFmb28KICBiYXIKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGJvdGhgCnwgYGJvdGhgLCBgcHJlZml4YCwgYHBvc3RmaXhgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3VubGVzcy1mb3ItbmVnYXRpdmVzCgo9PSBTdHlsZS9OZWdhdGVkSWZFbHNlQ29uZGl0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS4yCnwgLQp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgYGlmLWVsc2VgIGFuZCB0ZXJuYXJ5IG9wZXJhdG9ycyB3aXRoIGEgbmVnYXRlZCBjb25kaXRpb24Kd2hpY2ggY2FuIGJlIHNpbXBsaWZpZWQgYnkgaW52ZXJ0aW5nIGNvbmRpdGlvbiBhbmQgc3dhcHBpbmcgYnJhbmNoZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiAheAogIGRvX3NvbWV0aGluZwplbHNlCiAgZG9fc29tZXRoaW5nX2Vsc2UKZW5kCgojIGdvb2QKaWYgeAogIGRvX3NvbWV0aGluZ19lbHNlCmVsc2UKICBkb19zb21ldGhpbmcKZW5kCgojIGJhZAoheCA/IGRvX3NvbWV0aGluZyA6IGRvX3NvbWV0aGluZ19lbHNlCgojIGdvb2QKeCA/IGRvX3NvbWV0aGluZ19lbHNlIDogZG9fc29tZXRoaW5nCi0tLS0KCj09IFN0eWxlL05lZ2F0ZWRVbmxlc3MKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjY5CnwgLQp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgdW5sZXNzIHdpdGggYSBuZWdhdGVkIGNvbmRpdGlvbi4gT25seSB1bmxlc3MKd2l0aG91dCBlbHNlIGFyZSBjb25zaWRlcmVkLiBUaGVyZSBhcmUgdGhyZWUgZGlmZmVyZW50IHN0eWxlczoKCiogYm90aAoqIHByZWZpeAoqIHBvc3RmaXgKCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBib3RoIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZW5mb3JjZXMgYGlmYCBmb3IgYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBjb25kaXRpb25hbHMKCiMgYmFkCnVubGVzcyAhZm9vCiAgYmFyCmVuZAoKIyBnb29kCmlmIGZvbwogIGJhcgplbmQKCiMgYmFkCmJhciB1bmxlc3MgIWZvbwoKIyBnb29kCmJhciBpZiBmb28KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBwcmVmaXgKCltzb3VyY2UscnVieV0KLS0tLQojIGVuZm9yY2VzIGBpZmAgZm9yIGp1c3QgYHByZWZpeGAgY29uZGl0aW9uYWxzCgojIGJhZAp1bmxlc3MgIWZvbwogIGJhcgplbmQKCiMgZ29vZAppZiBmb28KICBiYXIKZW5kCgojIGdvb2QKYmFyIHVubGVzcyAhZm9vCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcG9zdGZpeAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZW5mb3JjZXMgYGlmYCBmb3IganVzdCBgcG9zdGZpeGAgY29uZGl0aW9uYWxzCgojIGJhZApiYXIgdW5sZXNzICFmb28KCiMgZ29vZApiYXIgaWYgZm9vCgojIGdvb2QKdW5sZXNzICFmb28KICBiYXIKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGJvdGhgCnwgYGJvdGhgLCBgcHJlZml4YCwgYHBvc3RmaXhgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2lmLWZvci1uZWdhdGl2ZXMKCj09IFN0eWxlL05lZ2F0ZWRXaGlsZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMjAKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiB3aGlsZSB3aXRoIGEgbmVnYXRlZCBjb25kaXRpb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp3aGlsZSAhZm9vCiAgYmFyCmVuZAoKIyBnb29kCnVudGlsIGZvbwogIGJhcgplbmQKCiMgYmFkCmJhciB1bnRpbCAhZm9vCgojIGdvb2QKYmFyIHdoaWxlIGZvbwpiYXIgd2hpbGUgIWZvbyAmJiBiYXoKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjdW50aWwtZm9yLW5lZ2F0aXZlcwoKPT0gU3R5bGUvTmVzdGVkRmlsZURpcm5hbWUKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMy4xCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS4yNgp8IC0KfD09PQoKQ2hlY2tzIGZvciBuZXN0ZWQgYEZpbGUuZGlybmFtZWAuCkl0IHJlcGxhY2VzIG5lc3RlZCBgRmlsZS5kaXJuYW1lYCB3aXRoIHRoZSBsZXZlbCBhcmd1bWVudCBpbnRyb2R1Y2VkIGluIFJ1YnkgMy4xLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRmlsZS5kaXJuYW1lKEZpbGUuZGlybmFtZShwYXRoKSkKCiMgZ29vZApGaWxlLmRpcm5hbWUocGF0aCwgMikKLS0tLQoKPT0gU3R5bGUvTmVzdGVkTW9kaWZpZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjM1CnwgLQp8PT09CgpDaGVja3MgZm9yIG5lc3RlZCB1c2Ugb2YgaWYsIHVubGVzcywgd2hpbGUgYW5kIHVudGlsIGluIHRoZWlyCm1vZGlmaWVyIGZvcm0uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzb21ldGhpbmcgaWYgYSBpZiBiCgojIGdvb2QKc29tZXRoaW5nIGlmIGIgJiYgYQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1uZXN0ZWQtbW9kaWZpZXJzCgo9PSBTdHlsZS9OZXN0ZWRQYXJlbnRoZXNpemVkQ2FsbHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjM2CnwgMC43Nwp8PT09CgpDaGVja3MgZm9yIHVucGFyZW50aGVzaXplZCBtZXRob2QgY2FsbHMgaW4gdGhlIGFyZ3VtZW50IGxpc3QKb2YgYSBwYXJlbnRoZXNpemVkIG1ldGhvZCBjYWxsLgpgYmVgLCBgYmVfYWAsIGBiZV9hbmAsIGBiZV9iZXR3ZWVuYCwgYGJlX2ZhbHNleWAsIGBiZV9raW5kX29mYCwgYGJlX2luc3RhbmNlX29mYCwKYGJlX3RydXRoeWAsIGBiZV93aXRoaW5gLCBgZXFgLCBgZXFsYCwgYGVuZF93aXRoYCwgYGluY2x1ZGVgLCBgbWF0Y2hgLCBgcmFpc2VfZXJyb3JgLApgcmVzcG9uZF90b2AsIGFuZCBgc3RhcnRfd2l0aGAgbWV0aG9kcyBhcmUgYWxsb3dlZCBieSBkZWZhdWx0LgpUaGVzZSBhcmUgY3VzdG9taXphYmxlIHdpdGggYEFsbG93ZWRNZXRob2RzYCBvcHRpb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKbWV0aG9kMShtZXRob2QyKGFyZykpCgojIGJhZAptZXRob2QxKG1ldGhvZDIgYXJnKQotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbZm9vXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAptZXRob2QxKGZvbyBhcmcpCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd2VkTWV0aG9kcwp8IGBiZWAsIGBiZV9hYCwgYGJlX2FuYCwgYGJlX2JldHdlZW5gLCBgYmVfZmFsc2V5YCwgYGJlX2tpbmRfb2ZgLCBgYmVfaW5zdGFuY2Vfb2ZgLCBgYmVfdHJ1dGh5YCwgYGJlX3dpdGhpbmAsIGBlcWAsIGBlcWxgLCBgZW5kX3dpdGhgLCBgaW5jbHVkZWAsIGBtYXRjaGAsIGByYWlzZV9lcnJvcmAsIGByZXNwb25kX3RvYCwgYHN0YXJ0X3dpdGhgCnwgQXJyYXkKfD09PQoKPT0gU3R5bGUvTmVzdGVkVGVybmFyeU9wZXJhdG9yCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC44Ngp8PT09CgpDaGVja3MgZm9yIG5lc3RlZCB0ZXJuYXJ5IG9wIGV4cHJlc3Npb25zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSA/IChiID8gYjEgOiBiMikgOiBhMgoKIyBnb29kCmlmIGEKICBiID8gYjEgOiBiMgplbHNlCiAgYTIKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLW5lc3RlZC10ZXJuYXJ5Cgo9PSBTdHlsZS9OZXh0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yMgp8IDAuMzUKfD09PQoKVXNlIGBuZXh0YCB0byBza2lwIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGEgY29uZGl0aW9uIGF0IHRoZSBlbmQuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2tpcF9tb2RpZmllcl9pZnMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKWzEsIDJdLmVhY2ggZG8gfGF8CiAgaWYgYSA9PSAxCiAgICBwdXRzIGEKICBlbmQKZW5kCgojIGdvb2QKWzEsIDJdLmVhY2ggZG8gfGF8CiAgbmV4dCB1bmxlc3MgYSA9PSAxCiAgcHV0cyBhCmVuZAoKIyBnb29kClsxLCAyXS5lYWNoIGRvIHxhfAogIHB1dHMgYSBpZiBhID09IDEKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYWx3YXlzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBXaXRoIGBhbHdheXNgIGFsbCBjb25kaXRpb25zIGF0IHRoZSBlbmQgb2YgYW4gaXRlcmF0aW9uIG5lZWRzIHRvIGJlCiMgcmVwbGFjZWQgYnkgbmV4dCAtIHdpdGggYHNraXBfbW9kaWZpZXJfaWZzYCB0aGUgbW9kaWZpZXIgaWYgbGlrZQojIHRoaXMgb25lIGFyZSBpZ25vcmVkOiBgWzEsIDJdLmVhY2ggeyB8YXwgcHV0cyBhIGlmIGEgPT0gMSB9YAoKIyBiYWQKWzEsIDJdLmVhY2ggZG8gfGF8CiAgcHV0cyBhIGlmIGEgPT0gMQplbmQKCiMgYmFkClsxLCAyXS5lYWNoIGRvIHxhfAogIGlmIGEgPT0gMQogICAgcHV0cyBhCiAgZW5kCmVuZAoKIyBnb29kClsxLCAyXS5lYWNoIGRvIHxhfAogIG5leHQgdW5sZXNzIGEgPT0gMQogIHB1dHMgYQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2tpcF9tb2RpZmllcl9pZnNgCnwgYHNraXBfbW9kaWZpZXJfaWZzYCwgYGFsd2F5c2AKCnwgTWluQm9keUxlbmd0aAp8IGAzYAp8IEludGVnZXIKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tbmVzdGVkLWNvbmRpdGlvbmFscwoKPT0gU3R5bGUvTmlsQ29tcGFyaXNvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTIKfCAwLjU5Cnw9PT0KCkNoZWNrcyBmb3IgY29tcGFyaXNvbiBvZiBzb21ldGhpbmcgd2l0aCBuaWwgdXNpbmcgYD09YCBhbmQKYG5pbD9gLgoKU3VwcG9ydGVkIHN0eWxlcyBhcmU6IHByZWRpY2F0ZSwgY29tcGFyaXNvbi4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBwcmVkaWNhdGUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgeCA9PSBuaWwKZW5kCgojIGdvb2QKaWYgeC5uaWw/CmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGNvbXBhcmlzb24KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiB4Lm5pbD8KZW5kCgojIGdvb2QKaWYgeCA9PSBuaWwKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHByZWRpY2F0ZWAKfCBgcHJlZGljYXRlYCwgYGNvbXBhcmlzb25gCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3ByZWRpY2F0ZS1tZXRob2RzCgo9PSBTdHlsZS9OaWxMYW1iZGEKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjMKfCAxLjE1Cnw9PT0KCkNoZWNrcyBmb3IgbGFtYmRhcyBhbmQgcHJvY3MgdGhhdCBhbHdheXMgcmV0dXJuIG5pbCwKd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYW4gZW1wdHkgbGFtYmRhIG9yIHByb2MgaW5zdGVhZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCi0+IHsgbmlsIH0KCmxhbWJkYSBkbwogIG5leHQgbmlsCmVuZAoKcHJvYyB7IG5pbCB9CgpQcm9jLm5ldyBkbwogIGJyZWFrIG5pbAplbmQKCiMgZ29vZAotPiB7fQoKbGFtYmRhIGRvCmVuZAoKLT4gKHgpIHsgbmlsIGlmIHggfQoKcHJvYyB7fQoKUHJvYy5uZXcgeyBuaWwgaWYgeCB9Ci0tLS0KCj09IFN0eWxlL05vbk5pbENoZWNrCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yMAp8IDAuMjIKfD09PQoKQ2hlY2tzIGZvciBub24tbmlsIGNoZWNrcywgd2hpY2ggYXJlIHVzdWFsbHkgcmVkdW5kYW50LgoKV2l0aCBgSW5jbHVkZVNlbWFudGljQ2hhbmdlc2Agc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdCwgdGhpcyBjb3AKZG9lcyBub3QgcmVwb3J0IG9mZmVuc2VzIGZvciBgIXgubmlsP2AgYW5kIGRvZXMgbm8gY2hhbmdlcyB0aGF0IG1pZ2h0CmNoYW5nZSBiZWhhdmlvci4KQWxzbyBgSW5jbHVkZVNlbWFudGljQ2hhbmdlc2Agc2V0IHRvIGBmYWxzZWAgd2l0aCBgRW5mb3JjZWRTdHlsZTogY29tcGFyaXNvbmAgb2YKYFN0eWxlL05pbENvbXBhcmlzb25gIGNvcCwgdGhpcyBjb3AgZG9lcyBub3QgcmVwb3J0IG9mZmVuc2VzIGZvciBgeCAhPSBuaWxgIGFuZApkb2VzIG5vIGNoYW5nZXMgdG8gYCF4Lm5pbD9gIHN0eWxlLgoKV2l0aCBgSW5jbHVkZVNlbWFudGljQ2hhbmdlc2Agc2V0IHRvIGB0cnVlYCwgdGhpcyBjb3AgcmVwb3J0cyBvZmZlbnNlcwpmb3IgYCF4Lm5pbD9gIGFuZCBhdXRvY29ycmVjdHMgdGhhdCBhbmQgYHggIT0gbmlsYCB0byBzb2xlbHkgYHhgLCB3aGljaAppcyAqdXN1YWxseSogT0ssIGJ1dCBtaWdodCBjaGFuZ2UgYmVoYXZpb3IuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppZiB4ICE9IG5pbAplbmQKCiMgZ29vZAppZiB4CmVuZAoKIyBOb24tbmlsIGNoZWNrcyBhcmUgYWxsb3dlZCBpZiB0aGV5IGFyZSB0aGUgZmluYWwgbm9kZXMgb2YgcHJlZGljYXRlLgojIGdvb2QKZGVmIHNpZ25lZF9pbj8KICAhY3VycmVudF91c2VyLm5pbD8KZW5kCi0tLS0KCj09PT0gSW5jbHVkZVNlbWFudGljQ2hhbmdlczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmlmICF4Lm5pbD8KZW5kCi0tLS0KCj09PT0gSW5jbHVkZVNlbWFudGljQ2hhbmdlczogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmICF4Lm5pbD8KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlU2VtYW50aWNDaGFuZ2VzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tbm9uLW5pbC1jaGVja3MKCj09IFN0eWxlL05vdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuMjAKfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIHRoZSBrZXl3b3JkIGBub3RgIGluc3RlYWQgb2YgYCFgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSBwYXJlbnRoZXNlcyBhcmUgcmVxdWlyZWQgYmVjYXVzZSBvZiBvcCBwcmVjZWRlbmNlCnggPSAobm90IHNvbWV0aGluZykKCiMgZ29vZAp4ID0gIXNvbWV0aGluZwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNiYW5nLW5vdC1ub3QKCj09IFN0eWxlL051bWJlcmVkUGFyYW1ldGVycwoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjcKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDEuMjIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgbnVtYmVyZWQgcGFyYW1ldGVycy4KCkl0IGNhbiBlaXRoZXIgcmVzdHJpY3QgdGhlIHVzZSBvZiBudW1iZXJlZCBwYXJhbWV0ZXJzIHRvCnNpbmdsZS1saW5lZCBibG9ja3MsIG9yIGRpc2FsbG93IGNvbXBsZXRlbHkgbnVtYmVyZWQgcGFyYW1ldGVycy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBhbGxvd19zaW5nbGVfbGluZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjb2xsZWN0aW9uLmVhY2ggZG8KICBwdXRzIF8xCmVuZAoKIyBnb29kCmNvbGxlY3Rpb24uZWFjaCB7IHB1dHMgXzEgfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGRpc2FsbG93Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY29sbGVjdGlvbi5lYWNoIHsgcHV0cyBfMSB9CgojIGdvb2QKY29sbGVjdGlvbi5lYWNoIHsgfGl0ZW18IHB1dHMgaXRlbSB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGFsbG93X3NpbmdsZV9saW5lYAp8IGBhbGxvd19zaW5nbGVfbGluZWAsIGBkaXNhbGxvd2AKfD09PQoKPT0gU3R5bGUvTnVtYmVyZWRQYXJhbWV0ZXJzTGltaXQKCk5PVEU6IFJlcXVpcmVkIFJ1YnkgdmVyc2lvbjogMi43Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAxLjIyCnwgLQp8PT09CgpEZXRlY3RzIHVzZSBvZiBhbiBleGNlc3NpdmUgYW1vdW50IG9mIG51bWJlcmVkIHBhcmFtZXRlcnMgaW4gYQpzaW5nbGUgYmxvY2suIEhhdmluZyB0b28gbWFueSBudW1iZXJlZCBwYXJhbWV0ZXJzIGNhbiBtYWtlIGNvZGUgdG9vCmNyeXB0aWMgYW5kIGhhcmQgdG8gcmVhZC4KClRoZSBjb3AgZGVmYXVsdHMgdG8gcmVnaXN0ZXJpbmcgYW4gb2ZmZW5zZSBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gMSBudW1iZXJlZApwYXJhbWV0ZXIgYnV0IHRoaXMgbWF4aW11bSBjYW4gYmUgY29uZmlndXJlZCBieSBzZXR0aW5nIGBNYXhgLgoKPT09IEV4YW1wbGVzCgo9PT09IE1heDogMSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp1c2VfbXVsdGlwbGVfbnVtYmVyZWRfcGFyYW1ldGVycyB7IF8xLmNhbGwoXzIsIF8zLCBfNCkgfQoKIyBnb29kCmFycmF5LmVhY2ggeyB1c2VfYXJyYXlfZWxlbWVudF9hc19udW1iZXJlZF9wYXJhbWV0ZXIoXzEpIH0KaGFzaC5lYWNoIHsgdXNlX29ubHlfaGFzaF92YWx1ZV9hc19udW1iZXJlZF9wYXJhbWV0ZXIoXzIpIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE1heAp8IGAxYAp8IEludGVnZXIKfD09PQoKPT0gU3R5bGUvTnVtZXJpY0xpdGVyYWxQcmVmaXgKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQxCnwgLQp8PT09CgpDaGVja3MgZm9yIG9jdGFsLCBoZXgsIGJpbmFyeSwgYW5kIGRlY2ltYWwgbGl0ZXJhbHMgdXNpbmcKdXBwZXJjYXNlIHByZWZpeGVzIGFuZCBjb3JyZWN0cyB0aGVtIHRvIGxvd2VyY2FzZSBwcmVmaXgKb3Igbm8gcHJlZml4IChpbiBjYXNlIG9mIGRlY2ltYWxzKS4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZE9jdGFsU3R5bGU6IHplcm9fd2l0aF9vIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gbWlzc2luZyBvY3RhbCBwcmVmaXgKbnVtID0gMDEyMzQKCiMgYmFkIC0gdXBwZXJjYXNlIHByZWZpeApudW0gPSAwTzEyMzQKbnVtID0gMFgxMkFCCm51bSA9IDBCMTAxMDEKCiMgYmFkIC0gcmVkdW5kYW50IGRlY2ltYWwgcHJlZml4Cm51bSA9IDBEMTIzNApudW0gPSAwZDEyMzQKCiMgZ29vZApudW0gPSAwbzEyMzQKbnVtID0gMHgxMkFCCm51bSA9IDBiMTAxMDEKbnVtID0gMTIzNAotLS0tCgo9PT09IEVuZm9yY2VkT2N0YWxTdHlsZTogemVyb19vbmx5Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbnVtID0gMG8xMjM0Cm51bSA9IDBPMTIzNAoKIyBnb29kCm51bSA9IDAxMjM0Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZE9jdGFsU3R5bGUKfCBgemVyb193aXRoX29gCnwgYHplcm9fd2l0aF9vYCwgYHplcm9fb25seWAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbnVtZXJpYy1saXRlcmFsLXByZWZpeGVzCgo9PSBTdHlsZS9OdW1lcmljTGl0ZXJhbHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjQ4Cnw9PT0KCkNoZWNrcyBmb3IgYmlnIG51bWVyaWMgbGl0ZXJhbHMgd2l0aG91dCBgX2AgYmV0d2VlbiBncm91cHMKb2YgZGlnaXRzIGluIHRoZW0uCgpBZGRpdGlvbmFsIGFsbG93ZWQgcGF0dGVybnMgY2FuIGJlIGFkZGVkIGJ5IGFkZGluZyByZWdleHBzIHRvCnRoZSBgQWxsb3dlZFBhdHRlcm5zYCBjb25maWd1cmF0aW9uLiBBbGwgcmVnZXhwcyBhcmUgdHJlYXRlZAphcyBhbmNob3JlZCBldmVuIGlmIHRoZSBwYXR0ZXJucyBkbyBub3QgY29udGFpbiBhbmNob3JzIChzbwpgXGR7NH1fXGR7NH1gIHdpbGwgYWxsb3cgYDEyMzRfNTY3OGAgYnV0IG5vdCBgMTIzNF81Njc4XzkwMTJgKS4KCk5PVEU6IEV2ZW4gaWYgYEFsbG93ZWRQYXR0ZXJuc2AgYXJlIGdpdmVuLCBhdXRvY29ycmVjdGlvbiB3aWxsCm9ubHkgY29ycmVjdCB0byB0aGUgc3RhbmRhcmQgcGF0dGVybiBvZiBhbiBgX2AgZXZlcnkgMyBkaWdpdHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAoxMDAwMDAwCjFfMDBfMDAwCjFfMDAwMAoKIyBnb29kCjFfMDAwXzAwMAoxMDAwCi0tLS0KCj09PT0gU3RyaWN0OiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKMTBfMDAwXzAwICMgdHlwaWNhbCByZXByZXNlbnRhdGlvbiBvZiAkMTAsMDAwIGluIGNlbnRzCi0tLS0KCj09PT0gU3RyaWN0OiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKMTBfMDAwXzAwICMgdHlwaWNhbCByZXByZXNlbnRhdGlvbiBvZiAkMTAsMDAwIGluIGNlbnRzCi0tLS0KCj09PT0gQWxsb3dlZE51bWJlcnM6IFszMDAwXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAozMDAwICMgWW91IGNhbiBzcGVjaWZ5IGFsbG93ZWQgbnVtYmVycy4gKGUuZy4gcG9ydCBudW1iZXIpCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBNaW5EaWdpdHMKfCBgNWAKfCBJbnRlZ2VyCgp8IFN0cmljdAp8IGBmYWxzZWAKfCBCb29sZWFuCgp8IEFsbG93ZWROdW1iZXJzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSN1bmRlcnNjb3Jlcy1pbi1udW1lcmljcwoKPT0gU3R5bGUvTnVtZXJpY1ByZWRpY2F0ZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC40Mgp8IDAuNTkKfD09PQoKQ2hlY2tzIGZvciB1c2FnZSBvZiBjb21wYXJpc29uIG9wZXJhdG9ycyAoYD09YCwKYD5gLCBgPGApIHRvIHRlc3QgbnVtYmVycyBhcyB6ZXJvLCBwb3NpdGl2ZSwgb3IgbmVnYXRpdmUuClRoZXNlIGNhbiBiZSByZXBsYWNlZCBieSB0aGVpciByZXNwZWN0aXZlIHByZWRpY2F0ZSBtZXRob2RzLgpUaGlzIGNvcCBjYW4gYWxzbyBiZSBjb25maWd1cmVkIHRvIGRvIHRoZSByZXZlcnNlLgoKVGhpcyBjb3AgY2FuIGJlIGN1c3RvbWl6ZWQgYWxsb3dlZCBtZXRob2RzIHdpdGggYEFsbG93ZWRNZXRob2RzYC4KQnkgZGVmYXVsdCwgdGhlcmUgYXJlIG5vIG1ldGhvZHMgdG8gYWxsb3dlZC4KClRoaXMgY29wIGRpc3JlZ2FyZHMgYCNub256ZXJvP2AgYXMgaXRzIHZhbHVlIGlzIHRydXRoeSBvciBmYWxzZXksCmJ1dCBub3QgYHRydWVgIGFuZCBgZmFsc2VgLCBhbmQgdGh1cyBub3QgYWx3YXlzIGludGVyY2hhbmdlYWJsZSB3aXRoCmAhPSAwYC4KClRoaXMgY29wIGFsbG93cyBjb21wYXJpc29ucyB0byBnbG9iYWwgdmFyaWFibGVzLCBzaW5jZSB0aGV5IGFyZSBvZnRlbgpwb3B1bGF0ZWQgd2l0aCBvYmplY3RzIHdoaWNoIGNhbiBiZSBjb21wYXJlZCB3aXRoIGludGVnZXJzLCBidXQgYXJlCm5vdCB0aGVtc2VsdmVzIGBJbnRlZ2VyYCBwb2x5bW9ycGhpYy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBndWFyYW50ZWVkIHRoYXQgdGhlIHJlY2VpdmVyCmRlZmluZXMgdGhlIHByZWRpY2F0ZXMgb3IgY2FuIGJlIGNvbXBhcmVkIHRvIGEgbnVtYmVyLCB3aGljaCBtYXkgbGVhZAp0byBhIGZhbHNlIHBvc2l0aXZlIGZvciBub24tc3RhbmRhcmQgY2xhc3Nlcy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBwcmVkaWNhdGUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vID09IDAKMCA+IGZvbwpiYXIuYmF6ID4gMAoKIyBnb29kCmZvby56ZXJvPwpmb28ubmVnYXRpdmU/CmJhci5iYXoucG9zaXRpdmU/Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY29tcGFyaXNvbgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby56ZXJvPwpmb28ubmVnYXRpdmU/CmJhci5iYXoucG9zaXRpdmU/CgojIGdvb2QKZm9vID09IDAKMCA+IGZvbwpiYXIuYmF6ID4gMAotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbXSAoZGVmYXVsdCkgd2l0aCBFbmZvcmNlZFN0eWxlOiBwcmVkaWNhdGUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gPT0gMAowID4gZm9vCmJhci5iYXogPiAwCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFs9PV0gd2l0aCBFbmZvcmNlZFN0eWxlOiBwcmVkaWNhdGUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZm9vID09IDAKCiMgYmFkCjAgPiBmb28KYmFyLmJheiA+IDAKLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnM6IFtdIChkZWZhdWx0KSB3aXRoIEVuZm9yY2VkU3R5bGU6IGNvbXBhcmlzb24KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28uemVybz8KZm9vLm5lZ2F0aXZlPwpiYXIuYmF6LnBvc2l0aXZlPwotLS0tCgo9PT09IEFsbG93ZWRQYXR0ZXJuczogWyd6ZXJvJ10gd2l0aCBFbmZvcmNlZFN0eWxlOiBwcmVkaWNhdGUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKIyBiYWQKZm9vLnplcm8/CgojIGJhZApmb28ubmVnYXRpdmU/CmJhci5iYXoucG9zaXRpdmU/Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHByZWRpY2F0ZWAKfCBgcHJlZGljYXRlYCwgYGNvbXBhcmlzb25gCgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQoKfCBFeGNsdWRlCnwgYCtzcGVjLyoqLyorYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3ByZWRpY2F0ZS1tZXRob2RzCgo9PSBTdHlsZS9PYmplY3RUaGVuCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuNgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuMjgKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSB1c2Ugb2YgY29uc2lzdGVudCBtZXRob2QgbmFtZXMKYE9iamVjdCN5aWVsZF9zZWxmYCBvciBgT2JqZWN0I3RoZW5gLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHRoZW4gKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKb2JqLnlpZWxkX3NlbGYgeyB8eHwgeC5kb19zb21ldGhpbmcgfQoKIyBnb29kCm9iai50aGVuIHsgfHh8IHguZG9fc29tZXRoaW5nIH0KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiB5aWVsZF9zZWxmCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKb2JqLnRoZW4geyB8eHwgeC5kb19zb21ldGhpbmcgfQoKIyBnb29kCm9iai55aWVsZF9zZWxmIHsgfHh8IHguZG9fc29tZXRoaW5nIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgdGhlbmAKfCBgdGhlbmAsIGB5aWVsZF9zZWxmYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNvYmplY3QteWllbGQtc2VsZi12cy1vYmplY3QtdGhlbgoKPT0gU3R5bGUvT25lTGluZUNvbmRpdGlvbmFsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC45MAp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgaWYvdGhlbi9lbHNlL2VuZCBjb25zdHJ1Y3RzIG9uIGEgc2luZ2xlIGxpbmUuCkFsd2F5c0NvcnJlY3RUb011bHRpbGluZSBjb25maWcgb3B0aW9uIGNhbiBiZSBzZXQgdG8gdHJ1ZSB0byBhdXRvLWNvbnZlcnQgYWxsIG9mZmVuc2VzIHRvCm11bHRpLWxpbmUgY29uc3RydWN0cy4gV2hlbiBBbHdheXNDb3JyZWN0VG9NdWx0aWxpbmUgaXMgZmFsc2UgKGRlZmF1bHQgY2FzZSkgdGhlCmF1dG9jb3JyZWN0IHdpbGwgZmlyc3QgdHJ5IGNvbnZlcnRpbmcgdGhlbSB0byB0ZXJuYXJ5IG9wZXJhdG9ycy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmlmIGZvbyB0aGVuIGJhciBlbHNlIGJheiBlbmQKCiMgYmFkCnVubGVzcyBmb28gdGhlbiBiYXogZWxzZSBiYXIgZW5kCgojIGdvb2QKZm9vID8gYmFyIDogYmF6CgojIGdvb2QKYmFyIGlmIGZvbwoKIyBnb29kCmlmIGZvbyB0aGVuIGJhciBlbmQKCiMgZ29vZAppZiBmb28KICBiYXIKZWxzZQogIGJhegplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsd2F5c0NvcnJlY3RUb011bHRpbGluZQp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3Rlcm5hcnktb3BlcmF0b3IKCj09IFN0eWxlL09wZW5TdHJ1Y3RVc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IE5vCnwgMS4yMwp8IDEuNTEKfD09PQoKRmxhZ3MgdXNlcyBvZiBPcGVuU3RydWN0LCBhcyBpdCBpcyBub3cgb2ZmaWNpYWxseSBkaXNjb3VyYWdlZAp0byBiZSB1c2VkIGZvciBwZXJmb3JtYW5jZSwgdmVyc2lvbiBjb21wYXRpYmlsaXR5LCBhbmQgcG90ZW50aWFsIHNlY3VyaXR5IGlzc3Vlcy4KCj09PSBTYWZldHkKCk5vdGUgdGhhdCB0aGlzIGNvcCBtYXkgZmxhZyBmYWxzZSBwb3NpdGl2ZXM7IGZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBsZWdhbAp1c2Ugb2YgYSBoYW5kLXJvbGxlZCBgT3BlblN0cnVjdGAgdHlwZSB3b3VsZCBiZSBjb25zaWRlcmVkIGFuIG9mZmVuc2U6CgpgYGAKbW9kdWxlIE15TmFtZXNwYWNlCiAgY2xhc3MgT3BlblN0cnVjdCAjIG5vdCB0aGUgT3BlblN0cnVjdCB3ZSdyZSBsb29raW5nIGZvcgogIGVuZAoKICBkZWYgbmV3X3N0cnVjdAogICAgT3BlblN0cnVjdC5uZXcgIyByZXNvbHZlcyB0byBNeU5hbWVzcGFjZTo6T3BlblN0cnVjdAogIGVuZAplbmQKYGBgCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApwb2ludCA9IE9wZW5TdHJ1Y3QubmV3KHg6IDAsIHk6IDEpCgojIGdvb2QKUG9pbnQgPSBTdHJ1Y3QubmV3KDp4LCA6eSkKcG9pbnQgPSBQb2ludC5uZXcoMCwgMSkKCiMgYWxzbyBnb29kCnBvaW50ID0geyB4OiAwLCB5OiAxIH0KCiMgYmFkCnRlc3RfZG91YmxlID0gT3BlblN0cnVjdC5uZXcoYTogJ2InKQoKIyBnb29kIChhc3N1bWVzIHRlc3QgdXNpbmcgcnNwZWMtbW9ja3MpCnRlc3RfZG91YmxlID0gZG91YmxlCmFsbG93KHRlc3RfZG91YmxlKS50byByZWNlaXZlKDphKS5hbmRfcmV0dXJuKCdiJykKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9kb2NzLnJ1YnktbGFuZy5vcmcvZW4vMy4wLjAvT3BlblN0cnVjdC5odG1sI2NsYXNzLU9wZW5TdHJ1Y3QtbGFiZWwtQ2F2ZWF0cwoKPT0gU3R5bGUvT3BlcmF0b3JNZXRob2RDYWxsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS4zNwp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgZG90IGJlZm9yZSBvcGVyYXRvciBtZXRob2QgY2FsbC4KVGhlIHRhcmdldCBvcGVyYXRvciBtZXRob2RzIGFyZSBgfGAsIGBeYCwgYCZgLCBgYDw9PmBgLCBgPT1gLCBgPT09YCwgYD1+YCwgYD5gLCBgPj1gLCBgPGAsCmBgPD1gYCwgYDw8YCwgYD4+YCwgYCtgLCBgLWAsIGAqYCwgYC9gLCBgJWAsIGAqKmAsIGB+YCwgYCFgLCBgIT1gLCBhbmQgYCF+YC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby4rIGJhcgpmb28uJiBiYXIKCiMgZ29vZApmb28gKyBiYXIKZm9vICYgYmFyCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI29wZXJhdG9yLW1ldGhvZC1jYWxsCgo9PSBTdHlsZS9PcHRpb25IYXNoCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMC4zMwp8IDAuMzQKfD09PQoKQ2hlY2tzIGZvciBvcHRpb25zIGhhc2hlcyBhbmQgZGlzY291cmFnZXMgdGhlbSBpZiB0aGUKY3VycmVudCBSdWJ5IHZlcnNpb24gc3VwcG9ydHMga2V5d29yZCBhcmd1bWVudHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZnJ5KG9wdGlvbnMgPSB7fSkKICB0ZW1wZXJhdHVyZSA9IG9wdGlvbnMuZmV0Y2goOnRlbXBlcmF0dXJlLCAzMDApCiAgIyAuLi4KZW5kCgojIGdvb2QKZGVmIGZyeSh0ZW1wZXJhdHVyZTogMzAwKQogICMgLi4uCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU3VzcGljaW91c1BhcmFtTmFtZXMKfCBgb3B0aW9uc2AsIGBvcHRzYCwgYGFyZ3NgLCBgcGFyYW1zYCwgYHBhcmFtZXRlcnNgCnwgQXJyYXkKCnwgQWxsb3dsaXN0CnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2tleXdvcmQtYXJndW1lbnRzLXZzLW9wdGlvbi1oYXNoZXMKCj09IFN0eWxlL09wdGlvbmFsQXJndW1lbnRzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBObwp8IDAuMzMKfCAwLjgzCnw9PT0KCkNoZWNrcyBmb3Igb3B0aW9uYWwgYXJndW1lbnRzIHRvIG1ldGhvZHMKdGhhdCBkbyBub3QgY29tZSBhdCB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudCBsaXN0LgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgY2hhbmdpbmcgYSBtZXRob2Qgc2lnbmF0dXJlIHdpbGwKaW1wbGljaXRseSBjaGFuZ2UgYmVoYXZpb3IuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vKGEgPSAxLCBiLCBjKQplbmQKCiMgZ29vZApkZWYgYmF6KGEsIGIsIGMgPSAxKQplbmQKCmRlZiBmb29iYXIoYSA9IDEsIGIgPSAyLCBjID0gMykKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI29wdGlvbmFsLWFyZ3VtZW50cwoKPT0gU3R5bGUvT3B0aW9uYWxCb29sZWFuUGFyYW1ldGVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBObwp8IDAuODkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIGtleXdvcmQgYXJndW1lbnRzIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YKYm9vbGVhbiBhcmd1bWVudHMgd2hlbiBkZWZpbmluZyBtZXRob2RzLiBgcmVzcG9uZF90b19taXNzaW5nP2AgbWV0aG9kIGlzIGFsbG93ZWQgYnkgZGVmYXVsdC4KVGhlc2UgYXJlIGN1c3RvbWl6YWJsZSB3aXRoIGBBbGxvd2VkTWV0aG9kc2Agb3B0aW9uLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgY2hhbmdpbmcgYSBtZXRob2Qgc2lnbmF0dXJlIHdpbGwKaW1wbGljaXRseSBjaGFuZ2UgYmVoYXZpb3IuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgc29tZV9tZXRob2QoYmFyID0gZmFsc2UpCiAgcHV0cyBiYXIKZW5kCgojIGJhZCAtIGNvbW1vbiBoYWNrIGJlZm9yZSBrZXl3b3JkIGFyZ3Mgd2VyZSBpbnRyb2R1Y2VkCmRlZiBzb21lX21ldGhvZChvcHRpb25zID0ge30pCiAgYmFyID0gb3B0aW9ucy5mZXRjaCg6YmFyLCBmYWxzZSkKICBwdXRzIGJhcgplbmQKCiMgZ29vZApkZWYgc29tZV9tZXRob2QoYmFyOiBmYWxzZSkKICBwdXRzIGJhcgplbmQKLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogWydzb21lX21ldGhvZCddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBzb21lX21ldGhvZChiYXIgPSBmYWxzZSkKICBwdXRzIGJhcgplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYHJlc3BvbmRfdG9fbWlzc2luZz9gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYm9vbGVhbi1rZXl3b3JkLWFyZ3VtZW50cwoKPT0gU3R5bGUvT3JBc3NpZ25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41MAp8IC0KfD09PQoKQ2hlY2tzIGZvciBwb3RlbnRpYWwgdXNhZ2Ugb2YgdGhlIGB8fD1gIG9wZXJhdG9yLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbmFtZSA9IG5hbWUgPyBuYW1lIDogJ0JvemhpZGFyJwoKIyBiYWQKbmFtZSA9IGlmIG5hbWUKICAgICAgICAgbmFtZQogICAgICAgZWxzZQogICAgICAgICAnQm96aGlkYXInCiAgICAgICBlbmQKCiMgYmFkCnVubGVzcyBuYW1lCiAgbmFtZSA9ICdCb3poaWRhcicKZW5kCgojIGJhZApuYW1lID0gJ0JvemhpZGFyJyB1bmxlc3MgbmFtZQoKIyBnb29kIC0gc2V0IG5hbWUgdG8gJ0JvemhpZGFyJywgb25seSBpZiBpdCdzIG5pbCBvciBmYWxzZQpuYW1lIHx8PSAnQm96aGlkYXInCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2RvdWJsZS1waXBlLWZvci11bmluaXQKCj09IFN0eWxlL1BhcmFsbGVsQXNzaWdubWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzIKfCAtCnw9PT0KCkNoZWNrcyBmb3Igc2ltcGxlIHVzYWdlcyBvZiBwYXJhbGxlbCBhc3NpZ25tZW50LgpUaGlzIHdpbGwgb25seSBjb21wbGFpbiB3aGVuIHRoZSBudW1iZXIgb2YgdmFyaWFibGVzCmJlaW5nIGFzc2lnbmVkIG1hdGNoZWQgdGhlIG51bWJlciBvZiBhc3NpZ25pbmcgdmFyaWFibGVzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSwgYiwgYyA9IDEsIDIsIDMKYSwgYiwgYyA9IFsxLCAyLCAzXQoKIyBnb29kCm9uZSwgdHdvID0gKmZvbwphLCBiID0gZm9vKCkKYSwgYiA9IGIsIGEKCmEgPSAxCmIgPSAyCmMgPSAzCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3BhcmFsbGVsLWFzc2lnbm1lbnQKCj09IFN0eWxlL1BhcmVudGhlc2VzQXJvdW5kQ29uZGl0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC41Ngp8PT09CgpDaGVja3MgZm9yIHRoZSBwcmVzZW5jZSBvZiBzdXBlcmZsdW91cyBwYXJlbnRoZXNlcyBhcm91bmQgdGhlCmNvbmRpdGlvbiBvZiBpZi91bmxlc3Mvd2hpbGUvdW50aWwuCgpgQWxsb3dTYWZlQXNzaWdubWVudGAgb3B0aW9uIGZvciBzYWZlIGFzc2lnbm1lbnQuCkJ5IHNhZmUgYXNzaWdubWVudCB3ZSBtZWFuIHB1dHRpbmcgcGFyZW50aGVzZXMgYXJvdW5kCmFuIGFzc2lnbm1lbnQgdG8gaW5kaWNhdGUgIkkga25vdyBJJ20gdXNpbmcgYW4gYXNzaWdubWVudAphcyBhIGNvbmRpdGlvbi4gSXQncyBub3QgYSBtaXN0YWtlLiIKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnggKz0gMSB3aGlsZSAoeCA8IDEwKQpmb28gdW5sZXNzIChiYXIgfHwgYmF6KQoKaWYgKHggPiAxMCkKZWxzaWYgKHggPCAzKQplbmQKCiMgZ29vZAp4ICs9IDEgd2hpbGUgeCA8IDEwCmZvbyB1bmxlc3MgYmFyIHx8IGJhegoKaWYgeCA+IDEwCmVsc2lmIHggPCAzCmVuZAotLS0tCgo9PT09IEFsbG93U2FmZUFzc2lnbm1lbnQ6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmZvbyB1bmxlc3MgKGJhciA9IGJheikKLS0tLQoKPT09PSBBbGxvd1NhZmVBc3NpZ25tZW50OiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvbyB1bmxlc3MgKGJhciA9IGJheikKLS0tLQoKPT09PSBBbGxvd0luTXVsdGlsaW5lQ29uZGl0aW9uczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgKHggPiAxMCAmJgogICB5ID4gMTApCmVuZAoKIyBnb29kCiBpZiB4ID4gMTAgJiYKICAgIHkgPiAxMAogZW5kCi0tLS0KCj09PT0gQWxsb3dJbk11bHRpbGluZUNvbmRpdGlvbnM6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKaWYgKHggPiAxMCAmJgogICB5ID4gMTApCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dTYWZlQXNzaWdubWVudAp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dJbk11bHRpbGluZUNvbmRpdGlvbnMKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1wYXJlbnMtYXJvdW5kLWNvbmRpdGlvbgoKPT0gU3R5bGUvUGVyY2VudExpdGVyYWxEZWxpbWl0ZXJzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xOQp8IDAuNDgKfD09PQoKRW5mb3JjZXMgdGhlIGNvbnNpc3RlbnQgdXNhZ2Ugb2YgYCVgLWxpdGVyYWwgZGVsaW1pdGVycy4KClNwZWNpZnkgdGhlICdkZWZhdWx0JyBrZXkgdG8gc2V0IGFsbCBwcmVmZXJyZWQgZGVsaW1pdGVycyBhdCBvbmNlLiBZb3UKY2FuIGNvbnRpbnVlIHRvIHNwZWNpZnkgaW5kaXZpZHVhbCBwcmVmZXJyZWQgZGVsaW1pdGVycyB0byBvdmVycmlkZSB0aGUKZGVmYXVsdC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgU3R5bGUvUGVyY2VudExpdGVyYWxEZWxpbWl0ZXJzOgojICAgUHJlZmVycmVkRGVsaW1pdGVyczoKIyAgICAgZGVmYXVsdDogJ1tdJwojICAgICAnJWknOiAgICAnKCknCgojIGdvb2QKJXdbYWxwaGEgYmV0YV0gKyAlaShnYW1tYSBkZWx0YSkKCiMgYmFkCiVXKGFscGhhICN7YmV0YX0pCgojIGJhZAolSShhbHBoYSBiZXRhKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgUHJlZmVycmVkRGVsaW1pdGVycwp8IGB7ImRlZmF1bHQiPT4iKCkiLCAiJWkiPT4iW10iLCAiJUkiPT4iW10iLCAiJXIiPT4ie30iLCAiJXciPT4iW10iLCAiJVciPT4iW10ifWAKfCAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjcGVyY2VudC1saXRlcmFsLWJyYWNlcwoKPT0gU3R5bGUvUGVyY2VudFFMaXRlcmFscwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMjUKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdXNhZ2Ugb2YgdGhlICVRKCkgc3ludGF4IHdoZW4gJXEoKSB3b3VsZCBkby4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBsb3dlcl9jYXNlX3EgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYGxvd2VyX2Nhc2VfcWAgc3R5bGUgcHJlZmVycyBgJXFgIHVubGVzcwojIGludGVycG9sYXRpb24gaXMgbmVlZGVkLgojIGJhZAolUVtNaXggdGhlIGZvbyBpbnRvIHRoZSBiYXouXQolUShUaGV5IGFsbCBzYWlkOiAnSG9vcmF5IScpCgojIGdvb2QKJXFbTWl4IHRoZSBmb28gaW50byB0aGUgYmF6XQolcShUaGV5IGFsbCBzYWlkOiAnSG9vcmF5IScpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogdXBwZXJfY2FzZV9xCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYHVwcGVyX2Nhc2VfcWAgc3R5bGUgcmVxdWlyZXMgdGhlIHNvbGUgdXNlIG9mIGAlUWAuCiMgYmFkCiVxL01peCB0aGUgZm9vIGludG8gdGhlIGJhei4vCiVxe1RoZXkgYWxsIHNhaWQ6ICdIb29yYXkhJ30KCiMgZ29vZAolUS9NaXggdGhlIGZvbyBpbnRvIHRoZSBiYXouLwolUXtUaGV5IGFsbCBzYWlkOiAnSG9vcmF5ISd9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGxvd2VyX2Nhc2VfcWAKfCBgbG93ZXJfY2FzZV9xYCwgYHVwcGVyX2Nhc2VfcWAKfD09PQoKPT0gU3R5bGUvUGVybEJhY2tyZWZzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xMwp8IC0KfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgUGVybC1zdHlsZSByZWdleHAgbWF0Y2gKYmFja3JlZmVyZW5jZXMgYW5kIHRoZWlyIEVuZ2xpc2ggdmVyc2lvbnMgbGlrZQokMSwgJDIsICQmLCAmKywgJE1BVENILCAkUFJFTUFUQ0gsIGV0Yy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnB1dHMgJDEKCiMgZ29vZApwdXRzIFJlZ2V4cC5sYXN0X21hdGNoKDEpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLXBlcmwtcmVnZXhwLWxhc3QtbWF0Y2hlcnMKCj09IFN0eWxlL1ByZWZlcnJlZEhhc2hNZXRob2RzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjQxCnwgMC43MAp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgbWV0aG9kcyBgSGFzaCNoYXNfa2V5P2AgYW5kCmBIYXNoI2hhc192YWx1ZT9gLCBhbmQgc3VnZ2VzdHMgdXNpbmcgYEhhc2gja2V5P2AgYW5kIGBIYXNoI3ZhbHVlP2AgaW5zdGVhZC4KCkl0IGlzIGNvbmZpZ3VyYWJsZSB0byBlbmZvcmNlIHRoZSB2ZXJib3NlIG1ldGhvZCBuYW1lcywgYnkgdXNpbmcgdGhlCmBFbmZvcmNlZFN0eWxlOiB2ZXJib3NlYCBjb25maWd1cmF0aW9uLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdCB0aGUgcmVjZWl2ZXIKaXMgYSBgSGFzaGAgb3IgcmVzcG9uZHMgdG8gdGhlIHJlcGxhY2VtZW50IG1ldGhvZHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2hvcnQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKSGFzaCNoYXNfa2V5PwpIYXNoI2hhc192YWx1ZT8KCiMgZ29vZApIYXNoI2tleT8KSGFzaCN2YWx1ZT8KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiB2ZXJib3NlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKSGFzaCNrZXk/Ckhhc2gjdmFsdWU/CgojIGdvb2QKSGFzaCNoYXNfa2V5PwpIYXNoI2hhc192YWx1ZT8KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2hvcnRgCnwgYHNob3J0YCwgYHZlcmJvc2VgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2hhc2gta2V5Cgo9PSBTdHlsZS9Qcm9jCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC4xOAp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgUHJvYy5uZXcgd2hlcmUgS2VybmVsI3Byb2MKd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnAgPSBQcm9jLm5ldyB7IHxufCBwdXRzIG4gfQoKIyBnb29kCnAgPSBwcm9jIHsgfG58IHB1dHMgbiB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3Byb2MKCj09IFN0eWxlL1F1b3RlZFN5bWJvbHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjE2CnwgLQp8PT09CgpDaGVja3MgaWYgdGhlIHF1b3RlcyB1c2VkIGZvciBxdW90ZWQgc3ltYm9scyBtYXRjaCB0aGUgY29uZmlndXJlZCBkZWZhdWx0cy4KQnkgZGVmYXVsdCB1c2VzIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gYXMgYFN0eWxlL1N0cmluZ0xpdGVyYWxzYDsgaWYgdGhhdApjb3AgaXMgbm90IGVuYWJsZWQsIHRoZSBkZWZhdWx0IGBFbmZvcmNlZFN0eWxlYCBpcyBgc2luZ2xlX3F1b3Rlc2AuCgpTdHJpbmcgaW50ZXJwb2xhdGlvbiBpcyBhbHdheXMga2VwdCBpbiBkb3VibGUgcXVvdGVzLgoKTm90ZTogYExpbnQvU3ltYm9sQ29udmVyc2lvbmAgY2FuIGJlIHVzZWQgaW4gcGFyYWxsZWwgdG8gZW5zdXJlIHRoYXQgc3ltYm9scwphcmUgbm90IHF1b3RlZCB0aGF0IGRvbid0IG5lZWQgdG8gYmUuIFRoaXMgY29wIGlzIGZvciBjb25maWd1cmluZyB0aGUgcXVvdGluZwpzdHlsZSB0byB1c2UgZm9yIHN5bWJvbHMgdGhhdCByZXF1aXJlIHF1b3Rlcy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBzYW1lX2FzX3N0cmluZ19saXRlcmFscyAoZGVmYXVsdCkgLyBzaW5nbGVfcXVvdGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKOiJhYmMtZGVmIgoKIyBnb29kCjonYWJjLWRlZicKOiIje3N0cn0iCjoiYVwnYiIKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBkb3VibGVfcXVvdGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKOidhYmMtZGVmJwoKIyBnb29kCjoiYWJjLWRlZiIKOiIje3N0cn0iCjoiYVwnYiIKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2FtZV9hc19zdHJpbmdfbGl0ZXJhbHNgCnwgYHNhbWVfYXNfc3RyaW5nX2xpdGVyYWxzYCwgYHNpbmdsZV9xdW90ZXNgLCBgZG91YmxlX3F1b3Rlc2AKfD09PQoKPT0gU3R5bGUvUmFpc2VBcmdzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjE0CnwgMS42MQp8PT09CgpDaGVja3MgdGhlIGFyZ3MgcGFzc2VkIHRvIGBmYWlsYCBhbmQgYHJhaXNlYC4gRm9yIGV4cGxvZGVkCnN0eWxlIChkZWZhdWx0KSwgaXQgcmVjb21tZW5kcyBwYXNzaW5nIHRoZSBleGNlcHRpb24gY2xhc3MgYW5kIG1lc3NhZ2UKdG8gYHJhaXNlYCwgcmF0aGVyIHRoYW4gY29uc3RydWN0IGFuIGluc3RhbmNlIG9mIHRoZSBlcnJvci4gSXQgd2lsbApzdGlsbCBhbGxvdyBwYXNzaW5nIGp1c3QgYSBtZXNzYWdlLCBvciB0aGUgY29uc3RydWN0aW9uIG9mIGFuIGVycm9yCndpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudC4KClRoZSBleHBsb2RlZCBzdHlsZSB3b3JrcyBpZGVudGljYWxseSwgYnV0IHdpdGggdGhlIGFkZGl0aW9uIHRoYXQgaXQKd2lsbCBhbHNvIHN1Z2dlc3QgY29uc3RydWN0aW5nIGVycm9yIG9iamVjdHMgd2hlbiB0aGUgZXhjZXB0aW9uIGlzCnBhc3NlZCBtdWx0aXBsZSBhcmd1bWVudHMuCgpUaGUgZXhwbG9kZWQgc3R5bGUgaGFzIGFuIGBBbGxvd2VkQ29tcGFjdFR5cGVzYCBjb25maWd1cmF0aW9uCm9wdGlvbiB0aGF0IHRha2VzIGFuIEFycmF5IG9mIGV4Y2VwdGlvbiBuYW1lIFN0cmluZ3MuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBgcmFpc2UgRm9vYCBjYWxscyBgRm9vLmV4Y2VwdGlvbmAsIG5vdCBgRm9vLm5ld2AuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogZXhwbG9kZWQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmFpc2UgU3RhbmRhcmRFcnJvci5uZXcoJ21lc3NhZ2UnKQoKIyBnb29kCnJhaXNlIFN0YW5kYXJkRXJyb3IsICdtZXNzYWdlJwpmYWlsICdtZXNzYWdlJwpyYWlzZSBNeUN1c3RvbUVycm9yCnJhaXNlIE15Q3VzdG9tRXJyb3IubmV3KGFyZzEsIGFyZzIsIGFyZzMpCnJhaXNlIE15S3dBcmdFcnJvci5uZXcoa2V5MTogdmFsMSwga2V5MjogdmFsMikKCiMgV2l0aCBgQWxsb3dlZENvbXBhY3RUeXBlc2Agc2V0IHRvIFsnTXlXcmFwcGVkRXJyb3InXQpyYWlzZSBNeVdyYXBwZWRFcnJvci5uZXcob2JqKQpyYWlzZSBNeVdyYXBwZWRFcnJvci5uZXcob2JqKSwgJ21lc3NhZ2UnCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY29tcGFjdAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnJhaXNlIFN0YW5kYXJkRXJyb3IsICdtZXNzYWdlJwpyYWlzZSBSdW50aW1lRXJyb3IsIGFyZzEsIGFyZzIsIGFyZzMKCiMgZ29vZApyYWlzZSBTdGFuZGFyZEVycm9yLm5ldygnbWVzc2FnZScpCnJhaXNlIE15Q3VzdG9tRXJyb3IKcmFpc2UgTXlDdXN0b21FcnJvci5uZXcoYXJnMSwgYXJnMiwgYXJnMykKZmFpbCAnbWVzc2FnZScKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZXhwbG9kZWRgCnwgYGNvbXBhY3RgLCBgZXhwbG9kZWRgCgp8IEFsbG93ZWRDb21wYWN0VHlwZXMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjZXhjZXB0aW9uLWNsYXNzLW1lc3NhZ2VzCgo9PSBTdHlsZS9SYW5kb21XaXRoT2Zmc2V0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIHJhbmRvbWx5IGdlbmVyYXRlZCBudW1iZXJzLAphZGRlZC9zdWJ0cmFjdGVkIHdpdGggaW50ZWdlciBsaXRlcmFscywgYXMgd2VsbCBhcyB0aG9zZSB3aXRoCkludGVnZXIjc3VjYyBhbmQgSW50ZWdlciNwcmVkIG1ldGhvZHMuIFByZWZlciB1c2luZyByYW5nZXMgaW5zdGVhZCwKYXMgaXQgY2xlYXJseSBzdGF0ZXMgdGhlIGludGVudGlvbnMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApyYW5kKDYpICsgMQoxICsgcmFuZCg2KQpyYW5kKDYpIC0gMQoxIC0gcmFuZCg2KQpyYW5kKDYpLnN1Y2MKcmFuZCg2KS5wcmVkClJhbmRvbS5yYW5kKDYpICsgMQpLZXJuZWwucmFuZCg2KSArIDEKcmFuZCgwLi41KSArIDEKCiMgZ29vZApyYW5kKDEuLjYpCnJhbmQoMS4uLjcpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3JhbmRvbS1udW1iZXJzCgo9PSBTdHlsZS9SZWR1bmRhbnRBcmd1bWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS40CnwgMS41NQp8PT09CgpDaGVja3MgZm9yIGEgcmVkdW5kYW50IGFyZ3VtZW50IHBhc3NlZCB0byBjZXJ0YWluIG1ldGhvZHMuCgpOT1RFOiBUaGlzIGNvcCBpcyBsaW1pdGVkIHRvIG1ldGhvZHMgd2l0aCBzaW5nbGUgcGFyYW1ldGVyLgoKTWV0aG9kIG5hbWVzIGFuZCB0aGVpciByZWR1bmRhbnQgYXJndW1lbnRzIGNhbiBiZSBjb25maWd1cmVkIGxpa2UgdGhpczoKCltzb3VyY2UseWFtbF0KLS0tLQpNZXRob2RzOgogIGpvaW46ICcnCiAgc3VtOiAwCiAgc3BsaXQ6ICcgJwogIGNob21wOiAiXG4iCiAgY2hvbXAhOiAiXG4iCiAgZm9vOiAyCi0tLS0KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgbGltaXRhdGlvbnM6CgoxLiBUaGlzIGNvcCBtYXRjaGVzIGJ5IG1ldGhvZCBuYW1lcyBvbmx5IGFuZCBoZW5jZSBjYW5ub3QgdGVsbCBhcGFydAogICBtZXRob2RzIHdpdGggc2FtZSBuYW1lIGluIGRpZmZlcmVudCBjbGFzc2VzLgoyLiBUaGlzIGNvcCBtYXkgYmUgdW5zYWZlIGlmIGNlcnRhaW4gc3BlY2lhbCBnbG9iYWwgdmFyaWFibGVzIChlLmcuIGAkO2AsIGAkL2ApIGFyZSBzZXQuCiAgIFRoYXQgZGVwZW5kcyBvbiB0aGUgbmF0dXJlIG9mIHRoZSB0YXJnZXQgbWV0aG9kcywgb2YgY291cnNlLiBGb3IgZXhhbXBsZSwgdGhlIGRlZmF1bHQKICAgYXJndW1lbnQgdG8gam9pbiBpcyBgJE9VVFBVVF9GSUVMRF9TRVBBUkFUT1JgIChvciBgJCxgKSByYXRoZXIgdGhhbiBgJydgLCBhbmQgaWYgdGhhdAogICBnbG9iYWwgaXMgY2hhbmdlZCwgYCcnYCBpcyBubyBsb25nZXIgYSByZWR1bmRhbnQgYXJndW1lbnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphcnJheS5qb2luKCcnKQpbMSwgMiwgM10uam9pbigiIikKYXJyYXkuc3VtKDApCmV4aXQodHJ1ZSkKZXhpdCEoZmFsc2UpCnN0cmluZy5zcGxpdCgiICIpCiJmaXJzdFxuc2Vjb25kIi5zcGxpdCgiICIpCnN0cmluZy5jaG9tcCgiXG4iKQpzdHJpbmcuY2hvbXAhKCJcbiIpCkEuZm9vKDIpCgojIGdvb2QKYXJyYXkuam9pbgpbMSwgMiwgM10uam9pbgphcnJheS5zdW0KZXhpdApleGl0IQpzdHJpbmcuc3BsaXQKImZpcnN0IHNlY29uZCIuc3BsaXQKc3RyaW5nLmNob21wCnN0cmluZy5jaG9tcCEKQS5mb28KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE1ldGhvZHMKfCBgeyJqb2luIj0+IiIsICJzdW0iPT4wLCAiZXhpdCI9PnRydWUsICJleGl0ISI9PmZhbHNlLCAic3BsaXQiPT4iICIsICJjaG9tcCI9PiJcbiIsICJjaG9tcCEiPT4iXG4ifWAKfCAKfD09PQoKPT0gU3R5bGUvUmVkdW5kYW50QXJyYXlDb25zdHJ1Y3RvcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuNTIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdGhlIGluc3RhbnRpYXRpb24gb2YgYXJyYXkgdXNpbmcgcmVkdW5kYW50IGBBcnJheWAgY29uc3RydWN0b3IuCkF1dG9jb3JyZWN0IHJlcGxhY2VzIHRvIGFycmF5IGxpdGVyYWwgd2hpY2ggaXMgdGhlIHNpbXBsZXN0IGFuZCBmYXN0ZXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKQXJyYXkubmV3KFtdKQpBcnJheVtdCkFycmF5KFtdKQpBcnJheS5uZXcoWydmb28nLCAnZm9vJywgJ2ZvbyddKQpBcnJheVsnZm9vJywgJ2ZvbycsICdmb28nXQpBcnJheShbJ2ZvbycsICdmb28nLCAnZm9vJ10pCgojIGdvb2QKW10KWydmb28nLCAnZm9vJywgJ2ZvbyddCkFycmF5Lm5ldygzLCAnZm9vJykKQXJyYXkubmV3KDMpIHsgJ2ZvbycgfQotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRBc3NpZ25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC44Nwp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgYXNzaWdubWVudCBiZWZvcmUgcmV0dXJuaW5nLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHRlc3QKICB4ID0gZm9vCiAgeAplbmQKCiMgYmFkCmRlZiB0ZXN0CiAgaWYgeAogICAgeiA9IGZvbwogICAgegogIGVsc2lmIHkKICAgIHogPSBiYXIKICAgIHoKICBlbmQKZW5kCgojIGdvb2QKZGVmIHRlc3QKICBmb28KZW5kCgojIGdvb2QKZGVmIHRlc3QKICBpZiB4CiAgICBmb28KICBlbHNpZiB5CiAgICBiYXIKICBlbmQKZW5kCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudEJlZ2luCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xMAp8IDAuMjEKfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgYGJlZ2luYCBibG9ja3MuCgpDdXJyZW50bHkgaXQgY2hlY2tzIGZvciBjb2RlIGxpa2UgdGhpczoKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiByZWR1bmRhbnQKICBiZWdpbgogICAgYWxhCiAgICBiYWxhCiAgcmVzY3VlIFN0YW5kYXJkRXJyb3IgPT4gZQogICAgc29tZXRoaW5nCiAgZW5kCmVuZAoKIyBnb29kCmRlZiBwcmVmZXJyZWQKICBhbGEKICBiYWxhCnJlc2N1ZSBTdGFuZGFyZEVycm9yID0+IGUKICBzb21ldGhpbmcKZW5kCgojIGJhZApiZWdpbgogIGRvX3NvbWV0aGluZwplbmQKCiMgZ29vZApkb19zb21ldGhpbmcKCiMgYmFkCiMgV2hlbiB1c2luZyBSdWJ5IDIuNSBvciBsYXRlci4KZG9fc29tZXRoaW5nIGRvCiAgYmVnaW4KICAgIHNvbWV0aGluZwogIHJlc2N1ZSA9PiBleAogICAgYW55dGhpbmcKICBlbmQKZW5kCgojIGdvb2QKIyBJbiBSdWJ5IDIuNSBvciBsYXRlciwgeW91IGNhbiBvbWl0IGBiZWdpbmAgaW4gYGRvLWVuZGAgYmxvY2suCmRvX3NvbWV0aGluZyBkbwogIHNvbWV0aGluZwpyZXNjdWUgPT4gZXgKICBhbnl0aGluZwplbmQKCiMgZ29vZAojIFN0YWJieSBsYW1iZGFzIGRvbid0IHN1cHBvcnQgaW1wbGljaXQgYGJlZ2luYCBpbiBgZG8tZW5kYCBibG9ja3MuCi0+IGRvCiAgYmVnaW4KICAgIGZvbwogIHJlc2N1ZSBCYXIKICAgIGJhegogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjYmVnaW4taW1wbGljaXQKCj09IFN0eWxlL1JlZHVuZGFudENhcGl0YWxXCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC43Ngp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2FnZSBvZiB0aGUgJVcoKSBzeW50YXggd2hlbiAldygpIHdvdWxkIGRvLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKJVcoY2F0IGRvZyBwaWcpCiVXW2Rvb3Igd2FsbCBmbG9vcl0KCiMgZ29vZAoldy9zd2ltIHJ1biBiaWtlLwold1tzaGlydCBwYW50cyBzaG9lc10KJVcoYXBwbGUgI3tmcnVpdH0gZ3JhcGUpCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudENvbmRpdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNzYKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdW5uZWNlc3NhcnkgY29uZGl0aW9uYWwgZXhwcmVzc2lvbnMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphID0gYiA/IGIgOiBjCgojIGdvb2QKYSA9IGIgfHwgYwotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgYgogIGIKZWxzZQogIGMKZW5kCgojIGdvb2QKYiB8fCBjCgojIGdvb2QKaWYgYgogIGIKZWxzaWYgY29uZAogIGMKZW5kCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudENvbmRpdGlvbmFsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41MAp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgcmV0dXJuaW5nIG9mIHRydWUvZmFsc2UgaW4gY29uZGl0aW9uYWxzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKeCA9PSB5ID8gdHJ1ZSA6IGZhbHNlCgojIGJhZAppZiB4ID09IHkKICB0cnVlCmVsc2UKICBmYWxzZQplbmQKCiMgZ29vZAp4ID09IHkKCiMgYmFkCnggPT0geSA/IGZhbHNlIDogdHJ1ZQoKIyBnb29kCnggIT0geQotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRDb25zdGFudEJhc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjQwCnwgLQp8PT09CgpBdm9pZCByZWR1bmRhbnQgYDo6YCBwcmVmaXggb24gY29uc3RhbnQuCgpIb3cgUnVieSBzZWFyY2hlcyBjb25zdGFudCBpcyBhIGJpdCBjb21wbGljYXRlZCwgYW5kIGl0IGNhbiBvZnRlbiBiZSBkaWZmaWN1bHQgdG8KdW5kZXJzdGFuZCBmcm9tIHRoZSBjb2RlIHdoZXRoZXIgdGhlIGA6OmAgaXMgaW50ZW5kZWQgb3Igbm90LiBXaGVyZSBgTW9kdWxlLm5lc3RpbmdgCmlzIGVtcHR5LCB0aGVyZSBpcyBubyBuZWVkIHRvIHByZXBlbmQgYDo6YCwgc28gaXQgd291bGQgYmUgbmljZSB0byBjb25zaXN0ZW50bHkKYXZvaWQgc3VjaCBtZWFuaW5nbGVzcyBgOjpgIHByZWZpeCB0byBhdm9pZCBjb25mdXNpb24uCgpOT1RFOiBUaGlzIGNvcCBpcyBkaXNhYmxlZCBpZiBgTGludC9Db25zdGFudFJlc29sdXRpb25gIGNvcCBpcyBlbmFibGVkIHRvIHByZXZlbnQKY29uZmxpY3RpbmcgcnVsZXMuIEJlY2F1c2UgaXQgcmVzcGVjdHMgdXNlciBjb25maWd1cmF0aW9ucyB0aGF0IHdhbnQgdG8gZW5hYmxlCmBMaW50L0NvbnN0YW50UmVzb2x1dGlvbmAgY29wIHdoaWNoIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo6OkNvbnN0CgojIGdvb2QKQ29uc3QKCiMgYmFkCmNsYXNzIDw8IHNlbGYKICA6OkNvbnN0CmVuZAoKIyBnb29kCmNsYXNzIDw8IHNlbGYKICBDb25zdAplbmQKCiMgZ29vZApjbGFzcyBBCiAgOjpDb25zdAplbmQKCiMgZ29vZAptb2R1bGUgQQogIDo6Q29uc3QKZW5kCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudEN1cnJlbnREaXJlY3RvcnlJblBhdGgKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjUzCnwgLQp8PT09CgpDaGVja3MgZm9yIHVzZXMgYSByZWR1bmRhbnQgY3VycmVudCBkaXJlY3RvcnkgaW4gcGF0aC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnJlcXVpcmVfcmVsYXRpdmUgJy4vcGF0aC90by9mZWF0dXJlJwoKIyBnb29kCnJlcXVpcmVfcmVsYXRpdmUgJ3BhdGgvdG8vZmVhdHVyZScKLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50RG91YmxlU3BsYXRIYXNoQnJhY2VzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS40MQp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgdXNlcyBvZiBkb3VibGUgc3BsYXQgaGFzaCBicmFjZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkb19zb21ldGhpbmcoKip7Zm9vOiBiYXIsIGJhejogcXV4fSkKCiMgZ29vZApkb19zb21ldGhpbmcoZm9vOiBiYXIsIGJhejogcXV4KQoKIyBiYWQKZG9fc29tZXRoaW5nKCoqe2ZvbzogYmFyLCBiYXo6IHF1eH0ubWVyZ2Uob3B0aW9ucykpCgojIGdvb2QKZG9fc29tZXRoaW5nKGZvbzogYmFyLCBiYXo6IHF1eCwgKipvcHRpb25zKQotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRFYWNoCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAxLjM4CnwgLQp8PT09CgpDaGVja3MgZm9yIHJlZHVuZGFudCBgZWFjaGAuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUsIGFzIGl0IGNhbiBwcm9kdWNlIGZhbHNlIHBvc2l0aXZlcyBpZiB0aGUgcmVjZWl2ZXIKaXMgbm90IGFuIGBFbnVtZXJhdG9yYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFycmF5LmVhY2guZWFjaCB7IHx2fCBkb19zb21ldGhpbmcodikgfQoKIyBnb29kCmFycmF5LmVhY2ggeyB8dnwgZG9fc29tZXRoaW5nKHYpIH0KCiMgYmFkCmFycmF5LmVhY2guZWFjaF93aXRoX2luZGV4IHsgfHYsIGl8IGRvX3NvbWV0aGluZyh2LCBpKSB9CgojIGdvb2QKYXJyYXkuZWFjaC53aXRoX2luZGV4IHsgfHYsIGl8IGRvX3NvbWV0aGluZyh2LCBpKSB9CmFycmF5LmVhY2hfd2l0aF9pbmRleCB7IHx2LCBpfCBkb19zb21ldGhpbmcodiwgaSkgfQoKIyBiYWQKYXJyYXkuZWFjaC5lYWNoX3dpdGhfb2JqZWN0IHsgfHYsIG98IGRvX3NvbWV0aGluZyh2LCBvKSB9CgojIGdvb2QKYXJyYXkuZWFjaC53aXRoX29iamVjdCB7IHx2LCBvfCBkb19zb21ldGhpbmcodiwgbykgfQphcnJheS5lYWNoX3dpdGhfb2JqZWN0IHsgfHYsIG98IGRvX3NvbWV0aGluZyh2LCBvKSB9Ci0tLS0KCj09IFN0eWxlL1JlZHVuZGFudEV4Y2VwdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTQKfCAwLjI5Cnw9PT0KCkNoZWNrcyBmb3IgUnVudGltZUVycm9yIGFzIHRoZSBhcmd1bWVudCBvZiByYWlzZS9mYWlsLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmFpc2UgUnVudGltZUVycm9yLCAnbWVzc2FnZScKcmFpc2UgUnVudGltZUVycm9yLm5ldygnbWVzc2FnZScpCgojIGdvb2QKcmFpc2UgJ21lc3NhZ2UnCgojIGJhZCAtIG1lc3NhZ2UgaXMgbm90IGEgc3RyaW5nCnJhaXNlIFJ1bnRpbWVFcnJvciwgT2JqZWN0Lm5ldwpyYWlzZSBSdW50aW1lRXJyb3IubmV3KE9iamVjdC5uZXcpCgojIGdvb2QKcmFpc2UgT2JqZWN0Lm5ldy50b19zCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLWV4cGxpY2l0LXJ1bnRpbWVlcnJvcgoKPT0gU3R5bGUvUmVkdW5kYW50RmV0Y2hCbG9jawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44Ngp8IC0KfD09PQoKSWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYGZldGNoKGtleSkgeyB2YWx1ZSB9YCBjYW4gYmUgcmVwbGFjZWQgYnkgYGZldGNoKGtleSwgdmFsdWUpYC4KCkluIHN1Y2ggY2FzZXMgYGZldGNoKGtleSwgdmFsdWUpYCBtZXRob2QgaXMgZmFzdGVyIHRoYW4gYGZldGNoKGtleSkgeyB2YWx1ZSB9YC4KCk5PVEU6IFRoZSBibG9jayBzdHJpbmcgYCd2YWx1ZSdgIGluIGBoYXNoLmZldGNoKDprZXkpIHsgJ3ZhbHVlJyB9YCBpcyBkZXRlY3RlZAp3aGVuIGZyb3plbiBzdHJpbmcgbGl0ZXJhbCBtYWdpYyBjb21tZW50IGlzIGVuYWJsZWQgKGkuZS4gYCMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlYCksCmJ1dCBub3Qgd2hlbiBkaXNhYmxlZC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBndWFyYW50ZWVkIHRoYXQgdGhlIHJlY2VpdmVyCmRvZXMgbm90IGhhdmUgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24gb2YgYGZldGNoYC4KCj09PSBFeGFtcGxlcwoKPT09PSBTYWZlRm9yQ29uc3RhbnRzOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApoYXNoLmZldGNoKDprZXkpIHsgNSB9Cmhhc2guZmV0Y2goOmtleSkgeyB0cnVlIH0KaGFzaC5mZXRjaCg6a2V5KSB7IG5pbCB9CmFycmF5LmZldGNoKDUpIHsgOnZhbHVlIH0KRU5WLmZldGNoKDprZXkpIHsgJ3ZhbHVlJyB9CgojIGdvb2QKaGFzaC5mZXRjaCg6a2V5LCA1KQpoYXNoLmZldGNoKDprZXksIHRydWUpCmhhc2guZmV0Y2goOmtleSwgbmlsKQphcnJheS5mZXRjaCg1LCA6dmFsdWUpCkVOVi5mZXRjaCg6a2V5LCAndmFsdWUnKQotLS0tCgo9PT09IFNhZmVGb3JDb25zdGFudHM6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApFTlYuZmV0Y2goOmtleSkgeyBWQUxVRSB9CgojIGdvb2QKRU5WLmZldGNoKDprZXksIFZBTFVFKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU2FmZUZvckNvbnN0YW50cwp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYXN0cnVieS9mYXN0LXJ1YnkjaGFzaGZldGNoLXdpdGgtYXJndW1lbnQtdnMtaGFzaGZldGNoLS1ibG9jay1jb2RlCgo9PSBTdHlsZS9SZWR1bmRhbnRGaWxlRXh0ZW5zaW9uSW5SZXF1aXJlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC44OAp8IC0KfD09PQoKQ2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2Ygc3VwZXJmbHVvdXMgYC5yYmAgZXh0ZW5zaW9uIGluCnRoZSBmaWxlbmFtZSBwcm92aWRlZCB0byBgcmVxdWlyZWAgYW5kIGByZXF1aXJlX3JlbGF0aXZlYC4KCk5vdGU6IElmIHRoZSBleHRlbnNpb24gaXMgb21pdHRlZCwgUnVieSB0cmllcyBhZGRpbmcgJy5yYicsICcuc28nLAogICAgICBhbmQgc28gb24gdG8gdGhlIG5hbWUgdW50aWwgZm91bmQuIElmIHRoZSBmaWxlIG5hbWVkIGNhbm5vdCBiZSBmb3VuZCwKICAgICAgYSBgTG9hZEVycm9yYCB3aWxsIGJlIHJhaXNlZC4KICAgICAgVGhlcmUgaXMgYW4gZWRnZSBjYXNlIHdoZXJlIGBmb28uc29gIGZpbGUgaXMgbG9hZGVkIGluc3RlYWQgb2YgYSBgTG9hZEVycm9yYAogICAgICBpZiBgZm9vLnNvYCBmaWxlIGV4aXN0cyB3aGVuIGByZXF1aXJlICdmb28ucmInYCB3aWxsIGJlIGNoYW5nZWQgdG8gYHJlcXVpcmUgJ2ZvbydgLAogICAgICBidXQgdGhhdCBzZWVtcyBoYXJtbGVzcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnJlcXVpcmUgJ2Zvby5yYicKcmVxdWlyZV9yZWxhdGl2ZSAnLi4vZm9vLnJiJwoKIyBnb29kCnJlcXVpcmUgJ2ZvbycKcmVxdWlyZSAnZm9vLnNvJwpyZXF1aXJlX3JlbGF0aXZlICcuLi9mb28nCnJlcXVpcmVfcmVsYXRpdmUgJy4uL2Zvby5zbycKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tZXhwbGljaXQtcmItdG8tcmVxdWlyZQoKPT0gU3R5bGUvUmVkdW5kYW50RmlsdGVyQ2hhaW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAxLjUyCnwgMS41Nwp8PT09CgpJZGVudGlmaWVzIHVzYWdlcyBvZiBgYW55P2AsIGBlbXB0eT9gIG9yIGBub25lP2AgcHJlZGljYXRlIG1ldGhvZHMKY2hhaW5lZCB0byBgc2VsZWN0YC9gZmlsdGVyYC9gZmluZF9hbGxgIGFuZCBjaGFuZ2UgdGhlbSB0byB1c2UgcHJlZGljYXRlIG1ldGhvZCBpbnN0ZWFkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBgYXJyYXkuc2VsZWN0LmFueT9gIGV2YWx1YXRlcyBhbGwgZWxlbWVudHMKdGhyb3VnaCB0aGUgYHNlbGVjdGAgbWV0aG9kLCB3aGlsZSBgYXJyYXkuYW55P2AgdXNlcyBzaG9ydC1jaXJjdWl0IGV2YWx1YXRpb24uCkluIG90aGVyIHdvcmRzLCBgYXJyYXkuc2VsZWN0LmFueT9gIGd1YXJhbnRlZXMgdGhlIGV2YWx1YXRpb24gb2YgZXZlcnkgZWxlbWVudCwKYnV0IGBhcnJheS5hbnk/YCBkb2VzIG5vdCBuZWNlc3NhcmlseSBldmFsdWF0ZSBhbGwgb2YgdGhlbS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFyci5zZWxlY3QgeyB8eHwgeCA+IDEgfS5hbnk/CgojIGdvb2QKYXJyLmFueT8geyB8eHwgeCA+IDEgfQoKIyBiYWQKYXJyLnNlbGVjdCB7IHx4fCB4ID4gMSB9LmVtcHR5PwphcnIuc2VsZWN0IHsgfHh8IHggPiAxIH0ubm9uZT8KCiMgZ29vZAphcnIubm9uZT8geyB8eHwgeCA+IDEgfQoKIyBnb29kCnJlbGF0aW9uLnNlbGVjdCg6bmFtZSkuYW55PwphcnIuc2VsZWN0IHsgfHh8IHggPiAxIH0uYW55PygmOm9kZD8pCi0tLS0KCj09PT0gQWxsQ29wczpBY3RpdmVTdXBwb3J0RXh0ZW5zaW9uc0VuYWJsZWQ6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAphcnIuc2VsZWN0IHsgfHh8IHggPiAxIH0ubWFueT8KCiMgZ29vZAphcnIuc2VsZWN0IHsgfHh8IHggPiAxIH0ucHJlc2VudD8KLS0tLQoKPT09PSBBbGxDb3BzOkFjdGl2ZVN1cHBvcnRFeHRlbnNpb25zRW5hYmxlZDogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFyci5zZWxlY3QgeyB8eHwgeCA+IDEgfS5tYW55PwoKIyBnb29kCmFyci5tYW55PyB7IHx4fCB4ID4gMSB9CgojIGJhZAphcnIuc2VsZWN0IHsgfHh8IHggPiAxIH0ucHJlc2VudD8KCiMgZ29vZAphcnIuYW55PyB7IHx4fCB4ID4gMSB9Ci0tLS0KCj09IFN0eWxlL1JlZHVuZGFudEZyZWV6ZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzQKfCAwLjY2Cnw9PT0KCkNoZWNrIGZvciB1c2VzIG9mIGBPYmplY3QjZnJlZXplYCBvbiBpbW11dGFibGUgb2JqZWN0cy4KCk5PVEU6IFJlZ2V4cCBhbmQgUmFuZ2UgbGl0ZXJhbHMgYXJlIGZyb3plbiBvYmplY3RzIHNpbmNlIFJ1YnkgMy4wLgoKTk9URTogRnJvbSBSdWJ5IDMuMCwgdGhpcyBjb3AgYWxsb3dzIGV4cGxpY2l0IGZyZWV6aW5nIG9mIGludGVycG9sYXRlZApzdHJpbmcgbGl0ZXJhbHMgd2hlbiBgIyBmcm96ZW4tc3RyaW5nLWxpdGVyYWw6IHRydWVgIGlzIHVzZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApDT05TVCA9IDEuZnJlZXplCgojIGdvb2QKQ09OU1QgPSAxCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudEhlcmVkb2NEZWxpbWl0ZXJRdW90ZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjQ1CnwgLQp8PT09CgpDaGVja3MgZm9yIHJlZHVuZGFudCBoZXJlZG9jIGRlbGltaXRlciBxdW90ZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkb19zb21ldGhpbmcoPDx+J0VPUycpCiAgbm8gc3RyaW5nIGludGVycG9sYXRpb24gc3R5bGUgdGV4dApFT1MKCiMgZ29vZApkb19zb21ldGhpbmcoPDx+RU9TKQogIG5vIHN0cmluZyBpbnRlcnBvbGF0aW9uIHN0eWxlIHRleHQKRU9TCgpkb19zb21ldGhpbmcoPDx+J0VPUycpCiAgI3tzdHJpbmdfaW50ZXJwb2xhdGlvbl9zdHlsZV90ZXh0X25vdF9ldmFsdWF0ZWR9CkVPUwoKZG9fc29tZXRoaW5nKDw8fidFT1MnKQogIFByZXNlcnZlIFwKICBuZXdsaW5lcwpFT1MKLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50SW5pdGlhbGl6ZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQ29tbWFuZC1saW5lIG9ubHkgKFVuc2FmZSkKfCAxLjI3CnwgMS42MQp8PT09CgpDaGVja3MgZm9yIGBpbml0aWFsaXplYCBtZXRob2RzIHRoYXQgYXJlIHJlZHVuZGFudC4KCkFuIGluaXRpYWxpemVyIGlzIHJlZHVuZGFudCBpZiBpdCBkb2VzIG5vdCBkbyBhbnl0aGluZywgb3IgaWYgaXQgb25seQpjYWxscyBgc3VwZXJgIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGdpdmVuIHRvIGl0LiBJZiB0aGUgaW5pdGlhbGl6ZXIgdGFrZXMKYW4gYXJndW1lbnQgdGhhdCBhY2NlcHRzIG11bHRpcGxlIHZhbHVlcyAoYHJlc3RhcmdgLCBga3dyZXN0YXJnYCwgZXRjLikgaXQKd2lsbCBub3QgcmVnaXN0ZXIgYW4gb2ZmZW5zZSwgYmVjYXVzZSBpdCBhbGxvd3MgdGhlIGluaXRpYWxpemVyIHRvIHRha2UgYSBkaWZmZXJlbnQKbnVtYmVyIG9mIGFyZ3VtZW50cyBhcyBpdHMgc3VwZXJjbGFzcyBwb3RlbnRpYWxseSBkb2VzLgoKTk9URTogSWYgYW4gaW5pdGlhbGl6ZXIgYXJndW1lbnQgaGFzIGEgZGVmYXVsdCB2YWx1ZSwgUnVib0NvcCBhc3N1bWVzIGl0CnRvICpub3QqIGJlIHJlZHVuZGFudC4KCk5PVEU6IEVtcHR5IGluaXRpYWxpemVycyBhcmUgcmVnaXN0ZXJlZCBhcyBvZmZlbnNlcywgYnV0IGl0IGlzIHBvc3NpYmxlCnRvIHB1cnBvc2VseSBjcmVhdGUgYW4gZW1wdHkgYGluaXRpYWxpemVgIG1ldGhvZCB0byBvdmVycmlkZSBhIHN1cGVyY2xhc3Mncwppbml0aWFsaXplci4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGlmIHN1YmNsYXNzIG92ZXJyaWRlcyBgaW5pdGlhbGl6ZWAgbWV0aG9kIHdpdGgKYSBkaWZmZXJlbnQgYXJpdHkgdGhhbiBzdXBlcmNsYXNzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGluaXRpYWxpemUKZW5kCgojIGJhZApkZWYgaW5pdGlhbGl6ZQogIHN1cGVyCmVuZAoKIyBiYWQKZGVmIGluaXRpYWxpemUoYSwgYikKICBzdXBlcgplbmQKCiMgYmFkCmRlZiBpbml0aWFsaXplKGEsIGIpCiAgc3VwZXIoYSwgYikKZW5kCgojIGdvb2QKZGVmIGluaXRpYWxpemUKICBkb19zb21ldGhpbmcKZW5kCgojIGdvb2QKZGVmIGluaXRpYWxpemUKICBkb19zb21ldGhpbmcKICBzdXBlcgplbmQKCiMgZ29vZCAoZGlmZmVyZW50IG51bWJlciBvZiBwYXJhbWV0ZXJzKQpkZWYgaW5pdGlhbGl6ZShhLCBiKQogIHN1cGVyKGEpCmVuZAoKIyBnb29kIChkZWZhdWx0IHZhbHVlKQpkZWYgaW5pdGlhbGl6ZShhLCBiID0gNSkKICBzdXBlcgplbmQKCiMgZ29vZCAoZGVmYXVsdCB2YWx1ZSkKZGVmIGluaXRpYWxpemUoYSwgYjogNSkKICBzdXBlcgplbmQKCiMgZ29vZCAoY2hhbmdlcyB0aGUgcGFyYW1ldGVyIHJlcXVpcmVtZW50cykKZGVmIGluaXRpYWxpemUoKikKZW5kCgojIGdvb2QgKGNoYW5nZXMgdGhlIHBhcmFtZXRlciByZXF1aXJlbWVudHMpCmRlZiBpbml0aWFsaXplKCoqKQplbmQKCiMgZ29vZCAoY2hhbmdlcyB0aGUgcGFyYW1ldGVyIHJlcXVpcmVtZW50cykKZGVmIGluaXRpYWxpemUoLi4uKQplbmQKLS0tLQoKPT09PSBBbGxvd0NvbW1lbnRzOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgaW5pdGlhbGl6ZQogICMgT3ZlcnJpZGluZyB0byBuZWdhdGUgc3VwZXJjbGFzcyBgaW5pdGlhbGl6ZWAgbWV0aG9kLgplbmQKLS0tLQoKPT09PSBBbGxvd0NvbW1lbnRzOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBpbml0aWFsaXplCiAgIyBPdmVycmlkaW5nIHRvIG5lZ2F0ZSBzdXBlcmNsYXNzIGBpbml0aWFsaXplYCBtZXRob2QuCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dDb21tZW50cwp8IGB0cnVlYAp8IEJvb2xlYW4KfD09PQoKPT0gU3R5bGUvUmVkdW5kYW50SW50ZXJwb2xhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNzYKfCAxLjMwCnw9PT0KCkNoZWNrcyBmb3Igc3RyaW5ncyB0aGF0IGFyZSBqdXN0IGFuIGludGVycG9sYXRlZCBleHByZXNzaW9uLgoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2Ugd2hlbiBjYWxsaW5nIGEgZGVzdHJ1Y3RpdmUgbWV0aG9kIHRvIHN0cmluZywKdGhlIHJlc3VsdGluZyBzdHJpbmcgbWF5IGhhdmUgZGlmZmVyZW50IGJlaGF2aW9yIG9yIHJhaXNlIGBGcm96ZW5FcnJvcmAuCgpbc291cmNlLHJ1YnldCi0tLS0KeCA9ICdhJwp5ID0gIiN7eH0iCnkgPDwgJ2InICAgIyByZXR1cm4gJ2FiJwp4ICAgICAgICAgICMgcmV0dXJuICdhJwp5ID0geC50b19zCnkgPDwgJ2InICAgIyByZXR1cm4gJ2FiJwp4ICAgICAgICAgICMgcmV0dXJuICdhYicKCnggPSAnYScuZnJlZXplCnkgPSAiI3t4fSIKeSA8PCAnYicgICAjIHJldHVybiAnYWInLgp5ID0geC50b19zCnkgPDwgJ2InICAgIyByYWlzZSBgRnJvemVuRXJyb3JgLgotLS0tCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAoiI3tAdmFyfSIKCiMgZ29vZApAdmFyLnRvX3MKCiMgZ29vZCBpZiBAdmFyIGlzIGFscmVhZHkgYSBTdHJpbmcKQHZhcgotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRMaW5lQ29udGludWF0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS40OQp8IC0KfD09PQoKQ2hlY2sgZm9yIHJlZHVuZGFudCBsaW5lIGNvbnRpbnVhdGlvbi4KClRoaXMgY29wIG1hcmtzIGEgbGluZSBjb250aW51YXRpb24gYXMgcmVkdW5kYW50IGlmIHJlbW92aW5nIHRoZSBiYWNrc2xhc2gKZG9lcyBub3QgcmVzdWx0IGluIGEgc3ludGF4IGVycm9yLgpIb3dldmVyLCBhIGJhY2tzbGFzaCBhdCB0aGUgZW5kIG9mIGEgY29tbWVudCBvcgpmb3Igc3RyaW5nIGNvbmNhdGVuYXRpb24gaXMgbm90IHJlZHVuZGFudCBhbmQgaXMgbm90IGNvbnNpZGVyZWQgYW4gb2ZmZW5zZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby4gXAogIGJhcgpmb28gXAogICYuYmFyIFwKICAgIC5iYXoKCiMgZ29vZApmb28uCiAgYmFyCmZvbwogICYuYmFyCiAgICAuYmF6CgojIGJhZApbZm9vLCBcCiAgYmFyXQp7Zm9vOiBcCiAgYmFyfQoKIyBnb29kCltmb28sCiAgYmFyXQp7Zm9vOgogIGJhcn0KCiMgYmFkCmZvbyhiYXIsIFwKICBiYXopCgojIGdvb2QKZm9vKGJhciwKICBiYXopCgojIGFsc28gZ29vZCAtIGJhY2tzbGFzaCBpbiBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpcyBub3QgcmVkdW5kYW50CmZvbygnYmFyJyBcCiAgJ2JheicpCgojIGFsc28gZ29vZCAtIGJhY2tzbGFzaCBhdCB0aGUgZW5kIG9mIGEgY29tbWVudCBpcyBub3QgcmVkdW5kYW50CmZvbyhiYXIsICMgXAogIGJheikKCiMgYWxzbyBnb29kIC0gYmFja3NsYXNoIGF0IHRoZSBsaW5lIGZvbGxvd2luZyB0aGUgbmV3bGluZSBiZWdpbnMgd2l0aCBhICsgb3IgLSwKIyBpdCBpcyBub3QgcmVkdW5kYW50CjEgXAogICsgMiBcCiAgICAtIDMKCiMgYWxzbyBnb29kIC0gYmFja3NsYXNoIHdpdGggbmV3bGluZSBiZXR3ZWVuIHRoZSBtZXRob2QgbmFtZSBhbmQgaXRzIGFyZ3VtZW50cywKIyBpdCBpcyBub3QgcmVkdW5kYW50Lgpzb21lX21ldGhvZCBcCiAgKGFyZ3VtZW50KQotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRQYXJlbnRoZXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzYKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcmVkdW5kYW50IHBhcmVudGhlc2VzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKKHgpIGlmICgoeS56KS5uaWw/KQoKIyBnb29kCnggaWYgeS56Lm5pbD8KLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50UGVyY2VudFEKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjc2CnwgLQp8PT09CgpDaGVja3MgZm9yIHVzYWdlIG9mIHRoZSAlcS8lUSBzeW50YXggd2hlbiAnJyBvciAiIiB3b3VsZCBkby4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm5hbWUgPSAlcShCcnVjZSBXYXluZSkKdGltZSA9ICVxKDggbydjbG9jaykKcXVlc3Rpb24gPSAlcSgiV2hhdCBkaWQgeW91IHNheT8iKQoKIyBnb29kCm5hbWUgPSAnQnJ1Y2UgV2F5bmUnCnRpbWUgPSAiOCBvJ2Nsb2NrIgpxdWVzdGlvbiA9ICciV2hhdCBkaWQgeW91IHNheT8iJwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNwZXJjZW50LXEKCj09IFN0eWxlL1JlZHVuZGFudFJlZ2V4cEFyZ3VtZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS41Mwp8IC0KfD09PQoKSWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYXJndW1lbnQgY2FuIGJlIHJlcGxhY2VkIGZyb20KYSBkZXRlcm1pbmlzdGljIHJlZ2V4cCB0byBhIHN0cmluZy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCidmb28nLmJ5dGVpbmRleCgvZi8pCidmb28nLmJ5dGVyaW5kZXgoL2YvKQonZm9vJy5nc3ViKC9mLywgJ3gnKQonZm9vJy5nc3ViISgvZi8sICd4JykKJ2ZvbycucGFydGl0aW9uKC9mLykKJ2ZvbycucnBhcnRpdGlvbigvZi8pCidmb28nLnNjYW4oL2YvKQonZm9vJy5zcGxpdCgvZi8pCidmb28nLnN0YXJ0X3dpdGg/KC9mLykKJ2Zvbycuc3ViKC9mLywgJ3gnKQonZm9vJy5zdWIhKC9mLywgJ3gnKQoKIyBnb29kCidmb28nLmJ5dGVpbmRleCgnZicpCidmb28nLmJ5dGVyaW5kZXgoJ2YnKQonZm9vJy5nc3ViKCdmJywgJ3gnKQonZm9vJy5nc3ViISgnZicsICd4JykKJ2ZvbycucGFydGl0aW9uKCdmJykKJ2ZvbycucnBhcnRpdGlvbignZicpCidmb28nLnNjYW4oJ2YnKQonZm9vJy5zcGxpdCgnZicpCidmb28nLnN0YXJ0X3dpdGg/KCdmJykKJ2Zvbycuc3ViKCdmJywgJ3gnKQonZm9vJy5zdWIhKCdmJywgJ3gnKQotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRSZWdleHBDaGFyYWN0ZXJDbGFzcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuODUKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdW5uZWNlc3Nhcnkgc2luZ2xlLWVsZW1lbnQgUmVnZXhwIGNoYXJhY3RlciBjbGFzc2VzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKciA9IC9beF0vCgojIGdvb2QKciA9IC94LwoKIyBiYWQKciA9IC9bXHNdLwoKIyBnb29kCnIgPSAvXHMvCgojIGJhZApyID0gJXJ7L1tiXX0KCiMgZ29vZApyID0gJXJ7L2J9CgojIGdvb2QKciA9IC9bYWJdLwotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRSZWdleHBDb25zdHJ1Y3RvcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuNTIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdGhlIGluc3RhbnRpYXRpb24gb2YgcmVnZXhwIHVzaW5nIHJlZHVuZGFudCBgUmVnZXhwLm5ld2Agb3IgYFJlZ2V4cC5jb21waWxlYC4KQXV0b2NvcnJlY3QgcmVwbGFjZXMgdG8gcmVnZXhwIGxpdGVyYWwgd2hpY2ggaXMgdGhlIHNpbXBsZXN0IGFuZCBmYXN0ZXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKUmVnZXhwLm5ldygvcmVnZXhwLykKUmVnZXhwLmNvbXBpbGUoL3JlZ2V4cC8pCgojIGdvb2QKL3JlZ2V4cC8KUmVnZXhwLm5ldygncmVnZXhwJykKUmVnZXhwLmNvbXBpbGUoJ3JlZ2V4cCcpCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudFJlZ2V4cEVzY2FwZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuODUKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcmVkdW5kYW50IGVzY2FwZXMgaW5zaWRlIFJlZ2V4cCBsaXRlcmFscy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiVye2Zvb1wvYmFyfQoKIyBnb29kCiVye2Zvby9iYXJ9CgojIGdvb2QKL2Zvb1wvYmFyLwoKIyBnb29kCiVyL2Zvb1wvYmFyLwoKIyBnb29kCiVyIWZvb1whYmFyIQoKIyBiYWQKL2FcLWIvCgojIGdvb2QKL2EtYi8KCiMgYmFkCi9bXCtcLV1cZC8KCiMgZ29vZAovWytcLV1cZC8KLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50UmV0dXJuCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xMAp8IDAuMTQKfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgYHJldHVybmAgZXhwcmVzc2lvbnMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIFRoZXNlIGJhZCBjYXNlcyBzaG91bGQgYmUgZXh0ZW5kZWQgdG8gaGFuZGxlIG1ldGhvZHMgd2hvc2UgYm9keSBpcwojIGlmL2Vsc2Ugb3IgYSBjYXNlIGV4cHJlc3Npb24gd2l0aCBhIGRlZmF1bHQgYnJhbmNoLgoKIyBiYWQKZGVmIHRlc3QKICByZXR1cm4gc29tZXRoaW5nCmVuZAoKIyBiYWQKZGVmIHRlc3QKICBvbmUKICB0d28KICB0aHJlZQogIHJldHVybiBzb21ldGhpbmcKZW5kCgojIGJhZApkZWYgdGVzdAogIHJldHVybiBzb21ldGhpbmcgaWYgc29tZXRoaW5nX2Vsc2UKZW5kCgojIGdvb2QKZGVmIHRlc3QKICBzb21ldGhpbmcgaWYgc29tZXRoaW5nX2Vsc2UKZW5kCgojIGdvb2QKZGVmIHRlc3QKICBpZiB4CiAgZWxzaWYgeQogIGVsc2UKICBlbmQKZW5kCi0tLS0KCj09PT0gQWxsb3dNdWx0aXBsZVJldHVyblZhbHVlczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHRlc3QKICByZXR1cm4geCwgeQplbmQKLS0tLQoKPT09PSBBbGxvd011bHRpcGxlUmV0dXJuVmFsdWVzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiB0ZXN0CiAgcmV0dXJuIHgsIHkKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd011bHRpcGxlUmV0dXJuVmFsdWVzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tZXhwbGljaXQtcmV0dXJuCgo9PSBTdHlsZS9SZWR1bmRhbnRTZWxmCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xMAp8IDAuMTMKfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgdXNlcyBvZiBgc2VsZmAuCgpUaGUgdXNhZ2Ugb2YgYHNlbGZgIGlzIG9ubHkgbmVlZGVkIHdoZW46CgoqIFNlbmRpbmcgYSBtZXNzYWdlIHRvIHNhbWUgb2JqZWN0IHdpdGggemVybyBhcmd1bWVudHMgaW4KICBwcmVzZW5jZSBvZiBhIG1ldGhvZCBuYW1lIGNsYXNoIHdpdGggYW4gYXJndW1lbnQgb3IgYSBsb2NhbAogIHZhcmlhYmxlLgoKKiBDYWxsaW5nIGFuIGF0dHJpYnV0ZSB3cml0ZXIgdG8gcHJldmVudCBhIGxvY2FsIHZhcmlhYmxlIGFzc2lnbm1lbnQuCgpOb3RlLCB3aXRoIHVzaW5nIGV4cGxpY2l0IHNlbGYgeW91IGNhbiBvbmx5IHNlbmQgbWVzc2FnZXMgd2l0aCBwdWJsaWMgb3IKcHJvdGVjdGVkIHNjb3BlLCB5b3UgY2Fubm90IHNlbmQgcHJpdmF0ZSBtZXNzYWdlcyB0aGlzIHdheS4KCk5vdGUgd2UgYWxsb3cgdXNlcyBvZiBgc2VsZmAgd2l0aCBvcGVyYXRvcnMgYmVjYXVzZSBpdCB3b3VsZCBiZSBhd2t3YXJkCm90aGVyd2lzZS4gQWxzbyBhbGxvd3MgdGhlIHVzZSBvZiBgc2VsZi5pdGAgd2l0aG91dCBhcmd1bWVudHMgaW4gYmxvY2tzLAphcyBpbiBgMC50aW1lcyB7IHNlbGYuaXQgfWAsIGZvbGxvd2luZyBgTGludC9JdFdpdGhvdXRBcmd1bWVudHNJbkJsb2NrYCBjb3AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vKGJhcikKICBzZWxmLmJhegplbmQKCiMgZ29vZApkZWYgZm9vKGJhcikKICBzZWxmLmJhciAgIyBSZXNvbHZlcyBuYW1lIGNsYXNoIHdpdGggdGhlIGFyZ3VtZW50LgplbmQKCmRlZiBmb28KICBiYXIgPSAxCiAgc2VsZi5iYXIgICMgUmVzb2x2ZXMgbmFtZSBjbGFzaCB3aXRoIHRoZSBsb2NhbCB2YXJpYWJsZS4KZW5kCgpkZWYgZm9vCiAgJXdbeCB5IHpdLnNlbGVjdCBkbyB8YmFyfAogICAgc2VsZi5iYXIgPT0gYmFyICAjIFJlc29sdmVzIG5hbWUgY2xhc2ggd2l0aCBhcmd1bWVudCBvZiB0aGUgYmxvY2suCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1zZWxmLXVubGVzcy1yZXF1aXJlZAoKPT0gU3R5bGUvUmVkdW5kYW50U2VsZkFzc2lnbm1lbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuOTAKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIHJlZHVuZGFudCBhc3NpZ25tZW50cyBhcmUgbWFkZSBmb3IgaW4gcGxhY2UKbW9kaWZpY2F0aW9uIG1ldGhvZHMuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUsIGJlY2F1c2UgaXQgY2FuIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIGZvcgp1c2VyIGRlZmluZWQgbWV0aG9kcyBoYXZpbmcgb25lIG9mIHRoZSBleHBlY3RlZCBuYW1lcywgYnV0IG5vdCBtb2RpZnlpbmcKaXRzIHJlY2VpdmVyIGluIHBsYWNlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXJncyA9IGFyZ3MuY29uY2F0KGFyeSkKaGFzaCA9IGhhc2gubWVyZ2UhKG90aGVyKQoKIyBnb29kCmFyZ3MuY29uY2F0KGZvbykKYXJncyArPSBmb28KaGFzaC5tZXJnZSEob3RoZXIpCgojIGJhZApzZWxmLmZvbyA9IGZvby5jb25jYXQoYXJ5KQoKIyBnb29kCmZvby5jb25jYXQoYXJ5KQpzZWxmLmZvbyArPSBhcnkKLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50U2VsZkFzc2lnbm1lbnRCcmFuY2gKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjE5CnwgLQp8PT09CgpDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBjb25kaXRpb25hbCBicmFuY2ggbWFrZXMgcmVkdW5kYW50IHNlbGYtYXNzaWdubWVudC4KCkl0IG9ubHkgZGV0ZWN0cyBsb2NhbCB2YXJpYWJsZSBiZWNhdXNlIGl0IG1heSByZXBsYWNlIHN0YXRlIG9mIGluc3RhbmNlIHZhcmlhYmxlLApjbGFzcyB2YXJpYWJsZSwgYW5kIGdsb2JhbCB2YXJpYWJsZSB0aGF0IGhhdmUgc3RhdGUgYWNyb3NzIG1ldGhvZHMgd2l0aCBgbmlsYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvbyA9IGNvbmRpdGlvbiA/IGJhciA6IGZvbwoKIyBnb29kCmZvbyA9IGJhciBpZiBjb25kaXRpb24KCiMgYmFkCmZvbyA9IGNvbmRpdGlvbiA/IGZvbyA6IGJhcgoKIyBnb29kCmZvbyA9IGJhciB1bmxlc3MgY29uZGl0aW9uCi0tLS0KCj09IFN0eWxlL1JlZHVuZGFudFNvcnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNzYKfCAxLjIyCnw9PT0KCklkZW50aWZpZXMgaW5zdGFuY2VzIG9mIHNvcnRpbmcgYW5kIHRoZW4KdGFraW5nIG9ubHkgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudC4gVGhlIHNhbWUgYmVoYXZpb3IgY2FuCmJlIGFjY29tcGxpc2hlZCB3aXRob3V0IGEgcmVsYXRpdmVseSBleHBlbnNpdmUgc29ydCBieSB1c2luZwpgRW51bWVyYWJsZSNtaW5gIGluc3RlYWQgb2Ygc29ydGluZyBhbmQgdGFraW5nIHRoZSBmaXJzdAplbGVtZW50IGFuZCBgRW51bWVyYWJsZSNtYXhgIGluc3RlYWQgb2Ygc29ydGluZyBhbmQgdGFraW5nIHRoZQpsYXN0IGVsZW1lbnQuIFNpbWlsYXJseSwgYEVudW1lcmFibGUjbWluX2J5YCBhbmQKYEVudW1lcmFibGUjbWF4X2J5YCBjYW4gcmVwbGFjZSBgRW51bWVyYWJsZSNzb3J0X2J5YCBjYWxscwphZnRlciB3aGljaCBvbmx5IHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgaXMgdXNlZC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSwgYmVjYXVzZSBgc29ydC4uLmxhc3RgIGFuZCBgbWF4YCBtYXkgbm90IHJldHVybiB0aGUKc2FtZSBlbGVtZW50IGluIGFsbCBjYXNlcy4KCkluIGFuIGVudW1lcmFibGUgd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIGVsZW1lbnRzIHdoZXJlIGBgYSA8PT4gYiA9PSAwYGAsCm9yIHdoZXJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBkb25lIGJ5IHRoZSBgc29ydF9ieWAgYmxvY2sgaGFzIHRoZQpzYW1lIHJlc3VsdCwgYHNvcnQubGFzdGAgYW5kIGBtYXhgIChvciBgc29ydF9ieS5sYXN0YCBhbmQgYG1heF9ieWApCndpbGwgcmV0dXJuIGRpZmZlcmVudCBlbGVtZW50cy4gYHNvcnQubGFzdGAgd2lsbCByZXR1cm4gdGhlIGxhc3QKZWxlbWVudCBidXQgYG1heGAgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGVsZW1lbnQuCgpGb3IgZXhhbXBsZToKCltzb3VyY2UscnVieV0KLS0tLQogIGNsYXNzIE15U3RyaW5nIDwgU3RyaW5nOyBlbmQKICBzdHJpbmdzID0gW015U3RyaW5nLm5ldygndGVzdCcpLCAndGVzdCddCiAgc3RyaW5ncy5zb3J0Lmxhc3QuY2xhc3MgICAjPT4gU3RyaW5nCiAgc3RyaW5ncy5tYXguY2xhc3MgICAgICAgICAjPT4gTXlTdHJpbmcKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiAgd29yZHMgPSAldyhkb2cgaG9yc2UgbW91c2UpCiAgd29yZHMuc29ydF9ieSB7IHx3b3JkfCB3b3JkLmxlbmd0aCB9Lmxhc3QgICAjPT4gJ21vdXNlJwogIHdvcmRzLm1heF9ieSB7IHx3b3JkfCB3b3JkLmxlbmd0aCB9ICAgICAgICAgIz0+ICdob3JzZScKLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKWzIsIDEsIDNdLnNvcnQuZmlyc3QKWzIsIDEsIDNdLnNvcnRbMF0KWzIsIDEsIDNdLnNvcnQuYXQoMCkKWzIsIDEsIDNdLnNvcnQuc2xpY2UoMCkKCiMgZ29vZApbMiwgMSwgM10ubWluCgojIGJhZApbMiwgMSwgM10uc29ydC5sYXN0ClsyLCAxLCAzXS5zb3J0Wy0xXQpbMiwgMSwgM10uc29ydC5hdCgtMSkKWzIsIDEsIDNdLnNvcnQuc2xpY2UoLTEpCgojIGdvb2QKWzIsIDEsIDNdLm1heAoKIyBiYWQKYXJyLnNvcnRfYnkoJjpmb28pLmZpcnN0CmFyci5zb3J0X2J5KCY6Zm9vKVswXQphcnIuc29ydF9ieSgmOmZvbykuYXQoMCkKYXJyLnNvcnRfYnkoJjpmb28pLnNsaWNlKDApCgojIGdvb2QKYXJyLm1pbl9ieSgmOmZvbykKCiMgYmFkCmFyci5zb3J0X2J5KCY6Zm9vKS5sYXN0CmFyci5zb3J0X2J5KCY6Zm9vKVstMV0KYXJyLnNvcnRfYnkoJjpmb28pLmF0KC0xKQphcnIuc29ydF9ieSgmOmZvbykuc2xpY2UoLTEpCgojIGdvb2QKYXJyLm1heF9ieSgmOmZvbykKLS0tLQoKPT0gU3R5bGUvUmVkdW5kYW50U29ydEJ5Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zNgp8IC0KfD09PQoKSWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYHNvcnRfYnkgeyAuLi4gfWAgY2FuIGJlIHJlcGxhY2VkIGJ5CmBzb3J0YC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFycmF5LnNvcnRfYnkgeyB8eHwgeCB9CmFycmF5LnNvcnRfYnkgZG8gfHZhcnwKICB2YXIKZW5kCgojIGdvb2QKYXJyYXkuc29ydAotLS0tCgo9PSBTdHlsZS9SZWR1bmRhbnRTdHJpbmdFc2NhcGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjM3CnwgLQp8PT09CgpDaGVja3MgZm9yIHJlZHVuZGFudCBlc2NhcGVzIGluIHN0cmluZyBsaXRlcmFscy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gbm8gbmVlZCB0byBlc2NhcGUgIyB3aXRob3V0IGZvbGxvd2luZyB7LyQvQAoiXCNmb28iCgojIGJhZCAtIG5vIG5lZWQgdG8gZXNjYXBlIHNpbmdsZSBxdW90ZXMgaW5zaWRlIGRvdWJsZSBxdW90ZWQgc3RyaW5nCiJcJ2Zvb1wnIgoKIyBiYWQgLSBoZXJlZG9jcyBhcmUgYWxzbyBjaGVja2VkIGZvciB1bm5lY2Vzc2FyeSBlc2NhcGVzCjw8flNUUgogIFwjZm9vIFwiZm9vXCIKU1RSCgojIGdvb2QKIiNmb28iCgojIGdvb2QKIlwje25vX2ludGVycG9sYXRpb259IgoKIyBnb29kCiInZm9vJyIKCiMgZ29vZAoiZm9vXApiYXIiCgojIGdvb2QKPDx+U1RSCiAgI2ZvbyAiZm9vIgpTVFIKLS0tLQoKPT0gU3R5bGUvUmVnZXhwTGl0ZXJhbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDAuMzAKfD09PQoKRW5mb3JjZXMgdXNpbmcgYC8vYCBvciBgJXJgIGFyb3VuZCByZWd1bGFyIGV4cHJlc3Npb25zLgoKTk9URTogVGhlIGZvbGxvd2luZyBgJXJgIGNhc2VzIHVzaW5nIGEgcmVnZXhwIHN0YXJ0cyB3aXRoIGEgYmxhbmsgb3IgYD1gCmFzIGEgbWV0aG9kIGFyZ3VtZW50IGFsbG93ZWQgdG8gcHJldmVudCBzeW50YXggZXJyb3JzLgoKW3NvdXJjZSxydWJ5XQotLS0tCmRvX3NvbWV0aGluZyAlcnsgcmVnZXhwfSAjIGBkb19zb21ldGhpbmcgLyByZWdleHAvYCBpcyBhbiBpbnZhbGlkIHN5bnRheC4KZG9fc29tZXRoaW5nICVyez1yZWdleHB9ICMgYGRvX3NvbWV0aGluZyAvPXJlZ2V4cC9gIGlzIGFuIGludmFsaWQgc3ludGF4LgotLS0tCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2xhc2hlcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzbmFrZV9jYXNlID0gJXJ7XltcZEEtWl9dKyR9CgojIGJhZApyZWdleCA9ICVyewogIGZvbwogIChiYXIpCiAgKGJheikKfXgKCiMgZ29vZApzbmFrZV9jYXNlID0gL15bXGRBLVpfXSskLwoKIyBnb29kCnJlZ2V4ID0gLwogIGZvbwogIChiYXIpCiAgKGJheikKL3gKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBwZXJjZW50X3IKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzbmFrZV9jYXNlID0gL15bXGRBLVpfXSskLwoKIyBiYWQKcmVnZXggPSAvCiAgZm9vCiAgKGJhcikKICAoYmF6KQoveAoKIyBnb29kCnNuYWtlX2Nhc2UgPSAlcnteW1xkQS1aX10rJH0KCiMgZ29vZApyZWdleCA9ICVyewogIGZvbwogIChiYXIpCiAgKGJheikKfXgKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBtaXhlZAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnNuYWtlX2Nhc2UgPSAlcnteW1xkQS1aX10rJH0KCiMgYmFkCnJlZ2V4ID0gLwogIGZvbwogIChiYXIpCiAgKGJheikKL3gKCiMgZ29vZApzbmFrZV9jYXNlID0gL15bXGRBLVpfXSskLwoKIyBnb29kCnJlZ2V4ID0gJXJ7CiAgZm9vCiAgKGJhcikKICAoYmF6KQp9eAotLS0tCgo9PT09IEFsbG93SW5uZXJTbGFzaGVzOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIElmIGBmYWxzZWAsIHRoZSBjb3Agd2lsbCBhbHdheXMgcmVjb21tZW5kIHVzaW5nIGAlcmAgaWYgb25lIG9yIG1vcmUKIyBzbGFzaGVzIGFyZSBmb3VuZCBpbiB0aGUgcmVnZXhwIHN0cmluZy4KCiMgYmFkCnggPX4gL2hvbWVcLy8KCiMgZ29vZAp4ID1+ICVye2hvbWUvfQotLS0tCgo9PT09IEFsbG93SW5uZXJTbGFzaGVzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCnggPX4gL2hvbWVcLy8KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2xhc2hlc2AKfCBgc2xhc2hlc2AsIGBwZXJjZW50X3JgLCBgbWl4ZWRgCgp8IEFsbG93SW5uZXJTbGFzaGVzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjcGVyY2VudC1yCgo9PSBTdHlsZS9SZXF1aXJlT3JkZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMS40MAp8IC0KfD09PQoKU29ydCBgcmVxdWlyZWAgYW5kIGByZXF1aXJlX3JlbGF0aXZlYCBpbiBhbHBoYWJldGljYWwgb3JkZXIuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0IHdpbGwgb2J2aW91c2x5IGNoYW5nZSB0aGUgZXhlY3V0aW9uIG9yZGVyLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVxdWlyZSAnYicKcmVxdWlyZSAnYScKCiMgZ29vZApyZXF1aXJlICdhJwpyZXF1aXJlICdiJwoKIyBiYWQKcmVxdWlyZV9yZWxhdGl2ZSAnYicKcmVxdWlyZV9yZWxhdGl2ZSAnYScKCiMgZ29vZApyZXF1aXJlX3JlbGF0aXZlICdhJwpyZXF1aXJlX3JlbGF0aXZlICdiJwoKIyBnb29kIChzb3J0ZWQgd2l0aGluIGVhY2ggc2VjdGlvbiBzZXBhcmF0ZWQgYnkgYSBibGFuayBsaW5lKQpyZXF1aXJlICdhJwpyZXF1aXJlICdkJwoKcmVxdWlyZSAnYicKcmVxdWlyZSAnYycKCiMgZ29vZApyZXF1aXJlICdiJwpyZXF1aXJlX3JlbGF0aXZlICdjJwpyZXF1aXJlICdhJwoKIyBiYWQKcmVxdWlyZSAnYScKcmVxdWlyZSAnYycgaWYgZm9vCnJlcXVpcmUgJ2InCgojIGdvb2QKcmVxdWlyZSAnYScKcmVxdWlyZSAnYicKcmVxdWlyZSAnYycgaWYgZm9vCgojIGJhZApyZXF1aXJlICdjJwppZiBmb28KICByZXF1aXJlICdkJwogIHJlcXVpcmUgJ2InCmVuZApyZXF1aXJlICdhJwoKIyBnb29kCnJlcXVpcmUgJ2MnCmlmIGZvbwogIHJlcXVpcmUgJ2InCiAgcmVxdWlyZSAnZCcKZW5kCnJlcXVpcmUgJ2EnCi0tLS0KCj09IFN0eWxlL1Jlc2N1ZU1vZGlmaWVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC4zNAp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgYHJlc2N1ZWAgaW4gaXRzIG1vZGlmaWVyIGZvcm0gaXMgYWRkZWQgZm9yIGZvbGxvd2luZwpyZWFzb25zOgoKKiBUaGUgc3ludGF4IG9mIG1vZGlmaWVyIGZvcm0gYHJlc2N1ZWAgY2FuIGJlIG1pc2xlYWRpbmcgYmVjYXVzZSBpdAogIG1pZ2h0IGxlYWQgdXMgdG8gYmVsaWV2ZSB0aGF0IGByZXNjdWVgIGhhbmRsZXMgdGhlIGdpdmVuIGV4Y2VwdGlvbgogIGJ1dCBpdCBhY3R1YWxseSByZXNjdWUgYWxsIGV4Y2VwdGlvbnMgdG8gcmV0dXJuIHRoZSBnaXZlbiByZXNjdWUKICBibG9jay4gSW4gdGhpcyBjYXNlLCB2YWx1ZSByZXR1cm5lZCBieSBoYW5kbGVfZXJyb3Igb3IKICBTb21lRXhjZXB0aW9uLgoKKiBNb2RpZmllciBmb3JtIGByZXNjdWVgIHdvdWxkIHJlc2N1ZSBhbGwgdGhlIGV4Y2VwdGlvbnMuIEl0IHdvdWxkCiAgc2lsZW50bHkgc2tpcCBhbGwgZXhjZXB0aW9uIG9yIGVycm9ycyBhbmQgaGFuZGxlIHRoZSBlcnJvci4KICBFeGFtcGxlOiBJZiBgTm9NZXRob2RFcnJvcmAgaXMgcmFpc2VkLCBtb2RpZmllciBmb3JtIHJlc2N1ZSB3b3VsZAogIGhhbmRsZSB0aGUgZXhjZXB0aW9uLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc29tZV9tZXRob2QgcmVzY3VlIGhhbmRsZV9lcnJvcgoKIyBiYWQKc29tZV9tZXRob2QgcmVzY3VlIFNvbWVFeGNlcHRpb24KCiMgZ29vZApiZWdpbgogIHNvbWVfbWV0aG9kCnJlc2N1ZQogIGhhbmRsZV9lcnJvcgplbmQKCiMgZ29vZApiZWdpbgogIHNvbWVfbWV0aG9kCnJlc2N1ZSBTb21lRXhjZXB0aW9uCiAgaGFuZGxlX2Vycm9yCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1yZXNjdWUtbW9kaWZpZXJzCgo9PSBTdHlsZS9SZXNjdWVTdGFuZGFyZEVycm9yCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciByZXNjdWluZyBgU3RhbmRhcmRFcnJvcmAuIFRoZXJlIGFyZSB0d28gc3VwcG9ydGVkCnN0eWxlcyBgaW1wbGljaXRgIGFuZCBgZXhwbGljaXRgLiBUaGlzIGNvcCB3aWxsIG5vdCByZWdpc3RlciBhbiBvZmZlbnNlCmlmIGFueSBlcnJvciBvdGhlciB0aGFuIGBTdGFuZGFyZEVycm9yYCBpcyBzcGVjaWZpZWQuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogZXhwbGljaXQgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBgZXhwbGljaXRgIHdpbGwgZW5mb3JjZSB1c2luZyBgcmVzY3VlIFN0YW5kYXJkRXJyb3JgCiMgaW5zdGVhZCBvZiBgcmVzY3VlYC4KCiMgYmFkCmJlZ2luCiAgZm9vCnJlc2N1ZQogIGJhcgplbmQKCiMgZ29vZApiZWdpbgogIGZvbwpyZXNjdWUgU3RhbmRhcmRFcnJvcgogIGJhcgplbmQKCiMgZ29vZApiZWdpbgogIGZvbwpyZXNjdWUgT3RoZXJFcnJvcgogIGJhcgplbmQKCiMgZ29vZApiZWdpbgogIGZvbwpyZXNjdWUgU3RhbmRhcmRFcnJvciwgU2VjdXJpdHlFcnJvcgogIGJhcgplbmQKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBpbXBsaWNpdAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYGltcGxpY2l0YCB3aWxsIGVuZm9yY2UgdXNpbmcgYHJlc2N1ZWAgaW5zdGVhZCBvZgojIGByZXNjdWUgU3RhbmRhcmRFcnJvcmAuCgojIGJhZApiZWdpbgogIGZvbwpyZXNjdWUgU3RhbmRhcmRFcnJvcgogIGJhcgplbmQKCiMgZ29vZApiZWdpbgogIGZvbwpyZXNjdWUKICBiYXIKZW5kCgojIGdvb2QKYmVnaW4KICBmb28KcmVzY3VlIE90aGVyRXJyb3IKICBiYXIKZW5kCgojIGdvb2QKYmVnaW4KICBmb28KcmVzY3VlIFN0YW5kYXJkRXJyb3IsIFNlY3VyaXR5RXJyb3IKICBiYXIKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGV4cGxpY2l0YAp8IGBpbXBsaWNpdGAsIGBleHBsaWNpdGAKfD09PQoKPT0gU3R5bGUvUmV0dXJuTmlsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTAKfCAtCnw9PT0KCkVuZm9yY2VzIGNvbnNpc3RlbmN5IGJldHdlZW4gYHJldHVybiBuaWxgIGFuZCBgcmV0dXJuYC4KClRoaXMgY29wIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuIEJlY2F1c2UgdGhlcmUgc2VlbXMgdG8gYmUgYSBwZXJjZWl2ZWQgc2VtYW50aWMgZGlmZmVyZW5jZQpiZXR3ZWVuIGByZXR1cm5gIGFuZCBgcmV0dXJuIG5pbGAuIFRoZSBmb3JtZXIgY2FuIGJlIHNlZW4gYXMganVzdCBoYWx0aW5nIGV2YWx1YXRpb24sCndoaWxlIHRoZSBsYXR0ZXIgbWlnaHQgYmUgdXNlZCB3aGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgb2Ygc3BlY2lmaWMgY29uY2Vybi4KClN1cHBvcnRlZCBzdHlsZXMgYXJlIGByZXR1cm5gIGFuZCBgcmV0dXJuX25pbGAuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogcmV0dXJuIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28oYXJnKQogIHJldHVybiBuaWwgaWYgYXJnCmVuZAoKIyBnb29kCmRlZiBmb28oYXJnKQogIHJldHVybiBpZiBhcmcKZW5kCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmV0dXJuX25pbAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28oYXJnKQogIHJldHVybiBpZiBhcmcKZW5kCgojIGdvb2QKZGVmIGZvbyhhcmcpCiAgcmV0dXJuIG5pbCBpZiBhcmcKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHJldHVybmAKfCBgcmV0dXJuYCwgYHJldHVybl9uaWxgCnw9PT0KCj09IFN0eWxlL1JldHVybk5pbEluUHJlZGljYXRlTWV0aG9kRGVmaW5pdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNTMKfCAtCnw9PT0KCkNoZWNrcyBpZiBgcmV0dXJuYCBvciBgcmV0dXJuIG5pbGAgaXMgdXNlZCBpbiBwcmVkaWNhdGUgbWV0aG9kIGRlZmluaXRpb25zLgoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgbWFya2VkIGFzIHVuc2FmZSBiZWNhdXNlIHRoZSBjaGFuZ2Ugb2YgdGhlIHJldHVybiB2YWx1ZQpmcm9tIGBuaWxgIHRvIGBmYWxzZWAgY291bGQgcG90ZW50aWFsbHkgbGVhZCB0byBpbmNvbXBhdGliaWxpdHkgaXNzdWVzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIGZvbz8KICByZXR1cm4gaWYgY29uZGl0aW9uCgogIGRvX3NvbWV0aGluZz8KZW5kCgojIGJhZApkZWYgZm9vPwogIHJldHVybiBuaWwgaWYgY29uZGl0aW9uCgogIGRvX3NvbWV0aGluZz8KZW5kCgojIGdvb2QKZGVmIGZvbz8KICByZXR1cm4gZmFsc2UgaWYgY29uZGl0aW9uCgogIGRvX3NvbWV0aGluZz8KZW5kCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFsnZm9vPyddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBmb28/CiAgcmV0dXJuIGlmIGNvbmRpdGlvbgoKICBkb19zb21ldGhpbmc/CmVuZAotLS0tCgo9PT09IEFsbG93ZWRQYXR0ZXJuczogWy9mb28vXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgZm9vPwogIHJldHVybiBpZiBjb25kaXRpb24KCiAgZG9fc29tZXRoaW5nPwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNib29sLW1ldGhvZHMtcW1hcmsKCj09IFN0eWxlL1NhZmVOYXZpZ2F0aW9uCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuMwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNDMKfCAxLjI3Cnw9PT0KClRyYW5zZm9ybXMgdXNhZ2VzIG9mIGEgbWV0aG9kIGNhbGwgc2FmZWd1YXJkZWQgYnkgYSBub24gYG5pbGAKY2hlY2sgZm9yIHRoZSB2YXJpYWJsZSB3aG9zZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIHRvCnNhZmUgbmF2aWdhdGlvbiAoYCYuYCkuIElmIHRoZXJlIGlzIGEgbWV0aG9kIGNoYWluLCBhbGwgb2YgdGhlIG1ldGhvZHMKaW4gdGhlIGNoYWluIG5lZWQgdG8gYmUgY2hlY2tlZCBmb3Igc2FmZXR5LCBhbmQgYWxsIG9mIHRoZSBtZXRob2RzIHdpbGwKbmVlZCB0byBiZSBjaGFuZ2VkIHRvIHVzZSBzYWZlIG5hdmlnYXRpb24uCgpUaGUgZGVmYXVsdCBmb3IgYENvbnZlcnRDb2RlVGhhdENhblN0YXJ0VG9SZXR1cm5OaWxgIGlzIGBmYWxzZWAuCldoZW4gY29uZmlndXJlZCB0byBgdHJ1ZWAsIHRoaXMgd2lsbApjaGVjayBmb3IgY29kZSBpbiB0aGUgZm9ybWF0IGAhZm9vLm5pbD8gJiYgZm9vLmJhcmAuIEFzIGl0IGlzIHdyaXR0ZW4sCnRoZSByZXR1cm4gb2YgdGhpcyBjb2RlIGlzIGxpbWl0ZWQgdG8gYGZhbHNlYCBhbmQgd2hhdGV2ZXIgdGhlIHJldHVybgpvZiB0aGUgbWV0aG9kIGlzLiBJZiB0aGlzIGlzIGNvbnZlcnRlZCB0byBzYWZlIG5hdmlnYXRpb24sCmBmb28mLmJhcmAgY2FuIHN0YXJ0IHJldHVybmluZyBgbmlsYCBhcyB3ZWxsIGFzIHdoYXQgdGhlIG1ldGhvZApyZXR1cm5zLgoKVGhlIGRlZmF1bHQgZm9yIGBNYXhDaGFpbkxlbmd0aGAgaXMgYDJgCldlIGhhdmUgbGltaXRlZCB0aGUgY29wIHRvIG5vdCByZWdpc3RlciBhbiBvZmZlbnNlIGZvciBtZXRob2QgY2hhaW5zCnRoYXQgZXhjZWVkIHRoaXMgb3B0aW9uIGlzIHNldC4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGlmIGEgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIHJlc3VsdGluZwpjb2RlIHdpbGwgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3Igb3IgcmFpc2UgYW4gZXJyb3IuCgpbc291cmNlLHJ1YnldCi0tLS0KeCA9IGZhbHNlCnggJiYgeC5mb28gICMgcmV0dXJuIGZhbHNlCngmLmZvbyAgICAgICMgcmFpc2VzIE5vTWV0aG9kRXJyb3IKLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vLmJhciBpZiBmb28KZm9vLmJhci5iYXogaWYgZm9vCmZvby5iYXIocGFyYW0xLCBwYXJhbTIpIGlmIGZvbwpmb28uYmFyIHsgfGV8IGUuc29tZXRoaW5nIH0gaWYgZm9vCmZvby5iYXIocGFyYW0pIHsgfGV8IGUuc29tZXRoaW5nIH0gaWYgZm9vCgpmb28uYmFyIGlmICFmb28ubmlsPwpmb28uYmFyIHVubGVzcyAhZm9vCmZvby5iYXIgdW5sZXNzIGZvby5uaWw/Cgpmb28gJiYgZm9vLmJhcgpmb28gJiYgZm9vLmJhci5iYXoKZm9vICYmIGZvby5iYXIocGFyYW0xLCBwYXJhbTIpCmZvbyAmJiBmb28uYmFyIHsgfGV8IGUuc29tZXRoaW5nIH0KZm9vICYmIGZvby5iYXIocGFyYW0pIHsgfGV8IGUuc29tZXRoaW5nIH0KCmZvbyA/IGZvby5iYXIgOiBuaWwKZm9vLm5pbD8gPyBuaWwgOiBmb28uYmFyCiFmb28ubmlsPyA/IGZvby5iYXIgOiBuaWwKIWZvbyA/IG5pbCA6IGZvby5iYXIKCiMgZ29vZApmb28mLmJhcgpmb28mLmJhciYuYmF6CmZvbyYuYmFyKHBhcmFtMSwgcGFyYW0yKQpmb28mLmJhciB7IHxlfCBlLnNvbWV0aGluZyB9CmZvbyYuYmFyKHBhcmFtKSB7IHxlfCBlLnNvbWV0aGluZyB9CmZvbyAmJiBmb28uYmFyLmJhei5xdXggIyBtZXRob2QgY2hhaW4gd2l0aCBtb3JlIHRoYW4gMiBtZXRob2RzCmZvbyAmJiBmb28ubmlsPyAjIG1ldGhvZCB0aGF0IGBuaWxgIHJlc3BvbmRzIHRvCgojIE1ldGhvZCBjYWxscyB0aGF0IGRvIG5vdCB1c2UgYC5gCmZvbyAmJiBmb28gPCBiYXIKZm9vIDwgYmFyIGlmIGZvbwoKIyBXaGVuIGNoZWNraW5nIGBmb28mLmVtcHR5P2AgaW4gYSBjb25kaXRpb25hbCwgYGZvb2AgYmVpbmcgYG5pbGAgd2lsbCBhY3R1YWxseQojIGRvIHRoZSBvcHBvc2l0ZSBvZiB3aGF0IHRoZSBhdXRob3IgaW50ZW5kcy4KZm9vICYmIGZvby5lbXB0eT8KCiMgVGhpcyBjb3VsZCBzdGFydCByZXR1cm5pbmcgYG5pbGAgYXMgd2VsbCBhcyB0aGUgcmV0dXJuIG9mIHRoZSBtZXRob2QKZm9vLm5pbD8gfHwgZm9vLmJhcgohZm9vIHx8IGZvby5iYXIKCiMgTWV0aG9kcyB0aGF0IGFyZSB1c2VkIG9uIGFzc2lnbm1lbnQsIGFyaXRobWV0aWMgb3BlcmF0aW9uIG9yCiMgY29tcGFyaXNvbiBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byB1c2Ugc2FmZSBuYXZpZ2F0aW9uCmZvby5iYXogPSBiYXIgaWYgZm9vCmZvby5iYXogKyBiYXIgaWYgZm9vCmZvby5iYXIgPiAyIGlmIGZvbwotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQ29udmVydENvZGVUaGF0Q2FuU3RhcnRUb1JldHVybk5pbAp8IGBmYWxzZWAKfCBCb29sZWFuCgp8IEFsbG93ZWRNZXRob2RzCnwgYHByZXNlbnQ/YCwgYGJsYW5rP2AsIGBwcmVzZW5jZWAsIGB0cnlgLCBgdHJ5IWAKfCBBcnJheQoKfCBNYXhDaGFpbkxlbmd0aAp8IGAyYAp8IEludGVnZXIKfD09PQoKPT0gU3R5bGUvU2FtcGxlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zMAp8IC0KfD09PQoKSWRlbnRpZmllcyB1c2FnZXMgb2YgYHNodWZmbGUuZmlyc3RgLApgc2h1ZmZsZS5sYXN0YCwgYW5kIGBzaHVmZmxlW11gIGFuZCBjaGFuZ2UgdGhlbSB0byB1c2UKYHNhbXBsZWAgaW5zdGVhZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClsxLCAyLCAzXS5zaHVmZmxlLmZpcnN0ClsxLCAyLCAzXS5zaHVmZmxlLmZpcnN0KDIpClsxLCAyLCAzXS5zaHVmZmxlLmxhc3QKWzIsIDEsIDNdLnNodWZmbGUuYXQoMCkKWzIsIDEsIDNdLnNodWZmbGUuc2xpY2UoMCkKWzEsIDIsIDNdLnNodWZmbGVbMl0KWzEsIDIsIDNdLnNodWZmbGVbMCwgMl0gICAgIyBzYW1wbGUoMikgd2lsbCBkbyB0aGUgc2FtZQpbMSwgMiwgM10uc2h1ZmZsZVswLi4yXSAgICAjIHNhbXBsZSgzKSB3aWxsIGRvIHRoZSBzYW1lClsxLCAyLCAzXS5zaHVmZmxlKHJhbmRvbTogUmFuZG9tLm5ldykuZmlyc3QKCiMgZ29vZApbMSwgMiwgM10uc2h1ZmZsZQpbMSwgMiwgM10uc2FtcGxlClsxLCAyLCAzXS5zYW1wbGUoMykKWzEsIDIsIDNdLnNodWZmbGVbMSwgM10gICAgIyBzYW1wbGUoMykgbWlnaHQgcmV0dXJuIGEgbG9uZ2VyIEFycmF5ClsxLCAyLCAzXS5zaHVmZmxlWzEuLjNdICAgICMgc2FtcGxlKDMpIG1pZ2h0IHJldHVybiBhIGxvbmdlciBBcnJheQpbMSwgMiwgM10uc2h1ZmZsZVtmb28sIGJhcl0KWzEsIDIsIDNdLnNodWZmbGUocmFuZG9tOiBSYW5kb20ubmV3KQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL2dpdGh1Yi5jb20vZmFzdHJ1YnkvZmFzdC1ydWJ5I2FycmF5c2h1ZmZsZWZpcnN0LXZzLWFycmF5c2FtcGxlLWNvZGUKCj09IFN0eWxlL1NlbGVjdEJ5UmVnZXhwCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4yMgp8IC0KfD09PQoKTG9va3MgZm9yIHBsYWNlcyB3aGVyZSBhbiBzdWJzZXQgb2YgYW4gRW51bWVyYWJsZSAoYXJyYXksCnJhbmdlLCBzZXQsIGV0Yy47IHNlZSBub3RlIGJlbG93KSBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIGEgYFJlZ2V4cGAKbWF0Y2gsIGFuZCBzdWdnZXN0cyBgZ3JlcGAgb3IgYGdyZXBfdmAgaW5zdGVhZC4KCk5PVEU6IEhhc2hlcyBkbyBub3QgYmVoYXZlIGFzIHlvdSBtYXkgZXhwZWN0IHdpdGggYGdyZXBgLCB3aGljaAptZWFucyB0aGF0IGBoYXNoLmdyZXBgIGlzIG5vdCBlcXVpdmFsZW50IHRvIGBoYXNoLnNlbGVjdGAuIEFsdGhvdWdoClJ1Ym9Db3AgaXMgbGltaXRlZCBieSBzdGF0aWMgYW5hbHlzaXMsIHRoaXMgY29wIGF0dGVtcHRzIHRvIGF2b2lkCnJlZ2lzdGVyaW5nIGFuIG9mZmVuc2Ugd2hlbiB0aGUgcmVjZWl2ZXIgaXMgYSBoYXNoIChoYXNoIGxpdGVyYWwsCmBIYXNoLm5ld2AsIGBIYXNoI1tdYCwgb3IgYHRvX2hgL2B0b19oYXNoYCkuCgpOT1RFOiBgZ3JlcGAgYW5kIGBncmVwX3ZgIHdlcmUgb3B0aW1pemVkIHdoZW4gdXNlZCB3aXRob3V0IGEgYmxvY2sKaW4gUnVieSAzLjAsIGJ1dCBtYXkgYmUgc2xvd2VyIGluIHByZXZpb3VzIHZlcnNpb25zLgpTZWUgaHR0cHM6Ly9idWdzLnJ1YnktbGFuZy5vcmcvaXNzdWVzLzE3MDMwCgo9PT0gU2FmZXR5CgpBdXRvY29ycmVjdGlvbiBpcyBtYXJrZWQgYXMgdW5zYWZlIGJlY2F1c2UgYE1hdGNoRGF0YWAgd2lsbApub3QgYmUgY3JlYXRlZCBieSBgZ3JlcGAsIGJ1dCBtYXkgaGF2ZSBwcmV2aW91c2x5IGJlZW4gcmVsaWVkCnVwb24gYWZ0ZXIgdGhlIGBtYXRjaD9gIG9yIGA9fmAgY2FsbC4KCkFkZGl0aW9uYWxseSwgdGhlIGNvcCBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlIHJlY2VpdmVyIG9mCmBzZWxlY3RgIG9yIGByZWplY3RgIGlzIGFjdHVhbGx5IGFuIGFycmF5IGJ5IHN0YXRpYyBhbmFseXNpcywKc28gdGhlIGNvcnJlY3Rpb24gbWF5IG5vdCBiZSBhY3R1YWxseSBlcXVpdmFsZW50LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgKHNlbGVjdCBvciBmaW5kX2FsbCkKYXJyYXkuc2VsZWN0IHsgfHh8IHgubWF0Y2g/IC9yZWdleHAvIH0KYXJyYXkuc2VsZWN0IHsgfHh8IC9yZWdleHAvLm1hdGNoPyh4KSB9CmFycmF5LnNlbGVjdCB7IHx4fCB4ID1+IC9yZWdleHAvIH0KYXJyYXkuc2VsZWN0IHsgfHh8IC9yZWdleHAvID1+IHggfQoKIyBiYWQgKHJlamVjdCkKYXJyYXkucmVqZWN0IHsgfHh8IHgubWF0Y2g/IC9yZWdleHAvIH0KYXJyYXkucmVqZWN0IHsgfHh8IC9yZWdleHAvLm1hdGNoPyh4KSB9CmFycmF5LnJlamVjdCB7IHx4fCB4ID1+IC9yZWdleHAvIH0KYXJyYXkucmVqZWN0IHsgfHh8IC9yZWdleHAvID1+IHggfQoKIyBnb29kCmFycmF5LmdyZXAocmVnZXhwKQphcnJheS5ncmVwX3YocmVnZXhwKQotLS0tCgo9PSBTdHlsZS9TZWxmQXNzaWdubWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTkKfCAwLjI5Cnw9PT0KCkVuZm9yY2VzIHRoZSB1c2UgdGhlIHNob3J0aGFuZCBmb3Igc2VsZi1hc3NpZ25tZW50LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKeCA9IHggKyAxCgojIGdvb2QKeCArPSAxCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3NlbGYtYXNzaWdubWVudAoKPT0gU3R5bGUvU2VtaWNvbG9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC4xOQp8PT09CgpDaGVja3MgZm9yIG11bHRpcGxlIGV4cHJlc3Npb25zIHBsYWNlZCBvbiB0aGUgc2FtZSBsaW5lLgpJdCBhbHNvIGNoZWNrcyBmb3IgbGluZXMgdGVybWluYXRlZCB3aXRoIGEgc2VtaWNvbG9uLgoKVGhpcyBjb3AgaGFzIGBBbGxvd0FzRXhwcmVzc2lvblNlcGFyYXRvcmAgY29uZmlndXJhdGlvbiBvcHRpb24uCkl0IGFsbG93cyBgO2AgdG8gc2VwYXJhdGUgc2V2ZXJhbCBleHByZXNzaW9ucyBvbiB0aGUgc2FtZSBsaW5lLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vID0gMTsgYmFyID0gMjsKYmF6ID0gMzsKCiMgZ29vZApmb28gPSAxCmJhciA9IDIKYmF6ID0gMwotLS0tCgo9PT09IEFsbG93QXNFeHByZXNzaW9uU2VwYXJhdG9yOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gPSAxOyBiYXIgPSAyCi0tLS0KCj09PT0gQWxsb3dBc0V4cHJlc3Npb25TZXBhcmF0b3I6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZm9vID0gMTsgYmFyID0gMgotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dBc0V4cHJlc3Npb25TZXBhcmF0b3IKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1zZW1pY29sb24KCj09IFN0eWxlL1NlbmQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgTm8KfCAwLjMzCnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSB1c2Ugb2YgdGhlIHNlbmQgbWV0aG9kLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRm9vLnNlbmQoYmFyKQpxdXV6LnNlbmQoZnJlZCkKCiMgZ29vZApGb28uX19zZW5kX18oYmFyKQpxdXV6LnB1YmxpY19zZW5kKGZyZWQpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3ByZWZlci1wdWJsaWMtc2VuZAoKPT0gU3R5bGUvU2VuZFdpdGhMaXRlcmFsTWV0aG9kTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS42NAp8IC0KfD09PQoKRGV0ZWN0cyB0aGUgdXNlIG9mIHRoZSBgcHVibGljX3NlbmRgIG1ldGhvZCB3aXRoIGEgbGl0ZXJhbCBtZXRob2QgbmFtZSBhcmd1bWVudC4KU2luY2UgdGhlIGBzZW5kYCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gY2FsbCBwcml2YXRlIG1ldGhvZHMsIGJ5IGRlZmF1bHQsCm9ubHkgdGhlIGBwdWJsaWNfc2VuZGAgbWV0aG9kIGlzIGRldGVjdGVkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgbm90IHNhZmUgYmVjYXVzZSBpdCBjYW4gaW5jb3JyZWN0bHkgZGV0ZWN0IGJhc2VkIG9uIHRoZSByZWNlaXZlci4KQWRkaXRpb25hbGx5LCB3aGVuIGBBbGxvd1NlbmRgIGlzIHNldCB0byBgdHJ1ZWAsIGl0IGNhbm5vdCBkZXRlcm1pbmUgd2hldGhlcgp0aGUgYHNlbmRgIG1ldGhvZCBiZWluZyBkZXRlY3RlZCBpcyBjYWxsaW5nIGEgcHJpdmF0ZSBtZXRob2QuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApvYmoucHVibGljX3NlbmQoOm1ldGhvZF9uYW1lKQpvYmoucHVibGljX3NlbmQoJ21ldGhvZF9uYW1lJykKCiMgZ29vZApvYmoubWV0aG9kX25hbWUKLS0tLQoKPT09PSBBbGxvd1NlbmQ6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCm9iai5zZW5kKDptZXRob2RfbmFtZSkKb2JqLnNlbmQoJ21ldGhvZF9uYW1lJykKb2JqLl9fc2VuZF9fKDptZXRob2RfbmFtZSkKb2JqLl9fc2VuZF9fKCdtZXRob2RfbmFtZScpCi0tLS0KCj09PT0gQWxsb3dTZW5kOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm9iai5zZW5kKDptZXRob2RfbmFtZSkKb2JqLnNlbmQoJ21ldGhvZF9uYW1lJykKb2JqLl9fc2VuZF9fKDptZXRob2RfbmFtZSkKb2JqLl9fc2VuZF9fKCdtZXRob2RfbmFtZScpCgojIGdvb2QKb2JqLm1ldGhvZF9uYW1lCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd1NlbmQKfCBgdHJ1ZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL1NpZ25hbEV4Y2VwdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTEKfCAwLjM3Cnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiBgZmFpbGAgYW5kIGByYWlzZWAuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogb25seV9yYWlzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIFRoZSBgb25seV9yYWlzZWAgc3R5bGUgZW5mb3JjZXMgdGhlIHNvbGUgdXNlIG9mIGByYWlzZWAuCiMgYmFkCmJlZ2luCiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgIyBoYW5kbGUgaXQKZW5kCgpkZWYgd2F0Y2hfb3V0CiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgIyBoYW5kbGUgaXQKZW5kCgpLZXJuZWwuZmFpbAoKIyBnb29kCmJlZ2luCiAgcmFpc2UKcmVzY3VlIEV4Y2VwdGlvbgogICMgaGFuZGxlIGl0CmVuZAoKZGVmIHdhdGNoX291dAogIHJhaXNlCnJlc2N1ZSBFeGNlcHRpb24KICAjIGhhbmRsZSBpdAplbmQKCktlcm5lbC5yYWlzZQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IG9ubHlfZmFpbAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgVGhlIGBvbmx5X2ZhaWxgIHN0eWxlIGVuZm9yY2VzIHRoZSBzb2xlIHVzZSBvZiBgZmFpbGAuCiMgYmFkCmJlZ2luCiAgcmFpc2UKcmVzY3VlIEV4Y2VwdGlvbgogICMgaGFuZGxlIGl0CmVuZAoKZGVmIHdhdGNoX291dAogIHJhaXNlCnJlc2N1ZSBFeGNlcHRpb24KICAjIGhhbmRsZSBpdAplbmQKCktlcm5lbC5yYWlzZQoKIyBnb29kCmJlZ2luCiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgIyBoYW5kbGUgaXQKZW5kCgpkZWYgd2F0Y2hfb3V0CiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgIyBoYW5kbGUgaXQKZW5kCgpLZXJuZWwuZmFpbAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNlbWFudGljCgpbc291cmNlLHJ1YnldCi0tLS0KIyBUaGUgYHNlbWFudGljYCBzdHlsZSBlbmZvcmNlcyB0aGUgdXNlIG9mIGBmYWlsYCB0byBzaWduYWwgYW4KIyBleGNlcHRpb24sIHRoZW4gd2lsbCB1c2UgYHJhaXNlYCB0byB0cmlnZ2VyIGFuIG9mZmVuc2UgYWZ0ZXIKIyBpdCBoYXMgYmVlbiByZXNjdWVkLgojIGJhZApiZWdpbgogIHJhaXNlCnJlc2N1ZSBFeGNlcHRpb24KICAjIGhhbmRsZSBpdAplbmQKCmRlZiB3YXRjaF9vdXQKICAjIEVycm9yIHRocm93bgpyZXNjdWUgRXhjZXB0aW9uCiAgZmFpbAplbmQKCktlcm5lbC5mYWlsCktlcm5lbC5yYWlzZQoKIyBnb29kCmJlZ2luCiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgIyBoYW5kbGUgaXQKZW5kCgpkZWYgd2F0Y2hfb3V0CiAgZmFpbApyZXNjdWUgRXhjZXB0aW9uCiAgcmFpc2UgJ1ByZWZlcmFibHkgd2l0aCBkZXNjcmlwdGl2ZSBtZXNzYWdlJwplbmQKCmV4cGxpY2l0X3JlY2VpdmVyLmZhaWwKZXhwbGljaXRfcmVjZWl2ZXIucmFpc2UKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgb25seV9yYWlzZWAKfCBgb25seV9yYWlzZWAsIGBvbmx5X2ZhaWxgLCBgc2VtYW50aWNgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3ByZWZlci1yYWlzZS1vdmVyLWZhaWwKCj09IFN0eWxlL1NpbmdsZUFyZ3VtZW50RGlnCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjg5CnwgLQp8PT09CgpTb21ldGltZXMgdXNpbmcgYGRpZ2AgbWV0aG9kIGVuZHMgdXAgd2l0aCBqdXN0IGEgc2luZ2xlCmFyZ3VtZW50LiBJbiBzdWNoIGNhc2VzLCBkaWcgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggYFtdYC4KClNpbmNlIHJlcGxhY2luZyBgaGFzaCYuZGlnKDprZXkpYCB3aXRoIGBoYXNoWzprZXldYCBjb3VsZCBwb3RlbnRpYWxseSBsZWFkIHRvIGVycm9yLApjYWxscyB0byB0aGUgYGRpZ2AgbWV0aG9kIHVzaW5nIHNhZmUgbmF2aWdhdGlvbiB3aWxsIGJlIGlnbm9yZWQuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IHRoZSByZWNlaXZlcgppcyBhbiBgRW51bWVyYWJsZWAgb3IgZG9lcyBub3QgaGF2ZSBhIG5vbnN0YW5kYXJkIGltcGxlbWVudGF0aW9uCm9mIGBkaWdgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKeyBrZXk6ICd2YWx1ZScgfS5kaWcoOmtleSkKWzEsIDIsIDNdLmRpZygwKQoKIyBnb29kCnsga2V5OiAndmFsdWUnIH1bOmtleV0KWzEsIDIsIDNdWzBdCgojIGdvb2QKeyBrZXkxOiB7IGtleTI6ICd2YWx1ZScgfSB9LmRpZyg6a2V5MSwgOmtleTIpClsxLCBbMiwgWzNdXV0uZGlnKDEsIDEpCgojIGdvb2QKa2V5cyA9ICVpW2tleTEga2V5Ml0KeyBrZXkxOiB7IGtleTI6ICd2YWx1ZScgfSB9LmRpZygqa2V5cykKLS0tLQoKPT0gU3R5bGUvU2luZ2xlTGluZUJsb2NrUGFyYW1zCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTYKfCAxLjYKfD09PQoKQ2hlY2tzIHdoZXRoZXIgdGhlIGJsb2NrIHBhcmFtZXRlcnMgb2YgYSBzaW5nbGUtbGluZQptZXRob2QgYWNjZXB0aW5nIGEgYmxvY2sgbWF0Y2ggdGhlIG5hbWVzIHNwZWNpZmllZCB2aWEgY29uZmlndXJhdGlvbi4KCkZvciBpbnN0YW5jZSBvbmUgY2FuIGNvbmZpZ3VyZSBgcmVkdWNlYChgaW5qZWN0YCkgdG8gdXNlIHxhLCBlfCBhcwpwYXJhbWV0ZXJzLgoKQ29uZmlndXJhdGlvbiBvcHRpb246IE1ldGhvZHMKU2hvdWxkIGJlIHNldCB0byB1c2UgdGhpcyBjb3AuIEFycmF5IG9mIGhhc2hlcywgd2hlcmUgZWFjaCBrZXkgaXMgdGhlCm1ldGhvZCBuYW1lIGFuZCB2YWx1ZSAtIGFycmF5IG9mIGFyZ3VtZW50IG5hbWVzLgoKPT09IEV4YW1wbGVzCgo9PT09IE1ldGhvZHM6IFt7cmVkdWNlOiAld1thIGJdfV0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28ucmVkdWNlIHsgfGMsIGR8IGMgKyBkIH0KZm9vLnJlZHVjZSB7IHxfLCBfZHwgMSB9CgojIGdvb2QKZm9vLnJlZHVjZSB7IHxhLCBifCBhICsgYiB9CmZvby5yZWR1Y2UgeyB8YSwgX2J8IGEgfQpmb28ucmVkdWNlIHsgfGEsIChpZCwgXyl8IGEgKyBpZCB9CmZvby5yZWR1Y2UgeyB0cnVlIH0KCiMgZ29vZApmb28ucmVkdWNlIGRvIHxjLCBkfAogIGMgKyBkCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWV0aG9kcwp8IGB7InJlZHVjZSI9PlsiYWNjIiwgImVsZW0iXX1gLCBgeyJpbmplY3QiPT5bImFjYyIsICJlbGVtIl19YAp8IEFycmF5Cnw9PT0KCj09IFN0eWxlL1NpbmdsZUxpbmVEb0VuZEJsb2NrCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMS41Nwp8IC0KfD09PQoKQ2hlY2tzIGZvciBzaW5nbGUtbGluZSBgZG9gLi4uYGVuZGAgYmxvY2suCgpJbiBwcmFjdGljZSBhIHNpbmdsZSBsaW5lIGBkb2AuLi5gZW5kYCBpcyBhdXRvY29ycmVjdGVkIHdoZW4gYEVuZm9yY2VkU3R5bGU6IHNlbWFudGljYAppbiBgU3R5bGUvQmxvY2tEZWxpbWl0ZXJzYC4gVGhlIGF1dG9jb3JyZWN0aW9uIG1haW50YWlucyB0aGUgYGRvYCAuLi4gYGVuZGAgc3ludGF4IHRvCnByZXNlcnZlIHNlbWFudGljcyBhbmQgZG9lcyBub3QgY2hhbmdlIGl0IHRvIGB7YC4uLmB9YCBibG9jay4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvbyBkbyB8YXJnfCBiYXIoYXJnKSBlbmQKCiMgZ29vZApmb28gZG8gfGFyZ3wKICBiYXIoYXJnKQplbmQKCiMgYmFkCi0+KGFyZykgZG8gYmFyKGFyZykgZW5kCgojIGdvb2QKLT4oYXJnKSB7IGJhcihhcmcpIH0KLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc2luZ2xlLWxpbmUtZG8tZW5kLWJsb2NrCgo9PSBTdHlsZS9TaW5nbGVMaW5lTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuOQp8IDEuOAp8PT09CgpDaGVja3MgZm9yIHNpbmdsZS1saW5lIG1ldGhvZCBkZWZpbml0aW9ucyB0aGF0IGNvbnRhaW4gYSBib2R5LgpJdCB3aWxsIGFjY2VwdCBzaW5nbGUtbGluZSBtZXRob2RzIHdpdGggbm8gYm9keS4KCkVuZGxlc3MgbWV0aG9kcyBhZGRlZCBpbiBSdWJ5IDMuMCBhcmUgYWxzbyBhY2NlcHRlZCBieSB0aGlzIGNvcC4KCklmIGBTdHlsZS9FbmRsZXNzTWV0aG9kYCBpcyBlbmFibGVkIHdpdGggYEVuZm9yY2VkU3R5bGU6IGFsbG93X3NpbmdsZV9saW5lYCBvcgpgYWxsb3dfYWx3YXlzYCwgc2luZ2xlLWxpbmUgbWV0aG9kcyB3aWxsIGJlIGF1dG9jb3JyZWN0ZWQgdG8gZW5kbGVzcwptZXRob2RzIGlmIHRoZXJlIGlzIG9ubHkgb25lIHN0YXRlbWVudCBpbiB0aGUgYm9keS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBzb21lX21ldGhvZDsgYm9keSBlbmQKZGVmIGxpbmtfdG8odXJsKTsgezpuYW1lID0+IHVybH07IGVuZApkZWYgQHRhYmxlLmNvbHVtbnM7IHN1cGVyOyBlbmQKCiMgZ29vZApkZWYgc2VsZi5yZXNvdXJjZV9jbGFzcz0oa2xhc3MpOyBlbmQKZGVmIEB0YWJsZS5jb2x1bW5zOyBlbmQKZGVmIHNvbWVfbWV0aG9kKCkgPSBib2R5Ci0tLS0KCj09PT0gQWxsb3dJZk1ldGhvZElzRW1wdHk6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBub19vcDsgZW5kCi0tLS0KCj09PT0gQWxsb3dJZk1ldGhvZElzRW1wdHk6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIG5vX29wOyBlbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93SWZNZXRob2RJc0VtcHR5CnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1zaW5nbGUtbGluZS1tZXRob2RzCgo9PSBTdHlsZS9TbGljaW5nV2l0aFJhbmdlCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuNgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44Mwp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgYXJyYXlzIGFyZSBub3Qgc2xpY2VkIHdpdGggdGhlIHJlZHVuZGFudCBgYXJ5WzAuLi0xXWAsIHJlcGxhY2luZyBpdCB3aXRoIGBhcnlgLAphbmQgZW5zdXJlcyBhcnJheXMgYXJlIHNsaWNlZCB3aXRoIGVuZGxlc3MgcmFuZ2VzIGluc3RlYWQgb2YgYGFyeVtzdGFydC4uLTFdYCBvbiBSdWJ5IDIuNissCmFuZCB3aXRoIGJlZ2lubGVzcyByYW5nZXMgaW5zdGVhZCBvZiBgYXJ5W25pbC4uZW5kXWAgb24gUnVieSAyLjcrLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgYHguLi0xYCBhbmQgYHguLmAgYXJlIG9ubHkgZ3VhcmFudGVlZCB0bwpiZSBlcXVpdmFsZW50IGZvciBgQXJyYXkjW11gLCBgU3RyaW5nI1tdYCwgYW5kIHRoZSBjb3AgY2Fubm90IGRldGVybWluZSB3aGF0IGNsYXNzCnRoZSByZWNlaXZlciBpcy4KCkZvciBleGFtcGxlOgpbc291cmNlLHJ1YnldCi0tLS0Kc3VtID0gcHJvYyB7IHxhcnl8IGFyeS5zdW0gfQpzdW1bLTMuLi0xXSAjID0+IC02CnN1bVstMy4uXSAjIEhhbmdzIGZvcmV2ZXIKLS0tLQoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXRlbXNbMC4uLTFdCml0ZW1zWzAuLm5pbF0KaXRlbXNbMC4uLm5pbF0KCiMgZ29vZAppdGVtcwoKIyBiYWQKaXRlbXNbMS4uLTFdICAgIyBSdWJ5IDIuNisKaXRlbXNbMS4ubmlsXSAgIyBSdWJ5IDIuNisKCiMgZ29vZAppdGVtc1sxLi5dICAgICAjIFJ1YnkgMi42KwoKIyBiYWQKaXRlbXNbbmlsLi40Ml0gIyBSdWJ5IDIuNysKCiMgZ29vZAppdGVtc1suLjQyXSAgICAjIFJ1YnkgMi43KwppdGVtc1swLi40Ml0gICAjIFJ1YnkgMi43KwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNzbGljaW5nLXdpdGgtcmFuZ2VzCgo9PSBTdHlsZS9Tb2xlTmVzdGVkQ29uZGl0aW9uYWwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjg5CnwgMS41Cnw9PT0KCklmIHRoZSBicmFuY2ggb2YgYSBjb25kaXRpb25hbCBjb25zaXN0cyBzb2xlbHkgb2YgYSBjb25kaXRpb25hbCBub2RlLAppdHMgY29uZGl0aW9ucyBjYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgY29uZGl0aW9ucyBvZiB0aGUgb3V0ZXIgYnJhbmNoLgpUaGlzIGhlbHBzIHRvIGtlZXAgdGhlIG5lc3RpbmcgbGV2ZWwgZnJvbSBnZXR0aW5nIHRvbyBkZWVwLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgY29uZGl0aW9uX2EKICBpZiBjb25kaXRpb25fYgogICAgZG9fc29tZXRoaW5nCiAgZW5kCmVuZAoKIyBiYWQKaWYgY29uZGl0aW9uX2IKICBkb19zb21ldGhpbmcKZW5kIGlmIGNvbmRpdGlvbl9hCgojIGdvb2QKaWYgY29uZGl0aW9uX2EgJiYgY29uZGl0aW9uX2IKICBkb19zb21ldGhpbmcKZW5kCi0tLS0KCj09PT0gQWxsb3dNb2RpZmllcjogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaWYgY29uZGl0aW9uX2EKICBkb19zb21ldGhpbmcgaWYgY29uZGl0aW9uX2IKZW5kCgojIGJhZAppZiBjb25kaXRpb25fYgogIGRvX3NvbWV0aGluZwplbmQgaWYgY29uZGl0aW9uX2EKLS0tLQoKPT09PSBBbGxvd01vZGlmaWVyOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmlmIGNvbmRpdGlvbl9hCiAgZG9fc29tZXRoaW5nIGlmIGNvbmRpdGlvbl9iCmVuZAoKIyBnb29kCmlmIGNvbmRpdGlvbl9iCiAgZG9fc29tZXRoaW5nCmVuZCBpZiBjb25kaXRpb25fYQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dNb2RpZmllcgp8IGBmYWxzZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL1NwZWNpYWxHbG9iYWxWYXJzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4xMwp8IDAuMzYKfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgUGVybC1zdHlsZSBnbG9iYWwgdmFyaWFibGVzLgpDb3JyZWN0aW5nIHRvIGdsb2JhbCB2YXJpYWJsZXMgaW4gdGhlICdFbmdsaXNoJyBsaWJyYXJ5CndpbGwgYWRkIGEgcmVxdWlyZSBzdGF0ZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgZmlsZSBpZgplbmFibGVkIGJ5IFJlcXVpcmVFbmdsaXNoIGNvbmZpZy4KCj09PSBTYWZldHkKCkF1dG9jb3JyZWN0aW9uIGlzIG1hcmtlZCBhcyB1bnNhZmUgYmVjYXVzZSBpZiBgUmVxdWlyZUVuZ2xpc2hgIGlzIG5vdAp0cnVlLCByZXBsYWNpbmcgcGVybC1zdHlsZSB2YXJpYWJsZXMgd2l0aCBlbmdsaXNoIHZhcmlhYmxlcyB3aWxsIGJyZWFrLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHVzZV9lbmdsaXNoX25hbWVzIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApyZXF1aXJlICdFbmdsaXNoJyAjIG9yIHRoaXMgY291bGQgYmUgaW4gYW5vdGhlciBmaWxlLgoKcHV0cyAkTE9BRF9QQVRICnB1dHMgJExPQURFRF9GRUFUVVJFUwpwdXRzICRQUk9HUkFNX05BTUUKcHV0cyAkRVJST1JfSU5GTwpwdXRzICRFUlJPUl9QT1NJVElPTgpwdXRzICRGSUVMRF9TRVBBUkFUT1IgIyBvciAkRlMKcHV0cyAkT1VUUFVUX0ZJRUxEX1NFUEFSQVRPUiAjIG9yICRPRlMKcHV0cyAkSU5QVVRfUkVDT1JEX1NFUEFSQVRPUiAjIG9yICRSUwpwdXRzICRPVVRQVVRfUkVDT1JEX1NFUEFSQVRPUiAjIG9yICRPUlMKcHV0cyAkSU5QVVRfTElORV9OVU1CRVIgIyBvciAkTlIKcHV0cyAkTEFTVF9SRUFEX0xJTkUKcHV0cyAkREVGQVVMVF9PVVRQVVQKcHV0cyAkREVGQVVMVF9JTlBVVApwdXRzICRQUk9DRVNTX0lEICMgb3IgJFBJRApwdXRzICRDSElMRF9TVEFUVVMKcHV0cyAkTEFTVF9NQVRDSF9JTkZPCnB1dHMgJElHTk9SRUNBU0UKcHV0cyAkQVJHViAjIG9yIEFSR1YKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiB1c2VfcGVybF9uYW1lcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApwdXRzICQ6CnB1dHMgJCIKcHV0cyAkMApwdXRzICQhCnB1dHMgJEAKcHV0cyAkOwpwdXRzICQsCnB1dHMgJC8KcHV0cyAkXApwdXRzICQuCnB1dHMgJF8KcHV0cyAkPgpwdXRzICQ8CnB1dHMgJCQKcHV0cyAkPwpwdXRzICR+CnB1dHMgJD0KcHV0cyAkKgotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHVzZV9idWlsdGluX2VuZ2xpc2hfbmFtZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKIyBMaWtlIGB1c2VfcGVybF9uYW1lc2AgYnV0IGFsbG93cyBidWlsdGluIGdsb2JhbCB2YXJzLgpwdXRzICRMT0FEX1BBVEgKcHV0cyAkTE9BREVEX0ZFQVRVUkVTCnB1dHMgJFBST0dSQU1fTkFNRQpwdXRzIEFSR1YKcHV0cyAkOgpwdXRzICQiCnB1dHMgJDAKcHV0cyAkIQpwdXRzICRACnB1dHMgJDsKcHV0cyAkLApwdXRzICQvCnB1dHMgJFwKcHV0cyAkLgpwdXRzICRfCnB1dHMgJD4KcHV0cyAkPApwdXRzICQkCnB1dHMgJD8KcHV0cyAkfgpwdXRzICQ9CnB1dHMgJCoKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFJlcXVpcmVFbmdsaXNoCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBFbmZvcmNlZFN0eWxlCnwgYHVzZV9lbmdsaXNoX25hbWVzYAp8IGB1c2VfcGVybF9uYW1lc2AsIGB1c2VfZW5nbGlzaF9uYW1lc2AsIGB1c2VfYnVpbHRpbl9lbmdsaXNoX25hbWVzYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1jcnlwdGljLXBlcmxpc21zCgo9PSBTdHlsZS9TdGFiYnlMYW1iZGFQYXJlbnRoZXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzUKfCAtCnw9PT0KCkNoZWNrIGZvciBwYXJlbnRoZXNlcyBhcm91bmQgc3RhYmJ5IGxhbWJkYSBhcmd1bWVudHMuClRoZXJlIGFyZSB0d28gZGlmZmVyZW50IHN0eWxlcy4gRGVmYXVsdHMgdG8gYHJlcXVpcmVfcGFyZW50aGVzZXNgLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfcGFyZW50aGVzZXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKLT5hLGIsYyB7IGEgKyBiICsgYyB9CgojIGdvb2QKLT4oYSxiLGMpIHsgYSArIGIgKyBjfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfbm9fcGFyZW50aGVzZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAotPihhLGIsYykgeyBhICsgYiArIGMgfQoKIyBnb29kCi0+YSxiLGMgeyBhICsgYiArIGN9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHJlcXVpcmVfcGFyZW50aGVzZXNgCnwgYHJlcXVpcmVfcGFyZW50aGVzZXNgLCBgcmVxdWlyZV9ub19wYXJlbnRoZXNlc2AKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjc3RhYmJ5LWxhbWJkYS13aXRoLWFyZ3MKCj09IFN0eWxlL1N0YXRpY0NsYXNzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4zCnwgLQp8PT09CgpDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBjbGFzc2VzIHdpdGggb25seSBjbGFzcyBtZXRob2RzIGNhbiBiZQpyZXBsYWNlZCB3aXRoIGEgbW9kdWxlLiBDbGFzc2VzIHNob3VsZCBiZSB1c2VkIG9ubHkgd2hlbiBpdCBtYWtlcyBzZW5zZSB0byBjcmVhdGUKaW5zdGFuY2VzIG91dCBvZiB0aGVtLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlLCBiZWNhdXNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhpcyBjbGFzcyBpcyBhIHBhcmVudApmb3Igc29tZSBvdGhlciBzdWJjbGFzcywgbW9ua2V5LXBhdGNoZWQgd2l0aCBpbnN0YW5jZSBtZXRob2RzIG9yCmEgZHVtbXkgaW5zdGFuY2UgaXMgaW5zdGFudGlhdGVkIGZyb20gaXQgc29tZXdoZXJlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgU29tZUNsYXNzCiAgZGVmIHNlbGYuc29tZV9tZXRob2QKICAgICMgYm9keSBvbWl0dGVkCiAgZW5kCgogIGRlZiBzZWxmLnNvbWVfb3RoZXJfbWV0aG9kCiAgICAjIGJvZHkgb21pdHRlZAogIGVuZAplbmQKCiMgZ29vZAptb2R1bGUgU29tZU1vZHVsZQogIG1vZHVsZV9mdW5jdGlvbgoKICBkZWYgc29tZV9tZXRob2QKICAgICMgYm9keSBvbWl0dGVkCiAgZW5kCgogIGRlZiBzb21lX290aGVyX21ldGhvZAogICAgIyBib2R5IG9taXR0ZWQKICBlbmQKZW5kCgojIGdvb2QgLSBoYXMgaW5zdGFuY2UgbWV0aG9kCmNsYXNzIFNvbWVDbGFzcwogIGRlZiBpbnN0YW5jZV9tZXRob2Q7IGVuZAogIGRlZiBzZWxmLmNsYXNzX21ldGhvZDsgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNtb2R1bGVzLXZzLWNsYXNzZXMKCj09IFN0eWxlL1N0ZGVyclB1dHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUxCnwgLQp8PT09CgpJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBgJHN0ZGVyci5wdXRzYCBjYW4gYmUgcmVwbGFjZWQgYnkKYHdhcm5gLiBUaGUgbGF0dGVyIGhhcyB0aGUgYWR2YW50YWdlIG9mIGVhc2lseSBiZWluZyBkaXNhYmxlZCBieSwKdGhlIGAtVzBgIGludGVycHJldGVyIGZsYWcgb3Igc2V0dGluZyBgJFZFUkJPU0VgIHRvIGBuaWxgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKJHN0ZGVyci5wdXRzKCdoZWxsbycpCgojIGdvb2QKd2FybignaGVsbG8nKQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSN3YXJuCgo9PSBTdHlsZS9TdHJpbmdDaGFycwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4xMgp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2VzIG9mIGBTdHJpbmcjc3BsaXRgIHdpdGggZW1wdHkgc3RyaW5nIG9yIHJlZ2V4cCBsaXRlcmFsIGFyZ3VtZW50LgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdCB0aGUgcmVjZWl2ZXIKaXMgYWN0dWFsbHkgYSBzdHJpbmcuIElmIGFub3RoZXIgY2xhc3MgaGFzIGEgYHNwbGl0YCBtZXRob2Qgd2l0aApkaWZmZXJlbnQgYmVoYXZpb3IsIGl0IHdvdWxkIGJlIHJlZ2lzdGVyZWQgYXMgYSBmYWxzZSBwb3NpdGl2ZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnN0cmluZy5zcGxpdCgvLykKc3RyaW5nLnNwbGl0KCcnKQoKIyBnb29kCnN0cmluZy5jaGFycwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNzdHJpbmctY2hhcnMKCj09IFN0eWxlL1N0cmluZ0NvbmNhdGVuYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuODkKfCAxLjE4Cnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIHN0cmluZyBjb25jYXRlbmF0aW9uCmNhbiBiZSByZXBsYWNlZCB3aXRoIHN0cmluZyBpbnRlcnBvbGF0aW9uLgoKVGhlIGNvcCBjYW4gYXV0b2NvcnJlY3Qgc2ltcGxlIGNhc2VzIGJ1dCB3aWxsIHNraXAgYXV0b2NvcnJlY3RpbmcKbW9yZSBjb21wbGV4IGNhc2VzIHdoZXJlIHRoZSByZXN1bHRpbmcgY29kZSB3b3VsZCBiZSBoYXJkZXIgdG8gcmVhZC4KSW4gdGhvc2UgY2FzZXMsIGl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBleHRyYWN0IHN0YXRlbWVudHMgdG8gbG9jYWwKdmFyaWFibGVzIG9yIG1ldGhvZHMgd2hpY2ggeW91IGNhbiB0aGVuIGludGVycG9sYXRlIGluIGEgc3RyaW5nLgoKTk9URTogV2hlbiBjb25jYXRlbmF0aW9uIGJldHdlZW4gdHdvIHN0cmluZ3MgaXMgYnJva2VuIG92ZXIgbXVsdGlwbGUKbGluZXMsIHRoaXMgY29wIGRvZXMgbm90IHJlZ2lzdGVyIGFuIG9mZmVuc2U7IGluc3RlYWQsCmBTdHlsZS9MaW5lRW5kQ29uY2F0ZW5hdGlvbmAgd2lsbCBwaWNrIHVwIHRoZSBvZmZlbnNlIGlmIGVuYWJsZWQuCgpUd28gbW9kZXMgYXJlIHN1cHBvcnRlZDoKMS4gYGFnZ3Jlc3NpdmVgIHN0eWxlIGNoZWNrcyBhbmQgY29ycmVjdHMgYWxsIG9jY3VycmVuY2VzIG9mIGArYCB3aGVyZQplaXRoZXIgdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiBgK2AgaXMgYSBzdHJpbmcgbGl0ZXJhbC4KMi4gYGNvbnNlcnZhdGl2ZWAgc3R5bGUgb24gdGhlIG90aGVyIGhhbmQsIGNoZWNrcyBhbmQgY29ycmVjdHMgb25seSBpZgpsZWZ0IHNpZGUgKHJlY2VpdmVyIG9mIGArYCBtZXRob2QgY2FsbCkgaXMgYSBzdHJpbmcgbGl0ZXJhbC4KVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGUgcmVjZWl2ZXIgaXMgc29tZSBleHByZXNzaW9uIHRoYXQgcmV0dXJucyBzdHJpbmcgbGlrZSBgUGF0aG5hbWVgCmluc3RlYWQgb2YgYSBzdHJpbmcgbGl0ZXJhbC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBpbiBgYWdncmVzc2l2ZWAgbW9kZSwgYXMgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdAp0aGUgcmVjZWl2ZXIgaXMgYWN0dWFsbHkgYSBzdHJpbmcsIHdoaWNoIGNhbiByZXN1bHQgaW4gYSBmYWxzZSBwb3NpdGl2ZS4KCj09PSBFeGFtcGxlcwoKPT09PSBNb2RlOiBhZ2dyZXNzaXZlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmVtYWlsX3dpdGhfbmFtZSA9IHVzZXIubmFtZSArICcgPCcgKyB1c2VyLmVtYWlsICsgJz4nClBhdGhuYW1lLm5ldygnLycpICsgJ3Rlc3QnCgojIGdvb2QKZW1haWxfd2l0aF9uYW1lID0gIiN7dXNlci5uYW1lfSA8I3t1c2VyLmVtYWlsfT4iCmVtYWlsX3dpdGhfbmFtZSA9IGZvcm1hdCgnJXMgPCVzPicsIHVzZXIubmFtZSwgdXNlci5lbWFpbCkKIiN7UGF0aG5hbWUubmV3KCcvJyl9dGVzdCIKCiMgYWNjZXB0ZWQsIGxpbmUtZW5kIGNvbmNhdGVuYXRpb24KbmFtZSA9ICdGaXJzdCcgKwogICdMYXN0JwotLS0tCgo9PT09IE1vZGU6IGNvbnNlcnZhdGl2ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCidIZWxsbycgKyB1c2VyLm5hbWUKCiMgZ29vZAoiSGVsbG8gI3t1c2VyLm5hbWV9Igp1c2VyLm5hbWUgKyAnISEnClBhdGhuYW1lLm5ldygnLycpICsgJ3Rlc3QnCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBNb2RlCnwgYGFnZ3Jlc3NpdmVgCnwgU3RyaW5nCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3N0cmluZy1pbnRlcnBvbGF0aW9uCgo9PSBTdHlsZS9TdHJpbmdIYXNoS2V5cwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNTIKfCAwLjc1Cnw9PT0KCkNoZWNrcyBmb3IgdGhlIHVzZSBvZiBzdHJpbmdzIGFzIGtleXMgaW4gaGFzaGVzLiBUaGUgdXNlIG9mCnN5bWJvbHMgaXMgcHJlZmVycmVkIGluc3RlYWQuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSB3aGlsZSBzeW1ib2xzIGFyZSBwcmVmZXJyZWQgZm9yIGhhc2gga2V5cywKdGhlcmUgYXJlIGluc3RhbmNlcyB3aGVuIHN0cmluZyBrZXlzIGFyZSByZXF1aXJlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnsgJ29uZScgPT4gMSwgJ3R3bycgPT4gMiwgJ3RocmVlJyA9PiAzIH0KCiMgZ29vZAp7IG9uZTogMSwgdHdvOiAyLCB0aHJlZTogMyB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI3N5bWJvbHMtYXMta2V5cwoKPT0gU3R5bGUvU3RyaW5nTGl0ZXJhbHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjM2Cnw9PT0KCkNoZWNrcyBpZiB1c2VzIG9mIHF1b3RlcyBtYXRjaCB0aGUgY29uZmlndXJlZCBwcmVmZXJlbmNlLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNpbmdsZV9xdW90ZXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIk5vIHNwZWNpYWwgc3ltYm9scyIKIk5vIHN0cmluZyBpbnRlcnBvbGF0aW9uIgoiSnVzdCB0ZXh0IgoKIyBnb29kCidObyBzcGVjaWFsIHN5bWJvbHMnCidObyBzdHJpbmcgaW50ZXJwb2xhdGlvbicKJ0p1c3QgdGV4dCcKIldhaXQhIFdoYXQncyAje3RoaXN9ISIKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBkb3VibGVfcXVvdGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKJ0p1c3Qgc29tZSB0ZXh0JwonTm8gc3BlY2lhbCBjaGFycyBvciBpbnRlcnBvbGF0aW9uJwoKIyBnb29kCiJKdXN0IHNvbWUgdGV4dCIKIk5vIHNwZWNpYWwgY2hhcnMgb3IgaW50ZXJwb2xhdGlvbiIKIkV2ZXJ5IHN0cmluZyBpbiAje3Byb2plY3R9IHVzZXMgZG91YmxlX3F1b3RlcyIKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc2luZ2xlX3F1b3Rlc2AKfCBgc2luZ2xlX3F1b3Rlc2AsIGBkb3VibGVfcXVvdGVzYAoKfCBDb25zaXN0ZW50UXVvdGVzSW5NdWx0aWxpbmUKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNjb25zaXN0ZW50LXN0cmluZy1saXRlcmFscwoKPT0gU3R5bGUvU3RyaW5nTGl0ZXJhbHNJbkludGVycG9sYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjI3CnwgLQp8PT09CgpDaGVja3MgdGhhdCBxdW90ZXMgaW5zaWRlIHN0cmluZywgc3ltYm9sLCBhbmQgcmVnZXhwIGludGVycG9sYXRpb25zCm1hdGNoIHRoZSBjb25maWd1cmVkIHByZWZlcmVuY2UuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2luZ2xlX3F1b3RlcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzdHJpbmcgPSAiVGVzdHMgI3tzdWNjZXNzID8gIlBBU1MiIDogIkZBSUwifSIKc3ltYm9sID0gOiJUZXN0cyAje3N1Y2Nlc3MgPyAiUEFTUyIgOiAiRkFJTCJ9IgpoZXJlZG9jID0gPDx+VEVYVAogIFRlc3RzICN7c3VjY2VzcyA/ICJQQVNTIiA6ICJGQUlMIn0KVEVYVApyZWdleHAgPSAvVGVzdHMgI3tzdWNjZXNzID8gIlBBU1MiIDogIkZBSUwifS8KCiMgZ29vZApzdHJpbmcgPSAiVGVzdHMgI3tzdWNjZXNzID8gJ1BBU1MnIDogJ0ZBSUwnfSIKc3ltYm9sID0gOiJUZXN0cyAje3N1Y2Nlc3MgPyAnUEFTUycgOiAnRkFJTCd9IgpoZXJlZG9jID0gPDx+VEVYVAogIFRlc3RzICN7c3VjY2VzcyA/ICdQQVNTJyA6ICdGQUlMJ30KVEVYVApyZWdleHAgPSAvVGVzdHMgI3tzdWNjZXNzID8gJ1BBU1MnIDogJ0ZBSUwnfS8KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBkb3VibGVfcXVvdGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3RyaW5nID0gIlRlc3RzICN7c3VjY2VzcyA/ICdQQVNTJyA6ICdGQUlMJ30iCnN5bWJvbCA9IDoiVGVzdHMgI3tzdWNjZXNzID8gJ1BBU1MnIDogJ0ZBSUwnfSIKaGVyZWRvYyA9IDw8flRFWFQKICBUZXN0cyAje3N1Y2Nlc3MgPyAnUEFTUycgOiAnRkFJTCd9ClRFWFQKcmVnZXhwID0gL1Rlc3RzICN7c3VjY2VzcyA/ICdQQVNTJyA6ICdGQUlMJ30vCgojIGdvb2QKc3RyaW5nID0gIlRlc3RzICN7c3VjY2VzcyA/ICJQQVNTIiA6ICJGQUlMIn0iCnN5bWJvbCA9IDoiVGVzdHMgI3tzdWNjZXNzID8gIlBBU1MiIDogIkZBSUwifSIKaGVyZWRvYyA9IDw8flRFWFQKICBUZXN0cyAje3N1Y2Nlc3MgPyAiUEFTUyIgOiAiRkFJTCJ9ClRFWFQKcmVnZXhwID0gL1Rlc3RzICN7c3VjY2VzcyA/ICJQQVNTIiA6ICJGQUlMIn0vCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHNpbmdsZV9xdW90ZXNgCnwgYHNpbmdsZV9xdW90ZXNgLCBgZG91YmxlX3F1b3Rlc2AKfD09PQoKPT0gU3R5bGUvU3RyaW5nTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjM0CnwgMC4zNAp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGNvbnNpc3RlbnQgbWV0aG9kIG5hbWVzCmZyb20gdGhlIFN0cmluZyBjbGFzcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiduYW1lJy5pbnRlcm4KJ3ZhcicudW5mYXZvcmVkX21ldGhvZAoKIyBnb29kCiduYW1lJy50b19zeW0KJ3ZhcicucHJlZmVycmVkX21ldGhvZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgUHJlZmVycmVkTWV0aG9kcwp8IGB7ImludGVybiI9PiJ0b19zeW0ifWAKfCAKfD09PQoKPT0gU3R5bGUvU3RyaXAKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjM2CnwgLQp8PT09CgpJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBgbHN0cmlwLnJzdHJpcGAgY2FuIGJlIHJlcGxhY2VkIGJ5CmBzdHJpcGAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAonYWJjJy5sc3RyaXAucnN0cmlwCidhYmMnLnJzdHJpcC5sc3RyaXAKCiMgZ29vZAonYWJjJy5zdHJpcAotLS0tCgo9PSBTdHlsZS9TdHJ1Y3RJbmhlcml0YW5jZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuMjkKfCAxLjIwCnw9PT0KCkNoZWNrcyBmb3IgaW5oZXJpdGFuY2UgZnJvbSBTdHJ1Y3QubmV3LgoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaXQgd2lsbCBjaGFuZ2UgdGhlIGluaGVyaXRhbmNlCnRyZWUgKGUuZy4gcmV0dXJuIHZhbHVlIG9mIGBNb2R1bGUjYW5jZXN0b3JzYCkgb2YgdGhlIGNvbnN0YW50LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgUGVyc29uIDwgU3RydWN0Lm5ldyg6Zmlyc3RfbmFtZSwgOmxhc3RfbmFtZSkKICBkZWYgYWdlCiAgICA0MgogIGVuZAplbmQKCiMgZ29vZApQZXJzb24gPSBTdHJ1Y3QubmV3KDpmaXJzdF9uYW1lLCA6bGFzdF9uYW1lKSBkbwogIGRlZiBhZ2UKICAgIDQyCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNuby1leHRlbmQtc3RydWN0LW5ldwoKPT0gU3R5bGUvU3VwZXJBcmd1bWVudHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjY0CnwgLQp8PT09CgpDaGVja3MgZm9yIHJlZHVuZGFudCBhcmd1bWVudCBmb3J3YXJkaW5nIHdoZW4gY2FsbGluZyBzdXBlcgp3aXRoIGFyZ3VtZW50cyBpZGVudGljYWwgdG8gdGhlIG1ldGhvZCBkZWZpbml0aW9uLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIG1ldGhvZCgqYXJncywgKiprd2FyZ3MpCiAgc3VwZXIoKmFyZ3MsICoqa3dhcmdzKQplbmQKCiMgZ29vZCAtIGltcGxpY2l0bHkgcGFzc2luZyBhbGwgYXJndW1lbnRzCmRlZiBtZXRob2QoKmFyZ3MsICoqa3dhcmdzKQogIHN1cGVyCmVuZAoKIyBnb29kIC0gZm9yd2FyZGluZyBhIHN1YnNldCBvZiB0aGUgYXJndW1lbnRzCmRlZiBtZXRob2QoKmFyZ3MsICoqa3dhcmdzKQogIHN1cGVyKCphcmdzKQplbmQKCiMgZ29vZCAtIGZvcndhcmRpbmcgbm8gYXJndW1lbnRzCmRlZiBtZXRob2QoKmFyZ3MsICoqa3dhcmdzKQogIHN1cGVyKCkKZW5kCi0tLS0KCj09IFN0eWxlL1N1cGVyV2l0aEFyZ3NQYXJlbnRoZXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDEuNTgKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSBwcmVzZW5jZSBvZiBwYXJlbnRoZXNlcyBpbiBgc3VwZXJgIGNvbnRhaW5pbmcgYXJndW1lbnRzLgoKYHN1cGVyYCBpcyBhIGtleXdvcmQgYW5kIGlzIHByb3ZpZGVkIGFzIGEgZGlzdGluY3QgY29wIGZyb20gdGhvc2UgZGVzaWduZWQgZm9yIG1ldGhvZCBjYWxsLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3VwZXIgbmFtZSwgYWdlCgojIGdvb2QKc3VwZXIobmFtZSwgYWdlKQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNzdXBlci13aXRoLWFyZ3MKCj09IFN0eWxlL1N3YXBWYWx1ZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAxLjEKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSB1c2Ugb2Ygc2hvcnRoYW5kLXN0eWxlIHN3YXBwaW5nIG9mIDIgdmFyaWFibGVzLgoKPT09IFNhZmV0eQoKQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlLCBiZWNhdXNlIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGUgdXNlZCB0bwpzd2FwIHZhcmlhYmxlcyB3aWxsIGJlIHJlbW92ZWQsIGJ1dCBtYXkgYmUgcmVmZXJyZWQgdG8gZWxzZXdoZXJlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKdG1wID0geAp4ID0geQp5ID0gdG1wCgojIGdvb2QKeCwgeSA9IHksIHgKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjdmFsdWVzLXN3YXBwaW5nCgo9PSBTdHlsZS9TeW1ib2xBcnJheQoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjAKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjQ5Cnw9PT0KCkNoZWNrcyBmb3IgYXJyYXkgbGl0ZXJhbHMgbWFkZSB1cCBvZiBzeW1ib2xzIHRoYXQgYXJlIG5vdAp1c2luZyB0aGUgJWkoKSBzeW50YXguCgpBbHRlcm5hdGl2ZWx5LCBpdCBjaGVja3MgZm9yIHN5bWJvbCBhcnJheXMgdXNpbmcgdGhlICVpKCkgc3ludGF4IG9uCnByb2plY3RzIHdoaWNoIGRvIG5vdCB3YW50IHRvIHVzZSB0aGF0IHN5bnRheCwgcGVyaGFwcyBiZWNhdXNlIHRoZXkKc3VwcG9ydCBhIHZlcnNpb24gb2YgUnVieSBsb3dlciB0aGFuIDIuMC4KCkNvbmZpZ3VyYXRpb24gb3B0aW9uOiBNaW5TaXplCklmIHNldCwgYXJyYXlzIHdpdGggZmV3ZXIgZWxlbWVudHMgdGhhbiB0aGlzIHZhbHVlIHdpbGwgbm90IHRyaWdnZXIgdGhlCmNvcC4gRm9yIGV4YW1wbGUsIGEgYE1pblNpemVgIG9mIGAzYCB3aWxsIG5vdCBlbmZvcmNlIGEgc3R5bGUgb24gYW4KYXJyYXkgb2YgMiBvciBmZXdlciBlbGVtZW50cy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBwZXJjZW50IChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAolaVtmb28gYmFyIGJhel0KCiMgYmFkCls6Zm9vLCA6YmFyLCA6YmF6XQoKIyBiYWQgKGNvbnRhaW5zIHNwYWNlcykKJWlbZm9vXCBiYXIgYmF6XCBxdXV4XQoKIyBiYWQgKGNvbnRhaW5zIFtdIHdpdGggc3BhY2VzKQolaVtmb28gXFsgXF1dCgojIGJhZCAoY29udGFpbnMgKCkgd2l0aCBzcGFjZXMpCiVpKGZvbyBcKCBcKSkKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBicmFja2V0cwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApbOmZvbywgOmJhciwgOmJhel0KCiMgYmFkCiVpW2ZvbyBiYXIgYmF6XQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBwZXJjZW50YAp8IGBwZXJjZW50YCwgYGJyYWNrZXRzYAoKfCBNaW5TaXplCnwgYDJgCnwgSW50ZWdlcgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSNwZXJjZW50LWkKCj09IFN0eWxlL1N5bWJvbExpdGVyYWwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjMwCnwgLQp8PT09CgpDaGVja3Mgc3ltYm9sIGxpdGVyYWwgc3ludGF4LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKOiJzeW1ib2wiCgojIGdvb2QKOnN5bWJvbAotLS0tCgo9PSBTdHlsZS9TeW1ib2xQcm9jCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjI2CnwgMS42NAp8PT09CgpVc2Ugc3ltYm9scyBhcyBwcm9jcyB3aGVuIHBvc3NpYmxlLgoKSWYgeW91IHByZWZlciBhIHN0eWxlIHRoYXQgYWxsb3dzIGJsb2NrIGZvciBtZXRob2Qgd2l0aCBhcmd1bWVudHMsCnBsZWFzZSBzZXQgYHRydWVgIHRvIGBBbGxvd01ldGhvZHNXaXRoQXJndW1lbnRzYC4KYGRlZmluZV9tZXRob2Q/YCBtZXRob2RzIGFyZSBhbGxvd2VkIGJ5IGRlZmF1bHQuClRoZXNlIGFyZSBjdXN0b21pemFibGUgd2l0aCBgQWxsb3dlZE1ldGhvZHNgIG9wdGlvbi4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIHRoZXJlIGlzIGEgZGlmZmVyZW5jZSB0aGF0IGEgYFByb2NgCmdlbmVyYXRlZCBmcm9tIGBTeW1ib2wjdG9fcHJvY2AgYmVoYXZlcyBhcyBhIGxhbWJkYSwgd2hpbGUKYSBgUHJvY2AgZ2VuZXJhdGVkIGZyb20gYSBibG9jayBkb2VzIG5vdC4KRm9yIGV4YW1wbGUsIGEgbGFtYmRhIHdpbGwgcmFpc2UgYW4gYEFyZ3VtZW50RXJyb3JgIGlmIHRoZQpudW1iZXIgb2YgYXJndW1lbnRzIGlzIHdyb25nLCBidXQgYSBub24tbGFtYmRhIGBQcm9jYCB3aWxsIG5vdC4KCkZvciBleGFtcGxlOgoKW3NvdXJjZSxydWJ5XQotLS0tCmNsYXNzIEZvbwogIGRlZiBiYXIKICAgIDpiYXIKICBlbmQKZW5kCgpkZWYgY2FsbChvcHRpb25zID0ge30sICZibG9jaykKICBibG9jay5jYWxsKEZvby5uZXcsIG9wdGlvbnMpCmVuZAoKY2FsbCB7IHx4fCB4LmJhciB9CiM9PiA6YmFyCmNhbGwoJjpiYXIpCiMgQXJndW1lbnRFcnJvcjogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMSwgZXhwZWN0ZWQgMCkKLS0tLQoKSXQgaXMgYWxzbyB1bnNhZmUgYmVjYXVzZSBgU3ltYm9sI3RvX3Byb2NgIGRvZXMgbm90IHdvcmsgd2l0aApgcHJvdGVjdGVkYCBtZXRob2RzIHdoaWNoIHdvdWxkIG90aGVyd2lzZSBiZSBhY2Nlc3NpYmxlLgoKRm9yIGV4YW1wbGU6Cgpbc291cmNlLHJ1YnldCi0tLS0KY2xhc3MgQm94CiAgZGVmIGluaXRpYWxpemUKICAgIEBzZWNyZXQgPSByYW5kCiAgZW5kCgogIGRlZiBub3JtYWxfbWF0Y2hlcz8oKm90aGVycykKICAgIG90aGVycy5tYXAgeyB8b3RoZXJ8IG90aGVyLnNlY3JldCB9LmFueT8oc2VjcmV0KQogIGVuZAoKICBkZWYgc3ltYm9sX3RvX3Byb2NfbWF0Y2hlcz8oKm90aGVycykKICAgIG90aGVycy5tYXAoJjpzZWNyZXQpLmFueT8oc2VjcmV0KQogIGVuZAoKICBwcm90ZWN0ZWQKCiAgYXR0cl9yZWFkZXIgOnNlY3JldAplbmQKCmJveGVzID0gW0JveC5uZXcsIEJveC5uZXddCkJveC5uZXcubm9ybWFsX21hdGNoZXM/KCpib3hlcykKIyA9PiBmYWxzZQpib3hlcy5maXJzdC5ub3JtYWxfbWF0Y2hlcz8oKmJveGVzKQojID0+IHRydWUKQm94Lm5ldy5zeW1ib2xfdG9fcHJvY19tYXRjaGVzPygqYm94ZXMpCiMgPT4gTm9NZXRob2RFcnJvcjogcHJvdGVjdGVkIG1ldGhvZCBgc2VjcmV0JyBjYWxsZWQgZm9yICM8Qm94Li4uPgpib3hlcy5maXJzdC5zeW1ib2xfdG9fcHJvY19tYXRjaGVzPygqYm94ZXMpCiMgPT4gTm9NZXRob2RFcnJvcjogcHJvdGVjdGVkIG1ldGhvZCBgc2VjcmV0JyBjYWxsZWQgZm9yICM8Qm94Li4uPgotLS0tCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzb21ldGhpbmcubWFwIHsgfHN8IHMudXBjYXNlIH0Kc29tZXRoaW5nLm1hcCB7IF8xLnVwY2FzZSB9CgojIGdvb2QKc29tZXRoaW5nLm1hcCgmOnVwY2FzZSkKLS0tLQoKPT09PSBBbGxvd01ldGhvZHNXaXRoQXJndW1lbnRzOiBmYWxzZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzb21ldGhpbmcuZG9fc29tZXRoaW5nKGZvbykgeyB8b3wgby5iYXIgfQoKIyBnb29kCnNvbWV0aGluZy5kb19zb21ldGhpbmcoZm9vLCAmOmJhcikKLS0tLQoKPT09PSBBbGxvd01ldGhvZHNXaXRoQXJndW1lbnRzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCnNvbWV0aGluZy5kb19zb21ldGhpbmcoZm9vKSB7IHxvfCBvLmJhciB9Ci0tLS0KCj09PT0gQWxsb3dDb21tZW50czogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc29tZXRoaW5nLmRvX3NvbWV0aGluZyBkbyB8c3wgIyBzb21lIGNvbW1lbnQKICAjIHNvbWUgY29tbWVudAogIHMudXBjYXNlICMgc29tZSBjb21tZW50CiAgIyBzb21lIGNvbW1lbnQKZW5kCi0tLS0KCj09PT0gQWxsb3dDb21tZW50czogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZCAgLSBpZiB0aGVyZSBhcmUgY29tbWVudCBpbiBlaXRoZXIgcG9zaXRpb24Kc29tZXRoaW5nLmRvX3NvbWV0aGluZyBkbyB8c3wgIyBzb21lIGNvbW1lbnQKICAjIHNvbWUgY29tbWVudAogIHMudXBjYXNlICMgc29tZSBjb21tZW50CiAgIyBzb21lIGNvbW1lbnQKZW5kCi0tLS0KCj09PT0gQWxsb3dlZE1ldGhvZHM6IFtkZWZpbmVfbWV0aG9kXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmaW5lX21ldGhvZCg6Zm9vKSB7IHxmb298IGZvby5iYXIgfQotLS0tCgo9PT09IEFsbG93ZWRQYXR0ZXJuczogW10gKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc29tZXRoaW5nLm1hcCB7IHxzfCBzLnVwY2FzZSB9Ci0tLS0KCj09PT0gQWxsb3dlZFBhdHRlcm5zOiBbJ21hcCddIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApzb21ldGhpbmcubWFwIHsgfHN8IHMudXBjYXNlIH0KLS0tLQoKPT09PSBBbGxDb3BzOkFjdGl2ZVN1cHBvcnRFeHRlbnNpb25zRW5hYmxlZDogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKLT4oeCkgeyB4LmZvbyB9CnByb2MgeyB8eHwgeC5mb28gfQpQcm9jLm5ldyB7IHx4fCB4LmZvbyB9CgojIGdvb2QKbGFtYmRhKCY6Zm9vKQpwcm9jKCY6Zm9vKQpQcm9jLm5ldygmOmZvbykKLS0tLQoKPT09PSBBbGxDb3BzOkFjdGl2ZVN1cHBvcnRFeHRlbnNpb25zRW5hYmxlZDogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAotPih4KSB7IHguZm9vIH0KcHJvYyB7IHx4fCB4LmZvbyB9ClByb2MubmV3IHsgfHh8IHguZm9vIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93TWV0aG9kc1dpdGhBcmd1bWVudHMKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBBbGxvd2VkTWV0aG9kcwp8IGBkZWZpbmVfbWV0aG9kYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQoKfCBBbGxvd0NvbW1lbnRzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT0gU3R5bGUvVGVybmFyeVBhcmVudGhlc2VzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC40Mgp8IDAuNDYKfD09PQoKQ2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgcGFyZW50aGVzZXMgYXJvdW5kIHRlcm5hcnkKY29uZGl0aW9ucy4gSXQgaXMgY29uZmlndXJhYmxlIHRvIGVuZm9yY2UgaW5jbHVzaW9uIG9yIG9taXNzaW9uIG9mCnBhcmVudGhlc2VzIHVzaW5nIGBFbmZvcmNlZFN0eWxlYC4gT21pc3Npb24gaXMgb25seSBlbmZvcmNlZCB3aGVuCnJlbW92aW5nIHRoZSBwYXJlbnRoZXNlcyB3b24ndCBjYXVzZSBhIGRpZmZlcmVudCBiZWhhdmlvci4KCmBBbGxvd1NhZmVBc3NpZ25tZW50YCBvcHRpb24gZm9yIHNhZmUgYXNzaWdubWVudC4KQnkgc2FmZSBhc3NpZ25tZW50IHdlIG1lYW4gcHV0dGluZyBwYXJlbnRoZXNlcyBhcm91bmQKYW4gYXNzaWdubWVudCB0byBpbmRpY2F0ZSAiSSBrbm93IEknbSB1c2luZyBhbiBhc3NpZ25tZW50CmFzIGEgY29uZGl0aW9uLiBJdCdzIG5vdCBhIG1pc3Rha2UuIgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfbm9fcGFyZW50aGVzZXMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vID0gKGJhcj8pID8gYSA6IGIKZm9vID0gKGJhci5iYXo/KSA/IGEgOiBiCmZvbyA9IChiYXIgJiYgYmF6KSA/IGEgOiBiCgojIGdvb2QKZm9vID0gYmFyPyA/IGEgOiBiCmZvbyA9IGJhci5iYXo/ID8gYSA6IGIKZm9vID0gYmFyICYmIGJheiA/IGEgOiBiCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmVxdWlyZV9wYXJlbnRoZXNlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvbyA9IGJhcj8gPyBhIDogYgpmb28gPSBiYXIuYmF6PyA/IGEgOiBiCmZvbyA9IGJhciAmJiBiYXogPyBhIDogYgoKIyBnb29kCmZvbyA9IChiYXI/KSA/IGEgOiBiCmZvbyA9IChiYXIuYmF6PykgPyBhIDogYgpmb28gPSAoYmFyICYmIGJheikgPyBhIDogYgotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfcGFyZW50aGVzZXNfd2hlbl9jb21wbGV4Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vID0gKGJhcj8pID8gYSA6IGIKZm9vID0gKGJhci5iYXo/KSA/IGEgOiBiCmZvbyA9IGJhciAmJiBiYXogPyBhIDogYgoKIyBnb29kCmZvbyA9IGJhcj8gPyBhIDogYgpmb28gPSBiYXIuYmF6PyA/IGEgOiBiCmZvbyA9IChiYXIgJiYgYmF6KSA/IGEgOiBiCi0tLS0KCj09PT0gQWxsb3dTYWZlQXNzaWdubWVudDogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZm9vID0gKGJhciA9IGJheikgPyBhIDogYgotLS0tCgo9PT09IEFsbG93U2FmZUFzc2lnbm1lbnQ6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZm9vID0gKGJhciA9IGJheikgPyBhIDogYgotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGByZXF1aXJlX25vX3BhcmVudGhlc2VzYAp8IGByZXF1aXJlX3BhcmVudGhlc2VzYCwgYHJlcXVpcmVfbm9fcGFyZW50aGVzZXNgLCBgcmVxdWlyZV9wYXJlbnRoZXNlc193aGVuX2NvbXBsZXhgCgp8IEFsbG93U2FmZUFzc2lnbm1lbnQKfCBgdHJ1ZWAKfCBCb29sZWFuCnw9PT0KCj09IFN0eWxlL1RvcExldmVsTWV0aG9kRGVmaW5pdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDEuMTUKfCAtCnw9PT0KCk5ld2NvbWVycyB0byBydWJ5IGFwcGxpY2F0aW9ucyBtYXkgd3JpdGUgdG9wLWxldmVsIG1ldGhvZHMsCndoZW4gaWRlYWxseSB0aGV5IHNob3VsZCBiZSBvcmdhbml6ZWQgaW4gYXBwcm9wcmlhdGUgY2xhc3NlcyBvciBtb2R1bGVzLgpUaGlzIGNvcCBsb29rcyBmb3IgZGVmaW5pdGlvbnMgb2YgdG9wLWxldmVsIG1ldGhvZHMgYW5kIHdhcm5zIGFib3V0IHRoZW0uCgpIb3dldmVyIGZvciBydWJ5IHNjcmlwdHMgaXQgaXMgcGVyZmVjdGx5IGZpbmUgdG8gdXNlIHRvcC1sZXZlbCBtZXRob2RzLgpIZW5jZSB0aGlzIGNvcCBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHNvbWVfbWV0aG9kCmVuZAoKIyBiYWQKZGVmIHNlbGYuc29tZV9tZXRob2QKZW5kCgojIGJhZApkZWZpbmVfbWV0aG9kKDpmb28pIHsgcHV0cyAxIH0KCiMgZ29vZAptb2R1bGUgRm9vCiAgZGVmIHNvbWVfbWV0aG9kCiAgZW5kCmVuZAoKIyBnb29kCmNsYXNzIEZvbwogIGRlZiBzZWxmLnNvbWVfbWV0aG9kCiAgZW5kCmVuZAoKIyBnb29kClN0cnVjdC5uZXcgZG8KICBkZWYgc29tZV9tZXRob2QKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgRm9vCiAgZGVmaW5lX21ldGhvZCg6Zm9vKSB7IHB1dHMgMSB9CmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSN0b3AtbGV2ZWwtbWV0aG9kcwoKPT0gU3R5bGUvVHJhaWxpbmdCb2R5T25DbGFzcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdHJhaWxpbmcgY29kZSBhZnRlciB0aGUgY2xhc3MgZGVmaW5pdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEZvbzsgZGVmIGZvbzsgZW5kCmVuZAoKIyBnb29kCmNsYXNzIEZvbwogIGRlZiBmb287IGVuZAplbmQKLS0tLQoKPT0gU3R5bGUvVHJhaWxpbmdCb2R5T25NZXRob2REZWZpbml0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciB0cmFpbGluZyBjb2RlIGFmdGVyIHRoZSBtZXRob2QgZGVmaW5pdGlvbi4KCk5PVEU6IEl0IGFsd2F5cyBhY2NlcHRzIGVuZGxlc3MgbWV0aG9kIGRlZmluaXRpb25zIHRoYXQgYXJlIGJhc2ljYWxseSBvbiB0aGUgc2FtZSBsaW5lLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHNvbWVfbWV0aG9kOyBkb19zdHVmZgplbmQKCmRlZiBmKHgpOyBiID0gZm9vCiAgYltjOiB4XQplbmQKCiMgZ29vZApkZWYgc29tZV9tZXRob2QKICBkb19zdHVmZgplbmQKCmRlZiBmKHgpCiAgYiA9IGZvbwogIGJbYzogeF0KZW5kCgpkZWYgZW5kbGVzc19tZXRob2QgPSBkb19zdHVmZgotLS0tCgo9PSBTdHlsZS9UcmFpbGluZ0JvZHlPbk1vZHVsZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdHJhaWxpbmcgY29kZSBhZnRlciB0aGUgbW9kdWxlIGRlZmluaXRpb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAptb2R1bGUgRm9vIGV4dGVuZCBzZWxmCmVuZAoKIyBnb29kCm1vZHVsZSBGb28KICBleHRlbmQgc2VsZgplbmQKLS0tLQoKPT0gU3R5bGUvVHJhaWxpbmdDb21tYUluQXJndW1lbnRzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4zNgp8IC0KfD09PQoKQ2hlY2tzIGZvciB0cmFpbGluZyBjb21tYSBpbiBhcmd1bWVudCBsaXN0cy4KVGhlIHN1cHBvcnRlZCBzdHlsZXMgYXJlOgoKKiBgY29uc2lzdGVudF9jb21tYWA6IFJlcXVpcmVzIGEgY29tbWEgYWZ0ZXIgdGhlIGxhc3QgYXJndW1lbnQsCmZvciBhbGwgcGFyZW50aGVzaXplZCBtZXRob2QgY2FsbHMgd2l0aCBhcmd1bWVudHMuCiogYGNvbW1hYDogUmVxdWlyZXMgYSBjb21tYSBhZnRlciB0aGUgbGFzdCBhcmd1bWVudCwgYnV0IG9ubHkgZm9yCnBhcmVudGhlc2l6ZWQgbWV0aG9kIGNhbGxzIHdoZXJlIGVhY2ggYXJndW1lbnQgaXMgb24gaXRzIG93biBsaW5lLgoqIGBub19jb21tYWA6IFJlcXVpcmVzIHRoYXQgdGhlcmUgaXMgbm8gY29tbWEgYWZ0ZXIgdGhlIGxhc3QKYXJndW1lbnQuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZUZvck11bHRpbGluZTogY29uc2lzdGVudF9jb21tYQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm1ldGhvZCgxLCAyLCkKCiMgZ29vZAptZXRob2QoMSwgMikKCiMgZ29vZAptZXRob2QoCiAgMSwgMiwKICAzLAopCgojIGdvb2QKbWV0aG9kKAogIDEsIDIsIDMsCikKCiMgZ29vZAptZXRob2QoCiAgMSwKICAyLAopCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZUZvck11bHRpbGluZTogY29tbWEKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAptZXRob2QoMSwgMiwpCgojIGdvb2QKbWV0aG9kKDEsIDIpCgojIGJhZAptZXRob2QoCiAgMSwgMiwKICAzLAopCgojIGdvb2QKbWV0aG9kKAogIDEsIDIsCiAgMwopCgojIGJhZAptZXRob2QoCiAgMSwgMiwgMywKKQoKIyBnb29kCm1ldGhvZCgKICAxLCAyLCAzCikKCiMgZ29vZAptZXRob2QoCiAgMSwKICAyLAopCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZUZvck11bHRpbGluZTogbm9fY29tbWEgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbWV0aG9kKDEsIDIsKQoKIyBnb29kCm1ldGhvZCgxLCAyKQoKIyBnb29kCm1ldGhvZCgKICAxLAogIDIKKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZUZvck11bHRpbGluZQp8IGBub19jb21tYWAKfCBgY29tbWFgLCBgY29uc2lzdGVudF9jb21tYWAsIGBub19jb21tYWAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tdHJhaWxpbmctcGFyYW1zLWNvbW1hCgo9PSBTdHlsZS9UcmFpbGluZ0NvbW1hSW5BcnJheUxpdGVyYWwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUzCnwgLQp8PT09CgpDaGVja3MgZm9yIHRyYWlsaW5nIGNvbW1hIGluIGFycmF5IGxpdGVyYWxzLgpUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZToKCiogYGNvbnNpc3RlbnRfY29tbWFgOiBSZXF1aXJlcyBhIGNvbW1hIGFmdGVyIHRoZQpsYXN0IGl0ZW0gb2YgYWxsIG5vbi1lbXB0eSwgbXVsdGlsaW5lIGFycmF5IGxpdGVyYWxzLgoqIGBjb21tYWA6IFJlcXVpcmVzIGEgY29tbWEgYWZ0ZXIgbGFzdCBpdGVtIGluIGFuIGFycmF5LApidXQgb25seSB3aGVuIGVhY2ggaXRlbSBpcyBvbiBpdHMgb3duIGxpbmUuCiogYG5vX2NvbW1hYDogRG9lcyBub3QgcmVxdWlyZSBhIGNvbW1hIGFmdGVyIHRoZQpsYXN0IGl0ZW0gaW4gYW4gYXJyYXkKCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBjb25zaXN0ZW50X2NvbW1hCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSA9IFsxLCAyLF0KCiMgZ29vZAphID0gWzEsIDJdCgojIGdvb2QKYSA9IFsKICAxLCAyLAogIDMsCl0KCiMgZ29vZAphID0gWwogIDEsIDIsIDMsCl0KCiMgZ29vZAphID0gWwogIDEsCiAgMiwKXQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGVGb3JNdWx0aWxpbmU6IGNvbW1hCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSA9IFsxLCAyLF0KCiMgZ29vZAphID0gWzEsIDJdCgojIGJhZAphID0gWwogIDEsIDIsCiAgMywKXQoKIyBnb29kCmEgPSBbCiAgMSwgMiwKICAzCl0KCiMgYmFkCmEgPSBbCiAgMSwgMiwgMywKXQoKIyBnb29kCmEgPSBbCiAgMSwgMiwgMwpdCgojIGdvb2QKYSA9IFsKICAxLAogIDIsCl0KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBub19jb21tYSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphID0gWzEsIDIsXQoKIyBnb29kCmEgPSBbCiAgMSwKICAyCl0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGVGb3JNdWx0aWxpbmUKfCBgbm9fY29tbWFgCnwgYGNvbW1hYCwgYGNvbnNpc3RlbnRfY29tbWFgLCBgbm9fY29tbWFgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLXRyYWlsaW5nLWFycmF5LWNvbW1hcwoKPT0gU3R5bGUvVHJhaWxpbmdDb21tYUluQmxvY2tBcmdzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC44MQp8IC0KfD09PQoKQ2hlY2tzIHdoZXRoZXIgdHJhaWxpbmcgY29tbWFzIGluIGJsb2NrIGFyZ3VtZW50cyBhcmUKcmVxdWlyZWQuIEJsb2NrcyB3aXRoIG9ubHkgb25lIGFyZ3VtZW50IGFuZCBhIHRyYWlsaW5nIGNvbW1hIHJlcXVpcmUKdGhhdCBjb21tYSB0byBiZSBwcmVzZW50LiBCbG9ja3Mgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IG5ldmVyCnJlcXVpcmUgYSB0cmFpbGluZyBjb21tYS4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGEgdHJhaWxpbmcgY29tbWEgY2FuIGluZGljYXRlIHRoZXJlIGFyZQptb3JlIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHVzZWQuCgpGb3IgZXhhbXBsZToKW3NvdXJjZSxydWJ5XQotLS0tCiMgd2l0aCBhIHRyYWlsaW5nIGNvbW1hCntmb286IDEsIGJhcjogMiwgYmF6OiAzfS5tYXAge3xrZXksfCBrZXkgfQojPT4gWzpmb28sIDpiYXIsIDpiYXpdCgojIHdpdGhvdXQgYSB0cmFpbGluZyBjb21tYQp7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30ubWFwIHt8a2V5fCBrZXkgfQojPT4gW1s6Zm9vLCAxXSwgWzpiYXIsIDJdLCBbOmJheiwgM11dCi0tLS0KClRoaXMgY2FuIGJlIGZpeGVkIGJ5IHJlcGxhY2luZyB0aGUgdHJhaWxpbmcgY29tbWEgd2l0aCBhIHBsYWNlaG9sZGVyCmFyZ3VtZW50IChzdWNoIGFzIGB8a2V5LCBfdmFsdWV8YCkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphZGQgeyB8Zm9vLCBiYXIsfCBmb28gKyBiYXIgfQoKIyBnb29kCmFkZCB7IHxmb28sIGJhcnwgZm9vICsgYmFyIH0KCiMgZ29vZAphZGQgeyB8Zm9vLHwgZm9vIH0KCiMgZ29vZAphZGQgeyBmb28gfQoKIyBiYWQKYWRkIGRvIHxmb28sIGJhcix8CiAgZm9vICsgYmFyCmVuZAoKIyBnb29kCmFkZCBkbyB8Zm9vLCBiYXJ8CiAgZm9vICsgYmFyCmVuZAoKIyBnb29kCmFkZCBkbyB8Zm9vLHwKICBmb28KZW5kCgojIGdvb2QKYWRkIGRvCiAgZm9vICsgYmFyCmVuZAotLS0tCgo9PSBTdHlsZS9UcmFpbGluZ0NvbW1hSW5IYXNoTGl0ZXJhbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdHJhaWxpbmcgY29tbWEgaW4gaGFzaCBsaXRlcmFscy4KVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmU6CgoqIGBjb25zaXN0ZW50X2NvbW1hYDogUmVxdWlyZXMgYSBjb21tYSBhZnRlciB0aGUKbGFzdCBpdGVtIG9mIGFsbCBub24tZW1wdHksIG11bHRpbGluZSBoYXNoIGxpdGVyYWxzLgoqIGBjb21tYWA6IFJlcXVpcmVzIGEgY29tbWEgYWZ0ZXIgdGhlIGxhc3QgaXRlbSBpbiBhIGhhc2gsCmJ1dCBvbmx5IHdoZW4gZWFjaCBpdGVtIGlzIG9uIGl0cyBvd24gbGluZS4KKiBgbm9fY29tbWFgOiBEb2VzIG5vdCByZXF1aXJlIGEgY29tbWEgYWZ0ZXIgdGhlCmxhc3QgaXRlbSBpbiBhIGhhc2gKCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBjb25zaXN0ZW50X2NvbW1hCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYSA9IHsgZm9vOiAxLCBiYXI6IDIsIH0KCiMgZ29vZAphID0geyBmb286IDEsIGJhcjogMiB9CgojIGdvb2QKYSA9IHsKICBmb286IDEsIGJhcjogMiwKICBxdXg6IDMsCn0KCiMgZ29vZAphID0gewogIGZvbzogMSwgYmFyOiAyLCBxdXg6IDMsCn0KCiMgZ29vZAphID0gewogIGZvbzogMSwKICBiYXI6IDIsCn0KLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBjb21tYQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgPSB7IGZvbzogMSwgYmFyOiAyLCB9CgojIGdvb2QKYSA9IHsgZm9vOiAxLCBiYXI6IDIgfQoKIyBiYWQKYSA9IHsKICBmb286IDEsIGJhcjogMiwKICBxdXg6IDMsCn0KCiMgZ29vZAphID0gewogIGZvbzogMSwgYmFyOiAyLAogIHF1eDogMwp9CgojIGJhZAphID0gewogIGZvbzogMSwgYmFyOiAyLCBxdXg6IDMsCn0KCiMgZ29vZAphID0gewogIGZvbzogMSwgYmFyOiAyLCBxdXg6IDMKfQoKIyBnb29kCmEgPSB7CiAgZm9vOiAxLAogIGJhcjogMiwKfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGVGb3JNdWx0aWxpbmU6IG5vX2NvbW1hIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEgPSB7IGZvbzogMSwgYmFyOiAyLCB9CgojIGdvb2QKYSA9IHsKICBmb286IDEsCiAgYmFyOiAyCn0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGVGb3JNdWx0aWxpbmUKfCBgbm9fY29tbWFgCnwgYGNvbW1hYCwgYGNvbnNpc3RlbnRfY29tbWFgLCBgbm9fY29tbWFgCnw9PT0KCj09IFN0eWxlL1RyYWlsaW5nTWV0aG9kRW5kU3RhdGVtZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciB0cmFpbGluZyBjb2RlIGFmdGVyIHRoZSBtZXRob2QgZGVmaW5pdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBzb21lX21ldGhvZApkb19zdHVmZjsgZW5kCgpkZWYgZG9fdGhpcyh4KQogIGJhei5tYXAgeyB8YnwgYi50aGlzKHgpIH0gZW5kCgpkZWYgZm9vCiAgYmxvY2sgZG8KICAgIGJhcgogIGVuZCBlbmQKCiMgZ29vZApkZWYgc29tZV9tZXRob2QKICBkb19zdHVmZgplbmQKCmRlZiBkb190aGlzKHgpCiAgYmF6Lm1hcCB7IHxifCBiLnRoaXMoeCkgfQplbmQKCmRlZiBmb28KICBibG9jayBkbwogICAgYmFyCiAgZW5kCmVuZAotLS0tCgo9PSBTdHlsZS9UcmFpbGluZ1VuZGVyc2NvcmVWYXJpYWJsZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzEKfCAwLjM1Cnw9PT0KCkNoZWNrcyBmb3IgZXh0cmEgdW5kZXJzY29yZXMgaW4gdmFyaWFibGUgYXNzaWdubWVudC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmEsIGIsIF8gPSBmb28oKQphLCBiLCBfLCA9IGZvbygpCmEsIF8sIF8gPSBmb28oKQphLCBfLCBfLCA9IGZvbygpCgojIGdvb2QKYSwgYiwgPSBmb28oKQphLCA9IGZvbygpCiphLCBiLCBfID0gZm9vKCkKIyA9PiBXZSBuZWVkIHRvIGtub3cgdG8gbm90IGluY2x1ZGUgMiB2YXJpYWJsZXMgaW4gYQphLCAqYiwgXyA9IGZvbygpCiMgPT4gVGhlIGNvcnJlY3Rpb24gYGEsICpiLCA9IGZvbygpYCBpcyBhIHN5bnRheCBlcnJvcgotLS0tCgo9PT09IEFsbG93TmFtZWRVbmRlcnNjb3JlVmFyaWFibGVzOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAphLCBiLCBfc29tZXRoaW5nID0gZm9vKCkKLS0tLQoKPT09PSBBbGxvd05hbWVkVW5kZXJzY29yZVZhcmlhYmxlczogZmFsc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphLCBiLCBfc29tZXRoaW5nID0gZm9vKCkKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93TmFtZWRVbmRlcnNjb3JlVmFyaWFibGVzCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PSBTdHlsZS9Ucml2aWFsQWNjZXNzb3JzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMS4xNQp8PT09CgpMb29rcyBmb3IgdHJpdmlhbCByZWFkZXIvd3JpdGVyIG1ldGhvZHMsIHRoYXQgY291bGQKaGF2ZSBiZWVuIGNyZWF0ZWQgd2l0aCB0aGUgYXR0cl8qIGZhbWlseSBvZiBmdW5jdGlvbnMgYXV0b21hdGljYWxseS4KYHRvX2FyeWAsIGB0b19hYCwgYHRvX2NgLCBgdG9fZW51bWAsIGB0b19oYCwgYHRvX2hhc2hgLCBgdG9faWAsIGB0b19pbnRgLCBgdG9faW9gLApgdG9fb3BlbmAsIGB0b19wYXRoYCwgYHRvX3Byb2NgLCBgdG9fcmAsIGB0b19yZWdleHBgLCBgdG9fc3RyYCwgYHRvX3NgLCBhbmQgYHRvX3N5bWAgbWV0aG9kcwphcmUgYWxsb3dlZCBieSBkZWZhdWx0LiBUaGVzZSBhcmUgY3VzdG9taXphYmxlIHdpdGggYEFsbG93ZWRNZXRob2RzYCBvcHRpb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgZm9vCiAgQGZvbwplbmQKCmRlZiBiYXI9KHZhbCkKICBAYmFyID0gdmFsCmVuZAoKZGVmIHNlbGYuYmF6CiAgQGJhegplbmQKCiMgZ29vZAphdHRyX3JlYWRlciA6Zm9vCmF0dHJfd3JpdGVyIDpiYXIKCmNsYXNzIDw8IHNlbGYKICBhdHRyX3JlYWRlciA6YmF6CmVuZAotLS0tCgo9PT09IEV4YWN0TmFtZU1hdGNoOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgbmFtZQogIEBvdGhlcl9uYW1lCmVuZAotLS0tCgo9PT09IEV4YWN0TmFtZU1hdGNoOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBuYW1lCiAgQG90aGVyX25hbWUKZW5kCi0tLS0KCj09PT0gQWxsb3dQcmVkaWNhdGVzOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgZm9vPwogIEBmb28KZW5kCi0tLS0KCj09PT0gQWxsb3dQcmVkaWNhdGVzOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb28/CiAgQGZvbwplbmQKCiMgZ29vZAphdHRyX3JlYWRlciA6Zm9vCi0tLS0KCj09PT0gQWxsb3dEU0xXcml0ZXJzOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgb25fZXhjZXB0aW9uKGFjdGlvbikKICBAb25fZXhjZXB0aW9uPWFjdGlvbgplbmQKLS0tLQoKPT09PSBBbGxvd0RTTFdyaXRlcnM6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIG9uX2V4Y2VwdGlvbihhY3Rpb24pCiAgQG9uX2V4Y2VwdGlvbj1hY3Rpb24KZW5kCgojIGdvb2QKYXR0cl93cml0ZXIgOm9uX2V4Y2VwdGlvbgotLS0tCgo9PT09IElnbm9yZUNsYXNzTWV0aG9kczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHNlbGYuZm9vCiAgQGZvbwplbmQKCiMgZ29vZApjbGFzcyA8PCBzZWxmCiAgYXR0cl9yZWFkZXIgOmZvbwplbmQKLS0tLQoKPT09PSBJZ25vcmVDbGFzc01ldGhvZHM6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVmIHNlbGYuZm9vCiAgQGZvbwplbmQKLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogWydhbGxvd2VkX21ldGhvZCddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBhbGxvd2VkX21ldGhvZAogIEBmb28KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFeGFjdE5hbWVNYXRjaAp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dQcmVkaWNhdGVzCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBBbGxvd0RTTFdyaXRlcnMKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IElnbm9yZUNsYXNzTWV0aG9kcwp8IGBmYWxzZWAKfCBCb29sZWFuCgp8IEFsbG93ZWRNZXRob2RzCnwgYHRvX2FyeWAsIGB0b19hYCwgYHRvX2NgLCBgdG9fZW51bWAsIGB0b19oYCwgYHRvX2hhc2hgLCBgdG9faWAsIGB0b19pbnRgLCBgdG9faW9gLCBgdG9fb3BlbmAsIGB0b19wYXRoYCwgYHRvX3Byb2NgLCBgdG9fcmAsIGB0b19yZWdleHBgLCBgdG9fc3RyYCwgYHRvX3NgLCBgdG9fc3ltYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2F0dHJfZmFtaWx5Cgo9PSBTdHlsZS9Vbmxlc3NFbHNlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgLQp8PT09CgpMb29rcyBmb3IgYHVubGVzc2AgZXhwcmVzc2lvbnMgd2l0aCBgZWxzZWAgY2xhdXNlcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnVubGVzcyBmb29fYmFyLm5pbD8KICAjIGRvIHNvbWV0aGluZy4uLgplbHNlCiAgIyBkbyBhIGRpZmZlcmVudCB0aGluZy4uLgplbmQKCiMgZ29vZAppZiBmb29fYmFyLnByZXNlbnQ/CiAgIyBkbyBzb21ldGhpbmcuLi4KZWxzZQogICMgZG8gYSBkaWZmZXJlbnQgdGhpbmcuLi4KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI25vLWVsc2Utd2l0aC11bmxlc3MKCj09IFN0eWxlL1VubGVzc0xvZ2ljYWxPcGVyYXRvcnMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgTm8KfCAxLjExCnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSB1c2Ugb2YgbG9naWNhbCBvcGVyYXRvcnMgaW4gYW4gYHVubGVzc2AgY29uZGl0aW9uLgpJdCBkaXNjb3VyYWdlcyBzdWNoIGNvZGUsIGFzIHRoZSBjb25kaXRpb24gYmVjb21lcyBtb3JlIGRpZmZpY3VsdAp0byByZWFkIGFuZCB1bmRlcnN0YW5kLgoKVGhpcyBjb3Agc3VwcG9ydHMgdHdvIHN0eWxlczoKCi0gYGZvcmJpZF9taXhlZF9sb2dpY2FsX29wZXJhdG9yc2AgKGRlZmF1bHQpCi0gYGZvcmJpZF9sb2dpY2FsX29wZXJhdG9yc2AKCmBmb3JiaWRfbWl4ZWRfbG9naWNhbF9vcGVyYXRvcnNgIHN0eWxlIGZvcmJpZHMgdGhlIHVzZSBvZiBtb3JlIHRoYW4gb25lIHR5cGUKb2YgbG9naWNhbCBvcGVyYXRvcnMuIFRoaXMgbWFrZXMgdGhlIGB1bmxlc3NgIGNvbmRpdGlvbiBlYXNpZXIgdG8gcmVhZApiZWNhdXNlIGVpdGhlciBhbGwgY29uZGl0aW9ucyBuZWVkIHRvIGJlIG1ldCBvciBhbnkgY29uZGl0aW9uIG5lZWQgdG8gYmUgbWV0CmluIG9yZGVyIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSB0cnV0aHkgb3IgZmFsc2V5LgoKYGZvcmJpZF9sb2dpY2FsX29wZXJhdG9yc2Agc3R5bGUgZm9yYmlkcyBhbnkgdXNlIG9mIGxvZ2ljYWwgb3BlcmF0b3IuClRoaXMgbWFrZXMgaXQgZXZlbiBtb3JlIGVhc3kgdG8gcmVhZCB0aGUgYHVubGVzc2AgY29uZGl0aW9uIGFzCnRoZXJlIGlzIG9ubHkgb25lIGNvbmRpdGlvbiBpbiB0aGUgZXhwcmVzc2lvbi4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBmb3JiaWRfbWl4ZWRfbG9naWNhbF9vcGVyYXRvcnMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmV0dXJuIHVubGVzcyBhIHx8IGIgJiYgYwpyZXR1cm4gdW5sZXNzIGEgJiYgYiB8fCBjCnJldHVybiB1bmxlc3MgYSAmJiBiIGFuZCBjCnJldHVybiB1bmxlc3MgYSB8fCBiIG9yIGMKcmV0dXJuIHVubGVzcyBhICYmIGIgb3IgYwpyZXR1cm4gdW5sZXNzIGEgfHwgYiBhbmQgYwoKIyBnb29kCnJldHVybiB1bmxlc3MgYSAmJiBiICYmIGMKcmV0dXJuIHVubGVzcyBhIHx8IGIgfHwgYwpyZXR1cm4gdW5sZXNzIGEgYW5kIGIgYW5kIGMKcmV0dXJuIHVubGVzcyBhIG9yIGIgb3IgYwpyZXR1cm4gdW5sZXNzIGE/Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogZm9yYmlkX2xvZ2ljYWxfb3BlcmF0b3JzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmV0dXJuIHVubGVzcyBhIHx8IGIKcmV0dXJuIHVubGVzcyBhICYmIGIKcmV0dXJuIHVubGVzcyBhIG9yIGIKcmV0dXJuIHVubGVzcyBhIGFuZCBiCgojIGdvb2QKcmV0dXJuIHVubGVzcyBhCnJldHVybiB1bmxlc3MgYT8KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZm9yYmlkX21peGVkX2xvZ2ljYWxfb3BlcmF0b3JzYAp8IGBmb3JiaWRfbWl4ZWRfbG9naWNhbF9vcGVyYXRvcnNgLCBgZm9yYmlkX2xvZ2ljYWxfb3BlcmF0b3JzYAp8PT09Cgo9PSBTdHlsZS9VbnBhY2tGaXJzdAoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjU0CnwgLQp8PT09CgpDaGVja3MgZm9yIGFjY2Vzc2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgU3RyaW5nI3VucGFja2AKd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggdGhlIHNob3J0ZXIgbWV0aG9kIGB1bnBhY2sxYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCidmb28nLnVucGFjaygnaConKS5maXJzdAonZm9vJy51bnBhY2soJ2gqJylbMF0KJ2ZvbycudW5wYWNrKCdoKicpLnNsaWNlKDApCidmb28nLnVucGFjaygnaConKS5hdCgwKQoKIyBnb29kCidmb28nLnVucGFjazEoJ2gqJykKLS0tLQoKPT0gU3R5bGUvVmFyaWFibGVJbnRlcnBvbGF0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC45CnwgMC4yMAp8PT09CgpDaGVja3MgZm9yIHZhcmlhYmxlIGludGVycG9sYXRpb24gKGxpa2UgIiNAaXZhciIpLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKIkhpcyBuYW1lIGlzICMkbmFtZSIKL2NoZWNrICMkcGF0dGVybi8KIkxldCdzIGdvIHRvIHRoZSAjQHN0b3JlIgoKIyBnb29kCiJIaXMgbmFtZSBpcyAjeyRuYW1lfSIKL2NoZWNrICN7JHBhdHRlcm59LwoiTGV0J3MgZ28gdG8gdGhlICN7QHN0b3JlfSIKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjY3VybGllcy1pbnRlcnBvbGF0ZQoKPT0gU3R5bGUvV2hlblRoZW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgYHdoZW47YCB1c2VzIGluIGBjYXNlYCBleHByZXNzaW9ucy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNhc2UgZm9vCndoZW4gMTsgJ2JheicKd2hlbiAyOyAnYmFyJwplbmQKCiMgZ29vZApjYXNlIGZvbwp3aGVuIDEgdGhlbiAnYmF6Jwp3aGVuIDIgdGhlbiAnYmFyJwplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8td2hlbi1zZW1pY29sb25zCgo9PSBTdHlsZS9XaGlsZVVudGlsRG8KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdXNlcyBvZiBgZG9gIGluIG11bHRpLWxpbmUgYHdoaWxlL3VudGlsYCBzdGF0ZW1lbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKd2hpbGUgeC5hbnk/IGRvCiAgZG9fc29tZXRoaW5nKHgucG9wKQplbmQKCiMgZ29vZAp3aGlsZSB4LmFueT8KICBkb19zb21ldGhpbmcoeC5wb3ApCmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKdW50aWwgeC5lbXB0eT8gZG8KICBkb19zb21ldGhpbmcoeC5wb3ApCmVuZAoKIyBnb29kCnVudGlsIHguZW1wdHk/CiAgZG9fc29tZXRoaW5nKHgucG9wKQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjbm8tbXVsdGlsaW5lLXdoaWxlLWRvCgo9PSBTdHlsZS9XaGlsZVVudGlsTW9kaWZpZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjMwCnw9PT0KCkNoZWNrcyBmb3Igd2hpbGUgYW5kIHVudGlsIHN0YXRlbWVudHMgdGhhdCB3b3VsZCBmaXQgb24gb25lIGxpbmUKaWYgd3JpdHRlbiBhcyBhIG1vZGlmaWVyIHdoaWxlL3VudGlsLiBUaGUgbWF4aW11bSBsaW5lIGxlbmd0aCBpcwpjb25maWd1cmVkIGluIHRoZSBgTGF5b3V0L0xpbmVMZW5ndGhgIGNvcC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCndoaWxlIHggPCAxMAogIHggKz0gMQplbmQKCiMgZ29vZAp4ICs9IDEgd2hpbGUgeCA8IDEwCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp1bnRpbCB4ID4gMTAKICB4ICs9IDEKZW5kCgojIGdvb2QKeCArPSAxIHVudGlsIHggPiAxMAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKeCArPSAxMDAgd2hpbGUgeCA8IDUwMCAjIGEgbG9uZyBjb21tZW50IHRoYXQgbWFrZXMgY29kZSB0b28gbG9uZyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGxpbmUKCiMgZ29vZAp3aGlsZSB4IDwgNTAwICMgYSBsb25nIGNvbW1lbnQgdGhhdCBtYWtlcyBjb2RlIHRvbyBsb25nIGlmIGl0IHdlcmUgYSBzaW5nbGUgbGluZQogIHggKz0gMTAwCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3J1YnlzdHlsZS5ndWlkZSN3aGlsZS1hcy1hLW1vZGlmaWVyCgo9PSBTdHlsZS9Xb3JkQXJyYXkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAxLjE5Cnw9PT0KCkNoZWNrcyBmb3IgYXJyYXkgbGl0ZXJhbHMgbWFkZSB1cCBvZiB3b3JkLWxpa2UKc3RyaW5ncywgdGhhdCBhcmUgbm90IHVzaW5nIHRoZSAldygpIHN5bnRheC4KCkFsdGVybmF0aXZlbHksIGl0IGNhbiBjaGVjayBmb3IgdXNlcyBvZiB0aGUgJXcoKSBzeW50YXgsIGluIHByb2plY3RzCndoaWNoIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgdGhhdCBzeW50YXguCgpOT1RFOiBXaGVuIHVzaW5nIHRoZSBgcGVyY2VudGAgc3R5bGUsICV3KCkgYXJyYXlzIGNvbnRhaW5pbmcgYSBzcGFjZQp3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgb2ZmZW5zZXMuCgpDb25maWd1cmF0aW9uIG9wdGlvbjogTWluU2l6ZQpJZiBzZXQsIGFycmF5cyB3aXRoIGZld2VyIGVsZW1lbnRzIHRoYW4gdGhpcyB2YWx1ZSB3aWxsIG5vdCB0cmlnZ2VyIHRoZQpjb3AuIEZvciBleGFtcGxlLCBhIGBNaW5TaXplYCBvZiBgM2Agd2lsbCBub3QgZW5mb3JjZSBhIHN0eWxlIG9uIGFuCmFycmF5IG9mIDIgb3IgZmV3ZXIgZWxlbWVudHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogcGVyY2VudCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKJXdbZm9vIGJhciBiYXpdCgojIGJhZApbJ2ZvbycsICdiYXInLCAnYmF6J10KCiMgYmFkIChjb250YWlucyBzcGFjZXMpCiV3W2Zvb1wgYmFyIGJhelwgcXV1eF0KCiMgYmFkClsKICBbJ29uZScsICdPbmUnXSwKICBbJ3R3bycsICdUd28nXQpdCgojIGdvb2QKWwogICV3W29uZSBPbmVdLAogICV3W3R3byBUd29dCl0KCiMgZ29vZCAoMmQgYXJyYXkgY29udGFpbmluZyBzcGFjZXMpClsKICBbJ29uZScsICdPbmUnXSwKICBbJ3R3bycsICdUd28nXSwKICBbJ2ZvcnR5IHR3bycsICdGb3J0eSBUd28nXQpdCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYnJhY2tldHMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKWydmb28nLCAnYmFyJywgJ2JheiddCgojIGJhZAold1tmb28gYmFyIGJhel0KCiMgZ29vZCAoY29udGFpbnMgc3BhY2VzKQpbJ2ZvbyBiYXInLCAnYmF6IHF1dXgnXQoKIyBnb29kClsKICBbJ29uZScsICdPbmUnXSwKICBbJ3R3bycsICdUd28nXQpdCgojIGJhZApbCiAgJXdbb25lIE9uZV0sCiAgJXdbdHdvIFR3b10KXQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBwZXJjZW50YAp8IGBwZXJjZW50YCwgYGJyYWNrZXRzYAoKfCBNaW5TaXplCnwgYDJgCnwgSW50ZWdlcgoKfCBXb3JkUmVnZXgKfCBgKD8tbWl4OlxBKD86XHB7V29yZH1cfFxwe1dvcmR9LVxwe1dvcmR9XHxcblx8XHQpK1x6KWAKfCAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUjcGVyY2VudC13Cgo9PSBTdHlsZS9ZQU1MRmlsZVJlYWQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAxLjUzCnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSB1c2Ugb2YgYFlBTUwubG9hZGAsIGBZQU1MLnNhZmVfbG9hZGAsIGFuZCBgWUFNTC5wYXJzZWAgd2l0aApgRmlsZS5yZWFkYCBhcmd1bWVudC4KCk5PVEU6IGBZQU1MLnNhZmVfbG9hZF9maWxlYCB3YXMgaW50cm9kdWNlZCBpbiBSdWJ5IDMuMC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCllBTUwubG9hZChGaWxlLnJlYWQocGF0aCkpCllBTUwucGFyc2UoRmlsZS5yZWFkKHBhdGgpKQoKIyBnb29kCllBTUwubG9hZF9maWxlKHBhdGgpCllBTUwucGFyc2VfZmlsZShwYXRoKQoKIyBiYWQKWUFNTC5zYWZlX2xvYWQoRmlsZS5yZWFkKHBhdGgpKSAjIFJ1YnkgMy4wIGFuZCBuZXdlcgoKIyBnb29kCllBTUwuc2FmZV9sb2FkX2ZpbGUocGF0aCkgICAgICAgIyBSdWJ5IDMuMCBhbmQgbmV3ZXIKLS0tLQoKPT0gU3R5bGUvWW9kYUNvbmRpdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC40OQp8IDAuNzUKfD09PQoKRW5mb3JjZXMgb3IgZm9yYmlkcyBZb2RhIGNvbmRpdGlvbnMsCmkuZS4gY29tcGFyaXNvbiBvcGVyYXRpb25zIHdoZXJlIHRoZSBvcmRlciBvZiBleHByZXNzaW9uIGlzIHJldmVyc2VkLgplZy4gYDUgPT0geGAKCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGNvbXBhcmlzb24gb3BlcmF0b3JzIGNhbiBiZSBkZWZpbmVkCmRpZmZlcmVudGx5IG9uIGRpZmZlcmVudCBjbGFzc2VzLCBhbmQgYXJlIG5vdCBndWFyYW50ZWVkIHRvCmhhdmUgdGhlIHNhbWUgcmVzdWx0IGlmIHJldmVyc2VkLgoKRm9yIGV4YW1wbGU6Cgpbc291cmNlLHJ1YnldCi0tLS0KY2xhc3MgTXlLbGFzcwogIGRlZiA9PShvdGhlcikKICAgIHRydWUKICBlbmQKZW5kCgpvYmogPSBNeUtsYXNzLm5ldwpvYmogPT0gJ3N0cmluZycgICAjPT4gdHJ1ZQonc3RyaW5nJyA9PSBvYmogICAjPT4gZmFsc2UKLS0tLQoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGZvcmJpZF9mb3JfYWxsX2NvbXBhcmlzb25fb3BlcmF0b3JzIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCjk5ID09IGZvbwoiYmFyIiAhPSBmb28KNDIgPj0gZm9vCjEwIDwgYmFyCjk5ID09IENPTlNUCgojIGdvb2QKZm9vID09IDk5CmZvbyA9PSAiYmFyIgpmb28gPD0gNDIKYmFyID4gMTAKQ09OU1QgPT0gOTkKIiN7aW50ZXJwb2xhdGlvbn0iID09IGZvbwovI3tpbnRlcnBvbGF0aW9ufS8gPT0gZm9vCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogZm9yYmlkX2Zvcl9lcXVhbGl0eV9vcGVyYXRvcnNfb25seQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCjk5ID09IGZvbwoiYmFyIiAhPSBmb28KCiMgZ29vZAo5OSA+PSBmb28KMyA8IGEgJiYgYSA8IDUKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiByZXF1aXJlX2Zvcl9hbGxfY29tcGFyaXNvbl9vcGVyYXRvcnMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApmb28gPT0gOTkKZm9vID09ICJiYXIiCmZvbyA8PSA0MgpiYXIgPiAxMAoKIyBnb29kCjk5ID09IGZvbwoiYmFyIiAhPSBmb28KNDIgPj0gZm9vCjEwIDwgYmFyCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmVxdWlyZV9mb3JfZXF1YWxpdHlfb3BlcmF0b3JzX29ubHkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAo5OSA+PSBmb28KMyA8IGEgJiYgYSA8IDUKCiMgZ29vZAo5OSA9PSBmb28KImJhciIgIT0gZm9vCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGZvcmJpZF9mb3JfYWxsX2NvbXBhcmlzb25fb3BlcmF0b3JzYAp8IGBmb3JiaWRfZm9yX2FsbF9jb21wYXJpc29uX29wZXJhdG9yc2AsIGBmb3JiaWRfZm9yX2VxdWFsaXR5X29wZXJhdG9yc19vbmx5YCwgYHJlcXVpcmVfZm9yX2FsbF9jb21wYXJpc29uX29wZXJhdG9yc2AsIGByZXF1aXJlX2Zvcl9lcXVhbGl0eV9vcGVyYXRvcnNfb25seWAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWW9kYV9jb25kaXRpb25zCgo9PSBTdHlsZS9Zb2RhRXhwcmVzc2lvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNDIKfCAxLjQzCnw9PT0KCkZvcmJpZHMgWW9kYSBleHByZXNzaW9ucywgaS5lLiBiaW5hcnkgb3BlcmF0aW9ucyAodXNpbmcgYCpgLCBgK2AsIGAmYCwgYHxgLAphbmQgYF5gIG9wZXJhdG9ycykgd2hlcmUgdGhlIG9yZGVyIG9mIGV4cHJlc3Npb24gaXMgcmV2ZXJzZWQsIGVnLiBgMSArIHhgLgpUaGlzIGNvcCBjb21wbGVtZW50cyBgU3R5bGUvWW9kYUNvbmRpdGlvbmAgY29wLCB3aGljaCBoYXMgYSBzaW1pbGFyIHB1cnBvc2UuCgpUaGlzIGNvcCBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IHRvIHJlc3BlY3QgdXNlciBpbnRlbnRpb25zIHN1Y2ggYXM6Cgpbc291cmNlLHJ1YnldCi0tLS0KY29uZmlnLnNlcnZlcl9wb3J0ID0gOTAwMCArIEVOVlsiVEVTVF9FTlZfTlVNQkVSIl0udG9faQotLS0tCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBiaW5hcnkgb3BlcmF0b3JzIGNhbiBiZSBkZWZpbmVkCmRpZmZlcmVudGx5IG9uIGRpZmZlcmVudCBjbGFzc2VzLCBhbmQgYXJlIG5vdCBndWFyYW50ZWVkIHRvCmhhdmUgdGhlIHNhbWUgcmVzdWx0IGlmIHJldmVyc2VkLgoKPT09IEV4YW1wbGVzCgo9PT09IFN1cHBvcnRlZE9wZXJhdG9yczogWycqJywgJysnLCAnJicsICd8JywgJ14nXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAoxMCAqIHkKMSArIHgKMSAmIHoKMSB8IHgKMSBeIHgKMSArIENPTlNUCgojIGdvb2QKeSAqIDEwCnggKyAxCnogJiAxCnggfCAxCnggXiAxCkNPTlNUICsgMQo2MCAqIDI0Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKCnw9PT0KCj09IFN0eWxlL1plcm9MZW5ndGhQcmVkaWNhdGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuMzcKfCAwLjM5Cnw9PT0KCkNoZWNrcyBmb3IgbnVtZXJpYyBjb21wYXJpc29ucyB0aGF0IGNhbiBiZSByZXBsYWNlZApieSBhIHByZWRpY2F0ZSBtZXRob2QsIHN1Y2ggYXMgYHJlY2VpdmVyLmxlbmd0aCA9PSAwYCwKYHJlY2VpdmVyLmxlbmd0aCA+IDBgLCBhbmQgYHJlY2VpdmVyLmxlbmd0aCAhPSAwYCwKYHJlY2VpdmVyLmxlbmd0aCA8IDFgIGFuZCBgcmVjZWl2ZXIuc2l6ZSA9PSAwYCB0aGF0IGNhbiBiZQpyZXBsYWNlZCBieSBgcmVjZWl2ZXIuZW1wdHk/YCBhbmQgYCFyZWNlaXZlci5lbXB0eT9gLgoKTk9URTogYEZpbGVgLCBgVGVtcGZpbGVgLCBhbmQgYFN0cmluZ0lPYCBkbyBub3QgaGF2ZSBgZW1wdHk/YApzbyBhbGxvdyBgc2l6ZSA9PSAwYCBhbmQgYHNpemUuemVybz9gLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdCB0aGUgcmVjZWl2ZXIKaGFzIGFuIGBlbXB0eT9gIG1ldGhvZCB0aGF0IGlzIGRlZmluZWQgaW4gdGVybXMgb2YgYGxlbmd0aGAuIElmIHRoZXJlCmlzIGEgbm9uLXN0YW5kYXJkIGNsYXNzIHRoYXQgcmVkZWZpbmVzIGBsZW5ndGhgIG9yIGBlbXB0eT9gLCB0aGUgY29wCm1heSByZWdpc3RlciBhIGZhbHNlIHBvc2l0aXZlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKWzEsIDIsIDNdLmxlbmd0aCA9PSAwCjAgPT0gImZvb2JhciIubGVuZ3RoCmFycmF5Lmxlbmd0aCA8IDEKe2E6IDEsIGI6IDJ9Lmxlbmd0aCAhPSAwCnN0cmluZy5sZW5ndGggPiAwCmhhc2guc2l6ZSA+IDAKCiMgZ29vZApbMSwgMiwgM10uZW1wdHk/CiJmb29iYXIiLmVtcHR5PwphcnJheS5lbXB0eT8KIXthOiAxLCBiOiAyfS5lbXB0eT8KIXN0cmluZy5lbXB0eT8KIWhhc2guZW1wdHk/Ci0tLS0K
  recorded_at: Mon, 27 May 2024 05:30:41 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop/v1.64.0/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '168537'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"e185e054ab1250e567bc7d701057414fdaffe462c298a3b1faf18ff14cbea6c3"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - CF5C:3F1A91:13E2F4D:151ACE1:66541A80
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:41 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230112-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787841.414027,VS0,VE215
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - ec70e99c916954e024e58bb25da417c992d095ef
      Expires:
      - Mon, 27 May 2024 05:35:41 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: !binary |-
        IyBDb21tb24gY29uZmlndXJhdGlvbi4KCkFsbENvcHM6CiAgUnVieUludGVycHJldGVyczoKICAgIC0gcnVieQogICAgLSBtYWNydWJ5CiAgICAtIHJha2UKICAgIC0ganJ1YnkKICAgIC0gcmJ4CiAgIyBJbmNsdWRlIGNvbW1vbiBSdWJ5IHNvdXJjZSBmaWxlcy4KICBJbmNsdWRlOgogICAgLSAnKiovKi5yYicKICAgIC0gJyoqLyouYXJiJwogICAgLSAnKiovKi5heGxzeCcKICAgIC0gJyoqLyouYnVpbGRlcicKICAgIC0gJyoqLyouZmNnaScKICAgIC0gJyoqLyouZ2VtZmlsZScKICAgIC0gJyoqLyouZ2Vtc3BlYycKICAgIC0gJyoqLyouZ29kJwogICAgLSAnKiovKi5qYicKICAgIC0gJyoqLyouamJ1aWxkZXInCiAgICAtICcqKi8qLm1zcGVjJwogICAgLSAnKiovKi5vcGFsJwogICAgLSAnKiovKi5wbHVnaW5zcGVjJwogICAgLSAnKiovKi5wb2RzcGVjJwogICAgLSAnKiovKi5yYWJsJwogICAgLSAnKiovKi5yYWtlJwogICAgLSAnKiovKi5yYnVpbGQnCiAgICAtICcqKi8qLnJidycKICAgIC0gJyoqLyoucmJ4JwogICAgLSAnKiovKi5ydScKICAgIC0gJyoqLyoucnVieScKICAgIC0gJyoqLyouc2NoZW1hJwogICAgLSAnKiovKi5zcGVjJwogICAgLSAnKiovKi50aG9yJwogICAgLSAnKiovKi53YXRjaHInCiAgICAtICcqKi8uaXJicmMnCiAgICAtICcqKi8ucHJ5cmMnCiAgICAtICcqKi8uc2ltcGxlY292JwogICAgLSAnKiovYnVpbGRmaWxlJwogICAgLSAnKiovQXBwcmFpc2FscycKICAgIC0gJyoqL0JlcmtzZmlsZScKICAgIC0gJyoqL0JyZXdmaWxlJwogICAgLSAnKiovQnVpbGRmaWxlJwogICAgLSAnKiovQ2FwZmlsZScKICAgIC0gJyoqL0NoZWZmaWxlJwogICAgLSAnKiovRGFuZ2VyZmlsZScKICAgIC0gJyoqL0RlbGl2ZXJmaWxlJwogICAgLSAnKiovRmFzdGZpbGUnCiAgICAtICcqKi8qRmFzdGZpbGUnCiAgICAtICcqKi9HZW1maWxlJwogICAgLSAnKiovR3VhcmRmaWxlJwogICAgLSAnKiovSmFyZmlsZScKICAgIC0gJyoqL01hdmVuZmlsZScKICAgIC0gJyoqL1BvZGZpbGUnCiAgICAtICcqKi9QdXBwZXRmaWxlJwogICAgLSAnKiovUmFrZWZpbGUnCiAgICAtICcqKi9yYWtlZmlsZScKICAgIC0gJyoqL1NjaGVtYWZpbGUnCiAgICAtICcqKi9TbmFwZmlsZScKICAgIC0gJyoqL1N0ZWVwZmlsZScKICAgIC0gJyoqL1Rob3JmaWxlJwogICAgLSAnKiovVmFnYWJvbmRmaWxlJwogICAgLSAnKiovVmFncmFudGZpbGUnCiAgRXhjbHVkZToKICAgIC0gJ25vZGVfbW9kdWxlcy8qKi8qJwogICAgLSAndG1wLyoqLyonCiAgICAtICd2ZW5kb3IvKiovKicKICAgIC0gJy5naXQvKiovKicKICAjIERlZmF1bHQgZm9ybWF0dGVyIHdpbGwgYmUgdXNlZCBpZiBubyBgLWYvLS1mb3JtYXRgIG9wdGlvbiBpcyBnaXZlbi4KICBEZWZhdWx0Rm9ybWF0dGVyOiBwcm9ncmVzcwogICMgQ29wIG5hbWVzIGFyZSBkaXNwbGF5ZWQgaW4gb2ZmZW5zZSBtZXNzYWdlcyBieSBkZWZhdWx0LiBDaGFuZ2UgYmVoYXZpb3IKICAjIGJ5IG92ZXJyaWRpbmcgRGlzcGxheUNvcE5hbWVzLCBvciBieSBnaXZpbmcgdGhlIGAtLW5vLWRpc3BsYXktY29wLW5hbWVzYAogICMgb3B0aW9uLgogIERpc3BsYXlDb3BOYW1lczogdHJ1ZQogICMgU3R5bGUgZ3VpZGUgVVJMcyBhcmUgbm90IGRpc3BsYXllZCBpbiBvZmZlbnNlIG1lc3NhZ2VzIGJ5IGRlZmF1bHQuIENoYW5nZQogICMgYmVoYXZpb3IgYnkgb3ZlcnJpZGluZyBgRGlzcGxheVN0eWxlR3VpZGVgLCBvciBieSBnaXZpbmcgdGhlCiAgIyBgLVMvLS1kaXNwbGF5LXN0eWxlLWd1aWRlYCBvcHRpb24uCiAgRGlzcGxheVN0eWxlR3VpZGU6IGZhbHNlCiAgIyBXaGVuIHNwZWNpZnlpbmcgc3R5bGUgZ3VpZGUgVVJMcywgYW55IHBhdGhzIGFuZC9vciBmcmFnbWVudHMgd2lsbCBiZQogICMgZXZhbHVhdGVkIHJlbGF0aXZlIHRvIHRoZSBiYXNlIFVSTC4KICBTdHlsZUd1aWRlQmFzZVVSTDogaHR0cHM6Ly9ydWJ5c3R5bGUuZ3VpZGUKICAjIERvY3VtZW50YXRpb24gVVJMcyB3aWxsIGJlIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBiYXNlIFVSTC4KICBEb2N1bWVudGF0aW9uQmFzZVVSTDogaHR0cHM6Ly9kb2NzLnJ1Ym9jb3Aub3JnL3J1Ym9jb3AKICAjIEV4dHJhIGRldGFpbHMgYXJlIG5vdCBkaXNwbGF5ZWQgaW4gb2ZmZW5zZSBtZXNzYWdlcyBieSBkZWZhdWx0LiBDaGFuZ2UKICAjIGJlaGF2aW9yIGJ5IG92ZXJyaWRpbmcgRXh0cmFEZXRhaWxzLCBvciBieSBnaXZpbmcgdGhlCiAgIyBgLUUvLS1leHRyYS1kZXRhaWxzYCBvcHRpb24uCiAgRXh0cmFEZXRhaWxzOiBmYWxzZQogICMgQWRkaXRpb25hbCBjb3BzIHRoYXQgZG8gbm90IHJlZmVyZW5jZSBhIHN0eWxlIGd1aWRlIHJ1bGUgbWF5IGJlIGVuYWJsZWQgYnkKICAjIGRlZmF1bHQuIENoYW5nZSBiZWhhdmlvciBieSBvdmVycmlkaW5nIGBTdHlsZUd1aWRlQ29wc09ubHlgLCBvciBieSBnaXZpbmcKICAjIHRoZSBgLS1vbmx5LWd1aWRlLWNvcHNgIG9wdGlvbi4KICBTdHlsZUd1aWRlQ29wc09ubHk6IGZhbHNlCiAgIyBBbGwgY29wcyBleGNlcHQgdGhlIG9uZXMgY29uZmlndXJlZCBgRW5hYmxlZDogZmFsc2VgIGluIHRoaXMgZmlsZSBhcmUgZW5hYmxlZCBieSBkZWZhdWx0LgogICMgQ2hhbmdlIHRoaXMgYmVoYXZpb3IgYnkgb3ZlcnJpZGluZyBlaXRoZXIgYERpc2FibGVkQnlEZWZhdWx0YCBvciBgRW5hYmxlZEJ5RGVmYXVsdGAuCiAgIyBXaGVuIGBEaXNhYmxlZEJ5RGVmYXVsdGAgaXMgYHRydWVgLCBhbGwgY29wcyBpbiB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uCiAgIyBhcmUgZGlzYWJsZWQsIGFuZCBvbmx5IGNvcHMgaW4gdXNlciBjb25maWd1cmF0aW9uIGFyZSBlbmFibGVkLiBUaGlzIG1ha2VzCiAgIyBjb3BzIG9wdC1pbiBpbnN0ZWFkIG9mIG9wdC1vdXQuIE5vdGUgdGhhdCB3aGVuIGBEaXNhYmxlZEJ5RGVmYXVsdGAgaXMgYHRydWVgLAogICMgY29wcyBpbiB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBlbmFibGVkIGV2ZW4gaWYgdGhleSBkb24ndCBzZXQgdGhlCiAgIyBFbmFibGVkIHBhcmFtZXRlci4KICAjIFdoZW4gYEVuYWJsZWRCeURlZmF1bHRgIGlzIGB0cnVlYCwgYWxsIGNvcHMsIGV2ZW4gdGhvc2UgY29uZmlndXJlZCBgRW5hYmxlZDogZmFsc2VgCiAgIyBpbiB0aGlzIGZpbGUgYXJlIGVuYWJsZWQgYnkgZGVmYXVsdC4gQ29wcyBjYW4gc3RpbGwgYmUgZGlzYWJsZWQgaW4gdXNlciBjb25maWd1cmF0aW9uLgogICMgTm90ZSB0aGF0IGl0IGlzIGludmFsaWQgdG8gc2V0IGJvdGggRW5hYmxlZEJ5RGVmYXVsdCBhbmQgRGlzYWJsZWRCeURlZmF1bHQKICAjIHRvIHRydWUgaW4gdGhlIHNhbWUgY29uZmlndXJhdGlvbi4KICBFbmFibGVkQnlEZWZhdWx0OiBmYWxzZQogIERpc2FibGVkQnlEZWZhdWx0OiBmYWxzZQogICMgTmV3IGNvcHMgaW50cm9kdWNlZCBiZXR3ZWVuIG1ham9yIHZlcnNpb25zIGFyZSBzZXQgdG8gYSBzcGVjaWFsIHBlbmRpbmcgc3RhdHVzCiAgIyBhbmQgYXJlIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQgd2l0aCB3YXJuaW5nIG1lc3NhZ2UuCiAgIyBDaGFuZ2UgdGhpcyBiZWhhdmlvciBieSBvdmVycmlkaW5nIGVpdGhlciBgTmV3Q29wczogZW5hYmxlYCBvciBgTmV3Q29wczogZGlzYWJsZWAuCiAgIyBXaGVuIGBOZXdDb3BzYCBpcyBgZW5hYmxlYCwgcGVuZGluZyBjb3BzIGFyZSBlbmFibGVkIGluIGJ1bGsuIENhbiBiZSBvdmVycmlkZGVuIGJ5CiAgIyB0aGUgYC0tZW5hYmxlLXBlbmRpbmctY29wc2AgY29tbWFuZC1saW5lIG9wdGlvbi4KICAjIFdoZW4gYE5ld0NvcHNgIGlzIGBkaXNhYmxlYCwgcGVuZGluZyBjb3BzIGFyZSBkaXNhYmxlZCBpbiBidWxrLiBDYW4gYmUgb3ZlcnJpZGRlbiBieQogICMgdGhlIGAtLWRpc2FibGUtcGVuZGluZy1jb3BzYCBjb21tYW5kLWxpbmUgb3B0aW9uLgogIE5ld0NvcHM6IHBlbmRpbmcKICAjIEVuYWJsZXMgdGhlIHJlc3VsdCBjYWNoZSBpZiBgdHJ1ZWAuIENhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBgLS1jYWNoZWAgY29tbWFuZAogICMgbGluZSBvcHRpb24uCiAgVXNlQ2FjaGU6IHRydWUKICAjIFRocmVzaG9sZCBmb3IgaG93IG1hbnkgZmlsZXMgY2FuIGJlIHN0b3JlZCBpbiB0aGUgcmVzdWx0IGNhY2hlIGJlZm9yZSBzb21lCiAgIyBvZiB0aGUgZmlsZXMgYXJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4KICBNYXhGaWxlc0luQ2FjaGU6IDIwMDAwCiAgIyBUaGUgY2FjaGUgd2lsbCBiZSBzdG9yZWQgaW4gInJ1Ym9jb3BfY2FjaGUiIHVuZGVyIHRoaXMgZGlyZWN0b3J5LiBJZgogICMgQ2FjaGVSb290RGlyZWN0b3J5IGlzIH4gKG5pbCksIHdoaWNoIGl0IGlzIGJ5IGRlZmF1bHQsIHRoZSByb290IHdpbGwgYmUKICAjIHRha2VuIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGAkWERHX0NBQ0hFX0hPTUVgIGlmIGl0IGlzIHNldCwgb3IgaWYKICAjIGAkWERHX0NBQ0hFX0hPTUVgIGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYCRIT01FLy5jYWNoZS9gLgogICMgVGhlIENhY2hlUm9vdERpcmVjdG9yeSBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgcGFzc2luZyB0aGUgYC0tY2FjaGUtcm9vdGAgY29tbWFuZAogICMgbGluZSBvcHRpb24gb3IgYnkgc2V0dGluZyBgJFJVQk9DT1BfQ0FDSEVfUk9PVGAgZW52aXJvbm1lbnQgdmFyaWFibGUuCiAgQ2FjaGVSb290RGlyZWN0b3J5OiB+CiAgIyBJdCBpcyBwb3NzaWJsZSBmb3IgYSBtYWxpY2lvdXMgdXNlciB0byBrbm93IHRoZSBsb2NhdGlvbiBvZiBSdWJvQ29wJ3MgY2FjaGUKICAjIGRpcmVjdG9yeSBieSBsb29raW5nIGF0IENhY2hlUm9vdERpcmVjdG9yeSwgYW5kIGNyZWF0ZSBhIHN5bWxpbmsgaW4gaXRzCiAgIyBwbGFjZSB0aGF0IGNvdWxkIGNhdXNlIFJ1Ym9Db3AgdG8gb3ZlcndyaXRlIHVuaW50ZW5kZWQgZmlsZXMsIG9yIHJlYWQKICAjIG1hbGljaW91cyBpbnB1dC4gSWYgeW91IGFyZSBjZXJ0YWluIHRoYXQgeW91ciBjYWNoZSBsb2NhdGlvbiBpcyBzZWN1cmUgZnJvbQogICMgdGhpcyBraW5kIG9mIGF0dGFjaywgYW5kIHdpc2ggdG8gdXNlIGEgc3ltbGlua2VkIGNhY2hlIGxvY2F0aW9uLCBzZXQgdGhpcwogICMgdmFsdWUgdG8gInRydWUiLgogIEFsbG93U3ltbGlua3NJbkNhY2hlUm9vdERpcmVjdG9yeTogZmFsc2UKICAjIFdoYXQgTVJJIHZlcnNpb24gb2YgdGhlIFJ1YnkgaW50ZXJwcmV0ZXIgaXMgdGhlIGluc3BlY3RlZCBjb2RlIGludGVuZGVkIHRvCiAgIyBydW4gb24/IChJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lLCBzZXQgdGhpcyB0byB0aGUgbG93ZXN0IHZlcnNpb24uKQogICMgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIFRhcmdldFJ1YnlWZXJzaW9uIHRoZW4gaXQgaXMgdXNlZC4gQWNjZXB0YWJsZQogICMgdmFsdWVzIGFyZSBzcGVjaWZpZWQgYXMgYSBmbG9hdCAoaS5lLiAzLjApOyB0aGUgdGVlbnkgdmVyc2lvbiBvZiBSdWJ5CiAgIyBzaG91bGQgbm90IGJlIGluY2x1ZGVkLiBJZiB0aGUgcHJvamVjdCBzcGVjaWZpZXMgYSBSdWJ5IHZlcnNpb24gaW4gdGhlCiAgIyAudG9vbC12ZXJzaW9ucyBvciAucnVieS12ZXJzaW9uIGZpbGVzLCBHZW1maWxlIG9yIGdlbXMucmIgZmlsZSwgUnVib0NvcCB3aWxsCiAgIyB0cnkgdG8gZGV0ZXJtaW5lIHRoZSBkZXNpcmVkIHZlcnNpb24gb2YgUnVieSBieSBpbnNwZWN0aW5nIHRoZQogICMgLnRvb2wtdmVyc2lvbnMgZmlsZSBmaXJzdCwgdGhlbiAucnVieS12ZXJzaW9uLCBmb2xsb3dlZCBieSB0aGUgR2VtZmlsZS5sb2NrCiAgIyBvciBnZW1zLmxvY2tlZCBmaWxlLiAoQWx0aG91Z2ggdGhlIFJ1YnkgdmVyc2lvbiBpcyBzcGVjaWZpZWQgaW4gdGhlIEdlbWZpbGUKICAjIG9yIGdlbXMucmIgZmlsZSwgUnVib0NvcCByZWFkcyB0aGUgZmluYWwgdmFsdWUgZnJvbSB0aGUgbG9jayBmaWxlLikgSWYgdGhlCiAgIyBSdWJ5IHZlcnNpb24gaXMgc3RpbGwgdW5yZXNvbHZlZCwgUnVib0NvcCB3aWxsIHVzZSB0aGUgb2xkZXN0IG9mZmljaWFsbHkKICAjIHN1cHBvcnRlZCBSdWJ5IHZlcnNpb24gKGN1cnJlbnRseSBSdWJ5IDIuNykuCiAgVGFyZ2V0UnVieVZlcnNpb246IH4KICAjIFlvdSBjYW4gc3BlY2lmeSB0aGUgcGFyc2VyIGVuZ2luZS4gVGhlcmUgYXJlIHR3byBvcHRpb25zIGF2YWlsYWJsZToKICAjIC0gYHBhcnNlcl93aGl0ZXF1YXJrYCAuLi4gaHR0cHM6Ly9naXRodWIuY29tL3doaXRlcXVhcmsvcGFyc2VyCiAgIyAtIGBwYXJzZXJfcHJpc21gIC4uLiBodHRwczovL2dpdGh1Yi5jb20vcnVieS9wcmlzbSAoYFByaXNtOjpUcmFuc2xhdGlvbjo6UGFyc2VyYCkKICAjIEJ5IGRlZmF1bHQsIGBwYXJzZXJgIGlzIHVzZWQuIEZvciB0aGUgYFRhcmdldFJ1YnlWZXJzaW9uYCB2YWx1ZSwgYHBhcnNlcmAgY2FuIGJlIHNwZWNpZmllZCBmb3IgdmVyc2lvbnMgYDIuMGAgYW5kIGFib3ZlLgogICMgYHBhcnNlcl9wcmlzbWAgY2FuIGJlIHNwZWNpZmllZCBmb3IgdmVyc2lvbnMgYDMuM2AgYW5kIGFib3ZlLiBgcGFyc2VyX3ByaXNtYCBpcyBmYXN0ZXIgYnV0IHN0aWxsIGNvbnNpZGVyZWQgZXhwZXJpbWVudGFsLgogIFBhcnNlckVuZ2luZTogcGFyc2VyX3doaXRlcXVhcmsKICAjIERldGVybWluZXMgaWYgYSBub3RpZmljYXRpb24gZm9yIGV4dGVuc2lvbiBsaWJyYXJpZXMgc2hvdWxkIGJlIHNob3duIHdoZW4KICAjIHJ1Ym9jb3AgaXMgcnVuLiBLZXlzIGFyZSB0aGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uLCBhbmQgdmFsdWVzIGFyZSBhbiBhcnJheQogICMgb2YgZ2VtcyBpbiB0aGUgR2VtZmlsZSB0aGF0IHRoZSBleHRlbnNpb24gaXMgc3VnZ2VzdGVkIGZvciwgaWYgbm90IGFscmVhZHkKICAjIGluY2x1ZGVkLgogIFN1Z2dlc3RFeHRlbnNpb25zOgogICAgcnVib2NvcC1yYWlsczogW3JhaWxzXQogICAgcnVib2NvcC1yc3BlYzogW3JzcGVjLCByc3BlYy1yYWlsc10KICAgIHJ1Ym9jb3AtbWluaXRlc3Q6IFttaW5pdGVzdF0KICAgIHJ1Ym9jb3Atc2VxdWVsOiBbc2VxdWVsXQogICAgcnVib2NvcC1yYWtlOiBbcmFrZV0KICAgIHJ1Ym9jb3AtZ3JhcGhxbDogW2dyYXBocWxdCiAgICBydWJvY29wLWNhcHliYXJhOiBbY2FweWJhcmFdCiAgICBydWJvY29wLWZhY3RvcnlfYm90OiBbZmFjdG9yeV9ib3QsIGZhY3RvcnlfYm90X3JhaWxzXQogICAgcnVib2NvcC1yc3BlY19yYWlsczogW3JzcGVjLXJhaWxzXQogICMgRW5hYmxlL0Rpc2FibGUgY2hlY2tpbmcgdGhlIG1ldGhvZHMgZXh0ZW5kZWQgYnkgQWN0aXZlIFN1cHBvcnQuCiAgQWN0aXZlU3VwcG9ydEV4dGVuc2lvbnNFbmFibGVkOiBmYWxzZQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMgQnVuZGxlciAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpCdW5kbGVyL0R1cGxpY2F0ZWRHZW06CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGR1cGxpY2F0ZSBnZW0gZW50cmllcyBpbiBHZW1maWxlLicKICBFbmFibGVkOiB0cnVlCiAgU2V2ZXJpdHk6IHdhcm5pbmcKICBWZXJzaW9uQWRkZWQ6ICcwLjQ2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS40MCcKICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1maWxlJwogICAgLSAnKiovR2VtZmlsZScKICAgIC0gJyoqL2dlbXMucmInCgpCdW5kbGVyL0R1cGxpY2F0ZWRHcm91cDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgZHVwbGljYXRlIGdyb3VwIGVudHJpZXMgaW4gR2VtZmlsZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFNldmVyaXR5OiB3YXJuaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41NicKICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1maWxlJwogICAgLSAnKiovR2VtZmlsZScKICAgIC0gJyoqL2dlbXMucmInCgpCdW5kbGVyL0dlbUNvbW1lbnQ6CiAgRGVzY3JpcHRpb246ICdBZGQgYSBjb21tZW50IGRlc2NyaWJpbmcgZWFjaCBnZW0uJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC41OScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODUnCiAgSW5jbHVkZToKICAgIC0gJyoqLyouZ2VtZmlsZScKICAgIC0gJyoqL0dlbWZpbGUnCiAgICAtICcqKi9nZW1zLnJiJwogIElnbm9yZWRHZW1zOiBbXQogIE9ubHlGb3I6IFtdCgpCdW5kbGVyL0dlbUZpbGVuYW1lOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgdGhlIGZpbGVuYW1lIGZvciBtYW5hZ2luZyBnZW1zLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMS4yMCcKICBFbmZvcmNlZFN0eWxlOiAnR2VtZmlsZScKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtICdHZW1maWxlJwogICAgLSAnZ2Vtcy5yYicKICBJbmNsdWRlOgogICAgLSAnKiovR2VtZmlsZScKICAgIC0gJyoqL2dlbXMucmInCiAgICAtICcqKi9HZW1maWxlLmxvY2snCiAgICAtICcqKi9nZW1zLmxvY2tlZCcKCkJ1bmRsZXIvR2VtVmVyc2lvbjoKICBEZXNjcmlwdGlvbjogJ1JlcXVpcmVzIG9yIGZvcmJpZHMgc3BlY2lmeWluZyBnZW0gdmVyc2lvbnMuJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS4xNCcKICBFbmZvcmNlZFN0eWxlOiAncmVxdWlyZWQnCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSAncmVxdWlyZWQnCiAgICAtICdmb3JiaWRkZW4nCiAgSW5jbHVkZToKICAgIC0gJyoqLyouZ2VtZmlsZScKICAgIC0gJyoqL0dlbWZpbGUnCiAgICAtICcqKi9nZW1zLnJiJwogIEFsbG93ZWRHZW1zOiBbXQoKQnVuZGxlci9JbnNlY3VyZVByb3RvY29sU291cmNlOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFRoZSBzb3VyY2UgYDpnZW1jdXR0ZXJgLCBgOnJ1YnlnZW1zYCBhbmQgYDpydWJ5Zm9yZ2VgIGFyZSBkZXByZWNhdGVkCiAgICAgICAgICAgICAgICAgYmVjYXVzZSBIVFRQIHJlcXVlc3RzIGFyZSBpbnNlY3VyZS4gUGxlYXNlIGNoYW5nZSB5b3VyIHNvdXJjZSB0bwogICAgICAgICAgICAgICAgICdodHRwczovL3J1YnlnZW1zLm9yZycgaWYgcG9zc2libGUsIG9yICdodHRwOi8vcnVieWdlbXMub3JnJyBpZiBub3QuCiAgRW5hYmxlZDogdHJ1ZQogIFNldmVyaXR5OiB3YXJuaW5nCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNDAnCiAgQWxsb3dIdHRwUHJvdG9jb2w6IHRydWUKICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1maWxlJwogICAgLSAnKiovR2VtZmlsZScKICAgIC0gJyoqL2dlbXMucmInCgpCdW5kbGVyL09yZGVyZWRHZW1zOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEdlbXMgd2l0aGluIGdyb3VwcyBpbiB0aGUgR2VtZmlsZSBzaG91bGQgYmUgYWxwaGFiZXRpY2FsbHkgc29ydGVkLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ2JwogIFZlcnNpb25DaGFuZ2VkOiAnMC40NycKICBUcmVhdENvbW1lbnRzQXNHcm91cFNlcGFyYXRvcnM6IHRydWUKICAjIEJ5IGRlZmF1bHQsICItIiBhbmQgIl8iIGFyZSBpZ25vcmVkIGZvciBvcmRlciBwdXJwb3Nlcy4KICAjIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlLgogIENvbnNpZGVyUHVuY3R1YXRpb246IGZhbHNlCiAgSW5jbHVkZToKICAgIC0gJyoqLyouZ2VtZmlsZScKICAgIC0gJyoqL0dlbWZpbGUnCiAgICAtICcqKi9nZW1zLnJiJwoKIyMjIyMjIyMjIyMjIyMjIyMjIyMgR2Vtc3BlYyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpHZW1zcGVjL0RlcGVuZGVuY3lWZXJzaW9uOgogIERlc2NyaXB0aW9uOiAnUmVxdWlyZXMgb3IgZm9yYmlkcyBzcGVjaWZ5aW5nIGdlbSBkZXBlbmRlbmN5IHZlcnNpb25zLicKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMjknCiAgRW5mb3JjZWRTdHlsZTogJ3JlcXVpcmVkJwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gJ3JlcXVpcmVkJwogICAgLSAnZm9yYmlkZGVuJwogIEluY2x1ZGU6CiAgICAtICcqKi8qLmdlbXNwZWMnCiAgQWxsb3dlZEdlbXM6IFtdCgpHZW1zcGVjL0RlcHJlY2F0ZWRBdHRyaWJ1dGVBc3NpZ25tZW50OgogIERlc2NyaXB0aW9uOiBDaGVja3MgdGhhdCBkZXByZWNhdGVkIGF0dHJpYnV0ZSBhc3NpZ25tZW50cyBhcmUgbm90IHNldCBpbiBhIGdlbXNwZWMgZmlsZS4KICBFbmFibGVkOiBwZW5kaW5nCiAgU2V2ZXJpdHk6IHdhcm5pbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjMwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS40MCcKICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1zcGVjJwoKR2Vtc3BlYy9EZXZlbG9wbWVudERlcGVuZGVuY2llczoKICBEZXNjcmlwdGlvbjogQ2hlY2tzIHRoYXQgZGV2ZWxvcG1lbnQgZGVwZW5kZW5jaWVzIGFyZSBzcGVjaWZpZWQgaW4gR2VtZmlsZSByYXRoZXIgdGhhbiBnZW1zcGVjLgogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjQ0JwogIEVuZm9yY2VkU3R5bGU6IEdlbWZpbGUKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIEdlbWZpbGUKICAgIC0gZ2Vtcy5yYgogICAgLSBnZW1zcGVjCiAgQWxsb3dlZEdlbXM6IFtdCiAgSW5jbHVkZToKICAgIC0gJyoqLyouZ2Vtc3BlYycKICAgIC0gJyoqL0dlbWZpbGUnCiAgICAtICcqKi9nZW1zLnJiJwoKR2Vtc3BlYy9EdXBsaWNhdGVkQXNzaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0FuIGF0dHJpYnV0ZSBhc3NpZ25tZW50IG1ldGhvZCBjYWxscyBzaG91bGQgYmUgbGlzdGVkIG9ubHkgb25jZSBpbiBhIGdlbXNwZWMuJwogIEVuYWJsZWQ6IHRydWUKICBTZXZlcml0eTogd2FybmluZwogIFZlcnNpb25BZGRlZDogJzAuNTInCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQwJwogIEluY2x1ZGU6CiAgICAtICcqKi8qLmdlbXNwZWMnCgpHZW1zcGVjL09yZGVyZWREZXBlbmRlbmNpZXM6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgRGVwZW5kZW5jaWVzIGluIHRoZSBnZW1zcGVjIHNob3VsZCBiZSBhbHBoYWJldGljYWxseSBzb3J0ZWQuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTEnCiAgVHJlYXRDb21tZW50c0FzR3JvdXBTZXBhcmF0b3JzOiB0cnVlCiAgIyBCeSBkZWZhdWx0LCAiLSIgYW5kICJfIiBhcmUgaWdub3JlZCBmb3Igb3JkZXIgcHVycG9zZXMuCiAgIyBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZS4KICBDb25zaWRlclB1bmN0dWF0aW9uOiBmYWxzZQogIEluY2x1ZGU6CiAgICAtICcqKi8qLmdlbXNwZWMnCgpHZW1zcGVjL1JlcXVpcmVNRkE6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhhdCB0aGUgZ2Vtc3BlYyBoYXMgbWV0YWRhdGEgdG8gcmVxdWlyZSBNdWx0aS1GYWN0b3IgQXV0aGVudGljYXRpb24gZnJvbSBSdWJ5R2Vtcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNldmVyaXR5OiB3YXJuaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4yMycKICBWZXJzaW9uQ2hhbmdlZDogJzEuNDAnCiAgUmVmZXJlbmNlOgogICAgLSBodHRwczovL2d1aWRlcy5ydWJ5Z2Vtcy5vcmcvbWZhLXJlcXVpcmVtZW50LW9wdC1pbi8KICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1zcGVjJwoKR2Vtc3BlYy9SZXF1aXJlZFJ1YnlWZXJzaW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoYXQgYHJlcXVpcmVkX3J1YnlfdmVyc2lvbmAgb2YgZ2Vtc3BlYyBpcyBzcGVjaWZpZWQgYW5kIGVxdWFsIHRvIGBUYXJnZXRSdWJ5VmVyc2lvbmAgb2YgLnJ1Ym9jb3AueW1sLicKICBFbmFibGVkOiB0cnVlCiAgU2V2ZXJpdHk6IHdhcm5pbmcKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwogIFZlcnNpb25DaGFuZ2VkOiAnMS40MCcKICBJbmNsdWRlOgogICAgLSAnKiovKi5nZW1zcGVjJwoKR2Vtc3BlYy9SdWJ5VmVyc2lvbkdsb2JhbHNVc2FnZToKICBEZXNjcmlwdGlvbjogQ2hlY2tzIHVzYWdlIG9mIFJVQllfVkVSU0lPTiBpbiBnZW1zcGVjLgogIFN0eWxlR3VpZGU6ICcjbm8tcnVieS12ZXJzaW9uLWluLXRoZS1nZW1zcGVjJwogIEVuYWJsZWQ6IHRydWUKICBTZXZlcml0eTogd2FybmluZwogIFZlcnNpb25BZGRlZDogJzAuNzInCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQwJwogIEluY2x1ZGU6CiAgICAtICcqKi8qLmdlbXNwZWMnCgojIyMjIyMjIyMjIyMjIyMjIyMjIyBMYXlvdXQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpMYXlvdXQvQWNjZXNzTW9kaWZpZXJJbmRlbnRhdGlvbjoKICBEZXNjcmlwdGlvbjogQ2hlY2sgaW5kZW50YXRpb24gb2YgcHJpdmF0ZS9wcm90ZWN0ZWQgdmlzaWJpbGl0eSBtb2RpZmllcnMuCiAgU3R5bGVHdWlkZTogJyNpbmRlbnQtcHVibGljLXByaXZhdGUtcHJvdGVjdGVkJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IGluZGVudAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gb3V0ZGVudAogICAgLSBpbmRlbnQKICAjIEJ5IGRlZmF1bHQgdGhlIGluZGVudGF0aW9uIHdpZHRoIGZyb20gYExheW91dC9JbmRlbnRhdGlvbldpZHRoYCBpcyB1c2VkLAogICMgYnV0IGl0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIuCiAgSW5kZW50YXRpb25XaWR0aDogfgoKTGF5b3V0L0FyZ3VtZW50QWxpZ25tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEFsaWduIHRoZSBhcmd1bWVudHMgb2YgYSBtZXRob2QgY2FsbCBpZiB0aGV5IHNwYW4gbW9yZQogICAgICAgICAgICAgICAgIHRoYW4gb25lIGxpbmUuCiAgU3R5bGVHdWlkZTogJyNuby1kb3VibGUtaW5kZW50JwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjY4JwogIFZlcnNpb25DaGFuZ2VkOiAnMC43NycKICAjIEFsaWdubWVudCBvZiBhcmd1bWVudHMgaW4gbXVsdGktbGluZSBtZXRob2QgY2FsbHMuCiAgIwogICMgVGhlIGB3aXRoX2ZpcnN0X2FyZ3VtZW50YCBzdHlsZSBhbGlnbnMgdGhlIGZvbGxvd2luZyBsaW5lcyBhbG9uZyB0aGUgc2FtZQogICMgY29sdW1uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuCiAgIwogICMgICAgIG1ldGhvZF9jYWxsKGEsCiAgIyAgICAgICAgICAgICAgICAgYikKICAjCiAgIyBUaGUgYHdpdGhfZml4ZWRfaW5kZW50YXRpb25gIHN0eWxlIGFsaWducyB0aGUgZm9sbG93aW5nIGxpbmVzIHdpdGggb25lCiAgIyBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgd2l0aCB0aGUgbWV0aG9kIGNhbGwuCiAgIwogICMgICAgIG1ldGhvZF9jYWxsKGEsCiAgIyAgICAgICBiKQogIEVuZm9yY2VkU3R5bGU6IHdpdGhfZmlyc3RfYXJndW1lbnQKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHdpdGhfZmlyc3RfYXJndW1lbnQKICAgIC0gd2l0aF9maXhlZF9pbmRlbnRhdGlvbgogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICBJbmRlbnRhdGlvbldpZHRoOiB+CgpMYXlvdXQvQXJyYXlBbGlnbm1lbnQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQWxpZ24gdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IGxpdGVyYWwgaWYgdGhleSBzcGFuIG1vcmUgdGhhbgogICAgICAgICAgICAgICAgIG9uZSBsaW5lLgogIFN0eWxlR3VpZGU6ICcjbm8tZG91YmxlLWluZGVudCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzcnCiAgIyBBbGlnbm1lbnQgb2YgZWxlbWVudHMgb2YgYSBtdWx0aS1saW5lIGFycmF5LgogICMKICAjIFRoZSBgd2l0aF9maXJzdF9wYXJhbWV0ZXJgIHN0eWxlIGFsaWducyB0aGUgZm9sbG93aW5nIGxpbmVzIGFsb25nIHRoZSBzYW1lCiAgIyBjb2x1bW4gYXMgdGhlIGZpcnN0IGVsZW1lbnQuCiAgIwogICMgICAgIGFycmF5ID0gWzEsIDIsIDMsCiAgIyAgICAgICAgICAgICAgNCwgNSwgNl0KICAjCiAgIyBUaGUgYHdpdGhfZml4ZWRfaW5kZW50YXRpb25gIHN0eWxlIGFsaWducyB0aGUgZm9sbG93aW5nIGxpbmVzIHdpdGggb25lCiAgIyBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgd2l0aCBzdGFydCBvZiBhcnJheS4KICAjCiAgIyAgICAgYXJyYXkgPSBbMSwgMiwgMywKICAjICAgICAgIDQsIDUsIDZdCiAgRW5mb3JjZWRTdHlsZTogd2l0aF9maXJzdF9lbGVtZW50CiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSB3aXRoX2ZpcnN0X2VsZW1lbnQKICAgIC0gd2l0aF9maXhlZF9pbmRlbnRhdGlvbgogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICBJbmRlbnRhdGlvbldpZHRoOiB+CgpMYXlvdXQvQXNzaWdubWVudEluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgQ2hlY2tzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgZmlyc3QgbGluZSBvZiB0aGUKICAgICAgICAgICAgICAgIHJpZ2h0LWhhbmQtc2lkZSBvZiBhIG11bHRpLWxpbmUgYXNzaWdubWVudC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuNDUnCiAgIyBCeSBkZWZhdWx0IHRoZSBpbmRlbnRhdGlvbiB3aWR0aCBmcm9tIGBMYXlvdXQvSW5kZW50YXRpb25XaWR0aGAgaXMgdXNlZCwKICAjIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyLgogIEluZGVudGF0aW9uV2lkdGg6IH4KCkxheW91dC9CZWdpbkVuZEFsaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0FsaWduIGVuZHMgY29ycmVzcG9uZGluZyB0byBiZWdpbnMgY29ycmVjdGx5LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45MScKICAjIFRoZSB2YWx1ZSBgc3RhcnRfb2ZfbGluZWAgbWVhbnMgdGhhdCBgZW5kYCBzaG91bGQgYmUgYWxpZ25lZCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUKICAjIHdoZXJlIHRoZSBgYmVnaW5gIGtleXdvcmQgaXMuCiAgIyBUaGUgdmFsdWUgYGJlZ2luYCBtZWFucyB0aGF0IGBlbmRgIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggdGhlIGBiZWdpbmAga2V5d29yZC4KICBFbmZvcmNlZFN0eWxlQWxpZ25XaXRoOiBzdGFydF9vZl9saW5lCiAgU3VwcG9ydGVkU3R5bGVzQWxpZ25XaXRoOgogICAgLSBzdGFydF9vZl9saW5lCiAgICAtIGJlZ2luCiAgU2V2ZXJpdHk6IHdhcm5pbmcKCkxheW91dC9CbG9ja0FsaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0FsaWduIGJsb2NrIGVuZHMgY29ycmVjdGx5LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICAjIFRoZSB2YWx1ZSBgc3RhcnRfb2ZfYmxvY2tgIG1lYW5zIHRoYXQgdGhlIGBlbmRgIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggbGluZQogICMgd2hlcmUgdGhlIGBkb2Aga2V5d29yZCBhcHBlYXJzLgogICMgVGhlIHZhbHVlIGBzdGFydF9vZl9saW5lYCBtZWFucyBpdCBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHRoZSB3aG9sZQogICMgZXhwcmVzc2lvbidzIHN0YXJ0aW5nIGxpbmUuCiAgIyBUaGUgdmFsdWUgYGVpdGhlcmAgbWVhbnMgYm90aCBhcmUgYWxsb3dlZC4KICBFbmZvcmNlZFN0eWxlQWxpZ25XaXRoOiBlaXRoZXIKICBTdXBwb3J0ZWRTdHlsZXNBbGlnbldpdGg6CiAgICAtIGVpdGhlcgogICAgLSBzdGFydF9vZl9ibG9jawogICAgLSBzdGFydF9vZl9saW5lCgpMYXlvdXQvQmxvY2tFbmROZXdsaW5lOgogIERlc2NyaXB0aW9uOiAnUHV0IGVuZCBzdGF0ZW1lbnQgb2YgbXVsdGlsaW5lIGJsb2NrIG9uIGl0cyBvd24gbGluZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvQ2FzZUluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiAnSW5kZW50YXRpb24gb2Ygd2hlbiBpbiBhIGNhc2UvKHdoZW58aW4pL1tlbHNlL11lbmQuJwogIFN0eWxlR3VpZGU6ICcjaW5kZW50LXdoZW4tdG8tY2FzZScKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMTYnCiAgRW5mb3JjZWRTdHlsZTogY2FzZQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gY2FzZQogICAgLSBlbmQKICBJbmRlbnRPbmVTdGVwOiBmYWxzZQogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICAjIFRoaXMgb25seSBtYXR0ZXJzIGlmIGBJbmRlbnRPbmVTdGVwYCBpcyBgdHJ1ZWAuCiAgSW5kZW50YXRpb25XaWR0aDogfgoKTGF5b3V0L0NsYXNzU3RydWN0dXJlOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgYSBjb25maWd1cmVkIG9yZGVyIG9mIGRlZmluaXRpb25zIHdpdGhpbiBhIGNsYXNzIGJvZHkuJwogIFN0eWxlR3VpZGU6ICcjY29uc2lzdGVudC1jbGFzc2VzJwogIEVuYWJsZWQ6IGZhbHNlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNTInCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjUzJwogIENhdGVnb3JpZXM6CiAgICBtb2R1bGVfaW5jbHVzaW9uOgogICAgICAtIGluY2x1ZGUKICAgICAgLSBwcmVwZW5kCiAgICAgIC0gZXh0ZW5kCiAgRXhwZWN0ZWRPcmRlcjoKICAgIC0gbW9kdWxlX2luY2x1c2lvbgogICAgLSBjb25zdGFudHMKICAgIC0gcHVibGljX2NsYXNzX21ldGhvZHMKICAgIC0gaW5pdGlhbGl6ZXIKICAgIC0gcHVibGljX21ldGhvZHMKICAgIC0gcHJvdGVjdGVkX21ldGhvZHMKICAgIC0gcHJpdmF0ZV9tZXRob2RzCgpMYXlvdXQvQ2xvc2luZ0hlcmVkb2NJbmRlbnRhdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB0aGUgaW5kZW50YXRpb24gb2YgaGVyZSBkb2N1bWVudCBjbG9zaW5ncy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTcnCgpMYXlvdXQvQ2xvc2luZ1BhcmVudGhlc2lzSW5kZW50YXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhlIGluZGVudGF0aW9uIG9mIGhhbmdpbmcgY2xvc2luZyBwYXJlbnRoZXNlcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvQ29tbWVudEluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiAnSW5kZW50YXRpb24gb2YgY29tbWVudHMuJwogIEVuYWJsZWQ6IHRydWUKICAjIFdoZW4gdHJ1ZSwgYWxsb3dzIGNvbW1lbnRzIHRvIGhhdmUgZXh0cmEgaW5kZW50YXRpb24gaWYgdGhhdCBhbGlnbnMgdGhlbQogICMgd2l0aCBhIGNvbW1lbnQgb24gdGhlIHByZWNlZGluZyBsaW5lLgogIEFsbG93Rm9yQWxpZ25tZW50OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjI0JwoKTGF5b3V0L0NvbmRpdGlvblBvc2l0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgY29uZGl0aW9uIHBsYWNlZCBpbiBhIGNvbmZ1c2luZyBwb3NpdGlvbiByZWxhdGl2ZSB0bwogICAgICAgICAgICAgICAgIHRoZSBrZXl3b3JkLgogIFN0eWxlR3VpZGU6ICcjc2FtZS1saW5lLWNvbmRpdGlvbicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICBWZXJzaW9uQ2hhbmdlZDogJzAuODMnCgpMYXlvdXQvRGVmRW5kQWxpZ25tZW50OgogIERlc2NyaXB0aW9uOiAnQWxpZ24gZW5kcyBjb3JyZXNwb25kaW5nIHRvIGRlZnMgY29ycmVjdGx5LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICAjIFRoZSB2YWx1ZSBgZGVmYCBtZWFucyB0aGF0IGBlbmRgIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggdGhlIGRlZiBrZXl3b3JkLgogICMgVGhlIHZhbHVlIGBzdGFydF9vZl9saW5lYCBtZWFucyB0aGF0IGBlbmRgIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggbWV0aG9kCiAgIyBjYWxscyBsaWtlIGBwcml2YXRlYCwgYHB1YmxpY2AsIGV0YywgaWYgcHJlc2VudCBpbiBmcm9udCBvZiB0aGUgYGRlZmAKICAjIGtleXdvcmQgb24gdGhlIHNhbWUgbGluZS4KICBFbmZvcmNlZFN0eWxlQWxpZ25XaXRoOiBzdGFydF9vZl9saW5lCiAgU3VwcG9ydGVkU3R5bGVzQWxpZ25XaXRoOgogICAgLSBzdGFydF9vZl9saW5lCiAgICAtIGRlZgogIFNldmVyaXR5OiB3YXJuaW5nCgpMYXlvdXQvRG90UG9zaXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhlIHBvc2l0aW9uIG9mIHRoZSBkb3QgaW4gbXVsdGktbGluZSBtZXRob2QgY2FsbHMuJwogIFN0eWxlR3VpZGU6ICcjY29uc2lzdGVudC1tdWx0aS1saW5lLWNoYWlucycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBFbmZvcmNlZFN0eWxlOiBsZWFkaW5nCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBsZWFkaW5nCiAgICAtIHRyYWlsaW5nCgpMYXlvdXQvRWxzZUFsaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0FsaWduIGVsc2VzIGFuZCBlbHNpZnMgY29ycmVjdGx5LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9FbXB0eUNvbW1lbnQ6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZW1wdHkgY29tbWVudC4nCiAgRW5hYmxlZDogdHJ1ZQogIEF1dG9Db3JyZWN0OiBjb250ZXh0dWFsCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjEnCiAgQWxsb3dCb3JkZXJDb21tZW50OiB0cnVlCiAgQWxsb3dNYXJnaW5Db21tZW50OiB0cnVlCgpMYXlvdXQvRW1wdHlMaW5lQWZ0ZXJHdWFyZENsYXVzZToKICBEZXNjcmlwdGlvbjogJ0FkZCBlbXB0eSBsaW5lIGFmdGVyIGd1YXJkIGNsYXVzZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjU5JwoKTGF5b3V0L0VtcHR5TGluZUFmdGVyTWFnaWNDb21tZW50OgogIERlc2NyaXB0aW9uOiAnQWRkIGFuIGVtcHR5IGxpbmUgYWZ0ZXIgbWFnaWMgY29tbWVudHMgdG8gc2VwYXJhdGUgdGhlbSBmcm9tIGNvZGUuJwogIFN0eWxlR3VpZGU6ICcjc2VwYXJhdGUtbWFnaWMtY29tbWVudHMtZnJvbS1jb2RlJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwoKTGF5b3V0L0VtcHR5TGluZUFmdGVyTXVsdGlsaW5lQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgZW1wdHkgbGluZSBhZnRlciBtdWx0aWxpbmUgY29uZGl0aW9uLicKICAjIFRoaXMgaXMgZGlzYWJsZWQsIGJlY2F1c2UgdGhpcyBzdHlsZSBpcyBub3QgdmVyeSBjb21tb24gaW4gcHJhY3RpY2UuCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjkwJwogIFJlZmVyZW5jZToKICAgIC0gaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9ydWJ5I211bHRpbGluZS1pZi1uZXdsaW5lCgpMYXlvdXQvRW1wdHlMaW5lQmV0d2VlbkRlZnM6CiAgRGVzY3JpcHRpb246ICdVc2UgZW1wdHkgbGluZXMgYmV0d2VlbiBjbGFzcy9tb2R1bGUvbWV0aG9kIGRlZnMuJwogIFN0eWxlR3VpZGU6ICcjZW1wdHktbGluZXMtYmV0d2Vlbi1tZXRob2RzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yMycKICBFbXB0eUxpbmVCZXR3ZWVuTWV0aG9kRGVmczogdHJ1ZQogIEVtcHR5TGluZUJldHdlZW5DbGFzc0RlZnM6IHRydWUKICBFbXB0eUxpbmVCZXR3ZWVuTW9kdWxlRGVmczogdHJ1ZQogICMgYERlZkxpa2VNYWNyb3NgIHRha2VzIHRoZSBuYW1lIG9mIGFueSBtYWNybyB0aGF0IHlvdSB3YW50IHRvIHRyZWF0IGxpa2UgYSBkZWYuCiAgRGVmTGlrZU1hY3JvczogW10KICAjIGBBbGxvd0FkamFjZW50T25lTGluZURlZnNgIG1lYW5zIHRoYXQgc2luZ2xlIGxpbmUgbWV0aG9kIGRlZmluaXRpb25zIGRvbid0CiAgIyBuZWVkIGFuIGVtcHR5IGxpbmUgYmV0d2VlbiB0aGVtLiBgdHJ1ZWAgYnkgZGVmYXVsdC4KICBBbGxvd0FkamFjZW50T25lTGluZURlZnM6IHRydWUKICAjIENhbiBiZSBhcnJheSB0byBzcGVjaWZ5IG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGVtcHR5IGxpbmVzLCBlLmcuIFsxLCAyXQogIE51bWJlck9mRW1wdHlMaW5lczogMQoKTGF5b3V0L0VtcHR5TGluZXM6CiAgRGVzY3JpcHRpb246ICJEb24ndCB1c2Ugc2V2ZXJhbCBlbXB0eSBsaW5lcyBpbiBhIHJvdy4iCiAgU3R5bGVHdWlkZTogJyN0d28tb3ItbW9yZS1lbXB0eS1saW5lcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9FbXB0eUxpbmVzQXJvdW5kQWNjZXNzTW9kaWZpZXI6CiAgRGVzY3JpcHRpb246ICJLZWVwIGJsYW5rIGxpbmVzIGFyb3VuZCBhY2Nlc3MgbW9kaWZpZXJzLiIKICBTdHlsZUd1aWRlOiAnI2VtcHR5LWxpbmVzLWFyb3VuZC1hY2Nlc3MtbW9kaWZpZXInCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogYXJvdW5kCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBhcm91bmQKICAgIC0gb25seV9iZWZvcmUKICBSZWZlcmVuY2U6CiAgICAjIEEgcmVmZXJlbmNlIHRvIGBFbmZvcmNlZFN0eWxlOiBvbmx5X2JlZm9yZWAuCiAgICAtIGh0dHBzOi8vZWRnZWd1aWRlcy5ydWJ5b25yYWlscy5vcmcvY29udHJpYnV0aW5nX3RvX3J1Ynlfb25fcmFpbHMuaHRtbCNmb2xsb3ctdGhlLWNvZGluZy1jb252ZW50aW9ucwoKTGF5b3V0L0VtcHR5TGluZXNBcm91bmRBcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICJLZWVwcyB0cmFjayBvZiBlbXB0eSBsaW5lcyBhcm91bmQgbWV0aG9kIGFyZ3VtZW50cy4iCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCgpMYXlvdXQvRW1wdHlMaW5lc0Fyb3VuZEF0dHJpYnV0ZUFjY2Vzc29yOgogIERlc2NyaXB0aW9uOiAiS2VlcCBibGFuayBsaW5lcyBhcm91bmQgYXR0cmlidXRlIGFjY2Vzc29ycy4iCiAgU3R5bGVHdWlkZTogJyNlbXB0eS1saW5lcy1hcm91bmQtYXR0cmlidXRlLWFjY2Vzc29yJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjgzJwogIFZlcnNpb25DaGFuZ2VkOiAnMC44NCcKICBBbGxvd0FsaWFzU3ludGF4OiB0cnVlCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIGFsaWFzX21ldGhvZAogICAgLSBwdWJsaWMKICAgIC0gcHJvdGVjdGVkCiAgICAtIHByaXZhdGUKCkxheW91dC9FbXB0eUxpbmVzQXJvdW5kQmVnaW5Cb2R5OgogIERlc2NyaXB0aW9uOiAiS2VlcHMgdHJhY2sgb2YgZW1wdHkgbGluZXMgYXJvdW5kIGJlZ2luLWVuZCBib2RpZXMuIgogIFN0eWxlR3VpZGU6ICcjZW1wdHktbGluZXMtYXJvdW5kLWJvZGllcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9FbXB0eUxpbmVzQXJvdW5kQmxvY2tCb2R5OgogIERlc2NyaXB0aW9uOiAiS2VlcHMgdHJhY2sgb2YgZW1wdHkgbGluZXMgYXJvdW5kIGJsb2NrIGJvZGllcy4iCiAgU3R5bGVHdWlkZTogJyNlbXB0eS1saW5lcy1hcm91bmQtYm9kaWVzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IG5vX2VtcHR5X2xpbmVzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBlbXB0eV9saW5lcwogICAgLSBub19lbXB0eV9saW5lcwoKTGF5b3V0L0VtcHR5TGluZXNBcm91bmRDbGFzc0JvZHk6CiAgRGVzY3JpcHRpb246ICJLZWVwcyB0cmFjayBvZiBlbXB0eSBsaW5lcyBhcm91bmQgY2xhc3MgYm9kaWVzLiIKICBTdHlsZUd1aWRlOiAnI2VtcHR5LWxpbmVzLWFyb3VuZC1ib2RpZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjUzJwogIEVuZm9yY2VkU3R5bGU6IG5vX2VtcHR5X2xpbmVzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBlbXB0eV9saW5lcwogICAgLSBlbXB0eV9saW5lc19leGNlcHRfbmFtZXNwYWNlCiAgICAtIGVtcHR5X2xpbmVzX3NwZWNpYWwKICAgIC0gbm9fZW1wdHlfbGluZXMKICAgIC0gYmVnaW5uaW5nX29ubHkKICAgIC0gZW5kaW5nX29ubHkKCkxheW91dC9FbXB0eUxpbmVzQXJvdW5kRXhjZXB0aW9uSGFuZGxpbmdLZXl3b3JkczoKICBEZXNjcmlwdGlvbjogIktlZXBzIHRyYWNrIG9mIGVtcHR5IGxpbmVzIGFyb3VuZCBleGNlcHRpb24gaGFuZGxpbmcga2V5d29yZHMuIgogIFN0eWxlR3VpZGU6ICcjZW1wdHktbGluZXMtYXJvdW5kLWJvZGllcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9FbXB0eUxpbmVzQXJvdW5kTWV0aG9kQm9keToKICBEZXNjcmlwdGlvbjogIktlZXBzIHRyYWNrIG9mIGVtcHR5IGxpbmVzIGFyb3VuZCBtZXRob2QgYm9kaWVzLiIKICBTdHlsZUd1aWRlOiAnI2VtcHR5LWxpbmVzLWFyb3VuZC1ib2RpZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvRW1wdHlMaW5lc0Fyb3VuZE1vZHVsZUJvZHk6CiAgRGVzY3JpcHRpb246ICJLZWVwcyB0cmFjayBvZiBlbXB0eSBsaW5lcyBhcm91bmQgbW9kdWxlIGJvZGllcy4iCiAgU3R5bGVHdWlkZTogJyNlbXB0eS1saW5lcy1hcm91bmQtYm9kaWVzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IG5vX2VtcHR5X2xpbmVzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBlbXB0eV9saW5lcwogICAgLSBlbXB0eV9saW5lc19leGNlcHRfbmFtZXNwYWNlCiAgICAtIGVtcHR5X2xpbmVzX3NwZWNpYWwKICAgIC0gbm9fZW1wdHlfbGluZXMKCkxheW91dC9FbmRBbGlnbm1lbnQ6CiAgRGVzY3JpcHRpb246ICdBbGlnbiBlbmRzIGNvcnJlY3RseS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCiAgIyBUaGUgdmFsdWUgYGtleXdvcmRgIG1lYW5zIHRoYXQgYGVuZGAgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB0aGUgbWF0Y2hpbmcKICAjIGtleXdvcmQgKGBpZmAsIGB3aGlsZWAsIGV0Yy4pLgogICMgVGhlIHZhbHVlIGB2YXJpYWJsZWAgbWVhbnMgdGhhdCBpbiBhc3NpZ25tZW50cywgYGVuZGAgc2hvdWxkIGJlIGFsaWduZWQKICAjIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSB2YXJpYWJsZSBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgYD1gLiBJbiBhbGwgb3RoZXIKICAjIHNpdHVhdGlvbnMsIGBlbmRgIHNob3VsZCBzdGlsbCBiZSBhbGlnbmVkIHdpdGggdGhlIGtleXdvcmQuCiAgIyBUaGUgdmFsdWUgYHN0YXJ0X29mX2xpbmVgIG1lYW5zIHRoYXQgYGVuZGAgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQKICAjIG9mIHRoZSBsaW5lIHdoaWNoIHRoZSBtYXRjaGluZyBrZXl3b3JkIGFwcGVhcnMgb24uCiAgRW5mb3JjZWRTdHlsZUFsaWduV2l0aDoga2V5d29yZAogIFN1cHBvcnRlZFN0eWxlc0FsaWduV2l0aDoKICAgIC0ga2V5d29yZAogICAgLSB2YXJpYWJsZQogICAgLSBzdGFydF9vZl9saW5lCiAgU2V2ZXJpdHk6IHdhcm5pbmcKCkxheW91dC9FbmRPZkxpbmU6CiAgRGVzY3JpcHRpb246ICdVc2UgVW5peC1zdHlsZSBsaW5lIGVuZGluZ3MuJwogIFN0eWxlR3VpZGU6ICcjY3JsZicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICAjIFRoZSBgbmF0aXZlYCBzdHlsZSBtZWFucyB0aGF0IENSK0xGIChDYXJyaWFnZSBSZXR1cm4gKyBMaW5lIEZlZWQpIGlzCiAgIyBlbmZvcmNlZCBvbiBXaW5kb3dzLCBhbmQgTEYgaXMgZW5mb3JjZWQgb24gb3RoZXIgcGxhdGZvcm1zLiBUaGUgb3RoZXIgc3R5bGVzCiAgIyBtZWFuIExGIGFuZCBDUitMRiwgcmVzcGVjdGl2ZWx5LgogIEVuZm9yY2VkU3R5bGU6IG5hdGl2ZQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gbmF0aXZlCiAgICAtIGxmCiAgICAtIGNybGYKCkxheW91dC9FeHRyYVNwYWNpbmc6CiAgRGVzY3JpcHRpb246ICdEbyBub3QgdXNlIHVubmVjZXNzYXJ5IHNwYWNpbmcuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogICMgV2hlbiB0cnVlLCBhbGxvd3MgbW9zdCB1c2VzIG9mIGV4dHJhIHNwYWNpbmcgaWYgdGhlIGludGVudCBpcyB0byBhbGlnbgogICMgdGhpbmdzIHdpdGggdGhlIHByZXZpb3VzIG9yIG5leHQgbGluZSwgbm90IGNvdW50aW5nIGVtcHR5IGxpbmVzIG9yIGNvbW1lbnQKICAjIGxpbmVzLgogIEFsbG93Rm9yQWxpZ25tZW50OiB0cnVlCiAgIyBXaGVuIHRydWUsIGFsbG93cyB0aGluZ3MgbGlrZSAnb2JqLm1ldGgoYXJnKSAgIyBjb21tZW50JywKICAjIHJhdGhlciB0aGFuIGluc2lzdGluZyBvbiAnb2JqLm1ldGgoYXJnKSAjIGNvbW1lbnQnLgogICMgSWYgZG9uZSBmb3IgYWxpZ25tZW50LCBlaXRoZXIgdGhpcyBPUiBBbGxvd0ZvckFsaWdubWVudCB3aWxsIGFsbG93IGl0LgogIEFsbG93QmVmb3JlVHJhaWxpbmdDb21tZW50czogZmFsc2UKICAjIFdoZW4gdHJ1ZSwgZm9yY2VzIHRoZSBhbGlnbm1lbnQgb2YgYD1gIGluIGFzc2lnbm1lbnRzIG9uIGNvbnNlY3V0aXZlIGxpbmVzLgogIEZvcmNlRXF1YWxTaWduQWxpZ25tZW50OiBmYWxzZQoKTGF5b3V0L0ZpcnN0QXJndW1lbnRJbmRlbnRhdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGZpcnN0IGFyZ3VtZW50IGluIGEgbWV0aG9kIGNhbGwuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjY4JwogIFZlcnNpb25DaGFuZ2VkOiAnMC43NycKICBFbmZvcmNlZFN0eWxlOiBzcGVjaWFsX2Zvcl9pbm5lcl9tZXRob2RfY2FsbF9pbl9wYXJlbnRoZXNlcwogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgVGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYWx3YXlzIGJlIGluZGVudGVkIG9uZSBzdGVwIG1vcmUgdGhhbiB0aGUKICAgICMgcHJlY2VkaW5nIGxpbmUuCiAgICAtIGNvbnNpc3RlbnQKICAgICMgVGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYWx3YXlzIGJlIGluZGVudGVkIG9uZSBsZXZlbCByZWxhdGl2ZSB0byB0aGUKICAgICMgcGFyZW50IHRoYXQgaXMgcmVjZWl2aW5nIHRoZSBwYXJhbWV0ZXIKICAgIC0gY29uc2lzdGVudF9yZWxhdGl2ZV90b19yZWNlaXZlcgogICAgIyBUaGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBub3JtYWxseSBiZSBpbmRlbnRlZCBvbmUgc3RlcCBtb3JlIHRoYW4gdGhlCiAgICAjIHByZWNlZGluZyBsaW5lLCBidXQgaWYgaXQncyBhIHBhcmFtZXRlciBmb3IgYSBtZXRob2QgY2FsbCB0aGF0IGlzIGl0c2VsZgogICAgIyBhIHBhcmFtZXRlciBpbiBhIG1ldGhvZCBjYWxsLCB0aGVuIHRoZSBpbm5lciBwYXJhbWV0ZXIgc2hvdWxkIGJlIGluZGVudGVkCiAgICAjIHJlbGF0aXZlIHRvIHRoZSBpbm5lciBtZXRob2QuCiAgICAtIHNwZWNpYWxfZm9yX2lubmVyX21ldGhvZF9jYWxsCiAgICAjIFNhbWUgYXMgYHNwZWNpYWxfZm9yX2lubmVyX21ldGhvZF9jYWxsYCBleGNlcHQgdGhhdCB0aGUgc3BlY2lhbCBydWxlIG9ubHkKICAgICMgYXBwbGllcyBpZiB0aGUgb3V0ZXIgbWV0aG9kIGNhbGwgZW5jbG9zZXMgaXRzIGFyZ3VtZW50cyBpbiBwYXJlbnRoZXNlcy4KICAgIC0gc3BlY2lhbF9mb3JfaW5uZXJfbWV0aG9kX2NhbGxfaW5fcGFyZW50aGVzZXMKICAjIEJ5IGRlZmF1bHQgdGhlIGluZGVudGF0aW9uIHdpZHRoIGZyb20gYExheW91dC9JbmRlbnRhdGlvbldpZHRoYCBpcyB1c2VkLAogICMgYnV0IGl0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIuCiAgSW5kZW50YXRpb25XaWR0aDogfgoKTGF5b3V0L0ZpcnN0QXJyYXlFbGVtZW50SW5kZW50YXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhbiBhcnJheQogICAgICAgICAgICAgICAgIGxpdGVyYWwuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNjgnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwogICMgVGhlIHZhbHVlIGBzcGVjaWFsX2luc2lkZV9wYXJlbnRoZXNlc2AgbWVhbnMgdGhhdCBhcnJheSBsaXRlcmFscyB3aXRoCiAgIyBicmFja2V0cyB0aGF0IGhhdmUgdGhlaXIgb3BlbmluZyBicmFja2V0IG9uIHRoZSBzYW1lIGxpbmUgYXMgYSBzdXJyb3VuZGluZwogICMgb3BlbmluZyByb3VuZCBwYXJlbnRoZXNpcywgc2hhbGwgaGF2ZSB0aGVpciBmaXJzdCBlbGVtZW50IGluZGVudGVkIHJlbGF0aXZlCiAgIyB0byB0aGUgZmlyc3QgcG9zaXRpb24gaW5zaWRlIHRoZSBwYXJlbnRoZXNpcy4KICAjCiAgIyBUaGUgdmFsdWUgYGNvbnNpc3RlbnRgIG1lYW5zIHRoYXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IHNoYWxsCiAgIyBhbHdheXMgYmUgcmVsYXRpdmUgdG8gdGhlIGZpcnN0IHBvc2l0aW9uIG9mIHRoZSBsaW5lIHdoZXJlIHRoZSBvcGVuaW5nCiAgIyBicmFja2V0IGlzLgogICMKICAjIFRoZSB2YWx1ZSBgYWxpZ25fYnJhY2tldHNgIG1lYW5zIHRoYXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50CiAgIyBzaGFsbCBhbHdheXMgYmUgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcGVuaW5nIGJyYWNrZXQuCiAgRW5mb3JjZWRTdHlsZTogc3BlY2lhbF9pbnNpZGVfcGFyZW50aGVzZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwZWNpYWxfaW5zaWRlX3BhcmVudGhlc2VzCiAgICAtIGNvbnNpc3RlbnQKICAgIC0gYWxpZ25fYnJhY2tldHMKICAjIEJ5IGRlZmF1bHQgdGhlIGluZGVudGF0aW9uIHdpZHRoIGZyb20gYExheW91dC9JbmRlbnRhdGlvbldpZHRoYCBpcyB1c2VkLAogICMgYnV0IGl0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIuCiAgSW5kZW50YXRpb25XaWR0aDogfgoKTGF5b3V0L0ZpcnN0QXJyYXlFbGVtZW50TGluZUJyZWFrOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYSBsaW5lIGJyZWFrIGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhCiAgICAgICAgICAgICAgICAgbXVsdGktbGluZSBhcnJheS4KICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgQWxsb3dNdWx0aWxpbmVGaW5hbEVsZW1lbnQ6IGZhbHNlCgpMYXlvdXQvRmlyc3RIYXNoRWxlbWVudEluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgZmlyc3Qga2V5IGluIGEgaGFzaCBsaXRlcmFsLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC42OCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzcnCiAgIyBUaGUgdmFsdWUgYHNwZWNpYWxfaW5zaWRlX3BhcmVudGhlc2VzYCBtZWFucyB0aGF0IGhhc2ggbGl0ZXJhbHMgd2l0aCBicmFjZXMKICAjIHRoYXQgaGF2ZSB0aGVpciBvcGVuaW5nIGJyYWNlIG9uIHRoZSBzYW1lIGxpbmUgYXMgYSBzdXJyb3VuZGluZyBvcGVuaW5nCiAgIyByb3VuZCBwYXJlbnRoZXNpcywgc2hhbGwgaGF2ZSB0aGVpciBmaXJzdCBrZXkgaW5kZW50ZWQgcmVsYXRpdmUgdG8gdGhlCiAgIyBmaXJzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIHBhcmVudGhlc2lzLgogICMKICAjIFRoZSB2YWx1ZSBgY29uc2lzdGVudGAgbWVhbnMgdGhhdCB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGZpcnN0IGtleSBzaGFsbAogICMgYWx3YXlzIGJlIHJlbGF0aXZlIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBvZiB0aGUgbGluZSB3aGVyZSB0aGUgb3BlbmluZwogICMgYnJhY2UgaXMuCiAgIwogICMgVGhlIHZhbHVlIGBhbGlnbl9icmFjZXNgIG1lYW5zIHRoYXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBmaXJzdCBrZXkgc2hhbGwKICAjIGFsd2F5cyBiZSByZWxhdGl2ZSB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG9wZW5pbmcgYnJhY2UuCiAgRW5mb3JjZWRTdHlsZTogc3BlY2lhbF9pbnNpZGVfcGFyZW50aGVzZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwZWNpYWxfaW5zaWRlX3BhcmVudGhlc2VzCiAgICAtIGNvbnNpc3RlbnQKICAgIC0gYWxpZ25fYnJhY2VzCiAgIyBCeSBkZWZhdWx0IHRoZSBpbmRlbnRhdGlvbiB3aWR0aCBmcm9tIGBMYXlvdXQvSW5kZW50YXRpb25XaWR0aGAgaXMgdXNlZCwKICAjIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyLgogIEluZGVudGF0aW9uV2lkdGg6IH4KCkxheW91dC9GaXJzdEhhc2hFbGVtZW50TGluZUJyZWFrOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYSBsaW5lIGJyZWFrIGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhCiAgICAgICAgICAgICAgICAgbXVsdGktbGluZSBoYXNoLgogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBBbGxvd011bHRpbGluZUZpbmFsRWxlbWVudDogZmFsc2UKCkxheW91dC9GaXJzdE1ldGhvZEFyZ3VtZW50TGluZUJyZWFrOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYSBsaW5lIGJyZWFrIGJlZm9yZSB0aGUgZmlyc3QgYXJndW1lbnQgaW4gYQogICAgICAgICAgICAgICAgIG11bHRpLWxpbmUgbWV0aG9kIGNhbGwuCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEFsbG93TXVsdGlsaW5lRmluYWxFbGVtZW50OiBmYWxzZQoKTGF5b3V0L0ZpcnN0TWV0aG9kUGFyYW1ldGVyTGluZUJyZWFrOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYSBsaW5lIGJyZWFrIGJlZm9yZSB0aGUgZmlyc3QgcGFyYW1ldGVyIGluIGEKICAgICAgICAgICAgICAgICBtdWx0aS1saW5lIG1ldGhvZCBwYXJhbWV0ZXIgZGVmaW5pdGlvbi4KICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgQWxsb3dNdWx0aWxpbmVGaW5hbEVsZW1lbnQ6IGZhbHNlCgpMYXlvdXQvRmlyc3RQYXJhbWV0ZXJJbmRlbnRhdGlvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaW4gYQogICAgICAgICAgICAgICAgIG1ldGhvZCBkZWZpbml0aW9uLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIFZlcnNpb25DaGFuZ2VkOiAnMC43NycKICBFbmZvcmNlZFN0eWxlOiBjb25zaXN0ZW50CiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBjb25zaXN0ZW50CiAgICAtIGFsaWduX3BhcmVudGhlc2VzCiAgIyBCeSBkZWZhdWx0IHRoZSBpbmRlbnRhdGlvbiB3aWR0aCBmcm9tIGBMYXlvdXQvSW5kZW50YXRpb25XaWR0aGAgaXMgdXNlZCwKICAjIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyLgogIEluZGVudGF0aW9uV2lkdGg6IH4KCkxheW91dC9IYXNoQWxpZ25tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgQWxpZ24gdGhlIGVsZW1lbnRzIG9mIGEgaGFzaCBsaXRlcmFsIGlmIHRoZXkgc3BhbiBtb3JlIHRoYW4KICAgIG9uZSBsaW5lLgogIEVuYWJsZWQ6IHRydWUKICBBbGxvd011bHRpcGxlU3R5bGVzOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMTYnCiAgIyBBbGlnbm1lbnQgb2YgZW50cmllcyB1c2luZyBoYXNoIHJvY2tldCBhcyBzZXBhcmF0b3IuIFZhbGlkIHZhbHVlcyBhcmU6CiAgIwogICMga2V5IC0gbGVmdCBhbGlnbm1lbnQgb2Yga2V5cwogICMgICAnYScgPT4gMgogICMgICAnYmInID0+IDMKICAjIHNlcGFyYXRvciAtIGFsaWdubWVudCBvZiBoYXNoIHJvY2tldHMsIGtleXMgYXJlIHJpZ2h0IGFsaWduZWQKICAjICAgICdhJyA9PiAyCiAgIyAgICdiYicgPT4gMwogICMgdGFibGUgLSBsZWZ0IGFsaWdubWVudCBvZiBrZXlzLCBoYXNoIHJvY2tldHMsIGFuZCB2YWx1ZXMKICAjICAgJ2EnICA9PiAyCiAgIyAgICdiYicgPT4gMwogIEVuZm9yY2VkSGFzaFJvY2tldFN0eWxlOiBrZXkKICBTdXBwb3J0ZWRIYXNoUm9ja2V0U3R5bGVzOgogICAgLSBrZXkKICAgIC0gc2VwYXJhdG9yCiAgICAtIHRhYmxlCiAgIyBBbGlnbm1lbnQgb2YgZW50cmllcyB1c2luZyBjb2xvbiBhcyBzZXBhcmF0b3IuIFZhbGlkIHZhbHVlcyBhcmU6CiAgIwogICMga2V5IC0gbGVmdCBhbGlnbm1lbnQgb2Yga2V5cwogICMgICBhOiAwCiAgIyAgIGJiOiAxCiAgIyBzZXBhcmF0b3IgLSBhbGlnbm1lbnQgb2YgY29sb25zLCBrZXlzIGFyZSByaWdodCBhbGlnbmVkCiAgIyAgICBhOiAwCiAgIyAgIGJiOiAxCiAgIyB0YWJsZSAtIGxlZnQgYWxpZ25tZW50IG9mIGtleXMgYW5kIHZhbHVlcwogICMgICBhOiAgMAogICMgICBiYjogMQogIEVuZm9yY2VkQ29sb25TdHlsZToga2V5CiAgU3VwcG9ydGVkQ29sb25TdHlsZXM6CiAgICAtIGtleQogICAgLSBzZXBhcmF0b3IKICAgIC0gdGFibGUKICAjIFNlbGVjdCB3aGV0aGVyIGhhc2hlcyB0aGF0IGFyZSB0aGUgbGFzdCBhcmd1bWVudCBpbiBhIG1ldGhvZCBjYWxsIHNob3VsZCBiZQogICMgaW5zcGVjdGVkPyBWYWxpZCB2YWx1ZXMgYXJlOgogICMKICAjIGFsd2F5c19pbnNwZWN0IC0gSW5zcGVjdCBib3RoIGltcGxpY2l0IGFuZCBleHBsaWNpdCBoYXNoZXMuCiAgIyAgIFJlZ2lzdGVycyBhbiBvZmZlbnNlIGZvcjoKICAjICAgICBmdW5jdGlvbihhOiAxLAogICMgICAgICAgYjogMikKICAjICAgUmVnaXN0ZXJzIGFuIG9mZmVuc2UgZm9yOgogICMgICAgIGZ1bmN0aW9uKHthOiAxLAogICMgICAgICAgYjogMn0pCiAgIyBhbHdheXNfaWdub3JlIC0gSWdub3JlIGJvdGggaW1wbGljaXQgYW5kIGV4cGxpY2l0IGhhc2hlcy4KICAjICAgQWNjZXB0czoKICAjICAgICBmdW5jdGlvbihhOiAxLAogICMgICAgICAgYjogMikKICAjICAgQWNjZXB0czoKICAjICAgICBmdW5jdGlvbih7YTogMSwKICAjICAgICAgIGI6IDJ9KQogICMgaWdub3JlX2ltcGxpY2l0IC0gSWdub3JlIG9ubHkgaW1wbGljaXQgaGFzaGVzLgogICMgICBBY2NlcHRzOgogICMgICAgIGZ1bmN0aW9uKGE6IDEsCiAgIyAgICAgICBiOiAyKQogICMgICBSZWdpc3RlcnMgYW4gb2ZmZW5zZSBmb3I6CiAgIyAgICAgZnVuY3Rpb24oe2E6IDEsCiAgIyAgICAgICBiOiAyfSkKICAjIGlnbm9yZV9leHBsaWNpdCAtIElnbm9yZSBvbmx5IGV4cGxpY2l0IGhhc2hlcy4KICAjICAgQWNjZXB0czoKICAjICAgICBmdW5jdGlvbih7YTogMSwKICAjICAgICAgIGI6IDJ9KQogICMgICBSZWdpc3RlcnMgYW4gb2ZmZW5zZSBmb3I6CiAgIyAgICAgZnVuY3Rpb24oYTogMSwKICAjICAgICAgIGI6IDIpCiAgRW5mb3JjZWRMYXN0QXJndW1lbnRIYXNoU3R5bGU6IGFsd2F5c19pbnNwZWN0CiAgU3VwcG9ydGVkTGFzdEFyZ3VtZW50SGFzaFN0eWxlczoKICAgIC0gYWx3YXlzX2luc3BlY3QKICAgIC0gYWx3YXlzX2lnbm9yZQogICAgLSBpZ25vcmVfaW1wbGljaXQKICAgIC0gaWdub3JlX2V4cGxpY2l0CgpMYXlvdXQvSGVyZWRvY0FyZ3VtZW50Q2xvc2luZ1BhcmVudGhlc2lzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgdGhlIHBsYWNlbWVudCBvZiB0aGUgY2xvc2luZyBwYXJlbnRoZXNpcyBpbiBhCiAgICAgICAgICAgICAgICAgbWV0aG9kIGNhbGwgdGhhdCBwYXNzZXMgYSBIRVJFRE9DIHN0cmluZyBhcyBhbiBhcmd1bWVudC4KICBFbmFibGVkOiBmYWxzZQogIFN0eWxlR3VpZGU6ICcjaGVyZWRvYy1hcmd1bWVudC1jbG9zaW5nLXBhcmVudGhlc2VzJwogIFZlcnNpb25BZGRlZDogJzAuNjgnCgpMYXlvdXQvSGVyZWRvY0luZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgaGVyZSBkb2N1bWVudCBib2RpZXMuJwogIFN0eWxlR3VpZGU6ICcjc3F1aWdnbHktaGVyZWRvY3MnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjg1JwoKTGF5b3V0L0luZGVudGF0aW9uQ29uc2lzdGVuY3k6CiAgRGVzY3JpcHRpb246ICdLZWVwIGluZGVudGF0aW9uIHN0cmFpZ2h0LicKICBTdHlsZUd1aWRlOiAnI3NwYWNlcy1pbmRlbnRhdGlvbicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICAjIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYGluZGVudGVkYCBhbmQgYG5vcm1hbGAgaXMgdGhhdCB0aGUgYGluZGVudGVkX2ludGVybmFsX21ldGhvZHNgCiAgIyBzdHlsZSBwcmVzY3JpYmVzIHRoYXQgaW4gY2xhc3NlcyBhbmQgbW9kdWxlcyB0aGUgYHByb3RlY3RlZGAgYW5kIGBwcml2YXRlYAogICMgbW9kaWZpZXIga2V5d29yZHMgc2hhbGwgYmUgaW5kZW50ZWQgdGhlIHNhbWUgYXMgcHVibGljIG1ldGhvZHMgYW5kIHRoYXQKICAjIHByb3RlY3RlZCBhbmQgcHJpdmF0ZSBtZW1iZXJzIHNoYWxsIGJlIGluZGVudGVkIG9uZSBzdGVwIG1vcmUgdGhhbiB0aGUKICAjIG1vZGlmaWVycy4gT3RoZXIgdGhhbiB0aGF0LCBib3RoIHN0eWxlcyBtZWFuIHRoYXQgZW50aXRpZXMgb24gdGhlIHNhbWUKICAjIGxvZ2ljYWwgZGVwdGggc2hhbGwgaGF2ZSB0aGUgc2FtZSBpbmRlbnRhdGlvbi4KICBFbmZvcmNlZFN0eWxlOiBub3JtYWwKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIG5vcm1hbAogICAgLSBpbmRlbnRlZF9pbnRlcm5hbF9tZXRob2RzCiAgUmVmZXJlbmNlOgogICAgIyBBIHJlZmVyZW5jZSB0byBgRW5mb3JjZWRTdHlsZTogaW5kZW50ZWRfaW50ZXJuYWxfbWV0aG9kc2AuCiAgICAtIGh0dHBzOi8vZWRnZWd1aWRlcy5ydWJ5b25yYWlscy5vcmcvY29udHJpYnV0aW5nX3RvX3J1Ynlfb25fcmFpbHMuaHRtbCNmb2xsb3ctdGhlLWNvZGluZy1jb252ZW50aW9ucwoKTGF5b3V0L0luZGVudGF0aW9uU3R5bGU6CiAgRGVzY3JpcHRpb246ICdDb25zaXN0ZW50IGluZGVudGF0aW9uIGVpdGhlciB3aXRoIHRhYnMgb25seSBvciBzcGFjZXMgb25seS4nCiAgU3R5bGVHdWlkZTogJyNzcGFjZXMtaW5kZW50YXRpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgyJwogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICAjIEl0IGlzIHVzZWQgZHVyaW5nIGF1dG9jb3JyZWN0aW9uIHRvIGRldGVybWluZSBob3cgbWFueSBzcGFjZXMgc2hvdWxkCiAgIyByZXBsYWNlIGVhY2ggdGFiLgogIEluZGVudGF0aW9uV2lkdGg6IH4KICBFbmZvcmNlZFN0eWxlOiBzcGFjZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwYWNlcwogICAgLSB0YWJzCgpMYXlvdXQvSW5kZW50YXRpb25XaWR0aDoKICBEZXNjcmlwdGlvbjogJ1VzZSAyIHNwYWNlcyBmb3IgaW5kZW50YXRpb24uJwogIFN0eWxlR3VpZGU6ICcjc3BhY2VzLWluZGVudGF0aW9uJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogICMgTnVtYmVyIG9mIHNwYWNlcyBmb3IgZWFjaCBpbmRlbnRhdGlvbiBsZXZlbC4KICBXaWR0aDogMgogIEFsbG93ZWRQYXR0ZXJuczogW10KCkxheW91dC9Jbml0aWFsSW5kZW50YXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICBDaGVja3MgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBmaXJzdCBub24tYmxhbmsgbm9uLWNvbW1lbnQgbGluZSBpbiBhIGZpbGUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvTGVhZGluZ0NvbW1lbnRTcGFjZToKICBEZXNjcmlwdGlvbjogJ0NvbW1lbnRzIHNob3VsZCBzdGFydCB3aXRoIGEgc3BhY2UuJwogIFN0eWxlR3VpZGU6ICcjaGFzaC1zcGFjZScKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzMnCiAgQWxsb3dEb3h5Z2VuQ29tbWVudFN0eWxlOiBmYWxzZQogIEFsbG93R2VtZmlsZVJ1YnlDb21tZW50OiBmYWxzZQoKTGF5b3V0L0xlYWRpbmdFbXB0eUxpbmVzOgogIERlc2NyaXB0aW9uOiBDaGVjayBmb3IgdW5uZWNlc3NhcnkgYmxhbmsgbGluZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGZpbGUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTcnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwoKTGF5b3V0L0xpbmVDb250aW51YXRpb25MZWFkaW5nU3BhY2U6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIFVzZSB0cmFpbGluZyBzcGFjZXMgaW5zdGVhZCBvZiBsZWFkaW5nIHNwYWNlcyBpbiBzdHJpbmdzCiAgICAgICAgICAgICAgICAgIGJyb2tlbiBvdmVyIG11bHRpcGxlIGxpbmVzIChieSBhIGJhY2tzbGFzaCkuCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQ1JwogIEVuZm9yY2VkU3R5bGU6IHRyYWlsaW5nCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBsZWFkaW5nCiAgICAtIHRyYWlsaW5nCgpMYXlvdXQvTGluZUNvbnRpbnVhdGlvblNwYWNpbmc6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhlIHNwYWNpbmcgaW4gZnJvbnQgb2YgYmFja3NsYXNoIGluIGxpbmUgY29udGludWF0aW9ucy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzEnCiAgRW5mb3JjZWRTdHlsZTogc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCgpMYXlvdXQvTGluZUVuZFN0cmluZ0NvbmNhdGVuYXRpb25JbmRlbnRhdGlvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBuZXh0IGxpbmUgYWZ0ZXIgYSBsaW5lIHRoYXQKICAgICAgICAgICAgICAgICBlbmRzIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCBhbmQgYSBiYWNrc2xhc2guCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMTgnCiAgRW5mb3JjZWRTdHlsZTogYWxpZ25lZAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gYWxpZ25lZAogICAgLSBpbmRlbnRlZAogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICBJbmRlbnRhdGlvbldpZHRoOiB+CgpMYXlvdXQvTGluZUxlbmd0aDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB0aGF0IGxpbmUgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgY29uZmlndXJlZCBsaW1pdC4nCiAgU3R5bGVHdWlkZTogJyNtYXgtbGluZS1sZW5ndGgnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQnCiAgTWF4OiAxMjAKICAjIFRvIG1ha2UgaXQgcG9zc2libGUgdG8gY29weSBvciBjbGljayBvbiBVUklzIGluIHRoZSBjb2RlLCB3ZSBhbGxvdyBsaW5lcwogICMgY29udGFpbmluZyBhIFVSSSB0byBiZSBsb25nZXIgdGhhbiBNYXguCiAgQWxsb3dIZXJlZG9jOiB0cnVlCiAgQWxsb3dVUkk6IHRydWUKICBVUklTY2hlbWVzOgogICAgLSBodHRwCiAgICAtIGh0dHBzCiAgIyBUaGUgSWdub3JlQ29wRGlyZWN0aXZlcyBvcHRpb24gY2F1c2VzIHRoZSBMaW5lTGVuZ3RoIHJ1bGUgdG8gaWdub3JlIGNvcAogICMgZGlyZWN0aXZlcyBsaWtlICcjIHJ1Ym9jb3A6IGVuYWJsZSAuLi4nIHdoZW4gY2FsY3VsYXRpbmcgYSBsaW5lJ3MgbGVuZ3RoLgogIElnbm9yZUNvcERpcmVjdGl2ZXM6IHRydWUKICAjIFRoZSBBbGxvd2VkUGF0dGVybnMgb3B0aW9uIGlzIGEgbGlzdCBvZiAhcnVieS9yZWdleHAgYW5kL29yIHN0cmluZwogICMgZWxlbWVudHMuIFN0cmluZ3Mgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gUmVnZXhwIG9iamVjdHMuIEEgbGluZSB0aGF0IG1hdGNoZXMKICAjIGFueSByZWd1bGFyIGV4cHJlc3Npb24gbGlzdGVkIGluIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBieSBMaW5lTGVuZ3RoLgogIEFsbG93ZWRQYXR0ZXJuczogW10KCkxheW91dC9NdWx0aWxpbmVBcnJheUJyYWNlTGF5b3V0OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IHRoZSBjbG9zaW5nIGJyYWNlIGluIGFuIGFycmF5IGxpdGVyYWwgaXMKICAgICAgICAgICAgICAgICBlaXRoZXIgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgbGFzdCBhcnJheSBlbGVtZW50LCBvcgogICAgICAgICAgICAgICAgIGEgbmV3IGxpbmUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogc3ltbWV0cmljYWwKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIHN5bW1ldHJpY2FsOiBjbG9zaW5nIGJyYWNlIGlzIHBvc2l0aW9uZWQgaW4gc2FtZSB3YXkgYXMgb3BlbmluZyBicmFjZQogICAgIyBuZXdfbGluZTogY2xvc2luZyBicmFjZSBpcyBhbHdheXMgb24gYSBuZXcgbGluZQogICAgIyBzYW1lX2xpbmU6IGNsb3NpbmcgYnJhY2UgaXMgYWx3YXlzIG9uIHRoZSBzYW1lIGxpbmUgYXMgbGFzdCBlbGVtZW50CiAgICAtIHN5bW1ldHJpY2FsCiAgICAtIG5ld19saW5lCiAgICAtIHNhbWVfbGluZQoKTGF5b3V0L011bHRpbGluZUFycmF5TGluZUJyZWFrczoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgdGhhdCBlYWNoIGl0ZW0gaW4gYSBtdWx0aS1saW5lIGFycmF5IGxpdGVyYWwKICAgICAgICAgICAgICAgICBzdGFydHMgb24gYSBzZXBhcmF0ZSBsaW5lLgogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC42NycKICBBbGxvd011bHRpbGluZUZpbmFsRWxlbWVudDogZmFsc2UKCkxheW91dC9NdWx0aWxpbmVBc3NpZ25tZW50TGF5b3V0OgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgZm9yIGEgbmV3bGluZSBhZnRlciB0aGUgYXNzaWdubWVudCBvcGVyYXRvciBpbiBtdWx0aS1saW5lIGFzc2lnbm1lbnRzLicKICBTdHlsZUd1aWRlOiAnI2luZGVudC1jb25kaXRpb25hbC1hc3NpZ25tZW50JwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICAjIFRoZSB0eXBlcyBvZiBhc3NpZ25tZW50cyB3aGljaCBhcmUgc3ViamVjdCB0byB0aGlzIHJ1bGUuCiAgU3VwcG9ydGVkVHlwZXM6CiAgICAtIGJsb2NrCiAgICAtIGNhc2UKICAgIC0gY2xhc3MKICAgIC0gaWYKICAgIC0ga3diZWdpbgogICAgLSBtb2R1bGUKICBFbmZvcmNlZFN0eWxlOiBuZXdfbGluZQogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgRW5zdXJlcyB0aGF0IHRoZSBhc3NpZ25tZW50IG9wZXJhdG9yIGFuZCB0aGUgcmhzIGFyZSBvbiB0aGUgc2FtZSBsaW5lIGZvcgogICAgIyB0aGUgc2V0IG9mIHN1cHBvcnRlZCB0eXBlcy4KICAgIC0gc2FtZV9saW5lCiAgICAjIEVuc3VyZXMgdGhhdCB0aGUgYXNzaWdubWVudCBvcGVyYXRvciBhbmQgdGhlIHJocyBhcmUgb24gc2VwYXJhdGUgbGluZXMKICAgICMgZm9yIHRoZSBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzLgogICAgLSBuZXdfbGluZQoKTGF5b3V0L011bHRpbGluZUJsb2NrTGF5b3V0OgogIERlc2NyaXB0aW9uOiAnRW5zdXJlcyBuZXdsaW5lcyBhZnRlciBtdWx0aWxpbmUgYmxvY2sgZG8gc3RhdGVtZW50cy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvTXVsdGlsaW5lSGFzaEJyYWNlTGF5b3V0OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IHRoZSBjbG9zaW5nIGJyYWNlIGluIGEgaGFzaCBsaXRlcmFsIGlzCiAgICAgICAgICAgICAgICAgZWl0aGVyIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGxhc3QgaGFzaCBlbGVtZW50LCBvcgogICAgICAgICAgICAgICAgIGEgbmV3IGxpbmUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogc3ltbWV0cmljYWwKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIHN5bW1ldHJpY2FsOiBjbG9zaW5nIGJyYWNlIGlzIHBvc2l0aW9uZWQgaW4gc2FtZSB3YXkgYXMgb3BlbmluZyBicmFjZQogICAgIyBuZXdfbGluZTogY2xvc2luZyBicmFjZSBpcyBhbHdheXMgb24gYSBuZXcgbGluZQogICAgIyBzYW1lX2xpbmU6IGNsb3NpbmcgYnJhY2UgaXMgYWx3YXlzIG9uIHNhbWUgbGluZSBhcyBsYXN0IGVsZW1lbnQKICAgIC0gc3ltbWV0cmljYWwKICAgIC0gbmV3X2xpbmUKICAgIC0gc2FtZV9saW5lCgpMYXlvdXQvTXVsdGlsaW5lSGFzaEtleUxpbmVCcmVha3M6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoYXQgZWFjaCBpdGVtIGluIGEgbXVsdGktbGluZSBoYXNoIGxpdGVyYWwKICAgICAgICAgICAgICAgICBzdGFydHMgb24gYSBzZXBhcmF0ZSBsaW5lLgogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC42NycKICBBbGxvd011bHRpbGluZUZpbmFsRWxlbWVudDogZmFsc2UKCkxheW91dC9NdWx0aWxpbmVNZXRob2RBcmd1bWVudExpbmVCcmVha3M6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoYXQgZWFjaCBhcmd1bWVudCBpbiBhIG11bHRpLWxpbmUgbWV0aG9kIGNhbGwKICAgICAgICAgICAgICAgICBzdGFydHMgb24gYSBzZXBhcmF0ZSBsaW5lLgogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC42NycKICBBbGxvd011bHRpbGluZUZpbmFsRWxlbWVudDogZmFsc2UKCkxheW91dC9NdWx0aWxpbmVNZXRob2RDYWxsQnJhY2VMYXlvdXQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoYXQgdGhlIGNsb3NpbmcgYnJhY2UgaW4gYSBtZXRob2QgY2FsbCBpcwogICAgICAgICAgICAgICAgIGVpdGhlciBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBsYXN0IG1ldGhvZCBhcmd1bWVudCwgb3IKICAgICAgICAgICAgICAgICBhIG5ldyBsaW5lLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IHN5bW1ldHJpY2FsCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgIyBzeW1tZXRyaWNhbDogY2xvc2luZyBicmFjZSBpcyBwb3NpdGlvbmVkIGluIHNhbWUgd2F5IGFzIG9wZW5pbmcgYnJhY2UKICAgICMgbmV3X2xpbmU6IGNsb3NpbmcgYnJhY2UgaXMgYWx3YXlzIG9uIGEgbmV3IGxpbmUKICAgICMgc2FtZV9saW5lOiBjbG9zaW5nIGJyYWNlIGlzIGFsd2F5cyBvbiB0aGUgc2FtZSBsaW5lIGFzIGxhc3QgYXJndW1lbnQKICAgIC0gc3ltbWV0cmljYWwKICAgIC0gbmV3X2xpbmUKICAgIC0gc2FtZV9saW5lCgpMYXlvdXQvTXVsdGlsaW5lTWV0aG9kQ2FsbEluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBpbmRlbnRhdGlvbiBvZiBtZXRob2QgY2FsbHMgd2l0aCB0aGUgZG90IG9wZXJhdG9yCiAgICAgICAgICAgICAgICAgdGhhdCBzcGFuIG1vcmUgdGhhbiBvbmUgbGluZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBFbmZvcmNlZFN0eWxlOiBhbGlnbmVkCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBhbGlnbmVkCiAgICAtIGluZGVudGVkCiAgICAtIGluZGVudGVkX3JlbGF0aXZlX3RvX3JlY2VpdmVyCiAgIyBCeSBkZWZhdWx0IHRoZSBpbmRlbnRhdGlvbiB3aWR0aCBmcm9tIGBMYXlvdXQvSW5kZW50YXRpb25XaWR0aGAgaXMgdXNlZCwKICAjIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyLgogIEluZGVudGF0aW9uV2lkdGg6IH4KCkxheW91dC9NdWx0aWxpbmVNZXRob2REZWZpbml0aW9uQnJhY2VMYXlvdXQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoYXQgdGhlIGNsb3NpbmcgYnJhY2UgaW4gYSBtZXRob2QgZGVmaW5pdGlvbiBpcwogICAgICAgICAgICAgICAgIGVpdGhlciBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBsYXN0IG1ldGhvZCBwYXJhbWV0ZXIsIG9yCiAgICAgICAgICAgICAgICAgYSBuZXcgbGluZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBFbmZvcmNlZFN0eWxlOiBzeW1tZXRyaWNhbAogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgc3ltbWV0cmljYWw6IGNsb3NpbmcgYnJhY2UgaXMgcG9zaXRpb25lZCBpbiBzYW1lIHdheSBhcyBvcGVuaW5nIGJyYWNlCiAgICAjIG5ld19saW5lOiBjbG9zaW5nIGJyYWNlIGlzIGFsd2F5cyBvbiBhIG5ldyBsaW5lCiAgICAjIHNhbWVfbGluZTogY2xvc2luZyBicmFjZSBpcyBhbHdheXMgb24gdGhlIHNhbWUgbGluZSBhcyBsYXN0IHBhcmFtZXRlcgogICAgLSBzeW1tZXRyaWNhbAogICAgLSBuZXdfbGluZQogICAgLSBzYW1lX2xpbmUKCkxheW91dC9NdWx0aWxpbmVNZXRob2RQYXJhbWV0ZXJMaW5lQnJlYWtzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IGVhY2ggcGFyYW1ldGVyIGluIGEgbXVsdGktbGluZSBtZXRob2QgZGVmaW5pdGlvbgogICAgICAgICAgICAgICAgIHN0YXJ0cyBvbiBhIHNlcGFyYXRlIGxpbmUuCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjMyJwogIEFsbG93TXVsdGlsaW5lRmluYWxFbGVtZW50OiBmYWxzZQoKTGF5b3V0L011bHRpbGluZU9wZXJhdGlvbkluZGVudGF0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBpbmRlbnRhdGlvbiBvZiBiaW5hcnkgb3BlcmF0aW9ucyB0aGF0IHNwYW4gbW9yZSB0aGFuCiAgICAgICAgICAgICAgICAgb25lIGxpbmUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogYWxpZ25lZAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gYWxpZ25lZAogICAgLSBpbmRlbnRlZAogICMgQnkgZGVmYXVsdCB0aGUgaW5kZW50YXRpb24gd2lkdGggZnJvbSBgTGF5b3V0L0luZGVudGF0aW9uV2lkdGhgIGlzIHVzZWQsCiAgIyBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4KICBJbmRlbnRhdGlvbldpZHRoOiB+CgpMYXlvdXQvUGFyYW1ldGVyQWxpZ25tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEFsaWduIHRoZSBwYXJhbWV0ZXJzIG9mIGEgbWV0aG9kIGRlZmluaXRpb24gaWYgdGhleSBzcGFuIG1vcmUKICAgICAgICAgICAgICAgICB0aGFuIG9uZSBsaW5lLgogIFN0eWxlR3VpZGU6ICcjbm8tZG91YmxlLWluZGVudCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzcnCiAgIyBBbGlnbm1lbnQgb2YgcGFyYW1ldGVycyBpbiBtdWx0aS1saW5lIG1ldGhvZCBjYWxscy4KICAjCiAgIyBUaGUgYHdpdGhfZmlyc3RfcGFyYW1ldGVyYCBzdHlsZSBhbGlnbnMgdGhlIGZvbGxvd2luZyBsaW5lcyBhbG9uZyB0aGUgc2FtZQogICMgY29sdW1uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuCiAgIwogICMgICAgIGRlZiBtZXRob2RfZm9vKGEsCiAgIyAgICAgICAgICAgICAgICAgICAgYikKICAjCiAgIyBUaGUgYHdpdGhfZml4ZWRfaW5kZW50YXRpb25gIHN0eWxlIGFsaWducyB0aGUgZm9sbG93aW5nIGxpbmVzIHdpdGggb25lCiAgIyBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgd2l0aCB0aGUgbWV0aG9kIGNhbGwuCiAgIwogICMgICAgIGRlZiBtZXRob2RfZm9vKGEsCiAgIyAgICAgICBiKQogIEVuZm9yY2VkU3R5bGU6IHdpdGhfZmlyc3RfcGFyYW1ldGVyCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSB3aXRoX2ZpcnN0X3BhcmFtZXRlcgogICAgLSB3aXRoX2ZpeGVkX2luZGVudGF0aW9uCiAgIyBCeSBkZWZhdWx0IHRoZSBpbmRlbnRhdGlvbiB3aWR0aCBmcm9tIGBMYXlvdXQvSW5kZW50YXRpb25XaWR0aGAgaXMgdXNlZCwKICAjIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoaXMgcGFyYW1ldGVyLgogIEluZGVudGF0aW9uV2lkdGg6IH4KCkxheW91dC9SZWR1bmRhbnRMaW5lQnJlYWs6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgRG8gbm90IGJyZWFrIHVwIGFuIGV4cHJlc3Npb24gaW50byBtdWx0aXBsZSBsaW5lcyB3aGVuIGl0IGZpdHMKICAgICAgICAgICAgICAgICBvbiBhIHNpbmdsZSBsaW5lLgogIEVuYWJsZWQ6IGZhbHNlCiAgSW5zcGVjdEJsb2NrczogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjEzJwoKTGF5b3V0L1Jlc2N1ZUVuc3VyZUFsaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0FsaWduIHJlc2N1ZXMgYW5kIGVuc3VyZXMgY29ycmVjdGx5LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9TaW5nbGVMaW5lQmxvY2tDaGFpbjoKICBEZXNjcmlwdGlvbjogJ1B1dCBtZXRob2QgY2FsbCBvbiBhIHNlcGFyYXRlIGxpbmUgaWYgY2hhaW5lZCB0byBhIHNpbmdsZSBsaW5lIGJsb2NrLicKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMTQnCgpMYXlvdXQvU3BhY2VBZnRlckNvbG9uOgogIERlc2NyaXB0aW9uOiAnVXNlIHNwYWNlcyBhZnRlciBjb2xvbnMuJwogIFN0eWxlR3VpZGU6ICcjc3BhY2VzLW9wZXJhdG9ycycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9TcGFjZUFmdGVyQ29tbWE6CiAgRGVzY3JpcHRpb246ICdVc2Ugc3BhY2VzIGFmdGVyIGNvbW1hcy4nCiAgU3R5bGVHdWlkZTogJyNzcGFjZXMtb3BlcmF0b3JzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwoKTGF5b3V0L1NwYWNlQWZ0ZXJNZXRob2ROYW1lOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIERvIG5vdCBwdXQgYSBzcGFjZSBiZXR3ZWVuIGEgbWV0aG9kIG5hbWUgYW5kIHRoZSBvcGVuaW5nCiAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXMgaW4gYSBtZXRob2QgZGVmaW5pdGlvbi4KICBTdHlsZUd1aWRlOiAnI3BhcmVucy1uby1zcGFjZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VBZnRlck5vdDoKICBEZXNjcmlwdGlvbjogVHJhY2tzIHJlZHVuZGFudCBzcGFjZSBhZnRlciB0aGUgISBvcGVyYXRvci4KICBTdHlsZUd1aWRlOiAnI25vLXNwYWNlLWJhbmcnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VBZnRlclNlbWljb2xvbjoKICBEZXNjcmlwdGlvbjogJ1VzZSBzcGFjZXMgYWZ0ZXIgc2VtaWNvbG9ucy4nCiAgU3R5bGVHdWlkZTogJyNzcGFjZXMtb3BlcmF0b3JzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwoKTGF5b3V0L1NwYWNlQXJvdW5kQmxvY2tQYXJhbWV0ZXJzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoZSBzcGFjaW5nIGluc2lkZSBhbmQgYWZ0ZXIgYmxvY2sgcGFyYW1ldGVycyBwaXBlcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZUluc2lkZVBpcGVzOiBub19zcGFjZQogIFN1cHBvcnRlZFN0eWxlc0luc2lkZVBpcGVzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQoKTGF5b3V0L1NwYWNlQXJvdW5kRXF1YWxzSW5QYXJhbWV0ZXJEZWZhdWx0OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IHRoZSBlcXVhbHMgc2lnbnMgaW4gcGFyYW1ldGVyIGRlZmF1bHQgYXNzaWdubWVudHMKICAgICAgICAgICAgICAgICBoYXZlIG9yIGRvbid0IGhhdmUgc3Vycm91bmRpbmcgc3BhY2UgZGVwZW5kaW5nIG9uCiAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi4KICBTdHlsZUd1aWRlOiAnI3NwYWNlcy1hcm91bmQtZXF1YWxzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IHNwYWNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQoKTGF5b3V0L1NwYWNlQXJvdW5kS2V5d29yZDoKICBEZXNjcmlwdGlvbjogJ1VzZSBhIHNwYWNlIGFyb3VuZCBrZXl3b3JkcyBpZiBhcHByb3ByaWF0ZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VBcm91bmRNZXRob2RDYWxsT3BlcmF0b3I6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgbWV0aG9kIGNhbGwgb3BlcmF0b3JzIHRvIG5vdCBoYXZlIHNwYWNlcyBhcm91bmQgdGhlbS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODInCgpMYXlvdXQvU3BhY2VBcm91bmRPcGVyYXRvcnM6CiAgRGVzY3JpcHRpb246ICdVc2UgYSBzaW5nbGUgc3BhY2UgYXJvdW5kIG9wZXJhdG9ycy4nCiAgU3R5bGVHdWlkZTogJyNzcGFjZXMtb3BlcmF0b3JzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogICMgV2hlbiBgdHJ1ZWAsIGFsbG93cyBtb3N0IHVzZXMgb2YgZXh0cmEgc3BhY2luZyBpZiB0aGUgaW50ZW50IGlzIHRvIGFsaWduCiAgIyB3aXRoIGFuIG9wZXJhdG9yIG9uIHRoZSBwcmV2aW91cyBvciBuZXh0IGxpbmUsIG5vdCBjb3VudGluZyBlbXB0eSBsaW5lcwogICMgb3IgY29tbWVudCBsaW5lcy4KICBBbGxvd0ZvckFsaWdubWVudDogdHJ1ZQogIEVuZm9yY2VkU3R5bGVGb3JFeHBvbmVudE9wZXJhdG9yOiBub19zcGFjZQogIFN1cHBvcnRlZFN0eWxlc0ZvckV4cG9uZW50T3BlcmF0b3I6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCiAgRW5mb3JjZWRTdHlsZUZvclJhdGlvbmFsTGl0ZXJhbHM6IG5vX3NwYWNlCiAgU3VwcG9ydGVkU3R5bGVzRm9yUmF0aW9uYWxMaXRlcmFsczoKICAgIC0gc3BhY2UKICAgIC0gbm9fc3BhY2UKCkxheW91dC9TcGFjZUJlZm9yZUJsb2NrQnJhY2VzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IHRoZSBsZWZ0IGJsb2NrIGJyYWNlIGhhcyBvciBkb2Vzbid0IGhhdmUgc3BhY2UKICAgICAgICAgICAgICAgICBiZWZvcmUgaXQuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCiAgRW5mb3JjZWRTdHlsZUZvckVtcHR5QnJhY2VzOiBzcGFjZQogIFN1cHBvcnRlZFN0eWxlc0ZvckVtcHR5QnJhY2VzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQogIFZlcnNpb25DaGFuZ2VkOiAnMC41MicKCkxheW91dC9TcGFjZUJlZm9yZUJyYWNrZXRzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWNlaXZlciB3aXRoIGEgc3BhY2UgYmVmb3JlIHRoZSBvcGVuaW5nIGJyYWNrZXRzLicKICBTdHlsZUd1aWRlOiAnI3NwYWNlLWluLWJyYWNrZXRzLWFjY2VzcycKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS43JwoKTGF5b3V0L1NwYWNlQmVmb3JlQ29tbWE6CiAgRGVzY3JpcHRpb246ICdObyBzcGFjZXMgYmVmb3JlIGNvbW1hcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VCZWZvcmVDb21tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgbWlzc2luZyBzcGFjZSBiZXR3ZWVuIGNvZGUgYW5kIGEgY29tbWVudCBvbiB0aGUKICAgICAgICAgICAgICAgICBzYW1lIGxpbmUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VCZWZvcmVGaXJzdEFyZzoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgdGhhdCBleGFjdGx5IG9uZSBzcGFjZSBpcyB1c2VkIGJldHdlZW4gYSBtZXRob2QgbmFtZQogICAgICAgICAgICAgICAgIGFuZCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIG1ldGhvZCBjYWxscyB3aXRob3V0IHBhcmVudGhlc2VzLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogICMgV2hlbiBgdHJ1ZWAsIGFsbG93cyBtb3N0IHVzZXMgb2YgZXh0cmEgc3BhY2luZyBpZiB0aGUgaW50ZW50IGlzIHRvIGFsaWduCiAgIyB0aGluZ3Mgd2l0aCB0aGUgcHJldmlvdXMgb3IgbmV4dCBsaW5lLCBub3QgY291bnRpbmcgZW1wdHkgbGluZXMgb3IgY29tbWVudAogICMgbGluZXMuCiAgQWxsb3dGb3JBbGlnbm1lbnQ6IHRydWUKCkxheW91dC9TcGFjZUJlZm9yZVNlbWljb2xvbjoKICBEZXNjcmlwdGlvbjogJ05vIHNwYWNlcyBiZWZvcmUgc2VtaWNvbG9ucy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VJbkxhbWJkYUxpdGVyYWw6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHNwYWNlcyBpbiBsYW1iZGEgbGl0ZXJhbHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfbm9fc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHJlcXVpcmVfbm9fc3BhY2UKICAgIC0gcmVxdWlyZV9zcGFjZQoKTGF5b3V0L1NwYWNlSW5zaWRlQXJyYXlMaXRlcmFsQnJhY2tldHM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhlIHNwYWNpbmcgaW5zaWRlIGFycmF5IGxpdGVyYWwgYnJhY2tldHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwogIEVuZm9yY2VkU3R5bGU6IG5vX3NwYWNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQogICAgIyAnY29tcGFjdCcgbm9ybWFsbHkgcmVxdWlyZXMgYSBzcGFjZSBpbnNpZGUgdGhlIGJyYWNrZXRzLCB3aXRoIHRoZSBleGNlcHRpb24KICAgICMgdGhhdCBzdWNjZXNzaXZlIGxlZnQgYnJhY2tldHMgb3IgcmlnaHQgYnJhY2tldHMgYXJlIGNvbGxhcHNlZCB0b2dldGhlcgogICAgLSBjb21wYWN0CiAgRW5mb3JjZWRTdHlsZUZvckVtcHR5QnJhY2tldHM6IG5vX3NwYWNlCiAgU3VwcG9ydGVkU3R5bGVzRm9yRW1wdHlCcmFja2V0czoKICAgIC0gc3BhY2UKICAgIC0gbm9fc3BhY2UKCkxheW91dC9TcGFjZUluc2lkZUFycmF5UGVyY2VudExpdGVyYWw6CiAgRGVzY3JpcHRpb246ICdObyB1bm5lY2Vzc2FyeSBhZGRpdGlvbmFsIHNwYWNlcyBiZXR3ZWVuIGVsZW1lbnRzIGluICVpLyV3IGxpdGVyYWxzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9TcGFjZUluc2lkZUJsb2NrQnJhY2VzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyB0aGF0IGJsb2NrIGJyYWNlcyBoYXZlIG9yIGRvbid0IGhhdmUgc3Vycm91bmRpbmcgc3BhY2UuCiAgICAgICAgICAgICAgICAgRm9yIGJsb2NrcyB0YWtpbmcgcGFyYW1ldGVycywgY2hlY2tzIHRoYXQgdGhlIGxlZnQgYnJhY2UgaGFzCiAgICAgICAgICAgICAgICAgb3IgZG9lc24ndCBoYXZlIHRyYWlsaW5nIHNwYWNlLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IHNwYWNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQogIEVuZm9yY2VkU3R5bGVGb3JFbXB0eUJyYWNlczogbm9fc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXNGb3JFbXB0eUJyYWNlczoKICAgIC0gc3BhY2UKICAgIC0gbm9fc3BhY2UKICAjIFNwYWNlIGJldHdlZW4gYHtgIGFuZCBgfGAuIE92ZXJyaWRlcyBgRW5mb3JjZWRTdHlsZWAgaWYgdGhlcmUgaXMgYSBjb25mbGljdC4KICBTcGFjZUJlZm9yZUJsb2NrUGFyYW1ldGVyczogdHJ1ZQoKTGF5b3V0L1NwYWNlSW5zaWRlSGFzaExpdGVyYWxCcmFjZXM6CiAgRGVzY3JpcHRpb246ICJVc2Ugc3BhY2VzIGluc2lkZSBoYXNoIGxpdGVyYWwgYnJhY2VzIC0gb3IgZG9uJ3QuIgogIFN0eWxlR3VpZGU6ICcjc3BhY2VzLWJyYWNlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBFbmZvcmNlZFN0eWxlOiBzcGFjZQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc3BhY2UKICAgIC0gbm9fc3BhY2UKICAgICMgJ2NvbXBhY3QnIG5vcm1hbGx5IHJlcXVpcmVzIGEgc3BhY2UgaW5zaWRlIGhhc2ggYnJhY2VzLCB3aXRoIHRoZSBleGNlcHRpb24KICAgICMgdGhhdCBzdWNjZXNzaXZlIGxlZnQgYnJhY2VzIG9yIHJpZ2h0IGJyYWNlcyBhcmUgY29sbGFwc2VkIHRvZ2V0aGVyCiAgICAtIGNvbXBhY3QKICBFbmZvcmNlZFN0eWxlRm9yRW1wdHlCcmFjZXM6IG5vX3NwYWNlCiAgU3VwcG9ydGVkU3R5bGVzRm9yRW1wdHlCcmFjZXM6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCgoKTGF5b3V0L1NwYWNlSW5zaWRlUGFyZW5zOgogIERlc2NyaXB0aW9uOiAnTm8gc3BhY2VzIGFmdGVyICggb3IgYmVmb3JlICkuJwogIFN0eWxlR3VpZGU6ICcjc3BhY2VzLWJyYWNlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMjInCiAgRW5mb3JjZWRTdHlsZTogbm9fc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwYWNlCiAgICAtIGNvbXBhY3QKICAgIC0gbm9fc3BhY2UKCkxheW91dC9TcGFjZUluc2lkZVBlcmNlbnRMaXRlcmFsRGVsaW1pdGVyczoKICBEZXNjcmlwdGlvbjogJ05vIHVubmVjZXNzYXJ5IHNwYWNlcyBpbnNpZGUgZGVsaW1pdGVycyBvZiAlaS8ldy8leCBsaXRlcmFscy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCgpMYXlvdXQvU3BhY2VJbnNpZGVSYW5nZUxpdGVyYWw6CiAgRGVzY3JpcHRpb246ICdObyBzcGFjZXMgaW5zaWRlIHJhbmdlIGxpdGVyYWxzLicKICBTdHlsZUd1aWRlOiAnI25vLXNwYWNlLWluc2lkZS1yYW5nZS1saXRlcmFscycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxheW91dC9TcGFjZUluc2lkZVJlZmVyZW5jZUJyYWNrZXRzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoZSBzcGFjaW5nIGluc2lkZSByZWZlcmVudGlhbCBicmFja2V0cy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjUzJwogIEVuZm9yY2VkU3R5bGU6IG5vX3NwYWNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzcGFjZQogICAgLSBub19zcGFjZQogIEVuZm9yY2VkU3R5bGVGb3JFbXB0eUJyYWNrZXRzOiBub19zcGFjZQogIFN1cHBvcnRlZFN0eWxlc0ZvckVtcHR5QnJhY2tldHM6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCgpMYXlvdXQvU3BhY2VJbnNpZGVTdHJpbmdJbnRlcnBvbGF0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBwYWRkaW5nL3N1cnJvdW5kaW5nIHNwYWNlcyBpbnNpZGUgc3RyaW5nIGludGVycG9sYXRpb24uJwogIFN0eWxlR3VpZGU6ICcjc3RyaW5nLWludGVycG9sYXRpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgRW5mb3JjZWRTdHlsZTogbm9fc3BhY2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNwYWNlCiAgICAtIG5vX3NwYWNlCgpMYXlvdXQvVHJhaWxpbmdFbXB0eUxpbmVzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRyYWlsaW5nIGJsYW5rIGxpbmVzIGFuZCBmaW5hbCBuZXdsaW5lLicKICBTdHlsZUd1aWRlOiAnI25ld2xpbmUtZW9mJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIFZlcnNpb25DaGFuZ2VkOiAnMC43NycKICBFbmZvcmNlZFN0eWxlOiBmaW5hbF9uZXdsaW5lCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBmaW5hbF9uZXdsaW5lCiAgICAtIGZpbmFsX2JsYW5rX2xpbmUKCkxheW91dC9UcmFpbGluZ1doaXRlc3BhY2U6CiAgRGVzY3JpcHRpb246ICdBdm9pZCB0cmFpbGluZyB3aGl0ZXNwYWNlLicKICBTdHlsZUd1aWRlOiAnI25vLXRyYWlsaW5nLXdoaXRlc3BhY2UnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjAnCiAgQWxsb3dJbkhlcmVkb2M6IGZhbHNlCgojIyMjIyMjIyMjIyMjIyMjIyMjIyBMaW50ICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyMjIFdhcm5pbmdzCgpMaW50L0FtYmlndW91c0Fzc2lnbm1lbnQ6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIG1pc3R5cGVkIHNob3J0aGFuZCBhc3NpZ25tZW50cy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNycKCkxpbnQvQW1iaWd1b3VzQmxvY2tBc3NvY2lhdGlvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIGFtYmlndW91cyBibG9jayBhc3NvY2lhdGlvbiB3aXRoIG1ldGhvZCB3aGVuIHBhcmFtIHBhc3NlZCB3aXRob3V0CiAgICAgICAgICAgICAgICAgcGFyZW50aGVzZXMuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDgnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjEzJwogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KCkxpbnQvQW1iaWd1b3VzT3BlcmF0b3I6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBhbWJpZ3VvdXMgb3BlcmF0b3JzIGluIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBhCiAgICAgICAgICAgICAgICAgbWV0aG9kIGludm9jYXRpb24gd2l0aG91dCBwYXJlbnRoZXNlcy4KICBTdHlsZUd1aWRlOiAnI21ldGhvZC1pbnZvY2F0aW9uLXBhcmVucycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xNycKICBWZXJzaW9uQ2hhbmdlZDogJzAuODMnCgpMaW50L0FtYmlndW91c09wZXJhdG9yUHJlY2VkZW5jZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIGV4cHJlc3Npb25zIGNvbnRhaW5pbmcgbXVsdGlwbGUgYmluYXJ5IG9wZXJhdGlvbnMgd2l0aAogICAgICAgICAgICAgICAgIGFtYmlndW91cyBwcmVjZWRlbmNlLgogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjIxJwoKTGludC9BbWJpZ3VvdXNSYW5nZToKICBEZXNjcmlwdGlvbjogQ2hlY2tzIGZvciByYW5nZXMgd2l0aCBhbWJpZ3VvdXMgYm91bmRhcmllcy4KICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4xOScKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgUmVxdWlyZVBhcmVudGhlc2VzRm9yTWV0aG9kQ2hhaW5zOiBmYWxzZQoKTGludC9BbWJpZ3VvdXNSZWdleHBMaXRlcmFsOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYW1iaWd1b3VzIHJlZ2V4cCBsaXRlcmFscyBpbiB0aGUgZmlyc3QgYXJndW1lbnQgb2YKICAgICAgICAgICAgICAgICBhIG1ldGhvZCBpbnZvY2F0aW9uIHdpdGhvdXQgcGFyZW50aGVzZXMuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTcnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgzJwoKTGludC9Bc3NpZ25tZW50SW5Db25kaXRpb246CiAgRGVzY3JpcHRpb246ICJEb24ndCB1c2UgYXNzaWdubWVudCBpbiBjb25kaXRpb25zLiIKICBTdHlsZUd1aWRlOiAnI3NhZmUtYXNzaWdubWVudC1pbi1jb25kaXRpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQ1JwogIEFsbG93U2FmZUFzc2lnbm1lbnQ6IHRydWUKCkxpbnQvQmlnRGVjaW1hbE5ldzoKICBEZXNjcmlwdGlvbjogJ2BCaWdEZWNpbWFsLm5ldygpYCBpcyBkZXByZWNhdGVkLiBVc2UgYEJpZ0RlY2ltYWwoKWAgaW5zdGVhZC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCgpMaW50L0JpbmFyeU9wZXJhdG9yV2l0aElkZW50aWNhbE9wZXJhbmRzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBwbGFjZXMgd2hlcmUgYmluYXJ5IG9wZXJhdG9yIGhhcyBpZGVudGljYWwgb3BlcmFuZHMuJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjcnCgpMaW50L0Jvb2xlYW5TeW1ib2w6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgYDp0cnVlYCBhbmQgYDpmYWxzZWAgc3ltYm9scy4nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yMicKCkxpbnQvQ2lyY3VsYXJBcmd1bWVudFJlZmVyZW5jZToKICBEZXNjcmlwdGlvbjogIkRlZmF1bHQgdmFsdWVzIGluIG9wdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzIGFuZCBvcHRpb25hbCBvcmRpbmFsIGFyZ3VtZW50cyBzaG91bGQgbm90IHJlZmVyIGJhY2sgdG8gdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LiIKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMycKCkxpbnQvQ29uc3RhbnREZWZpbml0aW9uSW5CbG9jazoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCBkZWZpbmUgY29uc3RhbnRzIHdpdGhpbiBhIGJsb2NrLicKICBTdHlsZUd1aWRlOiAnI25vLWNvbnN0YW50LWRlZmluaXRpb24taW4tYmxvY2snCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjMnCiAgIyBgZW51bXNgIGZvciBUeXBlZCBFbnVtcyB2aWEgVDo6RW51bSBpbiBTb3JiZXQuCiAgIyBodHRwczovL3NvcmJldC5vcmcvZG9jcy90ZW51bQogIEFsbG93ZWRNZXRob2RzOgogICAgLSBlbnVtcwoKTGludC9Db25zdGFudE92ZXJ3cml0dGVuSW5SZXNjdWU6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIG92ZXJ3cml0aW5nIGFuIGV4Y2VwdGlvbiB3aXRoIGFuIGV4Y2VwdGlvbiByZXN1bHQgYnkgdXNlIGByZXNjdWUgPT5gLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4zMScKCkxpbnQvQ29uc3RhbnRSZXNvbHV0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgdGhhdCBjb25zdGFudHMgYXJlIGZ1bGx5IHF1YWxpZmllZCB3aXRoIGA6OmAuJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44NicKICAjIFJlc3RyaWN0IHRoaXMgY29wIHRvIG9ubHkgbG9va2luZyBhdCBjZXJ0YWluIG5hbWVzCiAgT25seTogW10KICAjIFJlc3RyaWN0IHRoaXMgY29wIGZyb20gb25seSBsb29raW5nIGF0IGNlcnRhaW4gbmFtZXMKICBJZ25vcmU6IFtdCgpMaW50L0RlYnVnZ2VyOgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgZm9yIGRlYnVnZ2VyIGNhbGxzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xNCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjMnCiAgRGVidWdnZXJNZXRob2RzOgogICAgIyBHcm91cHMgYXJlIGF2YWlsYWJsZSBzbyB0aGF0IGEgc3BlY2lmaWMgZ3JvdXAgY2FuIGJlIGRpc2FibGVkIGluCiAgICAjIGEgdXNlcidzIGNvbmZpZ3VyYXRpb24sIGJ1dCBhcmUgb3RoZXJ3aXNlIG5vdCBzaWduaWZpY2FudC4KICAgIEtlcm5lbDoKICAgICAgLSBiaW5kaW5nLmlyYgogICAgICAtIEtlcm5lbC5iaW5kaW5nLmlyYgogICAgQnllYnVnOgogICAgICAtIGJ5ZWJ1ZwogICAgICAtIHJlbW90ZV9ieWVidWcKICAgICAgLSBLZXJuZWwuYnllYnVnCiAgICAgIC0gS2VybmVsLnJlbW90ZV9ieWVidWcKICAgIENhcHliYXJhOgogICAgICAtIHBhZ2Uuc2F2ZV9hbmRfb3Blbl9wYWdlCiAgICAgIC0gcGFnZS5zYXZlX2FuZF9vcGVuX3NjcmVlbnNob3QKICAgICAgLSBwYWdlLnNhdmVfcGFnZQogICAgICAtIHBhZ2Uuc2F2ZV9zY3JlZW5zaG90CiAgICAgIC0gc2F2ZV9hbmRfb3Blbl9wYWdlCiAgICAgIC0gc2F2ZV9hbmRfb3Blbl9zY3JlZW5zaG90CiAgICAgIC0gc2F2ZV9wYWdlCiAgICAgIC0gc2F2ZV9zY3JlZW5zaG90CiAgICBkZWJ1Zy5yYjoKICAgICAgLSBiaW5kaW5nLmIKICAgICAgLSBiaW5kaW5nLmJyZWFrCiAgICAgIC0gS2VybmVsLmJpbmRpbmcuYgogICAgICAtIEtlcm5lbC5iaW5kaW5nLmJyZWFrCiAgICBQcnk6CiAgICAgIC0gYmluZGluZy5wcnkKICAgICAgLSBiaW5kaW5nLnJlbW90ZV9wcnkKICAgICAgLSBiaW5kaW5nLnByeV9yZW1vdGUKICAgICAgLSBLZXJuZWwuYmluZGluZy5wcnkKICAgICAgLSBLZXJuZWwuYmluZGluZy5yZW1vdGVfcHJ5CiAgICAgIC0gS2VybmVsLmJpbmRpbmcucHJ5X3JlbW90ZQogICAgICAtIFByeS5yZXNjdWUKICAgICAgLSBwcnkKICAgIFJhaWxzOgogICAgICAtIGRlYnVnZ2VyCiAgICAgIC0gS2VybmVsLmRlYnVnZ2VyCiAgICBSdWJ5SmFyZDoKICAgICAgLSBqYXJkCiAgICBXZWJDb25zb2xlOgogICAgICAtIGJpbmRpbmcuY29uc29sZQogIERlYnVnZ2VyUmVxdWlyZXM6CiAgICBkZWJ1Zy5yYjoKICAgICAgLSBkZWJ1Zy9vcGVuCiAgICAgIC0gZGVidWcvc3RhcnQKCkxpbnQvRGVwcmVjYXRlZENsYXNzTWV0aG9kczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrIGZvciBkZXByZWNhdGVkIGNsYXNzIG1ldGhvZCBjYWxscy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTknCgpMaW50L0RlcHJlY2F0ZWRDb25zdGFudHM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGRlcHJlY2F0ZWQgY29uc3RhbnRzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS44JwogIFZlcnNpb25DaGFuZ2VkOiAnMS40MCcKICAjIFlvdSBjYW4gY29uZmlndXJlIGRlcHJlY2F0ZWQgY29uc3RhbnRzLgogICMgSWYgdGhlcmUgaXMgYW4gYWx0ZXJuYXRpdmUgbWV0aG9kLCB5b3UgY2FuIHNldCBhbHRlcm5hdGl2ZSB2YWx1ZSBhcyBgQWx0ZXJuYXRpdmVgLgogICMgQW5kIHlvdSBjYW4gc2V0IHRoZSBkZXByZWNhdGVkIHZlcnNpb24gYXMgYERlcHJlY2F0ZWRWZXJzaW9uYC4KICAjIFRoZXNlIG9wdGlvbnMgY2FuIGJlIG9taXR0ZWQgaWYgdGhleSBhcmUgbm90IG5lZWRlZC4KICAjCiAgIyBEZXByZWNhdGVkQ29uc3RhbnRzOgogICMgICAnREVQUkVDQVRFRF9DT05TVEFOVCc6CiAgIyAgICAgQWx0ZXJuYXRpdmU6ICdhbHRlcm5hdGl2ZV92YWx1ZScKICAjICAgICBEZXByZWNhdGVkVmVyc2lvbjogJ2RlcHJlY2F0ZWRfdmVyc2lvbicKICAjCiAgRGVwcmVjYXRlZENvbnN0YW50czoKICAgICdOSUwnOgogICAgICBBbHRlcm5hdGl2ZTogJ25pbCcKICAgICAgRGVwcmVjYXRlZFZlcnNpb246ICcyLjQnCiAgICAnVFJVRSc6CiAgICAgIEFsdGVybmF0aXZlOiAndHJ1ZScKICAgICAgRGVwcmVjYXRlZFZlcnNpb246ICcyLjQnCiAgICAnRkFMU0UnOgogICAgICBBbHRlcm5hdGl2ZTogJ2ZhbHNlJwogICAgICBEZXByZWNhdGVkVmVyc2lvbjogJzIuNCcKICAgICdOZXQ6OkhUVFBTZXJ2ZXJFeGNlcHRpb24nOgogICAgICBBbHRlcm5hdGl2ZTogJ05ldDo6SFRUUENsaWVudEV4Y2VwdGlvbicKICAgICAgRGVwcmVjYXRlZFZlcnNpb246ICcyLjYnCiAgICAnUmFuZG9tOjpERUZBVUxUJzoKICAgICAgQWx0ZXJuYXRpdmU6ICdSYW5kb20ubmV3JwogICAgICBEZXByZWNhdGVkVmVyc2lvbjogJzMuMCcKICAgICdTdHJ1Y3Q6Okdyb3VwJzoKICAgICAgQWx0ZXJuYXRpdmU6ICdFdGM6Okdyb3VwJwogICAgICBEZXByZWNhdGVkVmVyc2lvbjogJzMuMCcKICAgICdTdHJ1Y3Q6OlBhc3N3ZCc6CiAgICAgIEFsdGVybmF0aXZlOiAnRXRjOjpQYXNzd2QnCiAgICAgIERlcHJlY2F0ZWRWZXJzaW9uOiAnMy4wJwoKTGludC9EZXByZWNhdGVkT3BlblNTTENvbnN0YW50OgogIERlc2NyaXB0aW9uOiAiRG9uJ3QgdXNlIGFsZ29yaXRobSBjb25zdGFudHMgZm9yIGBPcGVuU1NMOjpDaXBoZXJgIGFuZCBgT3BlblNTTDo6RGlnZXN0YC4iCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODQnCgpMaW50L0Rpc2p1bmN0aXZlQXNzaWdubWVudEluQ29uc3RydWN0b3I6CiAgRGVzY3JpcHRpb246ICdJbiBjb25zdHJ1Y3RvciwgcGxhaW4gYXNzaWdubWVudCBpcyBwcmVmZXJyZWQgb3ZlciBkaXNqdW5jdGl2ZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC42MicKICBWZXJzaW9uQ2hhbmdlZDogJzAuODgnCgpMaW50L0R1cGxpY2F0ZUJyYW5jaDoKICBEZXNjcmlwdGlvbjogQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIHJlcGVhdGVkIGJvZGllcyB3aXRoaW4gYGlmL3VubGVzc2AsIGBjYXNlLXdoZW5gIGFuZCBgcmVzY3VlYCBjb25zdHJ1Y3RzLgogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjcnCiAgSWdub3JlTGl0ZXJhbEJyYW5jaGVzOiBmYWxzZQogIElnbm9yZUNvbnN0YW50QnJhbmNoZXM6IGZhbHNlCgpMaW50L0R1cGxpY2F0ZUNhc2VDb25kaXRpb246CiAgRGVzY3JpcHRpb246ICdEbyBub3QgcmVwZWF0IHZhbHVlcyBpbiBjYXNlIGNvbmRpdGlvbmFscy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDUnCgpMaW50L0R1cGxpY2F0ZUVsc2lmQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiAnRG8gbm90IHJlcGVhdCBjb25kaXRpb25zIHVzZWQgaW4gaWYgYGVsc2lmYC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODgnCgpMaW50L0R1cGxpY2F0ZUhhc2hLZXk6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgZHVwbGljYXRlIGtleXMgaW4gaGFzaCBsaXRlcmFscy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzQnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwoKTGludC9EdXBsaWNhdGVNYWdpY0NvbW1lbnQ6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgZHVwbGljYXRlZCBtYWdpYyBjb21tZW50cy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzcnCgpMaW50L0R1cGxpY2F0ZU1hdGNoUGF0dGVybjoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCByZXBlYXQgcGF0dGVybnMgaW4gYGluYCBrZXl3b3Jkcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNTAnCgpMaW50L0R1cGxpY2F0ZU1ldGhvZHM6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgZHVwbGljYXRlIG1ldGhvZCBkZWZpbml0aW9ucy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjknCgpMaW50L0R1cGxpY2F0ZVJlZ2V4cENoYXJhY3RlckNsYXNzRWxlbWVudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgZHVwbGljYXRlIGVsZW1lbnRzIGluIFJlZ2V4cCBjaGFyYWN0ZXIgY2xhc3Nlcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMScKCkxpbnQvRHVwbGljYXRlUmVxdWlyZToKICBEZXNjcmlwdGlvbjogJ0NoZWNrIGZvciBkdXBsaWNhdGUgYHJlcXVpcmVgcyBhbmQgYHJlcXVpcmVfcmVsYXRpdmVgcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjkwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yOCcKCkxpbnQvRHVwbGljYXRlUmVzY3VlRXhjZXB0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIHJlcGVhdGVkIGV4Y2VwdGlvbnMgdXNlZCBpbiBgcmVzY3VlYCBleHByZXNzaW9ucy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCgpMaW50L0VhY2hXaXRoT2JqZWN0QXJndW1lbnQ6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgaW1tdXRhYmxlIGFyZ3VtZW50IGdpdmVuIHRvIGVhY2hfd2l0aF9vYmplY3QuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjMxJwoKTGludC9FbHNlTGF5b3V0OgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgZm9yIG9kZCBjb2RlIGFycmFuZ2VtZW50IGluIGFuIGVsc2UgYmxvY2suJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjE3JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yJwoKTGludC9FbXB0eUJsb2NrOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBibG9ja3Mgd2l0aG91dCBhIGJvZHkuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjE1JwogIEFsbG93Q29tbWVudHM6IHRydWUKICBBbGxvd0VtcHR5TGFtYmRhczogdHJ1ZQoKTGludC9FbXB0eUNsYXNzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBjbGFzc2VzIGFuZCBtZXRhY2xhc3NlcyB3aXRob3V0IGEgYm9keS4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMycKICBBbGxvd0NvbW1lbnRzOiBmYWxzZQoKTGludC9FbXB0eUNvbmRpdGlvbmFsQm9keToKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIGBpZmAsIGBlbHNpZmAgYW5kIGB1bmxlc3NgIGJyYW5jaGVzIHdpdGhvdXQgYSBib2R5LicKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgQWxsb3dDb21tZW50czogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwoKTGludC9FbXB0eUVuc3VyZToKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgZW1wdHkgZW5zdXJlIGJsb2NrLicKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcwLjEwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS42MScKCkxpbnQvRW1wdHlFeHByZXNzaW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBlbXB0eSBleHByZXNzaW9ucy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDUnCgpMaW50L0VtcHR5RmlsZToKICBEZXNjcmlwdGlvbjogJ0VuZm9yY2VzIHRoYXQgUnVieSBzb3VyY2UgZmlsZXMgYXJlIG5vdCBlbXB0eS4nCiAgRW5hYmxlZDogdHJ1ZQogIEFsbG93Q29tbWVudHM6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjkwJwoKTGludC9FbXB0eUluUGF0dGVybjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIGBpbmAgcGF0dGVybiBicmFuY2hlcyB3aXRob3V0IGEgYm9keS4nCiAgRW5hYmxlZDogcGVuZGluZwogIEFsbG93Q29tbWVudHM6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcxLjE2JwoKTGludC9FbXB0eUludGVycG9sYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGVtcHR5IHN0cmluZyBpbnRlcnBvbGF0aW9uLicKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcwLjIwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS42MScKCkxpbnQvRW1wdHlXaGVuOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBgd2hlbmAgYnJhbmNoZXMgd2l0aCBlbXB0eSBib2RpZXMuJwogIEVuYWJsZWQ6IHRydWUKICBBbGxvd0NvbW1lbnRzOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40NScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODMnCgpMaW50L0Vuc3VyZVJldHVybjoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCB1c2UgcmV0dXJuIGluIGFuIGVuc3VyZSBibG9jay4nCiAgU3R5bGVHdWlkZTogJyNuby1yZXR1cm4tZW5zdXJlJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgzJwoKTGludC9FcmJOZXdBcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICdVc2UgYDp0cmltX21vZGVgIGFuZCBgOmVvdXR2YXJgIGtleXdvcmQgYXJndW1lbnRzIHRvIGBFUkIubmV3YC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTYnCgpMaW50L0ZsaXBGbG9wOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBmbGlwLWZsb3BzLicKICBTdHlsZUd1aWRlOiAnI25vLWZsaXAtZmxvcHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTYnCgpMaW50L0Zsb2F0Q29tcGFyaXNvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIHByZWNpc2UgY29tcGFyaXNvbiBvZiBmbG9hdGluZyBwb2ludCBudW1iZXJzLicKICBTdHlsZUd1aWRlOiAnI2Zsb2F0LWNvbXBhcmlzb24nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCgpMaW50L0Zsb2F0T3V0T2ZSYW5nZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDYXRjaGVzIGZsb2F0aW5nLXBvaW50IGxpdGVyYWxzIHRvbyBsYXJnZSBvciBzbWFsbCBmb3IgUnVieSB0bwogICAgICAgICAgICAgICAgIHJlcHJlc2VudC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNicKCkxpbnQvRm9ybWF0UGFyYW1ldGVyTWlzbWF0Y2g6CiAgRGVzY3JpcHRpb246ICdUaGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgdG8gZm9ybWF0L3NwcmludCBtdXN0IG1hdGNoIHRoZSBmaWVsZHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjMzJwoKTGludC9IYXNoQ29tcGFyZUJ5SWRlbnRpdHk6CiAgRGVzY3JpcHRpb246ICdQcmVmZXIgdXNpbmcgYEhhc2gjY29tcGFyZV9ieV9pZGVudGl0eWAgdGhhbiB1c2luZyBgb2JqZWN0X2lkYCBmb3Iga2V5cy4nCiAgU3R5bGVHdWlkZTogJyNpZGVudGl0eS1jb21wYXJpc29uJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuOTMnCgpMaW50L0hlcmVkb2NNZXRob2RDYWxsUG9zaXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB0aGUgb3JkZXJpbmcgb2YgYSBtZXRob2QgY2FsbCB3aGVyZQogICAgICAgICAgICAgICAgIHRoZSByZWNlaXZlciBvZiB0aGUgY2FsbCBpcyBhIEhFUkVET0MuCiAgRW5hYmxlZDogZmFsc2UKICBTdHlsZUd1aWRlOiAnI2hlcmVkb2MtbWV0aG9kLWNhbGxzJwogIFZlcnNpb25BZGRlZDogJzAuNjgnCgpMaW50L0lkZW50aXR5Q29tcGFyaXNvbjoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBgZXF1YWw/YCBvdmVyIGA9PWAgd2hlbiBjb21wYXJpbmcgYG9iamVjdF9pZGAuJwogIEVuYWJsZWQ6IHRydWUKICBTdHlsZUd1aWRlOiAnI2lkZW50aXR5LWNvbXBhcmlzb24nCiAgVmVyc2lvbkFkZGVkOiAnMC45MScKCkxpbnQvSW1wbGljaXRTdHJpbmdDb25jYXRlbmF0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYWRqYWNlbnQgc3RyaW5nIGxpdGVyYWxzIG9uIHRoZSBzYW1lIGxpbmUsIHdoaWNoCiAgICAgICAgICAgICAgICAgY291bGQgYmV0dGVyIGJlIHJlcHJlc2VudGVkIGFzIGEgc2luZ2xlIHN0cmluZyBsaXRlcmFsLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjM2JwoKTGludC9JbmNvbXBhdGlibGVJb1NlbGVjdFdpdGhGaWJlclNjaGVkdWxlcjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgYElPLnNlbGVjdGAgdGhhdCBpcyBpbmNvbXBhdGlibGUgd2l0aCBGaWJlciBTY2hlZHVsZXIuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS4yMScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMjQnCgpMaW50L0luZWZmZWN0aXZlQWNjZXNzTW9kaWZpZXI6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBhdHRlbXB0cyB0byB1c2UgYHByaXZhdGVgIG9yIGBwcm90ZWN0ZWRgIHRvIHNldAogICAgICAgICAgICAgICAgIHRoZSB2aXNpYmlsaXR5IG9mIGEgY2xhc3MgbWV0aG9kLCB3aGljaCBkb2VzIG5vdCB3b3JrLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjM2JwoKTGludC9Jbmhlcml0RXhjZXB0aW9uOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgaW5oZXJpdGluZyBmcm9tIHRoZSBgRXhjZXB0aW9uYCBjbGFzcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjQxJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yNicKICAjIFRoZSBkZWZhdWx0IGJhc2UgY2xhc3MgaW4gZmF2b3VyIG9mIGBFeGNlcHRpb25gLgogIEVuZm9yY2VkU3R5bGU6IHN0YW5kYXJkX2Vycm9yCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzdGFuZGFyZF9lcnJvcgogICAgLSBydW50aW1lX2Vycm9yCgpMaW50L0ludGVycG9sYXRpb25DaGVjazoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgaW50ZXJwb2xhdGlvbiBpbiBhIHNpbmdsZSBxdW90ZWQgc3RyaW5nLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQwJwoKTGludC9JdFdpdGhvdXRBcmd1bWVudHNJbkJsb2NrOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHVzZXMgb2YgYGl0YCBjYWxscyB3aXRob3V0IGFyZ3VtZW50cyBpbiBibG9jay4nCiAgUmVmZXJlbmNlOiAnaHR0cHM6Ly9idWdzLnJ1YnktbGFuZy5vcmcvaXNzdWVzLzE4OTgwJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjU5JwoKTGludC9MYW1iZGFXaXRob3V0TGl0ZXJhbEJsb2NrOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHVzZXMgb2YgbGFtYmRhIHdpdGhvdXQgYSBsaXRlcmFsIGJsb2NrLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS44JwoKTGludC9MaXRlcmFsQXNDb25kaXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3Mgb2YgbGl0ZXJhbHMgdXNlZCBpbiBjb25kaXRpb25zLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MScKCkxpbnQvTGl0ZXJhbEFzc2lnbm1lbnRJbkNvbmRpdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgbGl0ZXJhbCBhc3NpZ25tZW50cyBpbiB0aGUgY29uZGl0aW9ucy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNTgnCgpMaW50L0xpdGVyYWxJbkludGVycG9sYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGxpdGVyYWxzIHVzZWQgaW4gaW50ZXJwb2xhdGlvbi4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjMyJwoKTGludC9Mb29wOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSBLZXJuZWwjbG9vcCB3aXRoIGJyZWFrIHJhdGhlciB0aGFuIGJlZ2luL2VuZC91bnRpbCBvcgogICAgICAgICAgICAgICAgIGJlZ2luL2VuZC93aGlsZSBmb3IgcG9zdC1sb29wIHRlc3RzLgogIFN0eWxlR3VpZGU6ICcjbG9vcC13aXRoLWJyZWFrJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjMnCiAgU2FmZTogZmFsc2UKCkxpbnQvTWlzc2luZ0NvcEVuYWJsZURpcmVjdGl2ZToKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgYSBgIyBydWJvY29wOmVuYWJsZWAgYWZ0ZXIgYCMgcnVib2NvcDpkaXNhYmxlYC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCiAgIyBNYXhpbXVtIG51bWJlciBvZiBjb25zZWN1dGl2ZSBsaW5lcyB0aGUgY29wIGNhbiBiZSBkaXNhYmxlZCBmb3IuCiAgIyAwIGFsbG93cyBvbmx5IHNpbmdsZS1saW5lIGRpc2FibGVzCiAgIyAxIHdvdWxkIG1lYW4gdGhlIG1heGltdW0gYWxsb3dlZCBpcyB0aGUgZm9sbG93aW5nOgogICMgICAjIHJ1Ym9jb3A6ZGlzYWJsZSBTb21lQ29wCiAgIyAgIGEgPSAxCiAgIyAgICMgcnVib2NvcDplbmFibGUgU29tZUNvcAogICMgLmluZiBmb3IgYW55IHNpemUKICBNYXhpbXVtUmFuZ2VTaXplOiAuaW5mCgpMaW50L01pc3NpbmdTdXBlcjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgY29uc3RydWN0b3JzIGFuZCBsaWZlY3ljbGUgY2FsbGJhY2tzCiAgICAgICAgICAgICAgICAgIHdpdGhvdXQgY2FsbHMgdG8gYHN1cGVyYC4KICBFbmFibGVkOiB0cnVlCiAgQWxsb3dlZFBhcmVudENsYXNzZXM6IFtdCiAgVmVyc2lvbkFkZGVkOiAnMC44OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuNCcKCkxpbnQvTWl4ZWRDYXNlUmFuZ2U6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIG1peGVkLWNhc2UgY2hhcmFjdGVyIHJhbmdlcyBzaW5jZSB0aGV5IGluY2x1ZGUgbGlrZWx5IHVuaW50ZW5kZWQgY2hhcmFjdGVycy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjUzJwoKTGludC9NaXhlZFJlZ2V4cENhcHR1cmVUeXBlczoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCBtaXggbmFtZWQgY2FwdHVyZXMgYW5kIG51bWJlcmVkIGNhcHR1cmVzIGluIGEgUmVnZXhwIGxpdGVyYWwuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjg1JwoKTGludC9NdWx0aXBsZUNvbXBhcmlzb246CiAgRGVzY3JpcHRpb246ICJVc2UgYCYmYCBvcGVyYXRvciB0byBjb21wYXJlIG11bHRpcGxlIHZhbHVlcy4iCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDcnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjEnCgpMaW50L05lc3RlZE1ldGhvZERlZmluaXRpb246CiAgRGVzY3JpcHRpb246ICdEbyBub3QgdXNlIG5lc3RlZCBtZXRob2QgZGVmaW5pdGlvbnMuJwogIFN0eWxlR3VpZGU6ICcjbm8tbmVzdGVkLW1ldGhvZHMnCiAgRW5hYmxlZDogdHJ1ZQogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KICBWZXJzaW9uQWRkZWQ6ICcwLjMyJwoKTGludC9OZXN0ZWRQZXJjZW50TGl0ZXJhbDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgbmVzdGVkIHBlcmNlbnQgbGl0ZXJhbHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwoKTGludC9OZXh0V2l0aG91dEFjY3VtdWxhdG9yOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgICBEbyBub3Qgb21pdCB0aGUgYWNjdW11bGF0b3Igd2hlbiBjYWxsaW5nIGBuZXh0YAogICAgICAgICAgICAgICAgICBpbiBhIGByZWR1Y2VgL2BpbmplY3RgIGJsb2NrLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjM2JwoKTGludC9Ob1JldHVybkluQmVnaW5FbmRCbG9ja3M6CiAgRGVzY3JpcHRpb246ICdEbyBub3QgYHJldHVybmAgaW5zaWRlIGBiZWdpbi4uZW5kYCBibG9ja3MgaW4gYXNzaWdubWVudCBjb250ZXh0cy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMicKCkxpbnQvTm9uQXRvbWljRmlsZU9wZXJhdGlvbjoKICBEZXNjcmlwdGlvbjogQ2hlY2tzIGZvciBub24tYXRvbWljIGZpbGUgb3BlcmF0aW9ucy4KICBTdHlsZUd1aWRlOiAnI2F0b21pYy1maWxlLW9wZXJhdGlvbnMnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzEnCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQoKTGludC9Ob25EZXRlcm1pbmlzdGljUmVxdWlyZU9yZGVyOgogIERlc2NyaXB0aW9uOiAnQWx3YXlzIHNvcnQgYXJyYXlzIHJldHVybmVkIGJ5IERpci5nbG9iIHdoZW4gcmVxdWlyaW5nIGZpbGVzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC43OCcKICBTYWZlOiBmYWxzZQoKTGludC9Ob25Mb2NhbEV4aXRGcm9tSXRlcmF0b3I6CiAgRGVzY3JpcHRpb246ICdEbyBub3QgdXNlIHJldHVybiBpbiBpdGVyYXRvciB0byBjYXVzZSBub24tbG9jYWwgZXhpdC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzAnCgpMaW50L051bWJlckNvbnZlcnNpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdW5zYWZlIHVzYWdlIG9mIG51bWJlciBjb252ZXJzaW9uIG1ldGhvZHMuJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICBWZXJzaW9uQ2hhbmdlZDogJzEuMScKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgQWxsb3dlZE1ldGhvZHM6IFtdCiAgQWxsb3dlZFBhdHRlcm5zOiBbXQogIElnbm9yZWRDbGFzc2VzOgogICAgLSBUaW1lCiAgICAtIERhdGVUaW1lCgpMaW50L051bWJlcmVkUGFyYW1ldGVyQXNzaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlcyBvZiBudW1iZXJlZCBwYXJhbWV0ZXIgYXNzaWdubWVudC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuOScKCkxpbnQvT3JBc3NpZ25tZW50VG9Db25zdGFudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB1bmludGVuZGVkIG9yLWFzc2lnbm1lbnQgdG8gY29uc3RhbnQuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuOScKCkxpbnQvT3JkZXJlZE1hZ2ljQ29tbWVudHM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhlIHByb3BlciBvcmRlcmluZyBvZiBtYWdpYyBjb21tZW50cyBhbmQgd2hldGhlciBhIG1hZ2ljIGNvbW1lbnQgaXMgbm90IHBsYWNlZCBiZWZvcmUgYSBzaGViYW5nLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjM3JwoKTGludC9PdXRPZlJhbmdlUmVnZXhwUmVmOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBvdXQgb2YgcmFuZ2UgcmVmZXJlbmNlIGZvciBSZWdleHAgYmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyBuaWwuJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuODknCgpMaW50L1BhcmVudGhlc2VzQXNHcm91cGVkRXhwcmVzc2lvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIG1ldGhvZCBjYWxscyB3aXRoIGEgc3BhY2UgYmVmb3JlIHRoZSBvcGVuaW5nCiAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXMuCiAgU3R5bGVHdWlkZTogJyNwYXJlbnMtbm8tc3BhY2VzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEyJwogIFZlcnNpb25DaGFuZ2VkOiAnMC44MycKCkxpbnQvUGVyY2VudFN0cmluZ0FycmF5OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgdW53YW50ZWQgY29tbWFzIGFuZCBxdW90ZXMgaW4gJXcvJVcgbGl0ZXJhbHMuCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC40MScKCkxpbnQvUGVyY2VudFN5bWJvbEFycmF5OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgdW53YW50ZWQgY29tbWFzIGFuZCBjb2xvbnMgaW4gJWkvJUkgbGl0ZXJhbHMuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDEnCgpMaW50L1JhaXNlRXhjZXB0aW9uOgogIERlc2NyaXB0aW9uOiBDaGVja3MgZm9yIGByYWlzZWAgb3IgYGZhaWxgIHN0YXRlbWVudHMgd2hpY2ggYXJlIHJhaXNpbmcgYEV4Y2VwdGlvbmAgY2xhc3MuCiAgU3R5bGVHdWlkZTogJyNyYWlzZS1leGNlcHRpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44MScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODYnCiAgQWxsb3dlZEltcGxpY2l0TmFtZXNwYWNlczoKICAgIC0gJ0dlbScKCkxpbnQvUmFuZE9uZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIGByYW5kKDEpYCBjYWxscy4gU3VjaCBjYWxscyBhbHdheXMgcmV0dXJuIGAwYAogICAgICAgICAgICAgICAgIGFuZCBtb3N0IGxpa2VseSBhIG1pc3Rha2UuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzYnCgpMaW50L1JlZHVuZGFudENvcERpc2FibGVEaXJlY3RpdmU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBydWJvY29wOmRpc2FibGUgY29tbWVudHMgdGhhdCBjYW4gYmUgcmVtb3ZlZC4KICAgICAgICAgICAgICAgICBOb3RlOiB0aGlzIGNvcCBpcyBub3QgZGlzYWJsZWQgd2hlbiBkaXNhYmxpbmcgYWxsIGNvcHMuCiAgICAgICAgICAgICAgICAgSXQgbXVzdCBiZSBleHBsaWNpdGx5IGRpc2FibGVkLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjc2JwoKTGludC9SZWR1bmRhbnRDb3BFbmFibGVEaXJlY3RpdmU6CiAgRGVzY3JpcHRpb246IENoZWNrcyBmb3IgcnVib2NvcDplbmFibGUgY29tbWVudHMgdGhhdCBjYW4gYmUgcmVtb3ZlZC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC43NicKCkxpbnQvUmVkdW5kYW50RGlyR2xvYlNvcnQ6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBgc29ydGAgbWV0aG9kIHRvIGBEaXIuZ2xvYmAgYW5kIGBEaXJbXWAuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjgnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjI2JwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKCkxpbnQvUmVkdW5kYW50UmVnZXhwUXVhbnRpZmllcnM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBxdWFudGlmaWVycyBpbiBSZWdleHBzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41MycKCkxpbnQvUmVkdW5kYW50UmVxdWlyZVN0YXRlbWVudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdW5uZWNlc3NhcnkgYHJlcXVpcmVgIHN0YXRlbWVudC4nCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjc2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS41NycKCkxpbnQvUmVkdW5kYW50U2FmZU5hdmlnYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBzYWZlIG5hdmlnYXRpb24gY2FsbHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjkzJwogIEFsbG93ZWRNZXRob2RzOgogICAgLSBpbnN0YW5jZV9vZj8KICAgIC0ga2luZF9vZj8KICAgIC0gaXNfYT8KICAgIC0gZXFsPwogICAgLSByZXNwb25kX3RvPwogICAgLSBlcXVhbD8KICBTYWZlOiBmYWxzZQoKTGludC9SZWR1bmRhbnRTcGxhdEV4cGFuc2lvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3Igc3BsYXQgdW5uZWNlc3NhcmlseSBiZWluZyBjYWxsZWQgb24gbGl0ZXJhbHMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjc2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS43JwogIEFsbG93UGVyY2VudExpdGVyYWxBcnJheUFyZ3VtZW50OiB0cnVlCgpMaW50L1JlZHVuZGFudFN0cmluZ0NvZXJjaW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBPYmplY3QjdG9fcyB1c2FnZSBpbiBzdHJpbmcgaW50ZXJwb2xhdGlvbi4nCiAgU3R5bGVHdWlkZTogJyNuby10by1zJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjE5JwogIFZlcnNpb25DaGFuZ2VkOiAnMC43NycKCkxpbnQvUmVkdW5kYW50V2l0aEluZGV4OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWR1bmRhbnQgYHdpdGhfaW5kZXhgLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKCkxpbnQvUmVkdW5kYW50V2l0aE9iamVjdDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcmVkdW5kYW50IGB3aXRoX29iamVjdGAuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUxJwoKTGludC9SZWZpbmVtZW50SW1wb3J0TWV0aG9kczoKICBEZXNjcmlwdGlvbjogJ1VzZSBgUmVmaW5lbWVudCNpbXBvcnRfbWV0aG9kc2Agd2hlbiB1c2luZyBgaW5jbHVkZWAgb3IgYHByZXBlbmRgIGluIGByZWZpbmVgIGJsb2NrLicKICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMjcnCgpMaW50L1JlZ2V4cEFzQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIERvIG5vdCB1c2UgcmVnZXhwIGxpdGVyYWwgYXMgYSBjb25kaXRpb24uCiAgICAgICAgICAgICAgICAgVGhlIHJlZ2V4cCBsaXRlcmFsIG1hdGNoZXMgYCRfYCBpbXBsaWNpdGx5LgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUxJwogIFZlcnNpb25DaGFuZ2VkOiAnMC44NicKCkxpbnQvUmVxdWlyZVBhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSBwYXJlbnRoZXNlcyBpbiB0aGUgbWV0aG9kIGNhbGwgdG8gYXZvaWQgY29uZnVzaW9uCiAgICAgICAgICAgICAgICAgYWJvdXQgcHJlY2VkZW5jZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xOCcKCkxpbnQvUmVxdWlyZVJhbmdlUGFyZW50aGVzZXM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhhdCBhIHJhbmdlIGxpdGVyYWwgaXMgZW5jbG9zZWQgaW4gcGFyZW50aGVzZXMgd2hlbiB0aGUgZW5kIG9mIHRoZSByYW5nZSBpcyBhdCBhIGxpbmUgYnJlYWsuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjMyJwoKTGludC9SZXF1aXJlUmVsYXRpdmVTZWxmUGF0aDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlcyBhIGZpbGUgcmVxdWlyaW5nIGl0c2VsZiB3aXRoIGByZXF1aXJlX3JlbGF0aXZlYC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjInCgpMaW50L1Jlc2N1ZUV4Y2VwdGlvbjoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHJlc2N1aW5nIHRoZSBFeGNlcHRpb24gY2xhc3MuJwogIFN0eWxlR3VpZGU6ICcjbm8tYmxpbmQtcmVzY3VlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yNycKCkxpbnQvUmVzY3VlVHlwZToKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHJlc2N1aW5nIGZyb20gbm9uIGNvbnN0YW50cyB0aGF0IGNvdWxkIHJlc3VsdCBpbiBhIGBUeXBlRXJyb3JgLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKCkxpbnQvUmV0dXJuSW5Wb2lkQ29udGV4dDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcmV0dXJuIGluIHZvaWQgY29udGV4dC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCgpMaW50L1NhZmVOYXZpZ2F0aW9uQ2hhaW46CiAgRGVzY3JpcHRpb246ICdEbyBub3QgY2hhaW4gb3JkaW5hcnkgbWV0aG9kIGNhbGwgYWZ0ZXIgc2FmZSBuYXZpZ2F0aW9uIG9wZXJhdG9yLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40NycKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzcnCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIHByZXNlbnQ/CiAgICAtIGJsYW5rPwogICAgLSBwcmVzZW5jZQogICAgLSB0cnkKICAgIC0gdHJ5IQogICAgLSBpbj8KCkxpbnQvU2FmZU5hdmlnYXRpb25Db25zaXN0ZW5jeToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVjayB0byBtYWtlIHN1cmUgdGhhdCBpZiBzYWZlIG5hdmlnYXRpb24gaXMgdXNlZCBmb3IgYSBtZXRob2QKICAgICAgICAgICAgICAgICBjYWxsIGluIGFuIGAmJmAgb3IgYHx8YCBjb25kaXRpb24gdGhhdCBzYWZlIG5hdmlnYXRpb24gaXMgdXNlZAogICAgICAgICAgICAgICAgIGZvciBhbGwgbWV0aG9kIGNhbGxzIG9uIHRoYXQgc2FtZSBvYmplY3QuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwogIEFsbG93ZWRNZXRob2RzOgogICAgLSBwcmVzZW50PwogICAgLSBibGFuaz8KICAgIC0gcHJlc2VuY2UKICAgIC0gdHJ5CiAgICAtIHRyeSEKCkxpbnQvU2FmZU5hdmlnYXRpb25XaXRoRW1wdHk6CiAgRGVzY3JpcHRpb246ICdBdm9pZCBgZm9vJi5lbXB0eT9gIGluIGNvbmRpdGlvbmFscy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNjInCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjg3JwoKTGludC9TY3JpcHRQZXJtaXNzaW9uOgogIERlc2NyaXB0aW9uOiAnR3JhbnQgc2NyaXB0IGZpbGUgZXhlY3V0ZSBwZXJtaXNzaW9uLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNTAnCgpMaW50L1NlbGZBc3NpZ25tZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBzZWxmLWFzc2lnbm1lbnRzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44OScKCkxpbnQvU2VuZFdpdGhNaXhpbkFyZ3VtZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBgc2VuZGAgbWV0aG9kIHdoZW4gdXNpbmcgbWl4aW4uJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjc1JwoKTGludC9TaGFkb3dlZEFyZ3VtZW50OgogIERlc2NyaXB0aW9uOiAnQXZvaWQgcmVhc3NpZ25pbmcgYXJndW1lbnRzIGJlZm9yZSB0aGV5IHdlcmUgdXNlZC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCiAgSWdub3JlSW1wbGljaXRSZWZlcmVuY2VzOiBmYWxzZQoKCkxpbnQvU2hhZG93ZWRFeGNlcHRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIEF2b2lkIHJlc2N1aW5nIGEgaGlnaGVyIGxldmVsIGV4Y2VwdGlvbgogICAgICAgICAgICAgICAgICBiZWZvcmUgYSBsb3dlciBsZXZlbCBleGNlcHRpb24uCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDEnCgpMaW50L1NoYWRvd2luZ091dGVyTG9jYWxWYXJpYWJsZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBEbyBub3QgdXNlIHRoZSBzYW1lIG5hbWUgYXMgb3V0ZXIgbG9jYWwgdmFyaWFibGUKICAgICAgICAgICAgICAgICBmb3IgYmxvY2sgYXJndW1lbnRzIG9yIGJsb2NrIGxvY2FsIHZhcmlhYmxlcy4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwoKTGludC9TdHJ1Y3ROZXdPdmVycmlkZToKICBEZXNjcmlwdGlvbjogJ0Rpc2FsbG93IG92ZXJyaWRpbmcgdGhlIGBTdHJ1Y3RgIGJ1aWx0LWluIG1ldGhvZHMgdmlhIGBTdHJ1Y3QubmV3YC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODEnCgpMaW50L1N1cHByZXNzZWRFeGNlcHRpb246CiAgRGVzY3JpcHRpb246ICJEb24ndCBzdXBwcmVzcyBleGNlcHRpb25zLiIKICBTdHlsZUd1aWRlOiAnI2RvbnQtaGlkZS1leGNlcHRpb25zJwogIEVuYWJsZWQ6IHRydWUKICBBbGxvd0NvbW1lbnRzOiB0cnVlCiAgQWxsb3dOaWw6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjEyJwoKTGludC9TeW1ib2xDb252ZXJzaW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1bm5lY2Vzc2FyeSBzeW1ib2wgY29udmVyc2lvbnMuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjE2JwogIEVuZm9yY2VkU3R5bGU6IHN0cmljdAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc3RyaWN0CiAgICAtIGNvbnNpc3RlbnQKCkxpbnQvU3ludGF4OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBzeW50YXggZXJyb3JzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwoKTGludC9Ub0VudW1Bcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICdFbnN1cmVzIHRoYXQgYHRvX2VudW1gL2BlbnVtX2ZvcmAsIGNhbGxlZCBmb3IgdGhlIGN1cnJlbnQgbWV0aG9kLCBoYXMgY29ycmVjdCBhcmd1bWVudHMuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjEnCgpMaW50L1RvSlNPTjoKICBEZXNjcmlwdGlvbjogJ0Vuc3VyZSAjdG9fanNvbiBpbmNsdWRlcyBhbiBvcHRpb25hbCBhcmd1bWVudC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNjYnCgpMaW50L1RvcExldmVsUmV0dXJuV2l0aEFyZ3VtZW50OgogIERlc2NyaXB0aW9uOiAnRGV0ZWN0cyB0b3AgbGV2ZWwgcmV0dXJuIHN0YXRlbWVudHMgd2l0aCBhcmd1bWVudC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgIyBUaGVzZSBjb2RlcyBhcmUgYGV2YWxgLWVkIGluIG1ldGhvZCBhbmQgdGhlaXIgcmV0dXJuIHZhbHVlcyBtYXkgYmUgdXNlZC4KICBFeGNsdWRlOgogICAgLSAnKiovKi5qYicKCkxpbnQvVHJhaWxpbmdDb21tYUluQXR0cmlidXRlRGVjbGFyYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHRyYWlsaW5nIGNvbW1hcyBpbiBhdHRyaWJ1dGUgZGVjbGFyYXRpb25zLicKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcwLjkwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS42MScKCkxpbnQvVHJpcGxlUXVvdGVzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2VsZXNzIHRyaXBsZSBxdW90ZSBjb25zdHJ1Y3RzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS45JwoKTGludC9VbmRlcnNjb3JlUHJlZml4ZWRWYXJpYWJsZU5hbWU6CiAgRGVzY3JpcHRpb246ICdEbyBub3QgdXNlIHByZWZpeCBgX2AgZm9yIGEgdmFyaWFibGUgdGhhdCBpcyB1c2VkLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yMScKICBBbGxvd0tleXdvcmRCbG9ja0FyZ3VtZW50czogZmFsc2UKCkxpbnQvVW5leHBlY3RlZEJsb2NrQXJpdHk6CiAgRGVzY3JpcHRpb246ICdMb29rcyBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBmZXdlciBhcmd1bWVudHMgdGhhdCB0aGUgY2FsbGluZyBtZXRob2QgZXhwZWN0cy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS41JwogIE1ldGhvZHM6CiAgICBjaHVua193aGlsZTogMgogICAgZWFjaF93aXRoX2luZGV4OiAyCiAgICBlYWNoX3dpdGhfb2JqZWN0OiAyCiAgICBpbmplY3Q6IDIKICAgIG1heDogMgogICAgbWluOiAyCiAgICBtaW5tYXg6IDIKICAgIHJlZHVjZTogMgogICAgc2xpY2Vfd2hlbjogMgogICAgc29ydDogMgoKTGludC9VbmlmaWVkSW50ZWdlcjoKICBEZXNjcmlwdGlvbjogJ1VzZSBJbnRlZ2VyIGluc3RlYWQgb2YgRml4bnVtIG9yIEJpZ251bS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDMnCgpMaW50L1VubW9kaWZpZWRSZWR1Y2VBY2N1bXVsYXRvcjoKICBEZXNjcmlwdGlvbjogQ2hlY2tzIGZvciBgcmVkdWNlYCBvciBgaW5qZWN0YCBibG9ja3MgdGhhdCBkbyBub3QgdXBkYXRlIHRoZSBhY2N1bXVsYXRvciBlYWNoIGl0ZXJhdGlvbi4KICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4xJwogIFZlcnNpb25DaGFuZ2VkOiAnMS41JwoKTGludC9VbnJlYWNoYWJsZUNvZGU6CiAgRGVzY3JpcHRpb246ICdVbnJlYWNoYWJsZSBjb2RlLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwoKTGludC9VbnJlYWNoYWJsZUxvb3A6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGxvb3BzIHRoYXQgd2lsbCBoYXZlIGF0IG1vc3Qgb25lIGl0ZXJhdGlvbi4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjcnCiAgQWxsb3dlZFBhdHRlcm5zOgogICAgIyBSU3BlYyB1c2VzIGB0aW1lc2AgaW4gaXRzIG1lc3NhZ2UgZXhwZWN0YXRpb25zCiAgICAjIGVnLiBgZXhhY3RseSgyKS50aW1lc2AKICAgIC0gIXJ1YnkvcmVnZXhwIC8oZXhhY3RseXxhdF9sZWFzdHxhdF9tb3N0KVwoXGQrXClcLnRpbWVzLwoKTGludC9VbnVzZWRCbG9ja0FyZ3VtZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1bnVzZWQgYmxvY2sgYXJndW1lbnRzLicKICBTdHlsZUd1aWRlOiAnI3VuZGVyc2NvcmUtdW51c2VkLXZhcnMnCiAgRW5hYmxlZDogdHJ1ZQogIEF1dG9Db3JyZWN0OiBjb250ZXh0dWFsCiAgVmVyc2lvbkFkZGVkOiAnMC4yMScKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjEnCiAgSWdub3JlRW1wdHlCbG9ja3M6IHRydWUKICBBbGxvd1VudXNlZEtleXdvcmRBcmd1bWVudHM6IGZhbHNlCgpMaW50L1VudXNlZE1ldGhvZEFyZ3VtZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1bnVzZWQgbWV0aG9kIGFyZ3VtZW50cy4nCiAgU3R5bGVHdWlkZTogJyN1bmRlcnNjb3JlLXVudXNlZC12YXJzJwogIEVuYWJsZWQ6IHRydWUKICBBdXRvQ29ycmVjdDogY29udGV4dHVhbAogIFZlcnNpb25BZGRlZDogJzAuMjEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwogIEFsbG93VW51c2VkS2V5d29yZEFyZ3VtZW50czogZmFsc2UKICBJZ25vcmVFbXB0eU1ldGhvZHM6IHRydWUKICBJZ25vcmVOb3RJbXBsZW1lbnRlZE1ldGhvZHM6IHRydWUKCkxpbnQvVXJpRXNjYXBlVW5lc2NhcGU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgYFVSSS5lc2NhcGVgIG1ldGhvZCBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBJbnN0ZWFkLCB1c2UKICAgICAgICAgICAgICAgICBgQ0dJLmVzY2FwZWAsIGBVUkkuZW5jb2RlX3d3d19mb3JtYCBvciBgVVJJLmVuY29kZV93d3dfZm9ybV9jb21wb25lbnRgCiAgICAgICAgICAgICAgICAgZGVwZW5kaW5nIG9uIHlvdXIgc3BlY2lmaWMgdXNlIGNhc2UuCiAgICAgICAgICAgICAgICAgQWxzbyBgVVJJLnVuZXNjYXBlYCBtZXRob2QgaXMgb2Jzb2xldGUgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gSW5zdGVhZCwgdXNlCiAgICAgICAgICAgICAgICAgYENHSS51bmVzY2FwZWAsIGBVUkkuZGVjb2RlX3d3d19mb3JtYCBvciBgVVJJLmRlY29kZV93d3dfZm9ybV9jb21wb25lbnRgCiAgICAgICAgICAgICAgICAgZGVwZW5kaW5nIG9uIHlvdXIgc3BlY2lmaWMgdXNlIGNhc2UuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCgpMaW50L1VyaVJlZ2V4cDoKICBEZXNjcmlwdGlvbjogJ1VzZSBgVVJJOjpERUZBVUxUX1BBUlNFUi5tYWtlX3JlZ2V4cGAgaW5zdGVhZCBvZiBgVVJJLnJlZ2V4cGAuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwoKTGludC9Vc2VsZXNzQWNjZXNzTW9kaWZpZXI6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzZWxlc3MgYWNjZXNzIG1vZGlmaWVycy4nCiAgRW5hYmxlZDogdHJ1ZQogIEF1dG9Db3JyZWN0OiBjb250ZXh0dWFsCiAgVmVyc2lvbkFkZGVkOiAnMC4yMCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjEnCiAgQ29udGV4dENyZWF0aW5nTWV0aG9kczogW10KICBNZXRob2RDcmVhdGluZ01ldGhvZHM6IFtdCgpMaW50L1VzZWxlc3NBc3NpZ25tZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2VsZXNzIGFzc2lnbm1lbnQgdG8gYSBsb2NhbCB2YXJpYWJsZS4nCiAgU3R5bGVHdWlkZTogJyN1bmRlcnNjb3JlLXVudXNlZC12YXJzJwogIEVuYWJsZWQ6IHRydWUKICBBdXRvQ29ycmVjdDogY29udGV4dHVhbAogIFZlcnNpb25BZGRlZDogJzAuMTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKCkxpbnQvVXNlbGVzc0Vsc2VXaXRob3V0UmVzY3VlOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2VsZXNzIGBlbHNlYCBpbiBgYmVnaW4uLmVuZGAgd2l0aG91dCBgcmVzY3VlYC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTcnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjMxJwoKTGludC9Vc2VsZXNzTWV0aG9kRGVmaW5pdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlbGVzcyBtZXRob2QgZGVmaW5pdGlvbnMuJwogIEVuYWJsZWQ6IHRydWUKICBBdXRvQ29ycmVjdDogY29udGV4dHVhbAogIFZlcnNpb25BZGRlZDogJzAuOTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwogIFNhZmU6IGZhbHNlCgpMaW50L1VzZWxlc3NSZXNjdWU6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzZWxlc3MgYHJlc2N1ZWBzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS40MycKCkxpbnQvVXNlbGVzc1J1YnkyS2V5d29yZHM6CiAgRGVzY3JpcHRpb246ICdGaW5kcyB1bm5lY2Vzc2FyeSB1c2VzIG9mIGBydWJ5Ml9rZXl3b3Jkc2AuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjIzJwoKTGludC9Vc2VsZXNzU2V0dGVyQ2FsbDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlbGVzcyBzZXR0ZXIgY2FsbCB0byBhIGxvY2FsIHZhcmlhYmxlLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjEzJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yJwoKTGludC9Vc2VsZXNzVGltZXM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzZWxlc3MgYEludGVnZXIjdGltZXNgIGNhbGxzLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBBdXRvQ29ycmVjdDogY29udGV4dHVhbAogIFZlcnNpb25BZGRlZDogJzAuOTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwoKTGludC9Wb2lkOgogIERlc2NyaXB0aW9uOiAnUG9zc2libGUgdXNlIG9mIG9wZXJhdG9yL2xpdGVyYWwvdmFyaWFibGUgaW4gdm9pZCBjb250ZXh0LicKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwogIENoZWNrRm9yTWV0aG9kc1dpdGhOb1NpZGVFZmZlY3RzOiBmYWxzZQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMgTWV0cmljcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpNZXRyaWNzL0FiY1NpemU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQSBjYWxjdWxhdGVkIG1hZ25pdHVkZSBiYXNlZCBvbiBudW1iZXIgb2YgYXNzaWdubWVudHMsCiAgICAgICAgICAgICAgICAgYnJhbmNoZXMsIGFuZCBjb25kaXRpb25zLgogIFJlZmVyZW5jZToKICAgIC0gaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9BYmNNZXRyaWMKICAgIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQUJDX1NvZnR3YXJlX01ldHJpYwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjI3JwogIFZlcnNpb25DaGFuZ2VkOiAnMS41JwogICMgVGhlIEFCQyBzaXplIGlzIGEgY2FsY3VsYXRlZCBtYWduaXR1ZGUsIHNvIHRoaXMgbnVtYmVyIGNhbiBiZSBhbiBJbnRlZ2VyIG9yCiAgIyBhIEZsb2F0LgogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KICBDb3VudFJlcGVhdGVkQXR0cmlidXRlczogdHJ1ZQogIE1heDogMTcKCk1ldHJpY3MvQmxvY2tMZW5ndGg6CiAgRGVzY3JpcHRpb246ICdBdm9pZCBsb25nIGJsb2NrcyB3aXRoIG1hbnkgbGluZXMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ0JwogIFZlcnNpb25DaGFuZ2VkOiAnMS41JwogIENvdW50Q29tbWVudHM6IGZhbHNlICAjIGNvdW50IGZ1bGwgbGluZSBjb21tZW50cz8KICBNYXg6IDI1CiAgQ291bnRBc09uZTogW10KICBBbGxvd2VkTWV0aG9kczoKICAgICMgQnkgZGVmYXVsdCwgZXhjbHVkZSB0aGUgYCNyZWZpbmVgIG1ldGhvZCwgYXMgaXQgdGVuZHMgdG8gaGF2ZSBsYXJnZXIKICAgICMgYXNzb2NpYXRlZCBibG9ja3MuCiAgICAtIHJlZmluZQogIEFsbG93ZWRQYXR0ZXJuczogW10KICBFeGNsdWRlOgogICAgLSAnKiovKi5nZW1zcGVjJwoKTWV0cmljcy9CbG9ja05lc3Rpbmc6CiAgRGVzY3JpcHRpb246ICdBdm9pZCBleGNlc3NpdmUgYmxvY2sgbmVzdGluZy4nCiAgU3R5bGVHdWlkZTogJyN0aHJlZS1pcy10aGUtbnVtYmVyLXRob3Utc2hhbHQtY291bnQnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ3JwogIENvdW50QmxvY2tzOiBmYWxzZQogIE1heDogMwoKTWV0cmljcy9DbGFzc0xlbmd0aDoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIGNsYXNzZXMgbG9uZ2VyIHRoYW4gMTAwIGxpbmVzIG9mIGNvZGUuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjI1JwogIFZlcnNpb25DaGFuZ2VkOiAnMC44NycKICBDb3VudENvbW1lbnRzOiBmYWxzZSAgIyBjb3VudCBmdWxsIGxpbmUgY29tbWVudHM/CiAgTWF4OiAxMDAKICBDb3VudEFzT25lOiBbXQoKTWV0cmljcy9Db2xsZWN0aW9uTGl0ZXJhbExlbmd0aDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgYEFycmF5YCBvciBgSGFzaGAgbGl0ZXJhbHMgd2l0aCBtYW55IGVudHJpZXMuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjQ3JwogIExlbmd0aFRocmVzaG9sZDogMjUwCgojIEF2b2lkIGNvbXBsZXggbWV0aG9kcy4KTWV0cmljcy9DeWNsb21hdGljQ29tcGxleGl0eToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBBIGNvbXBsZXhpdHkgbWV0cmljIHRoYXQgaXMgc3Ryb25nbHkgY29ycmVsYXRlZCB0byB0aGUgbnVtYmVyCiAgICAgICAgICAgICAgICAgb2YgdGVzdCBjYXNlcyBuZWVkZWQgdG8gdmFsaWRhdGUgYSBtZXRob2QuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgxJwogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KICBNYXg6IDcKCk1ldHJpY3MvTWV0aG9kTGVuZ3RoOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgbWV0aG9kcyBsb25nZXIgdGhhbiAxMCBsaW5lcyBvZiBjb2RlLicKICBTdHlsZUd1aWRlOiAnI3Nob3J0LW1ldGhvZHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjUnCiAgQ291bnRDb21tZW50czogZmFsc2UgICMgY291bnQgZnVsbCBsaW5lIGNvbW1lbnRzPwogIE1heDogMTAKICBDb3VudEFzT25lOiBbXQogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KCk1ldHJpY3MvTW9kdWxlTGVuZ3RoOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgbW9kdWxlcyBsb25nZXIgdGhhbiAxMDAgbGluZXMgb2YgY29kZS4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjg3JwogIENvdW50Q29tbWVudHM6IGZhbHNlICAjIGNvdW50IGZ1bGwgbGluZSBjb21tZW50cz8KICBNYXg6IDEwMAogIENvdW50QXNPbmU6IFtdCgpNZXRyaWNzL1BhcmFtZXRlckxpc3RzOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgcGFyYW1ldGVyIGxpc3RzIGxvbmdlciB0aGFuIHRocmVlIG9yIGZvdXIgcGFyYW1ldGVycy4nCiAgU3R5bGVHdWlkZTogJyN0b28tbWFueS1wYXJhbXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjUnCiAgTWF4OiA1CiAgQ291bnRLZXl3b3JkQXJnczogdHJ1ZQogIE1heE9wdGlvbmFsUGFyYW1ldGVyczogMwoKTWV0cmljcy9QZXJjZWl2ZWRDb21wbGV4aXR5OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEEgY29tcGxleGl0eSBtZXRyaWMgZ2VhcmVkIHRvd2FyZHMgbWVhc3VyaW5nIGNvbXBsZXhpdHkgZm9yIGEKICAgICAgICAgICAgICAgICBodW1hbiByZWFkZXIuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjUnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgxJwogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KICBNYXg6IDgKCiMjIyMjIyMjIyMjIyMjIyMjIyBNaWdyYXRpb24gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCk1pZ3JhdGlvbi9EZXBhcnRtZW50TmFtZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVjayB0aGF0IGNvcCBuYW1lcyBpbiBydWJvY29wOmRpc2FibGUgKGV0YykgY29tbWVudHMgYXJlCiAgICAgICAgICAgICAgICAgZ2l2ZW4gd2l0aCBkZXBhcnRtZW50IG5hbWUuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNzUnCgojIyMjIyMjIyMjIyMjIyMjIyMjIyBOYW1pbmcgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpOYW1pbmcvQWNjZXNzb3JNZXRob2ROYW1lOgogIERlc2NyaXB0aW9uOiBDaGVjayB0aGUgbmFtaW5nIG9mIGFjY2Vzc29yIG1ldGhvZHMgZm9yIGdldF8vc2V0Xy4KICBTdHlsZUd1aWRlOiAnI2FjY2Vzc29yX211dGF0b3JfbWV0aG9kX25hbWVzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwoKTmFtaW5nL0FzY2lpSWRlbnRpZmllcnM6CiAgRGVzY3JpcHRpb246ICdVc2Ugb25seSBhc2NpaSBzeW1ib2xzIGluIGlkZW50aWZpZXJzIGFuZCBjb25zdGFudHMuJwogIFN0eWxlR3VpZGU6ICcjZW5nbGlzaC1pZGVudGlmaWVycycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuODcnCiAgQXNjaWlDb25zdGFudHM6IHRydWUKCk5hbWluZy9CaW5hcnlPcGVyYXRvclBhcmFtZXRlck5hbWU6CiAgRGVzY3JpcHRpb246ICdXaGVuIGRlZmluaW5nIGJpbmFyeSBvcGVyYXRvcnMsIG5hbWUgdGhlIGFyZ3VtZW50IG90aGVyLicKICBTdHlsZUd1aWRlOiAnI290aGVyLWFyZycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuMicKCk5hbWluZy9CbG9ja0ZvcndhcmRpbmc6CiAgRGVzY3JpcHRpb246ICdVc2UgYW5vbnltb3VzIGJsb2NrIGZvcndhcmRpbmcuJwogIFN0eWxlR3VpZGU6ICcjYmxvY2stZm9yd2FyZGluZycKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4yNCcKICBFbmZvcmNlZFN0eWxlOiBhbm9ueW1vdXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGFub255bW91cwogICAgLSBleHBsaWNpdAogIEJsb2NrRm9yd2FyZGluZ05hbWU6IGJsb2NrCgpOYW1pbmcvQmxvY2tQYXJhbWV0ZXJOYW1lOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgYmxvY2sgcGFyYW1ldGVyIG5hbWVzIHRoYXQgY29udGFpbiBjYXBpdGFsIGxldHRlcnMsCiAgICAgICAgICAgICAgICAgZW5kIGluIG51bWJlcnMsIG9yIGRvIG5vdCBtZWV0IGEgbWluaW1hbCBsZW5ndGguCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwogICMgUGFyYW1ldGVyIG5hbWVzIG1heSBiZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZQogIE1pbk5hbWVMZW5ndGg6IDEKICBBbGxvd05hbWVzRW5kaW5nSW5OdW1iZXJzOiB0cnVlCiAgIyBBbGxvd2VkIG5hbWVzIHRoYXQgd2lsbCBub3QgcmVnaXN0ZXIgYW4gb2ZmZW5zZQogIEFsbG93ZWROYW1lczogW10KICAjIEZvcmJpZGRlbiBuYW1lcyB0aGF0IHdpbGwgcmVnaXN0ZXIgYW4gb2ZmZW5zZQogIEZvcmJpZGRlbk5hbWVzOiBbXQoKTmFtaW5nL0NsYXNzQW5kTW9kdWxlQ2FtZWxDYXNlOgogIERlc2NyaXB0aW9uOiAnVXNlIENhbWVsQ2FzZSBmb3IgY2xhc3NlcyBhbmQgbW9kdWxlcy4nCiAgU3R5bGVHdWlkZTogJyNjYW1lbGNhc2UtY2xhc3NlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuODUnCiAgIyBBbGxvd2VkIGNsYXNzL21vZHVsZSBuYW1lcyBjYW4gYmUgc3BlY2lmaWVkIGhlcmUuCiAgIyBUaGVzZSBjYW4gYmUgZnVsbCBvciBwYXJ0IG9mIHRoZSBuYW1lLgogIEFsbG93ZWROYW1lczoKICAgIC0gbW9kdWxlX3BhcmVudAoKTmFtaW5nL0NvbnN0YW50TmFtZToKICBEZXNjcmlwdGlvbjogJ0NvbnN0YW50cyBzaG91bGQgdXNlIFNDUkVBTUlOR19TTkFLRV9DQVNFLicKICBTdHlsZUd1aWRlOiAnI3NjcmVhbWluZy1zbmFrZS1jYXNlJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwoKTmFtaW5nL0ZpbGVOYW1lOgogIERlc2NyaXB0aW9uOiAnVXNlIHNuYWtlX2Nhc2UgZm9yIHNvdXJjZSBmaWxlIG5hbWVzLicKICBTdHlsZUd1aWRlOiAnI3NuYWtlLWNhc2UtZmlsZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjIzJwogICMgQ2FtZWwgY2FzZSBmaWxlIG5hbWVzIGxpc3RlZCBpbiBgQWxsQ29wczpJbmNsdWRlYCBhbmQgYWxsIGZpbGUgbmFtZXMgbGlzdGVkCiAgIyBpbiBgQWxsQ29wczpFeGNsdWRlYCBhcmUgZXhjbHVkZWQgYnkgZGVmYXVsdC4gQWRkIGV4dHJhIGV4Y2x1ZGVzIGhlcmUuCiAgRXhjbHVkZToKICAgIC0gUmFrZWZpbGUucmIKICAjIFdoZW4gYHRydWVgLCByZXF1aXJlcyB0aGF0IGVhY2ggc291cmNlIGZpbGUgc2hvdWxkIGRlZmluZSBhIGNsYXNzIG9yIG1vZHVsZQogICMgd2l0aCBhIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgZmlsZSBuYW1lIChjb252ZXJ0ZWQgdG8gLi4uIGNhc2UpLgogICMgSXQgZnVydGhlciBleHBlY3RzIGl0IHRvIGJlIG5lc3RlZCBpbnNpZGUgbW9kdWxlcyB3aGljaCBtYXRjaCB0aGUgbmFtZXMKICAjIG9mIHN1YmRpcmVjdG9yaWVzIGluIGl0cyBwYXRoLgogIEV4cGVjdE1hdGNoaW5nRGVmaW5pdGlvbjogZmFsc2UKICAjIFdoZW4gYGZhbHNlYCwgY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgRXhwZWN0TWF0Y2hpbmdEZWZpbml0aW9uIHRvIG1hdGNoIG9ubHkKICAjIHdoZXRoZXIgZWFjaCBzb3VyY2UgZmlsZSdzIGNsYXNzIG9yIG1vZHVsZSBuYW1lIG1hdGNoZXMgdGhlIGZpbGUgbmFtZSAtLQogICMgbm90IHdoZXRoZXIgdGhlIG5lc3RlZCBtb2R1bGUgaGllcmFyY2h5IG1hdGNoZXMgdGhlIHN1YmRpcmVjdG9yeSBwYXRoLgogIENoZWNrRGVmaW5pdGlvblBhdGhIaWVyYXJjaHk6IHRydWUKICAjIHBhdGhzIHRoYXQgYXJlIGNvbnNpZGVyZWQgcm9vdCBkaXJlY3RvcmllcywgZm9yIGV4YW1wbGUgImxpYiIgaW4gbW9zdCBydWJ5IHByb2plY3RzCiAgIyBvciAiYXBwL21vZGVscyIgaW4gcmFpbHMgcHJvamVjdHMKICBDaGVja0RlZmluaXRpb25QYXRoSGllcmFyY2h5Um9vdHM6CiAgICAtIGxpYgogICAgLSBzcGVjCiAgICAtIHRlc3QKICAgIC0gc3JjCiAgIyBJZiBub24tYG5pbGAsIGV4cGVjdCBhbGwgc291cmNlIGZpbGUgbmFtZXMgdG8gbWF0Y2ggdGhlIGZvbGxvd2luZyByZWdleC4KICAjIE9ubHkgdGhlIGZpbGUgbmFtZSBpdHNlbGYgaXMgbWF0Y2hlZCwgbm90IHRoZSBlbnRpcmUgZmlsZSBwYXRoLgogICMgVXNlIGFuY2hvcnMgYXMgbmVjZXNzYXJ5IGlmIHlvdSB3YW50IHRvIG1hdGNoIHRoZSBlbnRpcmUgbmFtZSByYXRoZXIgdGhhbgogICMganVzdCBhIHBhcnQgb2YgaXQuCiAgUmVnZXg6IH4KICAjIFdpdGggYElnbm9yZUV4ZWN1dGFibGVTY3JpcHRzYCBzZXQgdG8gYHRydWVgLCB0aGlzIGNvcCBkb2VzIG5vdAogICMgcmVwb3J0IG9mZmVuZGluZyBmaWxlbmFtZXMgZm9yIGV4ZWN1dGFibGUgc2NyaXB0cyAoaS5lLiBzb3VyY2UKICAjIGZpbGVzIHdpdGggYSBzaGViYW5nIGluIHRoZSBmaXJzdCBsaW5lKS4KICBJZ25vcmVFeGVjdXRhYmxlU2NyaXB0czogdHJ1ZQogIEFsbG93ZWRBY3JvbnltczoKICAgIC0gQ0xJCiAgICAtIERTTAogICAgLSBBQ0wKICAgIC0gQVBJCiAgICAtIEFTQ0lJCiAgICAtIENQVQogICAgLSBDU1MKICAgIC0gRE5TCiAgICAtIEVPRgogICAgLSBHVUlECiAgICAtIEhUTUwKICAgIC0gSFRUUAogICAgLSBIVFRQUwogICAgLSBJRAogICAgLSBJUAogICAgLSBKU09OCiAgICAtIExIUwogICAgLSBRUFMKICAgIC0gUkFNCiAgICAtIFJIUwogICAgLSBSUEMKICAgIC0gU0xBCiAgICAtIFNNVFAKICAgIC0gU1FMCiAgICAtIFNTSAogICAgLSBUQ1AKICAgIC0gVExTCiAgICAtIFRUTAogICAgLSBVRFAKICAgIC0gVUkKICAgIC0gVUlECiAgICAtIFVVSUQKICAgIC0gVVJJCiAgICAtIFVSTAogICAgLSBVVEY4CiAgICAtIFZNCiAgICAtIFhNTAogICAgLSBYTVBQCiAgICAtIFhTUkYKICAgIC0gWFNTCgpOYW1pbmcvSGVyZWRvY0RlbGltaXRlckNhc2U6CiAgRGVzY3JpcHRpb246ICdVc2UgY29uZmlndXJlZCBjYXNlIGZvciBoZXJlZG9jIGRlbGltaXRlcnMuJwogIFN0eWxlR3VpZGU6ICcjaGVyZWRvYy1kZWxpbWl0ZXJzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yJwogIEVuZm9yY2VkU3R5bGU6IHVwcGVyY2FzZQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gbG93ZXJjYXNlCiAgICAtIHVwcGVyY2FzZQoKTmFtaW5nL0hlcmVkb2NEZWxpbWl0ZXJOYW1pbmc6CiAgRGVzY3JpcHRpb246ICdVc2UgZGVzY3JpcHRpdmUgaGVyZWRvYyBkZWxpbWl0ZXJzLicKICBTdHlsZUd1aWRlOiAnI2hlcmVkb2MtZGVsaW1pdGVycycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBGb3JiaWRkZW5EZWxpbWl0ZXJzOgogICAgLSAhcnVieS9yZWdleHAgJy8oXnxccykoRU9bQS1aXXsxfXxFTkQpKFxzfCQpL2knCgpOYW1pbmcvSW5jbHVzaXZlTGFuZ3VhZ2U6CiAgRGVzY3JpcHRpb246ICdSZWNvbW1lbmQgdGhlIHVzZSBvZiBpbmNsdXNpdmUgbGFuZ3VhZ2UgaW5zdGVhZCBvZiBwcm9ibGVtYXRpYyB0ZXJtcy4nCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjE4JwogIFZlcnNpb25DaGFuZ2VkOiAnMS40OScKICBDaGVja0lkZW50aWZpZXJzOiB0cnVlCiAgQ2hlY2tDb25zdGFudHM6IHRydWUKICBDaGVja1ZhcmlhYmxlczogdHJ1ZQogIENoZWNrU3RyaW5nczogZmFsc2UKICBDaGVja1N5bWJvbHM6IHRydWUKICBDaGVja0NvbW1lbnRzOiB0cnVlCiAgQ2hlY2tGaWxlcGF0aHM6IHRydWUKICBGbGFnZ2VkVGVybXM6CiAgICB3aGl0ZWxpc3Q6CiAgICAgIFJlZ2V4OiAhcnVieS9yZWdleHAgJy93aGl0ZVstX1xzXT9saXN0LycKICAgICAgU3VnZ2VzdGlvbnM6CiAgICAgICAgLSBhbGxvd2xpc3QKICAgICAgICAtIHBlcm1pdAogICAgYmxhY2tsaXN0OgogICAgICBSZWdleDogIXJ1YnkvcmVnZXhwICcvYmxhY2tbLV9cc10/bGlzdC8nCiAgICAgIFN1Z2dlc3Rpb25zOgogICAgICAgIC0gZGVueWxpc3QKICAgICAgICAtIGJsb2NrCiAgICBzbGF2ZToKICAgICAgV2hvbGVXb3JkOiB0cnVlCiAgICAgIFN1Z2dlc3Rpb25zOiBbJ3JlcGxpY2EnLCAnc2Vjb25kYXJ5JywgJ2ZvbGxvd2VyJ10KCk5hbWluZy9NZW1vaXplZEluc3RhbmNlVmFyaWFibGVOYW1lOgogIERlc2NyaXB0aW9uOiA+LQogICAgTWVtb2l6ZWQgbWV0aG9kIG5hbWUgc2hvdWxkIG1hdGNoIG1lbW8gaW5zdGFuY2UgdmFyaWFibGUgbmFtZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKICBWZXJzaW9uQ2hhbmdlZDogJzEuMicKICBFbmZvcmNlZFN0eWxlRm9yTGVhZGluZ1VuZGVyc2NvcmVzOiBkaXNhbGxvd2VkCiAgU3VwcG9ydGVkU3R5bGVzRm9yTGVhZGluZ1VuZGVyc2NvcmVzOgogICAgLSBkaXNhbGxvd2VkCiAgICAtIHJlcXVpcmVkCiAgICAtIG9wdGlvbmFsCiAgU2FmZTogZmFsc2UKCk5hbWluZy9NZXRob2ROYW1lOgogIERlc2NyaXB0aW9uOiAnVXNlIHRoZSBjb25maWd1cmVkIHN0eWxlIHdoZW4gbmFtaW5nIG1ldGhvZHMuJwogIFN0eWxlR3VpZGU6ICcjc25ha2UtY2FzZS1zeW1ib2xzLW1ldGhvZHMtdmFycycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKICBFbmZvcmNlZFN0eWxlOiBzbmFrZV9jYXNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBzbmFrZV9jYXNlCiAgICAtIGNhbWVsQ2FzZQogICMgTWV0aG9kIG5hbWVzIG1hdGNoaW5nIHBhdHRlcm5zIGFyZSBhbHdheXMgYWxsb3dlZC4KICAjCiAgIyAgIEFsbG93ZWRQYXR0ZXJuczoKICAjICAgICAtICdcQVxzKm9uU2VsZWN0aW9uQnVsa0NoYW5nZVxzKicKICAjICAgICAtICdcQVxzKm9uU2VsZWN0aW9uQ2xlYXJlZFxzKicKICAjCiAgQWxsb3dlZFBhdHRlcm5zOiBbXQoKTmFtaW5nL01ldGhvZFBhcmFtZXRlck5hbWU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBtZXRob2QgcGFyYW1ldGVyIG5hbWVzIHRoYXQgY29udGFpbiBjYXBpdGFsIGxldHRlcnMsCiAgICAgICAgICAgICAgICAgZW5kIGluIG51bWJlcnMsIG9yIGRvIG5vdCBtZWV0IGEgbWluaW1hbCBsZW5ndGguCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwogICMgUGFyYW1ldGVyIG5hbWVzIG1heSBiZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZQogIE1pbk5hbWVMZW5ndGg6IDMKICBBbGxvd05hbWVzRW5kaW5nSW5OdW1iZXJzOiB0cnVlCiAgIyBBbGxvd2VkIG5hbWVzIHRoYXQgd2lsbCBub3QgcmVnaXN0ZXIgYW4gb2ZmZW5zZQogIEFsbG93ZWROYW1lczoKICAgIC0gYXMKICAgIC0gYXQKICAgIC0gYnkKICAgIC0gY2MKICAgIC0gZGIKICAgIC0gaWQKICAgIC0gaWYKICAgIC0gaW4KICAgIC0gaW8KICAgIC0gaXAKICAgIC0gb2YKICAgIC0gJ29uJwogICAgLSBvcwogICAgLSBwcAogICAgLSB0bwogICMgRm9yYmlkZGVuIG5hbWVzIHRoYXQgd2lsbCByZWdpc3RlciBhbiBvZmZlbnNlCiAgRm9yYmlkZGVuTmFtZXM6IFtdCgpOYW1pbmcvUHJlZGljYXRlTmFtZToKICBEZXNjcmlwdGlvbjogJ0NoZWNrIHRoZSBuYW1lcyBvZiBwcmVkaWNhdGUgbWV0aG9kcy4nCiAgU3R5bGVHdWlkZTogJyNib29sLW1ldGhvZHMtcW1hcmsnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc3JwogICMgUHJlZGljYXRlIG5hbWUgcHJlZml4ZXMuCiAgTmFtZVByZWZpeDoKICAgIC0gaXNfCiAgICAtIGhhc18KICAgIC0gaGF2ZV8KICAjIFByZWRpY2F0ZSBuYW1lIHByZWZpeGVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuCiAgRm9yYmlkZGVuUHJlZml4ZXM6CiAgICAtIGlzXwogICAgLSBoYXNfCiAgICAtIGhhdmVfCiAgIyBQcmVkaWNhdGUgbmFtZXMgd2hpY2gsIGRlc3BpdGUgaGF2aW5nIGEgZm9yYmlkZGVuIHByZWZpeCwgb3Igbm8gYD9gLAogICMgc2hvdWxkIHN0aWxsIGJlIGFjY2VwdGVkCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIGlzX2E/CiAgIyBNZXRob2QgZGVmaW5pdGlvbiBtYWNyb3MgZm9yIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBtZXRob2RzLgogIE1ldGhvZERlZmluaXRpb25NYWNyb3M6CiAgICAtIGRlZmluZV9tZXRob2QKICAgIC0gZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QKICAjIEV4Y2x1ZGUgUnNwZWMgc3BlY3MgYmVjYXVzZSB0aGVyZSBpcyBhIHN0cm9uZyBjb252ZW50aW9uIHRvIHdyaXRlIHNwZWMKICAjIGhlbHBlcnMgaW4gdGhlIGZvcm0gb2YgYGhhdmVfc29tZXRoaW5nYCBvciBgYmVfc29tZXRoaW5nYC4KICBFeGNsdWRlOgogICAgLSAnc3BlYy8qKi8qJwoKTmFtaW5nL1Jlc2N1ZWRFeGNlcHRpb25zVmFyaWFibGVOYW1lOgogIERlc2NyaXB0aW9uOiAnVXNlIGNvbnNpc3RlbnQgcmVzY3VlZCBleGNlcHRpb25zIHZhcmlhYmxlcyBuYW1pbmcuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjY3JwogIFZlcnNpb25DaGFuZ2VkOiAnMC42OCcKICBQcmVmZXJyZWROYW1lOiBlCgpOYW1pbmcvVmFyaWFibGVOYW1lOgogIERlc2NyaXB0aW9uOiAnVXNlIHRoZSBjb25maWd1cmVkIHN0eWxlIHdoZW4gbmFtaW5nIHZhcmlhYmxlcy4nCiAgU3R5bGVHdWlkZTogJyNzbmFrZS1jYXNlLXN5bWJvbHMtbWV0aG9kcy12YXJzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS44JwogIEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNuYWtlX2Nhc2UKICAgIC0gY2FtZWxDYXNlCiAgQWxsb3dlZElkZW50aWZpZXJzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KCk5hbWluZy9WYXJpYWJsZU51bWJlcjoKICBEZXNjcmlwdGlvbjogJ1VzZSB0aGUgY29uZmlndXJlZCBzdHlsZSB3aGVuIG51bWJlcmluZyBzeW1ib2xzLCBtZXRob2RzIGFuZCB2YXJpYWJsZXMuJwogIFN0eWxlR3VpZGU6ICcjc25ha2UtY2FzZS1zeW1ib2xzLW1ldGhvZHMtdmFycy13aXRoLW51bWJlcnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjQnCiAgRW5mb3JjZWRTdHlsZTogbm9ybWFsY2FzZQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc25ha2VfY2FzZQogICAgLSBub3JtYWxjYXNlCiAgICAtIG5vbl9pbnRlZ2VyCiAgQ2hlY2tNZXRob2ROYW1lczogdHJ1ZQogIENoZWNrU3ltYm9sczogdHJ1ZQogIEFsbG93ZWRJZGVudGlmaWVyczoKICAgIC0gY2FwdHVyZTMgICAgICMgT3BlbjMuY2FwdHVyZTMKICAgIC0gaXNvODYwMSAgICAgICMgVGltZSNpc284NjAxCiAgICAtIHJmYzExMjNfZGF0ZSAjIENHSS5yZmMxMTIzX2RhdGUKICAgIC0gcmZjODIyICAgICAgICMgVGltZSNyZmM4MjIKICAgIC0gcmZjMjgyMiAgICAgICMgVGltZSNyZmMyODIyCiAgICAtIHJmYzMzMzkgICAgICAjIERhdGVUaW1lLnJmYzMzMzkKICAgIC0geDg2XzY0ICAgICAgICMgQWxsb3dlZCBieSBkZWZhdWx0IGFzIGFuIHVuZGVyc2NvcmUgc2VwYXJhdGVkIENQVSBhcmNoaXRlY3R1cmUgbmFtZQogIEFsbG93ZWRQYXR0ZXJuczogW10KCiMjIyMjIyMjIyMjIyMjIyMjIyMjIFNlY3VyaXR5ICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKU2VjdXJpdHkvQ29tcG91bmRIYXNoOgogIERlc2NyaXB0aW9uOiAnV2hlbiBvdmVyd3JpdGluZyBPYmplY3QjaGFzaCB0byBjb21iaW5lIHZhbHVlcywgcHJlZmVyIGRlbGVnYXRpbmcgdG8gQXJyYXkjaGFzaCBvdmVyIHdyaXRpbmcgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMjgnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjUxJwoKU2VjdXJpdHkvRXZhbDoKICBEZXNjcmlwdGlvbjogJ1RoZSB1c2Ugb2YgZXZhbCByZXByZXNlbnRzIGEgc2VyaW91cyBzZWN1cml0eSByaXNrLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40NycKClNlY3VyaXR5L0lvTWV0aG9kczoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgSU8ucmVhZGAsIGBJTy5iaW5yZWFkYCwgYElPLndyaXRlYCwgYElPLmJpbndyaXRlYCwKICAgICAgICAgICAgICAgICBgSU8uZm9yZWFjaGAsIGFuZCBgSU8ucmVhZGxpbmVzYC4KICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjIyJwoKU2VjdXJpdHkvSlNPTkxvYWQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgUHJlZmVyIHVzYWdlIG9mIGBKU09OLnBhcnNlYCBvdmVyIGBKU09OLmxvYWRgIGR1ZSB0byBwb3RlbnRpYWwKICAgICAgICAgICAgICAgICBzZWN1cml0eSBpc3N1ZXMuIFNlZSByZWZlcmVuY2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAgUmVmZXJlbmNlOiAnaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvc3RkbGliLTIuNy4wL2xpYmRvYy9qc29uL3Jkb2MvSlNPTi5odG1sI21ldGhvZC1pLWxvYWQnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjIyJwogICMgQXV0b2NvcnJlY3QgaGVyZSB3aWxsIGNoYW5nZSB0byBhIG1ldGhvZCB0aGF0IG1heSBjYXVzZSBjcmFzaGVzIGRlcGVuZGluZwogICMgb24gdGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC4KICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCgpTZWN1cml0eS9NYXJzaGFsTG9hZDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBBdm9pZCB1c2luZyBvZiBgTWFyc2hhbC5sb2FkYCBvciBgTWFyc2hhbC5yZXN0b3JlYCBkdWUgdG8gcG90ZW50aWFsCiAgICAgICAgICAgICAgICAgc2VjdXJpdHkgaXNzdWVzLiBTZWUgcmVmZXJlbmNlIGZvciBtb3JlIGluZm9ybWF0aW9uLgogIFJlZmVyZW5jZTogJ2h0dHBzOi8vcnVieS1kb2Mub3JnL2NvcmUtMi43LjAvTWFyc2hhbC5odG1sI21vZHVsZS1NYXJzaGFsLWxhYmVsLVNlY3VyaXR5K2NvbnNpZGVyYXRpb25zJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ3JwoKU2VjdXJpdHkvT3BlbjoKICBEZXNjcmlwdGlvbjogJ1RoZSB1c2Ugb2YgYEtlcm5lbCNvcGVuYCBhbmQgYFVSSS5vcGVuYCByZXByZXNlbnQgYSBzZXJpb3VzIHNlY3VyaXR5IHJpc2suJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUzJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4wJwogIFNhZmU6IGZhbHNlCgpTZWN1cml0eS9ZQU1MTG9hZDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBQcmVmZXIgdXNhZ2Ugb2YgYFlBTUwuc2FmZV9sb2FkYCBvdmVyIGBZQU1MLmxvYWRgIGR1ZSB0byBwb3RlbnRpYWwKICAgICAgICAgICAgICAgICBzZWN1cml0eSBpc3N1ZXMuIFNlZSByZWZlcmVuY2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAgUmVmZXJlbmNlOiAnaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvc3RkbGliLTIuNy4wL2xpYmRvYy95YW1sL3Jkb2MvWUFNTC5odG1sI21vZHVsZS1ZQU1MLWxhYmVsLVNlY3VyaXR5JwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ3JwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIFN0eWxlICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKClN0eWxlL0FjY2Vzc01vZGlmaWVyRGVjbGFyYXRpb25zOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHN0eWxlIG9mIGhvdyBhY2Nlc3MgbW9kaWZpZXJzIGFyZSB1c2VkLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41NycKICBWZXJzaW9uQ2hhbmdlZDogJzAuODEnCiAgRW5mb3JjZWRTdHlsZTogZ3JvdXAKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGlubGluZQogICAgLSBncm91cAogIEFsbG93TW9kaWZpZXJzT25TeW1ib2xzOiB0cnVlCiAgQWxsb3dNb2RpZmllcnNPbkF0dHJzOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQoKU3R5bGUvQWNjZXNzb3JHcm91cGluZzoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgZ3JvdXBpbmcgb2YgYWNjZXNzb3JzIGluIGBjbGFzc2AgYW5kIGBtb2R1bGVgIGJvZGllcy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODcnCiAgRW5mb3JjZWRTdHlsZTogZ3JvdXBlZAogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgc2VwYXJhdGVkOiBlYWNoIGFjY2Vzc29yIGdvZXMgaW4gYSBzZXBhcmF0ZSBzdGF0ZW1lbnQuCiAgICAjIGdyb3VwZWQ6IGFjY2Vzc29ycyBhcmUgZ3JvdXBlZCBpbnRvIGEgc2luZ2xlIHN0YXRlbWVudC4KICAgIC0gc2VwYXJhdGVkCiAgICAtIGdyb3VwZWQKClN0eWxlL0FsaWFzOgogIERlc2NyaXB0aW9uOiAnVXNlIGFsaWFzIGluc3RlYWQgb2YgYWxpYXNfbWV0aG9kLicKICBTdHlsZUd1aWRlOiAnI2FsaWFzLW1ldGhvZC1sZXhpY2FsbHknCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzYnCiAgRW5mb3JjZWRTdHlsZTogcHJlZmVyX2FsaWFzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBwcmVmZXJfYWxpYXMKICAgIC0gcHJlZmVyX2FsaWFzX21ldGhvZAoKU3R5bGUvQW5kT3I6CiAgRGVzY3JpcHRpb246ICdVc2UgJiYvfHwgaW5zdGVhZCBvZiBhbmQvb3IuJwogIFN0eWxlR3VpZGU6ICcjbm8tYW5kLW9yLW9yJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yMScKICAjIFdoZXRoZXIgYGFuZGAgYW5kIGBvcmAgYXJlIGJhbm5lZCBvbmx5IGluIGNvbmRpdGlvbmFscyAoY29uZGl0aW9uYWxzKQogICMgb3IgY29tcGxldGVseSAoYWx3YXlzKS4KICBFbmZvcmNlZFN0eWxlOiBjb25kaXRpb25hbHMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGFsd2F5cwogICAgLSBjb25kaXRpb25hbHMKClN0eWxlL0FyZ3VtZW50c0ZvcndhcmRpbmc6CiAgRGVzY3JpcHRpb246ICdVc2UgYXJndW1lbnRzIGZvcndhcmRpbmcuJwogIFN0eWxlR3VpZGU6ICcjYXJndW1lbnRzLWZvcndhcmRpbmcnCiAgRW5hYmxlZDogcGVuZGluZwogIEFsbG93T25seVJlc3RBcmd1bWVudDogdHJ1ZQogIFVzZUFub255bW91c0ZvcndhcmRpbmc6IHRydWUKICBSZWR1bmRhbnRSZXN0QXJndW1lbnROYW1lczoKICAgIC0gYXJncwogICAgLSBhcmd1bWVudHMKICBSZWR1bmRhbnRLZXl3b3JkUmVzdEFyZ3VtZW50TmFtZXM6CiAgICAtIGt3YXJncwogICAgLSBvcHRpb25zCiAgICAtIG9wdHMKICBSZWR1bmRhbnRCbG9ja0FyZ3VtZW50TmFtZXM6CiAgICAtIGJsawogICAgLSBibG9jawogICAgLSBwcm9jCiAgVmVyc2lvbkFkZGVkOiAnMS4xJwogIFZlcnNpb25DaGFuZ2VkOiAnMS41OCcKClN0eWxlL0FycmF5Q29lcmNpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIFVzZSBBcnJheSgpIGluc3RlYWQgb2YgZXhwbGljaXQgQXJyYXkgY2hlY2sgb3IgWyp2YXJdLCB3aGVuIGRlYWxpbmcKICAgICAgICAgICAgICAgICAgd2l0aCBhIHZhcmlhYmxlIHlvdSB3YW50IHRvIHRyZWF0IGFzIGFuIEFycmF5LCBidXQgeW91J3JlIG5vdCBjZXJ0YWluIGl0J3MgYW4gYXJyYXkuCiAgU3R5bGVHdWlkZTogJyNhcnJheS1jb2VyY2lvbicKICBTYWZlOiBmYWxzZQogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44OCcKClN0eWxlL0FycmF5Rmlyc3RMYXN0OgogIERlc2NyaXB0aW9uOiAnVXNlIGBhcnIuZmlyc3RgIGFuZCBgYXJyLmxhc3RgIGluc3RlYWQgb2YgYGFyclswXWAgYW5kIGBhcnJbLTFdYC4nCiAgUmVmZXJlbmNlOiAnI2ZpcnN0LWFuZC1sYXN0JwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS41OCcKICBTYWZlOiBmYWxzZQoKU3R5bGUvQXJyYXlJbnRlcnNlY3Q6CiAgRGVzY3JpcHRpb246ICdVc2UgYGFycmF5MS5pbnRlcnNlY3Q/KGFycmF5MilgIGluc3RlYWQgb2YgYChhcnJheTEgJiBhcnJheTIpLmFueT9gLicKICBFbmFibGVkOiAncGVuZGluZycKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuNDAnCgpTdHlsZS9BcnJheUpvaW46CiAgRGVzY3JpcHRpb246ICdVc2UgQXJyYXkjam9pbiBpbnN0ZWFkIG9mIEFycmF5IyouJwogIFN0eWxlR3VpZGU6ICcjYXJyYXktam9pbicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yMCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzEnCgpTdHlsZS9Bc2NpaUNvbW1lbnRzOgogIERlc2NyaXB0aW9uOiAnVXNlIG9ubHkgYXNjaWkgc3ltYm9scyBpbiBjb21tZW50cy4nCiAgU3R5bGVHdWlkZTogJyNlbmdsaXNoLWNvbW1lbnRzJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yMScKICBBbGxvd2VkQ2hhcnM6CiAgICAtIMKpCgpTdHlsZS9BdHRyOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2VzIG9mIE1vZHVsZSNhdHRyLicKICBTdHlsZUd1aWRlOiAnI2F0dHInCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMTInCgpTdHlsZS9BdXRvUmVzb3VyY2VDbGVhbnVwOgogIERlc2NyaXB0aW9uOiAnU3VnZ2VzdHMgdGhlIHVzYWdlIG9mIGFuIGF1dG8gcmVzb3VyY2UgY2xlYW51cCB2ZXJzaW9uIG9mIGEgbWV0aG9kIChpZiBhdmFpbGFibGUpLicKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMzAnCgpTdHlsZS9CYXJlUGVyY2VudExpdGVyYWxzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGlmIHVzYWdlIG9mICUoKSBvciAlUSgpIG1hdGNoZXMgY29uZmlndXJhdGlvbi4nCiAgU3R5bGVHdWlkZTogJyNwZXJjZW50LXEtc2hvcnRoYW5kJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjI1JwogIEVuZm9yY2VkU3R5bGU6IGJhcmVfcGVyY2VudAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gcGVyY2VudF9xCiAgICAtIGJhcmVfcGVyY2VudAoKU3R5bGUvQmVnaW5CbG9jazoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHRoZSB1c2Ugb2YgQkVHSU4gYmxvY2tzLicKICBTdHlsZUd1aWRlOiAnI25vLUJFR0lOLWJsb2NrcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwoKU3R5bGUvQmlzZWN0ZWRBdHRyQWNjZXNzb3I6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICBDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBgYXR0cl9yZWFkZXJgIGFuZCBgYXR0cl93cml0ZXJgCiAgICAgICAgICAgICAgICBmb3IgdGhlIHNhbWUgbWV0aG9kIGNhbiBiZSBjb21iaW5lZCBpbnRvIHNpbmdsZSBgYXR0cl9hY2Nlc3NvcmAuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODcnCgpTdHlsZS9CbG9ja0NvbW1lbnRzOgogIERlc2NyaXB0aW9uOiAnRG8gbm90IHVzZSBibG9jayBjb21tZW50cy4nCiAgU3R5bGVHdWlkZTogJyNuby1ibG9jay1jb21tZW50cycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yMycKClN0eWxlL0Jsb2NrRGVsaW1pdGVyczoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgIEF2b2lkIHVzaW5nIHsuLi59IGZvciBtdWx0aS1saW5lIGJsb2NrcyAobXVsdGlsaW5lIGNoYWluaW5nIGlzCiAgICAgICAgICAgICAgICBhbHdheXMgdWdseSkuCiAgICAgICAgICAgICAgICBQcmVmZXIgey4uLn0gb3ZlciBkby4uLmVuZCBmb3Igc2luZ2xlLWxpbmUgYmxvY2tzLgogIFN0eWxlR3VpZGU6ICcjc2luZ2xlLWxpbmUtYmxvY2tzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjMwJwogIFZlcnNpb25DaGFuZ2VkOiAnMC4zNScKICBFbmZvcmNlZFN0eWxlOiBsaW5lX2NvdW50X2Jhc2VkCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgIyBUaGUgYGxpbmVfY291bnRfYmFzZWRgIHN0eWxlIGVuZm9yY2VzIGJyYWNlcyBhcm91bmQgc2luZ2xlIGxpbmUgYmxvY2tzIGFuZAogICAgIyBkby4uZW5kIGFyb3VuZCBtdWx0aS1saW5lIGJsb2Nrcy4KICAgIC0gbGluZV9jb3VudF9iYXNlZAogICAgIyBUaGUgYHNlbWFudGljYCBzdHlsZSBlbmZvcmNlcyBicmFjZXMgYXJvdW5kIGZ1bmN0aW9uYWwgYmxvY2tzLCB3aGVyZSB0aGUKICAgICMgcHJpbWFyeSBwdXJwb3NlIG9mIHRoZSBibG9jayBpcyB0byByZXR1cm4gYSB2YWx1ZSBhbmQgZG8uLmVuZCBmb3IKICAgICMgbXVsdGktbGluZSBwcm9jZWR1cmFsIGJsb2Nrcywgd2hlcmUgdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGUgYmxvY2sgaXMKICAgICMgaXRzIHNpZGUtZWZmZWN0cy4gU2luZ2xlLWxpbmUgcHJvY2VkdXJhbCBibG9ja3MgbWF5IG9ubHkgdXNlIGRvLWVuZCwKICAgICMgdW5sZXNzIEFsbG93QnJhY2VzT25Qcm9jZWR1cmFsT25lTGluZXJzIGhhcyBhIHRydXRoeSB2YWx1ZSAoc2VlIGJlbG93KS4KICAgICMKICAgICMgVGhpcyBsb29rcyBhdCB0aGUgdXNhZ2Ugb2YgYSBibG9jaydzIG1ldGhvZCB0byBkZXRlcm1pbmUgaXRzIHR5cGUgKGUuZy4gaXMKICAgICMgdGhlIHJlc3VsdCBvZiBhIGBtYXBgIGFzc2lnbmVkIHRvIGEgdmFyaWFibGUgb3IgcGFzc2VkIHRvIGFub3RoZXIKICAgICMgbWV0aG9kKSBidXQgZXhjZXB0aW9ucyBhcmUgcGVybWl0dGVkIGluIHRoZSBgUHJvY2VkdXJhbE1ldGhvZHNgLAogICAgIyBgRnVuY3Rpb25hbE1ldGhvZHNgIGFuZCBgQWxsb3dlZE1ldGhvZHNgIHNlY3Rpb25zIGJlbG93LgogICAgLSBzZW1hbnRpYwogICAgIyBUaGUgYGJyYWNlc19mb3JfY2hhaW5pbmdgIHN0eWxlIGVuZm9yY2VzIGJyYWNlcyBhcm91bmQgc2luZ2xlIGxpbmUgYmxvY2tzCiAgICAjIGFuZCBkby4uZW5kIGFyb3VuZCBtdWx0aS1saW5lIGJsb2NrcywgZXhjZXB0IGZvciBtdWx0aS1saW5lIGJsb2NrcyB3aG9zZQogICAgIyByZXR1cm4gdmFsdWUgaXMgYmVpbmcgY2hhaW5lZCB3aXRoIGFub3RoZXIgbWV0aG9kIChpbiB3aGljaCBjYXNlIGJyYWNlcwogICAgIyBhcmUgZW5mb3JjZWQpLgogICAgLSBicmFjZXNfZm9yX2NoYWluaW5nCiAgICAjIFRoZSBgYWx3YXlzX2JyYWNlc2Agc3R5bGUgYWx3YXlzIGVuZm9yY2VzIGJyYWNlcy4KICAgIC0gYWx3YXlzX2JyYWNlcwogIFByb2NlZHVyYWxNZXRob2RzOgogICAgIyBNZXRob2RzIHRoYXQgYXJlIGtub3duIHRvIGJlIHByb2NlZHVyYWwgaW4gbmF0dXJlIGJ1dCBsb29rIGZ1bmN0aW9uYWwgZnJvbQogICAgIyB0aGVpciB1c2FnZSwgZS5nLgogICAgIwogICAgIyAgIHRpbWUgPSBCZW5jaG1hcmsucmVhbHRpbWUgZG8KICAgICMgICAgIGZvby5iYXIKICAgICMgICBlbmQKICAgICMKICAgICMgSGVyZSwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYmxvY2sgaXMgZGlzY2FyZGVkIGJ1dCB0aGUgcmV0dXJuIHZhbHVlIG9mCiAgICAjIGBCZW5jaG1hcmsucmVhbHRpbWVgIGlzIHVzZWQuCiAgICAtIGJlbmNobWFyawogICAgLSBibQogICAgLSBibWJtCiAgICAtIGNyZWF0ZQogICAgLSBlYWNoX3dpdGhfb2JqZWN0CiAgICAtIG1lYXN1cmUKICAgIC0gbmV3CiAgICAtIHJlYWx0aW1lCiAgICAtIHRhcAogICAgLSB3aXRoX29iamVjdAogIEZ1bmN0aW9uYWxNZXRob2RzOgogICAgIyBNZXRob2RzIHRoYXQgYXJlIGtub3duIHRvIGJlIGZ1bmN0aW9uYWwgaW4gbmF0dXJlIGJ1dCBsb29rIHByb2NlZHVyYWwgZnJvbQogICAgIyB0aGVpciB1c2FnZSwgZS5nLgogICAgIwogICAgIyAgIGxldCg6Zm9vKSB7IEZvby5uZXcgfQogICAgIwogICAgIyBIZXJlLCB0aGUgcmV0dXJuIHZhbHVlIG9mIGBGb28ubmV3YCBpcyB1c2VkIHRvIGRlZmluZSBhIGBmb29gIGhlbHBlciBidXQKICAgICMgZG9lc24ndCBhcHBlYXIgdG8gYmUgdXNlZCBmcm9tIHRoZSByZXR1cm4gdmFsdWUgb2YgYGxldGAuCiAgICAtIGxldAogICAgLSBsZXQhCiAgICAtIHN1YmplY3QKICAgIC0gd2F0Y2gKICBBbGxvd2VkTWV0aG9kczoKICAgICMgTWV0aG9kcyB0aGF0IGNhbiBiZSBlaXRoZXIgcHJvY2VkdXJhbCBvciBmdW5jdGlvbmFsIGFuZCBjYW5ub3QgYmUKICAgICMgY2F0ZWdvcmlzZWQgZnJvbSB0aGVpciB1c2FnZSBhbG9uZSwgZS5nLgogICAgIwogICAgIyAgIGZvbyA9IGxhbWJkYSBkbyB8eHwKICAgICMgICAgIHB1dHMgIkhlbGxvLCAje3h9IgogICAgIyAgIGVuZAogICAgIwogICAgIyAgIGZvbyA9IGxhbWJkYSBkbyB8eHwKICAgICMgICAgIHggKiAxMDAKICAgICMgICBlbmQKICAgICMKICAgICMgSGVyZSwgaXQgaXMgaW1wb3NzaWJsZSB0byB0ZWxsIGZyb20gdGhlIHJldHVybiB2YWx1ZSBvZiBgbGFtYmRhYCB3aGV0aGVyCiAgICAjIHRoZSBpbm5lciBibG9jaydzIHJldHVybiB2YWx1ZSBpcyBzaWduaWZpY2FudC4KICAgIC0gbGFtYmRhCiAgICAtIHByb2MKICAgIC0gaXQKICBBbGxvd2VkUGF0dGVybnM6IFtdCiAgIyBUaGUgQWxsb3dCcmFjZXNPblByb2NlZHVyYWxPbmVMaW5lcnMgb3B0aW9uIGlzIGlnbm9yZWQgdW5sZXNzIHRoZQogICMgRW5mb3JjZWRTdHlsZSBpcyBzZXQgdG8gYHNlbWFudGljYC4gSWYgc286CiAgIwogICMgSWYgQWxsb3dCcmFjZXNPblByb2NlZHVyYWxPbmVMaW5lcnMgaXMgdW5zcGVjaWZpZWQsIG9yIHNldCB0byBhbnkKICAjIGZhbHNleSB2YWx1ZSwgdGhlbiBzZW1hbnRpYyBwdXJpdHkgaXMgbWFpbnRhaW5lZCwgc28gb25lLWxpbmUKICAjIHByb2NlZHVyYWwgYmxvY2tzIG11c3QgdXNlIGRvLWVuZCwgbm90IGJyYWNlcy4KICAjCiAgIyAgICMgYmFkCiAgIyAgIGNvbGxlY3Rpb24uZWFjaCB7IHxlbGVtZW50fCBwdXRzIGVsZW1lbnQgfQogICMKICAjICAgIyBnb29kCiAgIyAgIGNvbGxlY3Rpb24uZWFjaCBkbyB8ZWxlbWVudHwgcHV0cyBlbGVtZW50IGVuZAogICMKICAjIElmIEFsbG93QnJhY2VzT25Qcm9jZWR1cmFsT25lTGluZXJzIGlzIHNldCB0byBhbnkgdHJ1dGh5IHZhbHVlLAogICMgdGhlbiBvbmUtbGluZSBwcm9jZWR1cmFsIGJsb2NrcyBtYXkgdXNlIGVpdGhlciBzdHlsZS4KICAjCiAgIyAgICMgZ29vZAogICMgICBjb2xsZWN0aW9uLmVhY2ggeyB8ZWxlbWVudHwgcHV0cyBlbGVtZW50IH0KICAjCiAgIyAgICMgYWxzbyBnb29kCiAgIyAgIGNvbGxlY3Rpb24uZWFjaCBkbyB8ZWxlbWVudHwgcHV0cyBlbGVtZW50IGVuZAogIEFsbG93QnJhY2VzT25Qcm9jZWR1cmFsT25lTGluZXJzOiBmYWxzZQogICMgVGhlIEJyYWNlc1JlcXVpcmVkTWV0aG9kcyBvdmVycmlkZXMgYWxsIG90aGVyIGNvbmZpZ3VyYXRpb25zIGV4Y2VwdAogICMgQWxsb3dlZE1ldGhvZHMuIEl0IGNhbiBiZSB1c2VkIHRvIGVuZm9yY2UgdGhhdCBhbGwgYmxvY2tzIGZvciBzcGVjaWZpYwogICMgbWV0aG9kcyB1c2UgYnJhY2VzLiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgdGhpcyB0byBlbmZvcmNlIFNvcmJldAogICMgc2lnbmF0dXJlcyB1c2UgYnJhY2VzIGV2ZW4gd2hlbiB0aGUgcmVzdCBvZiB5b3VyIGNvZGViYXNlIGVuZm9yY2VzCiAgIyB0aGUgYGxpbmVfY291bnRfYmFzZWRgIHN0eWxlLgogIEJyYWNlc1JlcXVpcmVkTWV0aG9kczogW10KClN0eWxlL0Nhc2VFcXVhbGl0eToKICBEZXNjcmlwdGlvbjogJ0F2b2lkIGV4cGxpY2l0IHVzZSBvZiB0aGUgY2FzZSBlcXVhbGl0eSBvcGVyYXRvcig9PT0pLicKICBTdHlsZUd1aWRlOiAnI25vLWNhc2UtZXF1YWxpdHknCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODknCiAgIyBJZiBgQWxsb3dPbkNvbnN0YW50YCBvcHRpb24gaXMgZW5hYmxlZCwgdGhlIGNvcCB3aWxsIGlnbm9yZSB2aW9sYXRpb25zIHdoZW4gdGhlIHJlY2VpdmVyIG9mCiAgIyB0aGUgY2FzZSBlcXVhbGl0eSBvcGVyYXRvciBpcyBhIGNvbnN0YW50LgogICMKICAjICAgIyBiYWQKICAjICAgL3N0cmluZy8gPT09ICJzdHJpbmciCiAgIwogICMgICAjIGdvb2QKICAjICAgU3RyaW5nID09PSAic3RyaW5nIgogIEFsbG93T25Db25zdGFudDogZmFsc2UKICAjIElmIGBBbGxvd09uU2VsZkNsYXNzYCBvcHRpb24gaXMgZW5hYmxlZCwgdGhlIGNvcCB3aWxsIGlnbm9yZSB2aW9sYXRpb25zIHdoZW4gdGhlIHJlY2VpdmVyIG9mCiAgIyB0aGUgY2FzZSBlcXVhbGl0eSBvcGVyYXRvciBpcyBgc2VsZi5jbGFzc2AuCiAgIwogICMgICAjIGJhZAogICMgICBzb21lX2NsYXNzID09PSBvYmplY3QKICAjCiAgIyAgICMgZ29vZAogICMgICBzZWxmLmNsYXNzID09PSBvYmplY3QKICBBbGxvd09uU2VsZkNsYXNzOiBmYWxzZQoKU3R5bGUvQ2FzZUxpa2VJZjoKICBEZXNjcmlwdGlvbjogJ0lkZW50aWZpZXMgcGxhY2VzIHdoZXJlIGBpZi1lbHNpZmAgY29uc3RydWN0aW9ucyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgY2FzZS13aGVuYC4nCiAgU3R5bGVHdWlkZTogJyNjYXNlLXZzLWlmLWVsc2UnCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44OCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNDgnCiAgIyBgTWluQnJhbmNoZXNDb3VudGAgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGJyYW5jaGVzIGBpZmAgbmVlZHMgdG8gaGF2ZSB0byB0cmlnZ2VyIHRoaXMgY29wLgogIE1pbkJyYW5jaGVzQ291bnQ6IDMKClN0eWxlL0NoYXJhY3RlckxpdGVyYWw6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzZXMgb2YgY2hhcmFjdGVyIGxpdGVyYWxzLicKICBTdHlsZUd1aWRlOiAnI25vLWNoYXJhY3Rlci1saXRlcmFscycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwoKU3R5bGUvQ2xhc3NBbmRNb2R1bGVDaGlsZHJlbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBzdHlsZSBvZiBjaGlsZHJlbiBjbGFzc2VzIGFuZCBtb2R1bGVzLicKICBTdHlsZUd1aWRlOiAnI25hbWVzcGFjZS1kZWZpbml0aW9uJwogICMgTW92aW5nIGZyb20gY29tcGFjdCB0byBuZXN0ZWQgY2hpbGRyZW4gcmVxdWlyZXMga25vd2xlZGdlIG9mIHdoZXRoZXIgdGhlCiAgIyBvdXRlciBwYXJlbnQgaXMgYSBtb2R1bGUgb3IgYSBjbGFzcy4gTW92aW5nIGZyb20gbmVzdGVkIHRvIGNvbXBhY3QgcmVxdWlyZXMKICAjIHZlcmlmaWNhdGlvbiB0aGF0IHRoZSBvdXRlciBwYXJlbnQgaXMgZGVmaW5lZCBlbHNld2hlcmUuIFJ1Ym9Db3AgZG9lcyBub3QKICAjIGhhdmUgdGhlIGtub3dsZWRnZSB0byBwZXJmb3JtIGVpdGhlciBvcGVyYXRpb24gc2FmZWx5IGFuZCB0aHVzIHJlcXVpcmVzCiAgIyBtYW51YWwgb3ZlcnNpZ2h0LgogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xOScKICAjCiAgIyBCYXNpY2FsbHkgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgc3R5bGVzOgogICMKICAjIGBuZXN0ZWRgIC0gaGF2ZSBlYWNoIGNoaWxkIG9uIGEgc2VwYXJhdGUgbGluZQogICMgICBjbGFzcyBGb28KICAjICAgICBjbGFzcyBCYXIKICAjICAgICBlbmQKICAjICAgZW5kCiAgIwogICMgYGNvbXBhY3RgIC0gY29tYmluZSBkZWZpbml0aW9ucyBhcyBtdWNoIGFzIHBvc3NpYmxlCiAgIyAgIGNsYXNzIEZvbzo6QmFyCiAgIyAgIGVuZAogICMKICAjIFRoZSBjb21wYWN0IHN0eWxlIGlzIG9ubHkgZm9yY2VkLCBmb3IgY2xhc3NlcyBvciBtb2R1bGVzIHdpdGggb25lIGNoaWxkLgogIEVuZm9yY2VkU3R5bGU6IG5lc3RlZAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gbmVzdGVkCiAgICAtIGNvbXBhY3QKClN0eWxlL0NsYXNzQ2hlY2s6CiAgRGVzY3JpcHRpb246ICdFbmZvcmNlcyBjb25zaXN0ZW50IHVzZSBvZiBgT2JqZWN0I2lzX2E/YCBvciBgT2JqZWN0I2tpbmRfb2Y/YC4nCiAgU3R5bGVHdWlkZTogJyNpcy1hLXZzLWtpbmQtb2YnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjQnCiAgRW5mb3JjZWRTdHlsZTogaXNfYT8KICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGlzX2E/CiAgICAtIGtpbmRfb2Y/CgpTdHlsZS9DbGFzc0VxdWFsaXR5Q29tcGFyaXNvbjoKICBEZXNjcmlwdGlvbjogJ0VuZm9yY2VzIHRoZSB1c2Ugb2YgYE9iamVjdCNpbnN0YW5jZV9vZj9gIGluc3RlYWQgb2YgY2xhc3MgY29tcGFyaXNvbiBmb3IgZXF1YWxpdHkuJwogIFN0eWxlR3VpZGU6ICcjaW5zdGFuY2Utb2YtdnMtY2xhc3MtY29tcGFyaXNvbicKICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuOTMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjU3JwogIEFsbG93ZWRNZXRob2RzOgogICAgLSA9PQogICAgLSBlcXVhbD8KICAgIC0gZXFsPwogIEFsbG93ZWRQYXR0ZXJuczogW10KClN0eWxlL0NsYXNzTWV0aG9kczoKICBEZXNjcmlwdGlvbjogJ1VzZSBzZWxmIHdoZW4gZGVmaW5pbmcgbW9kdWxlL2NsYXNzIG1ldGhvZHMuJwogIFN0eWxlR3VpZGU6ICcjZGVmLXNlbGYtY2xhc3MtbWV0aG9kcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yMCcKClN0eWxlL0NsYXNzTWV0aG9kc0RlZmluaXRpb25zOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgdXNpbmcgYGRlZiBzZWxmLm1ldGhvZF9uYW1lYCBvciBgY2xhc3MgPDwgc2VsZmAgdG8gZGVmaW5lIGNsYXNzIG1ldGhvZHMuJwogIFN0eWxlR3VpZGU6ICcjZGVmLXNlbGYtY2xhc3MtbWV0aG9kcycKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgRW5mb3JjZWRTdHlsZTogZGVmX3NlbGYKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGRlZl9zZWxmCiAgICAtIHNlbGZfY2xhc3MKClN0eWxlL0NsYXNzVmFyczoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHRoZSB1c2Ugb2YgY2xhc3MgdmFyaWFibGVzLicKICBTdHlsZUd1aWRlOiAnI25vLWNsYXNzLXZhcnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTMnCgpTdHlsZS9Db2xsZWN0aW9uQ29tcGFjdDoKICBEZXNjcmlwdGlvbjogJ1VzZSBge0FycmF5LEhhc2h9I3tjb21wYWN0LGNvbXBhY3QhfWAgaW5zdGVhZCBvZiBjdXN0b20gbG9naWMgdG8gcmVqZWN0IG5pbHMuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMicKICBWZXJzaW9uQ2hhbmdlZDogJzEuMycKICBBbGxvd2VkUmVjZWl2ZXJzOiBbXQoKIyBBbGlnbiB3aXRoIHRoZSBzdHlsZSBndWlkZS4KU3R5bGUvQ29sbGVjdGlvbk1ldGhvZHM6CiAgRGVzY3JpcHRpb246ICdQcmVmZXJyZWQgY29sbGVjdGlvbiBtZXRob2RzLicKICBTdHlsZUd1aWRlOiAnI21hcC1maW5kLXNlbGVjdC1yZWR1Y2UtaW5jbHVkZS1zaXplJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMS43JwogIFNhZmU6IGZhbHNlCiAgIyBNYXBwaW5nIGZyb20gdW5kZXNpcmVkIG1ldGhvZCB0byBkZXNpcmVkIG1ldGhvZAogICMgZS5nLiB0byB1c2UgYGRldGVjdGAgb3ZlciBgZmluZGA6CiAgIwogICMgU3R5bGUvQ29sbGVjdGlvbk1ldGhvZHM6CiAgIyAgIFByZWZlcnJlZE1ldGhvZHM6CiAgIyAgICAgZmluZDogZGV0ZWN0CiAgUHJlZmVycmVkTWV0aG9kczoKICAgIGNvbGxlY3Q6ICdtYXAnCiAgICBjb2xsZWN0ITogJ21hcCEnCiAgICBjb2xsZWN0X2NvbmNhdDogJ2ZsYXRfbWFwJwogICAgaW5qZWN0OiAncmVkdWNlJwogICAgZGV0ZWN0OiAnZmluZCcKICAgIGZpbmRfYWxsOiAnc2VsZWN0JwogICAgbWVtYmVyPzogJ2luY2x1ZGU/JwogICMgTWV0aG9kcyBpbiB0aGlzIGFycmF5IGFjY2VwdCBhIGZpbmFsIHN5bWJvbCBhcyBhbiBpbXBsaWNpdCBibG9jawogICMgZWcuIGBpbmplY3QoOispYAogIE1ldGhvZHNBY2NlcHRpbmdTeW1ib2w6CiAgICAtIGluamVjdAogICAgLSByZWR1Y2UKClN0eWxlL0NvbG9uTWV0aG9kQ2FsbDoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCB1c2UgOjogZm9yIG1ldGhvZCBjYWxsLicKICBTdHlsZUd1aWRlOiAnI2RvdWJsZS1jb2xvbnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKClN0eWxlL0NvbG9uTWV0aG9kRGVmaW5pdGlvbjoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCB1c2UgOjogZm9yIGRlZmluaW5nIGNsYXNzIG1ldGhvZHMuJwogIFN0eWxlR3VpZGU6ICcjY29sb24tbWV0aG9kLWRlZmluaXRpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCgpTdHlsZS9Db21iaW5hYmxlTG9vcHM6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIG11bHRpcGxlIGNvbnNlY3V0aXZlIGxvb3BzIG92ZXIgdGhlIHNhbWUgZGF0YQogICAgICAgICAgICAgICAgICBjYW4gYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBsb29wLgogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuOTAnCgpTdHlsZS9Db21tYW5kTGl0ZXJhbDoKICBEZXNjcmlwdGlvbjogJ1VzZSBgYCBvciAleCBhcm91bmQgY29tbWFuZCBsaXRlcmFscy4nCiAgU3R5bGVHdWlkZTogJyNwZXJjZW50LXgnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzAnCiAgRW5mb3JjZWRTdHlsZTogYmFja3RpY2tzCiAgIyBiYWNrdGlja3M6IEFsd2F5cyB1c2UgYmFja3RpY2tzLgogICMgcGVyY2VudF94OiBBbHdheXMgdXNlIGAleGAuCiAgIyBtaXhlZDogVXNlIGJhY2t0aWNrcyBvbiBzaW5nbGUtbGluZSBjb21tYW5kcywgYW5kIGAleGAgb24gbXVsdGktbGluZSBjb21tYW5kcy4KICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGJhY2t0aWNrcwogICAgLSBwZXJjZW50X3gKICAgIC0gbWl4ZWQKICAjIElmIGBmYWxzZWAsIHRoZSBjb3Agd2lsbCBhbHdheXMgcmVjb21tZW5kIHVzaW5nIGAleGAgaWYgb25lIG9yIG1vcmUgYmFja3RpY2tzCiAgIyBhcmUgZm91bmQgaW4gdGhlIGNvbW1hbmQgc3RyaW5nLgogIEFsbG93SW5uZXJCYWNrdGlja3M6IGZhbHNlCgojIENoZWNrcyBmb3JtYXR0aW5nIG9mIHNwZWNpYWwgY29tbWVudHMKU3R5bGUvQ29tbWVudEFubm90YXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvcm1hdHRpbmcgb2Ygc3BlY2lhbCBjb21tZW50cwogICAgICAgICAgICAgICAgIChUT0RPLCBGSVhNRSwgT1BUSU1JWkUsIEhBQ0ssIFJFVklFVywgTk9URSkuCiAgU3R5bGVHdWlkZTogJyNhbm5vdGF0ZS1rZXl3b3JkcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xMCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuMjAnCiAgS2V5d29yZHM6CiAgICAtIFRPRE8KICAgIC0gRklYTUUKICAgIC0gT1BUSU1JWkUKICAgIC0gSEFDSwogICAgLSBSRVZJRVcKICAgIC0gTk9URQogIFJlcXVpcmVDb2xvbjogdHJ1ZQoKU3R5bGUvQ29tbWVudGVkS2V5d29yZDoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCBwbGFjZSBjb21tZW50cyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNlcnRhaW4ga2V5d29yZHMuJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC41MScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMTknCgpTdHlsZS9Db21wYXJhYmxlQ2xhbXA6CiAgRGVzY3JpcHRpb246ICdFbmZvcmNlcyB0aGUgdXNlIG9mIGBDb21wYXJhYmxlI2NsYW1wYCBpbnN0ZWFkIG9mIGNvbXBhcmlzb24gYnkgbWluaW11bSBhbmQgbWF4aW11bS4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNDQnCgpTdHlsZS9Db25jYXRBcnJheUxpdGVyYWxzOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgdGhlIHVzZSBvZiBgQXJyYXkjcHVzaChpdGVtKWAgaW5zdGVhZCBvZiBgQXJyYXkjY29uY2F0KFtpdGVtXSlgIHRvIGF2b2lkIHJlZHVuZGFudCBhcnJheSBsaXRlcmFscy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40MScKClN0eWxlL0NvbmRpdGlvbmFsQXNzaWdubWVudDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBVc2UgdGhlIHJldHVybiB2YWx1ZSBvZiBgaWZgIGFuZCBgY2FzZWAgc3RhdGVtZW50cyBmb3IKICAgICAgICAgICAgICAgICBhc3NpZ25tZW50IHRvIGEgdmFyaWFibGUgYW5kIHZhcmlhYmxlIGNvbXBhcmlzb24gaW5zdGVhZAogICAgICAgICAgICAgICAgIG9mIGFzc2lnbmluZyB0aGF0IHZhcmlhYmxlIGluc2lkZSBvZiBlYWNoIGJyYW5jaC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNDcnCiAgRW5mb3JjZWRTdHlsZTogYXNzaWduX3RvX2NvbmRpdGlvbgogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gYXNzaWduX3RvX2NvbmRpdGlvbgogICAgLSBhc3NpZ25faW5zaWRlX2NvbmRpdGlvbgogICMgV2hlbiBjb25maWd1cmVkIHRvIGBhc3NpZ25fdG9fY29uZGl0aW9uYCwgYFNpbmdsZUxpbmVDb25kaXRpb25zT25seWAKICAjIHdpbGwgb25seSByZWdpc3RlciBhbiBvZmZlbnNlIHdoZW4gYWxsIGJyYW5jaGVzIG9mIGEgY29uZGl0aW9uIGFyZQogICMgYSBzaW5nbGUgbGluZS4KICAjIFdoZW4gY29uZmlndXJlZCB0byBgYXNzaWduX2luc2lkZV9jb25kaXRpb25gLCBgU2luZ2xlTGluZUNvbmRpdGlvbnNPbmx5YAogICMgd2lsbCBvbmx5IHJlZ2lzdGVyIGFuIG9mZmVuc2UgZm9yIGFzc2lnbm1lbnQgdG8gYSBjb25kaXRpb24gdGhhdCBoYXMKICAjIGF0IGxlYXN0IG9uZSBtdWx0aWxpbmUgYnJhbmNoLgogIFNpbmdsZUxpbmVDb25kaXRpb25zT25seTogdHJ1ZQogIEluY2x1ZGVUZXJuYXJ5RXhwcmVzc2lvbnM6IHRydWUKClN0eWxlL0NvbnN0YW50VmlzaWJpbGl0eToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVjayB0aGF0IGNsYXNzLSBhbmQgbW9kdWxlIGNvbnN0YW50cyBoYXZlCiAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSBkZWNsYXJhdGlvbnMuCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjY2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4xMCcKICBJZ25vcmVNb2R1bGVzOiBmYWxzZQoKIyBDaGVja3MgdGhhdCB5b3UgaGF2ZSBwdXQgYSBjb3B5cmlnaHQgaW4gYSBjb21tZW50IGJlZm9yZSBhbnkgY29kZS4KIwojIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgTm90aWNlIGluIHlvdXIgLnJ1Ym9jb3AueW1sIGZpbGUuCiMKIyBJbiBvcmRlciB0byB1c2UgYXV0b2NvcnJlY3QsIHlvdSBtdXN0IHN1cHBseSBhIHZhbHVlIGZvciB0aGUKIyBgQXV0b2NvcnJlY3ROb3RpY2VgIGtleSB0aGF0IG1hdGNoZXMgdGhlIHJlZ2V4cCBOb3RpY2UuIEEgYmxhbmsKIyBgQXV0b2NvcnJlY3ROb3RpY2VgIHdpbGwgY2F1c2UgYW4gZXJyb3IgZHVyaW5nIGF1dG9jb3JyZWN0LgojCiMgQXV0b2NvcnJlY3Qgd2lsbCBhZGQgYSBjb3B5cmlnaHQgbm90aWNlIGluIGEgY29tbWVudCBhdCB0aGUgdG9wCiMgb2YgdGhlIGZpbGUgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IHNoZWJhbmcgb3IgZW5jb2RpbmcgY29tbWVudHMuCiMKIyBFeGFtcGxlIHJ1Ym9jb3AueW1sOgojCiMgU3R5bGUvQ29weXJpZ2h0OgojICAgRW5hYmxlZDogdHJ1ZQojICAgTm90aWNlOiAnQ29weXJpZ2h0IChcKGNcKSApPzIwMTUgWWFob28hIEluYycKIyAgIEF1dG9jb3JyZWN0Tm90aWNlOiAnIyBDb3B5cmlnaHQgKGMpIDIwMTUgWWFob28hIEluYy4nCiMKU3R5bGUvQ29weXJpZ2h0OgogIERlc2NyaXB0aW9uOiAnSW5jbHVkZSBhIGNvcHlyaWdodCBub3RpY2UgaW4gZWFjaCBmaWxlIGJlZm9yZSBhbnkgY29kZS4nCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjMwJwogIE5vdGljZTogJ15Db3B5cmlnaHQgKFwoY1wpICk/MlswLTldezN9IC4rJwogIEF1dG9jb3JyZWN0Tm90aWNlOiAnJwoKU3R5bGUvRGF0YUluaGVyaXRhbmNlOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBpbmhlcml0YW5jZSBmcm9tIERhdGEuZGVmaW5lLicKICBTdHlsZUd1aWRlOiAnI25vLWV4dGVuZC1kYXRhLWRlZmluZScKICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjUxJwoKU3R5bGUvRGF0ZVRpbWU6CiAgRGVzY3JpcHRpb246ICdVc2UgVGltZSBvdmVyIERhdGVUaW1lLicKICBTdHlsZUd1aWRlOiAnI2RhdGUtdGltZScKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjkyJwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBBbGxvd0NvZXJjaW9uOiBmYWxzZQoKU3R5bGUvRGVmV2l0aFBhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnVXNlIGRlZiB3aXRoIHBhcmVudGhlc2VzIHdoZW4gdGhlcmUgYXJlIGFyZ3VtZW50cy4nCiAgU3R5bGVHdWlkZTogJyNtZXRob2QtcGFyZW5zJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjEyJwoKU3R5bGUvRGlyOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSB0aGUgYF9fZGlyX19gIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY2Fub25pY2FsaXplZAogICAgICAgICAgICAgICAgIGFic29sdXRlIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKClN0eWxlL0RpckVtcHR5OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFByZWZlciB0byB1c2UgYERpci5lbXB0eT8oJ3BhdGgvdG8vZGlyJylgIHdoZW4gY2hlY2tpbmcgaWYgYSBkaXJlY3RvcnkgaXMgZW1wdHkuCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNDgnCgpTdHlsZS9EaXNhYmxlQ29wc1dpdGhpblNvdXJjZUNvZGVEaXJlY3RpdmU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgRm9yYmlkcyBkaXNhYmxpbmcvZW5hYmxpbmcgY29wcyB3aXRoaW4gc291cmNlIGNvZGUuCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjgyJwogIFZlcnNpb25DaGFuZ2VkOiAnMS45JwogIEFsbG93ZWRDb3BzOiBbXQoKU3R5bGUvRG9jdW1lbnREeW5hbWljRXZhbERlZmluaXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIGBjbGFzc19ldmFsYCAob3Igb3RoZXIgYGV2YWxgKSB3aXRoIHN0cmluZyBpbnRlcnBvbGF0aW9uLAogICAgICAgICAgICAgICAgYWRkIGEgY29tbWVudCBibG9jayBzaG93aW5nIGl0cyBhcHBlYXJhbmNlIGlmIGludGVycG9sYXRlZC4KICBTdHlsZUd1aWRlOiAnI2V2YWwtY29tbWVudC1kb2NzJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjMnCgpTdHlsZS9Eb2N1bWVudGF0aW9uOgogIERlc2NyaXB0aW9uOiAnRG9jdW1lbnQgY2xhc3NlcyBhbmQgbm9uLW5hbWVzcGFjZSBtb2R1bGVzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIEFsbG93ZWRDb25zdGFudHM6IFtdCiAgRXhjbHVkZToKICAgIC0gJ3NwZWMvKiovKicKICAgIC0gJ3Rlc3QvKiovKicKClN0eWxlL0RvY3VtZW50YXRpb25NZXRob2Q6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIG1pc3NpbmcgZG9jdW1lbnRhdGlvbiBjb21tZW50IGZvciBwdWJsaWMgbWV0aG9kcy4nCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjQzJwogIEFsbG93ZWRNZXRob2RzOiBbXQogIEV4Y2x1ZGU6CiAgICAtICdzcGVjLyoqLyonCiAgICAtICd0ZXN0LyoqLyonCiAgUmVxdWlyZUZvck5vblB1YmxpY01ldGhvZHM6IGZhbHNlCgpTdHlsZS9Eb3VibGVDb3BEaXNhYmxlRGlyZWN0aXZlOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBkb3VibGUgcnVib2NvcDpkaXNhYmxlIGNvbW1lbnRzIG9uIGEgc2luZ2xlIGxpbmUuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjczJwoKU3R5bGUvRG91YmxlTmVnYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzZXMgb2YgZG91YmxlIG5lZ2F0aW9uICghISkuJwogIFN0eWxlR3VpZGU6ICcjbm8tYmFuZy1iYW5nJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjE5JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yJwogIEVuZm9yY2VkU3R5bGU6IGFsbG93ZWRfaW5fcmV0dXJucwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGFsbG93ZWRfaW5fcmV0dXJucwogICAgLSBmb3JiaWRkZW4KClN0eWxlL0VhY2hGb3JTaW1wbGVMb29wOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSBgSW50ZWdlciN0aW1lc2AgZm9yIGEgc2ltcGxlIGxvb3Agd2hpY2ggaXRlcmF0ZXMgYSBmaXhlZAogICAgICAgICAgICAgICAgIG51bWJlciBvZiB0aW1lcy4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40MScKClN0eWxlL0VhY2hXaXRoT2JqZWN0OgogIERlc2NyaXB0aW9uOiAnUHJlZmVyIGBlYWNoX3dpdGhfb2JqZWN0YCBvdmVyIGBpbmplY3RgIG9yIGByZWR1Y2VgLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yMicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNDInCgpTdHlsZS9FbXB0eUJsb2NrUGFyYW1ldGVyOgogIERlc2NyaXB0aW9uOiAnT21pdCBwaXBlcyBmb3IgZW1wdHkgYmxvY2sgcGFyYW1ldGVycy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCgpTdHlsZS9FbXB0eUNhc2VDb25kaXRpb246CiAgRGVzY3JpcHRpb246ICdBdm9pZCBlbXB0eSBjb25kaXRpb24gaW4gY2FzZSBzdGF0ZW1lbnRzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40MCcKClN0eWxlL0VtcHR5RWxzZToKICBEZXNjcmlwdGlvbjogJ0F2b2lkIGVtcHR5IGVsc2UtY2xhdXNlcy4nCiAgRW5hYmxlZDogdHJ1ZQogIEF1dG9Db3JyZWN0OiBjb250ZXh0dWFsCiAgVmVyc2lvbkFkZGVkOiAnMC4yOCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjEnCiAgRW5mb3JjZWRTdHlsZTogYm90aAogICMgZW1wdHkgLSB3YXJuIG9ubHkgb24gZW1wdHkgYGVsc2VgCiAgIyBuaWwgLSB3YXJuIG9uIGBlbHNlYCB3aXRoIG5pbCBpbiBpdAogICMgYm90aCAtIHdhcm4gb24gZW1wdHkgYGVsc2VgIGFuZCBgZWxzZWAgd2l0aCBgbmlsYCBpbiBpdAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gZW1wdHkKICAgIC0gbmlsCiAgICAtIGJvdGgKICBBbGxvd0NvbW1lbnRzOiBmYWxzZQoKU3R5bGUvRW1wdHlIZXJlZG9jOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2luZyBlbXB0eSBoZXJlZG9jIHRvIHJlZHVjZSByZWR1bmRhbmN5LicKICBFbmFibGVkOiBwZW5kaW5nCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcxLjMyJwogIFZlcnNpb25DaGFuZ2VkOiAnMS42MScKClN0eWxlL0VtcHR5TGFtYmRhUGFyYW1ldGVyOgogIERlc2NyaXB0aW9uOiAnT21pdCBwYXJlbnMgZm9yIGVtcHR5IGxhbWJkYSBwYXJhbWV0ZXJzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MicKClN0eWxlL0VtcHR5TGl0ZXJhbDoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBsaXRlcmFscyB0byBBcnJheS5uZXcvSGFzaC5uZXcvU3RyaW5nLm5ldy4nCiAgU3R5bGVHdWlkZTogJyNsaXRlcmFsLWFycmF5LWhhc2gnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMTInCgpTdHlsZS9FbXB0eU1ldGhvZDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB0aGUgZm9ybWF0dGluZyBvZiBlbXB0eSBtZXRob2QgZGVmaW5pdGlvbnMuJwogIFN0eWxlR3VpZGU6ICcjbm8tc2luZ2xlLWxpbmUtbWV0aG9kcycKICBFbmFibGVkOiB0cnVlCiAgQXV0b0NvcnJlY3Q6IGNvbnRleHR1YWwKICBWZXJzaW9uQWRkZWQ6ICcwLjQ2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS42MScKICBFbmZvcmNlZFN0eWxlOiBjb21wYWN0CiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBjb21wYWN0CiAgICAtIGV4cGFuZGVkCgpTdHlsZS9FbmNvZGluZzoKICBEZXNjcmlwdGlvbjogJ1VzZSBVVEYtOCBhcyB0aGUgc291cmNlIGZpbGUgZW5jb2RpbmcuJwogIFN0eWxlR3VpZGU6ICcjdXRmLTgnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNTAnCgpTdHlsZS9FbmRCbG9jazoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHRoZSB1c2Ugb2YgRU5EIGJsb2Nrcy4nCiAgU3R5bGVHdWlkZTogJyNuby1FTkQtYmxvY2tzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjgxJwoKU3R5bGUvRW5kbGVzc01ldGhvZDoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHRoZSB1c2Ugb2YgbXVsdGktbGluZWQgZW5kbGVzcyBtZXRob2QgZGVmaW5pdGlvbnMuJwogIFN0eWxlR3VpZGU6ICcjZW5kbGVzcy1tZXRob2RzJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjgnCiAgRW5mb3JjZWRTdHlsZTogYWxsb3dfc2luZ2xlX2xpbmUKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGFsbG93X3NpbmdsZV9saW5lCiAgICAtIGFsbG93X2Fsd2F5cwogICAgLSBkaXNhbGxvdwoKU3R5bGUvRW52SG9tZToKICBEZXNjcmlwdGlvbjogIkNoZWNrcyBmb3IgY29uc2lzdGVudCB1c2FnZSBvZiBgRU5WWydIT01FJ11gLiIKICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjI5JwoKU3R5bGUvRXZhbFdpdGhMb2NhdGlvbjoKICBEZXNjcmlwdGlvbjogJ1Bhc3MgYF9fRklMRV9fYCBhbmQgYF9fTElORV9fYCB0byBgZXZhbGAgbWV0aG9kLCBhcyB0aGV5IGFyZSB1c2VkIGJ5IGJhY2t0cmFjZXMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwoKU3R5bGUvRXZlbk9kZDoKICBEZXNjcmlwdGlvbjogJ0Zhdm9yIHRoZSB1c2Ugb2YgYEludGVnZXIjZXZlbj9gICYmIGBJbnRlZ2VyI29kZD9gLicKICBTdHlsZUd1aWRlOiAnI3ByZWRpY2F0ZS1tZXRob2RzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEyJwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yOScKClN0eWxlL0V4YWN0UmVnZXhwTWF0Y2g6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGV4YWN0IHJlZ2V4cCBtYXRjaCBpbnNpZGUgUmVnZXhwIGxpdGVyYWxzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41MScKClN0eWxlL0V4cGFuZFBhdGhBcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICJVc2UgYGV4cGFuZF9wYXRoKF9fZGlyX18pYCBpbnN0ZWFkIG9mIGBleHBhbmRfcGF0aCgnLi4nLCBfX0ZJTEVfXylgLiIKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKClN0eWxlL0V4cGxpY2l0QmxvY2tBcmd1bWVudDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgQ29uc2lkZXIgdXNpbmcgZXhwbGljaXQgYmxvY2sgYXJndW1lbnQgdG8gYXZvaWQgd3JpdGluZyBibG9jayBsaXRlcmFsCiAgICAgICAgICAgICAgICAgIHRoYXQganVzdCBwYXNzZXMgaXRzIGFyZ3VtZW50cyB0byBhbm90aGVyIGJsb2NrLgogIFN0eWxlR3VpZGU6ICcjYmxvY2stYXJndW1lbnQnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjgnCgpTdHlsZS9FeHBvbmVudGlhbE5vdGF0aW9uOgogIERlc2NyaXB0aW9uOiAnV2hlbiB1c2luZyBleHBvbmVudGlhbCBub3RhdGlvbiwgZmF2b3IgYSBtYW50aXNzYSBiZXR3ZWVuIDEgKGluY2x1c2l2ZSkgYW5kIDEwIChleGNsdXNpdmUpLicKICBTdHlsZUd1aWRlOiAnI2V4cG9uZW50aWFsLW5vdGF0aW9uJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjgyJwogIEVuZm9yY2VkU3R5bGU6IHNjaWVudGlmaWMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNjaWVudGlmaWMKICAgIC0gZW5naW5lZXJpbmcKICAgIC0gaW50ZWdyYWwKClN0eWxlL0ZldGNoRW52VmFyOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFN1Z2dlc3RzIGBFTlYuZmV0Y2hgIGZvciB0aGUgcmVwbGFjZW1lbnQgb2YgYEVOVltdYC4KICBSZWZlcmVuY2U6CiAgICAtIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlLyNoYXNoLWZldGNoLWRlZmF1bHRzCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjgnCiAgIyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gYmUgZXhjbHVkZWQgZnJvbSB0aGUgaW5zcGVjdGlvbi4KICBBbGxvd2VkVmFyczogW10KClN0eWxlL0ZpbGVFbXB0eToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBQcmVmZXIgdG8gdXNlIGBGaWxlLmVtcHR5PygncGF0aC90by9maWxlJylgIHdoZW4gY2hlY2tpbmcgaWYgYSBmaWxlIGlzIGVtcHR5LgogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuNDgnCgpTdHlsZS9GaWxlUmVhZDoKICBEZXNjcmlwdGlvbjogJ0Zhdm9yIGBGaWxlLihiaW4pcmVhZGAgY29udmVuaWVuY2UgbWV0aG9kcy4nCiAgU3R5bGVHdWlkZTogJyNmaWxlLXJlYWQnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjQnCgpTdHlsZS9GaWxlV3JpdGU6CiAgRGVzY3JpcHRpb246ICdGYXZvciBgRmlsZS4oYmluKXdyaXRlYCBjb252ZW5pZW5jZSBtZXRob2RzLicKICBTdHlsZUd1aWRlOiAnI2ZpbGUtd3JpdGUnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjQnCgpTdHlsZS9GbG9hdERpdmlzaW9uOgogIERlc2NyaXB0aW9uOiAnRm9yIHBlcmZvcm1pbmcgZmxvYXQgZGl2aXNpb24sIGNvZXJjZSBvbmUgc2lkZSBvbmx5LicKICBTdHlsZUd1aWRlOiAnI2Zsb2F0LWRpdmlzaW9uJwogIFJlZmVyZW5jZTogJ2h0dHBzOi8vYmxvZy5ydWJ5c3R5bGUuZ3VpZGUvcnVieS8yMDE5LzA2LzIxL2Zsb2F0LWRpdmlzaW9uLmh0bWwnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNzInCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjknCiAgU2FmZTogZmFsc2UKICBFbmZvcmNlZFN0eWxlOiBzaW5nbGVfY29lcmNlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBsZWZ0X2NvZXJjZQogICAgLSByaWdodF9jb2VyY2UKICAgIC0gc2luZ2xlX2NvZXJjZQogICAgLSBmZGl2CgpTdHlsZS9Gb3I6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdXNlIG9mIGZvciBvciBlYWNoIGluIG11bHRpbGluZSBsb29wcy4nCiAgU3R5bGVHdWlkZTogJyNuby1mb3ItbG9vcHMnCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjEzJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4yNicKICBFbmZvcmNlZFN0eWxlOiBlYWNoCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBlYWNoCiAgICAtIGZvcgoKU3R5bGUvRm9ybWF0U3RyaW5nOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZSB0aGUgdXNlIG9mIEtlcm5lbCNzcHJpbnRmLCBLZXJuZWwjZm9ybWF0IG9yIFN0cmluZyMlLicKICBTdHlsZUd1aWRlOiAnI3NwcmludGYnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IGZvcm1hdAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gZm9ybWF0CiAgICAtIHNwcmludGYKICAgIC0gcGVyY2VudAoKU3R5bGUvRm9ybWF0U3RyaW5nVG9rZW46CiAgRGVzY3JpcHRpb246ICdVc2UgYSBjb25zaXN0ZW50IHN0eWxlIGZvciBmb3JtYXQgc3RyaW5nIHRva2Vucy4nCiAgRW5hYmxlZDogdHJ1ZQogIEVuZm9yY2VkU3R5bGU6IGFubm90YXRlZAogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgUHJlZmVyIHRva2VucyB3aGljaCBjb250YWluIGEgc3ByaW50ZiBsaWtlIHR5cGUgYW5ub3RhdGlvbiBsaWtlCiAgICAjIGAlPG5hbWU+c2AsIGAlPGFnZT5kYCwgYCU8c2NvcmU+ZmAKICAgIC0gYW5ub3RhdGVkCiAgICAjIFByZWZlciBzaW1wbGUgbG9va2luZyAidGVtcGxhdGUiIHN0eWxlIHRva2VucyBsaWtlIGAle25hbWV9YCwgYCV7YWdlfWAKICAgIC0gdGVtcGxhdGUKICAgIC0gdW5hbm5vdGF0ZWQKICAjIGBNYXhVbmFubm90YXRlZFBsYWNlaG9sZGVyc0FsbG93ZWRgIGRlZmluZXMgdGhlIG51bWJlciBvZiBgdW5hbm5vdGF0ZWRgCiAgIyBzdHlsZSB0b2tlbiBpbiBhIGZvcm1hdCBzdHJpbmcgdG8gYmUgYWxsb3dlZCB3aGVuIGVuZm9yY2VkIHN0eWxlIGlzIG5vdAogICMgYHVuYW5ub3RhdGVkYC4KICBNYXhVbmFubm90YXRlZFBsYWNlaG9sZGVyc0FsbG93ZWQ6IDEKICBWZXJzaW9uQWRkZWQ6ICcwLjQ5JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4wJwogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KClN0eWxlL0Zyb3plblN0cmluZ0xpdGVyYWxDb21tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEFkZCB0aGUgZnJvemVuX3N0cmluZ19saXRlcmFsIGNvbW1lbnQgdG8gdGhlIHRvcCBvZiBmaWxlcwogICAgICAgICAgICAgICAgIHRvIGhlbHAgdHJhbnNpdGlvbiB0byBmcm96ZW4gc3RyaW5nIGxpdGVyYWxzIGJ5IGRlZmF1bHQuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc5JwogIEVuZm9yY2VkU3R5bGU6IGFsd2F5cwogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgYGFsd2F5c2Agd2lsbCBhbHdheXMgYWRkIHRoZSBmcm96ZW4gc3RyaW5nIGxpdGVyYWwgY29tbWVudCB0byBhIGZpbGUKICAgICMgcmVnYXJkbGVzcyBvZiB0aGUgUnVieSB2ZXJzaW9uIG9yIGlmIGBmcmVlemVgIG9yIGA8PGAgYXJlIGNhbGxlZCBvbiBhCiAgICAjIHN0cmluZyBsaXRlcmFsLiBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoaXMgd2lsbCBjcmVhdGUgZXJyb3JzLgogICAgLSBhbHdheXMKICAgICMgYGFsd2F5c190cnVlYCB3aWxsIGFkZCB0aGUgZnJvemVuIHN0cmluZyBsaXRlcmFsIGNvbW1lbnQgdG8gYSBmaWxlLAogICAgIyBzaW1pbGFybHkgdG8gdGhlIGBhbHdheXNgIHN0eWxlLCBidXQgd2lsbCBhbHNvIGNoYW5nZSBhbnkgZGlzYWJsZWQKICAgICMgY29tbWVudHMgKGUuZy4gYCMgZnJvemVuX3N0cmluZ19saXRlcmFsOiBmYWxzZWApIHRvIGJlIGVuYWJsZWQuCiAgICAtIGFsd2F5c190cnVlCiAgICAjIGBuZXZlcmAgd2lsbCBlbmZvcmNlIHRoYXQgdGhlIGZyb3plbiBzdHJpbmcgbGl0ZXJhbCBjb21tZW50IGRvZXMgbm90CiAgICAjIGV4aXN0IGluIGEgZmlsZS4KICAgIC0gbmV2ZXIKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCgpTdHlsZS9HbG9iYWxTdGRTdHJlYW06CiAgRGVzY3JpcHRpb246ICdFbmZvcmNlcyB0aGUgdXNlIG9mIGAkc3Rkb3V0LyRzdGRlcnIvJHN0ZGluYCBpbnN0ZWFkIG9mIGBTVERPVVQvU1RERVJSL1NURElOYC4nCiAgU3R5bGVHdWlkZTogJyNnbG9iYWwtc3Rkb3V0JwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjg5JwogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKClN0eWxlL0dsb2JhbFZhcnM6CiAgRGVzY3JpcHRpb246ICdEbyBub3QgaW50cm9kdWNlIGdsb2JhbCB2YXJpYWJsZXMuJwogIFN0eWxlR3VpZGU6ICcjaW5zdGFuY2UtdmFycycKICBSZWZlcmVuY2U6ICdodHRwczovL3d3dy56ZW5zcGlkZXIuY29tL3J1YnkvcXVpY2tyZWYuaHRtbCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xMycKICAjIEJ1aWx0LWluIGdsb2JhbCB2YXJpYWJsZXMgYXJlIGFsbG93ZWQgYnkgZGVmYXVsdC4KICBBbGxvd2VkVmFyaWFibGVzOiBbXQoKU3R5bGUvR3VhcmRDbGF1c2U6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgY29uZGl0aW9uYWxzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggZ3VhcmQgY2xhdXNlcy4nCiAgU3R5bGVHdWlkZTogJyNuby1uZXN0ZWQtY29uZGl0aW9uYWxzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjIwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4zMScKICAjIGBNaW5Cb2R5TGVuZ3RoYCBkZWZpbmVzIHRoZSBudW1iZXIgb2YgbGluZXMgb2YgdGhlIGEgYm9keSBvZiBhbiBgaWZgIG9yIGB1bmxlc3NgCiAgIyBuZWVkcyB0byBoYXZlIHRvIHRyaWdnZXIgdGhpcyBjb3AKICBNaW5Cb2R5TGVuZ3RoOiAxCiAgQWxsb3dDb25zZWN1dGl2ZUNvbmRpdGlvbmFsczogZmFsc2UKClN0eWxlL0hhc2hBc0xhc3RBcnJheUl0ZW06CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGJyYWNlcyBhcm91bmQgaGFzaCBsaXRlcmFsIGFzIGEgbGFzdAogICAgICAgICAgICAgICAgIGFycmF5IGl0ZW0gZGVwZW5kaW5nIG9uIGNvbmZpZ3VyYXRpb24uCiAgU3R5bGVHdWlkZTogJyNoYXNoLWxpdGVyYWwtYXMtbGFzdC1hcnJheS1pdGVtJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjg4JwogIEVuZm9yY2VkU3R5bGU6IGJyYWNlcwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gYnJhY2VzCiAgICAtIG5vX2JyYWNlcwoKU3R5bGUvSGFzaENvbnZlcnNpb246CiAgRGVzY3JpcHRpb246ICdBdm9pZCBIYXNoW10gaW4gZmF2b3Igb2YgYXJ5LnRvX2ggb3IgbGl0ZXJhbCBoYXNoZXMuJwogIFN0eWxlR3VpZGU6ICcjYXZvaWQtaGFzaC1jb25zdHJ1Y3RvcicKICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMTAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjU1JwogIEFsbG93U3BsYXRBcmd1bWVudDogdHJ1ZQoKU3R5bGUvSGFzaEVhY2hNZXRob2RzOgogIERlc2NyaXB0aW9uOiAnVXNlIEhhc2gjZWFjaF9rZXkgYW5kIEhhc2gjZWFjaF92YWx1ZS4nCiAgU3R5bGVHdWlkZTogJyNoYXNoLWVhY2gnCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44MCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuMTYnCiAgQWxsb3dlZFJlY2VpdmVyczoKICAgIC0gVGhyZWFkLmN1cnJlbnQKClN0eWxlL0hhc2hFeGNlcHQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB1c2FnZXMgb2YgYEhhc2gjcmVqZWN0YCwgYEhhc2gjc2VsZWN0YCwgYW5kIGBIYXNoI2ZpbHRlcmAgbWV0aG9kcwogICAgICAgICAgICAgICAgIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYEhhc2gjZXhjZXB0YCBtZXRob2QuCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS43JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4zOScKClN0eWxlL0hhc2hMaWtlQ2FzZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciBwbGFjZXMgd2hlcmUgYGNhc2Utd2hlbmAgcmVwcmVzZW50cyBhIHNpbXBsZSAxOjEKICAgICAgICAgICAgICAgICAgbWFwcGluZyBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBoYXNoIGxvb2t1cC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44OCcKICAjIGBNaW5CcmFuY2hlc0NvdW50YCBkZWZpbmVzIHRoZSBudW1iZXIgb2YgYnJhbmNoZXMgYGNhc2VgIG5lZWRzIHRvIGhhdmUKICAjIHRvIHRyaWdnZXIgdGhpcyBjb3AKICBNaW5CcmFuY2hlc0NvdW50OiAzCgpTdHlsZS9IYXNoU3ludGF4OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFByZWZlciBSdWJ5IDEuOSBoYXNoIHN5bnRheCB7IGE6IDEsIGI6IDIgfSBvdmVyIDEuOCBzeW50YXgKICAgICAgICAgICAgICAgICB7IDphID0+IDEsIDpiID0+IDIgfS4KICBTdHlsZUd1aWRlOiAnI2hhc2gtbGl0ZXJhbHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMjQnCiAgRW5mb3JjZWRTdHlsZTogcnVieTE5CiAgU3VwcG9ydGVkU3R5bGVzOgogICAgIyBjaGVja3MgZm9yIDEuOSBzeW50YXggKGUuZy4ge2E6IDF9KSBmb3IgYWxsIHN5bWJvbCBrZXlzCiAgICAtIHJ1YnkxOQogICAgIyBjaGVja3MgZm9yIGhhc2ggcm9ja2V0IHN5bnRheCBmb3IgYWxsIGhhc2hlcwogICAgLSBoYXNoX3JvY2tldHMKICAgICMgZm9yYmlkcyBtaXhlZCBrZXkgc3ludGF4ZXMgKGUuZy4ge2E6IDEsIDpiID0+IDJ9KQogICAgLSBub19taXhlZF9rZXlzCiAgICAjIGVuZm9yY2VzIGJvdGggcnVieTE5IGFuZCBub19taXhlZF9rZXlzIHN0eWxlcwogICAgLSBydWJ5MTlfbm9fbWl4ZWRfa2V5cwogICMgRm9yY2UgaGFzaGVzIHRoYXQgaGF2ZSBhIGhhc2ggdmFsdWUgb21pc3Npb24KICBFbmZvcmNlZFNob3J0aGFuZFN5bnRheDogYWx3YXlzCiAgU3VwcG9ydGVkU2hvcnRoYW5kU3ludGF4OgogICAgIyBmb3JjZXMgdXNlIG9mIHRoZSAzLjEgc3ludGF4IChlLmcuIHtmb286fSkgd2hlbiB0aGUgaGFzaCBrZXkgYW5kIHZhbHVlIGFyZSB0aGUgc2FtZS4KICAgIC0gYWx3YXlzCiAgICAjIGZvcmNlcyB1c2Ugb2YgZXhwbGljaXQgaGFzaCBsaXRlcmFsIHZhbHVlLgogICAgLSBuZXZlcgogICAgIyBhY2NlcHRzIGJvdGggc2hvcnRoYW5kIGFuZCBleHBsaWNpdCB1c2Ugb2YgaGFzaCBsaXRlcmFsIHZhbHVlLgogICAgLSBlaXRoZXIKICAgICMgZm9yY2VzIHVzZSBvZiB0aGUgMy4xIHN5bnRheCBvbmx5IGlmIGFsbCB2YWx1ZXMgY2FuIGJlIG9taXR0ZWQgaW4gdGhlIGhhc2guCiAgICAtIGNvbnNpc3RlbnQKICAgICMgYWxsb3cgZWl0aGVyIChpbXBsaWNpdCBvciBleHBsaWNpdCkgc3ludGF4IGJ1dCBlbmZvcmNlIGNvbnNpc3RlbmN5IHdpdGhpbiBhIHNpbmdsZSBoYXNoCiAgICAtIGVpdGhlcl9jb25zaXN0ZW50CiAgIyBGb3JjZSBoYXNoZXMgdGhhdCBoYXZlIGEgc3ltYm9sIHZhbHVlIHRvIHVzZSBoYXNoIHJvY2tldHMKICBVc2VIYXNoUm9ja2V0c1dpdGhTeW1ib2xWYWx1ZXM6IGZhbHNlCiAgIyBEbyBub3Qgc3VnZ2VzdCB7IGE/OiAxIH0gb3ZlciB7IDphPyA9PiAxIH0gaW4gcnVieTE5IHN0eWxlCiAgUHJlZmVySGFzaFJvY2tldHNGb3JOb25BbG51bUVuZGluZ1N5bWJvbHM6IGZhbHNlCgpTdHlsZS9IYXNoVHJhbnNmb3JtS2V5czoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBgdHJhbnNmb3JtX2tleXNgIG92ZXIgYGVhY2hfd2l0aF9vYmplY3RgLCBgbWFwYCwgb3IgYHRvX2hgLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44MCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuOTAnCiAgU2FmZTogZmFsc2UKClN0eWxlL0hhc2hUcmFuc2Zvcm1WYWx1ZXM6CiAgRGVzY3JpcHRpb246ICdQcmVmZXIgYHRyYW5zZm9ybV92YWx1ZXNgIG92ZXIgYGVhY2hfd2l0aF9vYmplY3RgLCBgbWFwYCwgb3IgYHRvX2hgLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44MCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuOTAnCiAgU2FmZTogZmFsc2UKClN0eWxlL0lkZW50aWNhbENvbmRpdGlvbmFsQnJhbmNoZXM6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIHRoYXQgY29uZGl0aW9uYWwgc3RhdGVtZW50cyBkbyBub3QgaGF2ZSBhbiBpZGVudGljYWwKICAgICAgICAgICAgICAgICBsaW5lIGF0IHRoZSBlbmQgb2YgZWFjaCBicmFuY2gsIHdoaWNoIGNhbiB2YWxpZGx5IGJlIG1vdmVkCiAgICAgICAgICAgICAgICAgb3V0IG9mIHRoZSBjb25kaXRpb25hbC4KICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMzYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjE5JwoKU3R5bGUvSWZJbnNpZGVFbHNlOgogIERlc2NyaXB0aW9uOiAnRmluZHMgaWYgbm9kZXMgaW5zaWRlIGVsc2UsIHdoaWNoIGNhbiBiZSBjb252ZXJ0ZWQgdG8gZWxzaWYuJwogIEVuYWJsZWQ6IHRydWUKICBBbGxvd0lmTW9kaWZpZXI6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNicKICBWZXJzaW9uQ2hhbmdlZDogJzEuMycKClN0eWxlL0lmVW5sZXNzTW9kaWZpZXI6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgRmF2b3IgbW9kaWZpZXIgaWYvdW5sZXNzIHVzYWdlIHdoZW4geW91IGhhdmUgYQogICAgICAgICAgICAgICAgIHNpbmdsZS1saW5lIGJvZHkuCiAgU3R5bGVHdWlkZTogJyNpZi1hcy1hLW1vZGlmaWVyJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjMwJwoKU3R5bGUvSWZVbmxlc3NNb2RpZmllck9mSWZVbmxlc3M6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQXZvaWQgbW9kaWZpZXIgaWYvdW5sZXNzIHVzYWdlIG9uIGNvbmRpdGlvbmFscy4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODcnCgpTdHlsZS9JZldpdGhCb29sZWFuTGl0ZXJhbEJyYW5jaGVzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWR1bmRhbnQgYGlmYCB3aXRoIGJvb2xlYW4gbGl0ZXJhbCBicmFuY2hlcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuOScKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIG5vbnplcm8/CgpTdHlsZS9JZldpdGhTZW1pY29sb246CiAgRGVzY3JpcHRpb246ICdEbyBub3QgdXNlIGlmIHg7IC4uLi4gVXNlIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yIGluc3RlYWQuJwogIFN0eWxlR3VpZGU6ICcjbm8tc2VtaWNvbG9uLWlmcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC44MycKClN0eWxlL0ltcGxpY2l0UnVudGltZUVycm9yOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSBgcmFpc2VgIG9yIGBmYWlsYCB3aXRoIGFuIGV4cGxpY2l0IGV4Y2VwdGlvbiBjbGFzcyBhbmQKICAgICAgICAgICAgICAgICBtZXNzYWdlLCByYXRoZXIgdGhhbiBqdXN0IGEgbWVzc2FnZS4KICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNDEnCgpTdHlsZS9JblBhdHRlcm5UaGVuOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBgaW47YCB1c2VzIGluIGBjYXNlYCBleHByZXNzaW9ucy4nCiAgU3R5bGVHdWlkZTogJyNuby1pbi1wYXR0ZXJuLXNlbWljb2xvbnMnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMTYnCgpTdHlsZS9JbmZpbml0ZUxvb3A6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgVXNlIEtlcm5lbCNsb29wIGZvciBpbmZpbml0ZSBsb29wcy4KICAgICAgICAgICAgICAgICBUaGlzIGNvcCBpcyB1bnNhZmUgaWYgdGhlIGJvZHkgbWF5IHJhaXNlIGEgYFN0b3BJdGVyYXRpb25gIGV4Y2VwdGlvbi4KICBTYWZlOiBmYWxzZQogIFN0eWxlR3VpZGU6ICcjaW5maW5pdGUtbG9vcCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yNicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNjEnCgpTdHlsZS9JbmxpbmVDb21tZW50OgogIERlc2NyaXB0aW9uOiAnQXZvaWQgdHJhaWxpbmcgaW5saW5lIGNvbW1lbnRzLicKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMjMnCgpTdHlsZS9JbnZlcnNlTWV0aG9kczoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBVc2UgdGhlIGludmVyc2UgbWV0aG9kIGluc3RlYWQgb2YgYCEubWV0aG9kYAogICAgICAgICAgICAgICAgIGlmIGFuIGludmVyc2UgbWV0aG9kIGlzIGRlZmluZWQuCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC40OCcKICAjIGBJbnZlcnNlTWV0aG9kc2AgYXJlIG1ldGhvZHMgdGhhdCBjYW4gYmUgaW52ZXJ0ZWQgYnkgYSBub3QgKGBub3RgIG9yIGAhYCkKICAjIFRoZSByZWxhdGlvbnNoaXAgb2YgaW52ZXJzZSBtZXRob2RzIG9ubHkgbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBvbmUgZGlyZWN0aW9uLgogICMgS2V5cyBhbmQgdmFsdWVzIGJvdGggbmVlZCB0byBiZSBkZWZpbmVkIGFzIHN5bWJvbHMuCiAgSW52ZXJzZU1ldGhvZHM6CiAgICA6YW55PzogOm5vbmU/CiAgICA6ZXZlbj86IDpvZGQ/CiAgICA6PT06IDohPQogICAgOj1+OiA6IX4KICAgIDo8OiA6Pj0KICAgIDo+OiA6PD0KICAjIGBJbnZlcnNlQmxvY2tzYCBhcmUgbWV0aG9kcyB0aGF0IGFyZSBpbnZlcnRlZCBieSBpbnZlcnRpbmcgdGhlIHJldHVybgogICMgb2YgdGhlIGJsb2NrIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBtZXRob2QKICBJbnZlcnNlQmxvY2tzOgogICAgOnNlbGVjdDogOnJlamVjdAogICAgOnNlbGVjdCE6IDpyZWplY3QhCgpTdHlsZS9JbnZlcnRpYmxlVW5sZXNzQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiAnRmF2b3IgYGlmYCB3aXRoIGludmVydGVkIGNvbmRpdGlvbiBvdmVyIGB1bmxlc3NgLicKICBFbmFibGVkOiBmYWxzZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40NCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuNTAnCiAgIyBgSW52ZXJzZU1ldGhvZHNgIGFyZSBtZXRob2RzIHRoYXQgY2FuIGJlIGludmVydGVkIGluIGEgYHVubGVzc2AgY29uZGl0aW9uLgogICMgVGhlIHJlbGF0aW9uc2hpcCBvZiBpbnZlcnNlIG1ldGhvZHMgbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBib3RoIGRpcmVjdGlvbnMuCiAgIyBLZXlzIGFuZCB2YWx1ZXMgYm90aCBuZWVkIHRvIGJlIGRlZmluZWQgYXMgc3ltYm9scy4KICBJbnZlcnNlTWV0aG9kczoKICAgIDohPTogOj09CiAgICA6PjogOjw9CiAgICA6PD06IDo+CiAgICA6PDogOj49CiAgICA6Pj06IDo8CiAgICA6IX46IDo9fgogICAgOnplcm8/OiA6bm9uemVybz8KICAgIDpub256ZXJvPzogOnplcm8/CiAgICA6YW55PzogOm5vbmU/CiAgICA6bm9uZT86IDphbnk/CiAgICA6ZXZlbj86IDpvZGQ/CiAgICA6b2RkPzogOmV2ZW4/CgpTdHlsZS9JcEFkZHJlc3NlczoKICBEZXNjcmlwdGlvbjogIkRvbid0IGluY2x1ZGUgbGl0ZXJhbCBJUCBhZGRyZXNzZXMgaW4gY29kZS4iCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjU4JwogIFZlcnNpb25DaGFuZ2VkOiAnMC45MScKICAjIEFsbG93IGFkZHJlc3NlcyB0byBiZSBwZXJtaXR0ZWQKICBBbGxvd2VkQWRkcmVzc2VzOgogICAgLSAiOjoiCiAgICAjIDo6IGlzIGEgdmFsaWQgSVB2NiBhZGRyZXNzLCBidXQgY291bGQgcG90ZW50aWFsbHkgYmUgbGVnaXRpbWF0ZWx5IGluIGNvZGUKICBFeGNsdWRlOgogICAgLSAnKiovKi5nZW1maWxlJwogICAgLSAnKiovR2VtZmlsZScKICAgIC0gJyoqL2dlbXMucmInCiAgICAtICcqKi8qLmdlbXNwZWMnCgpTdHlsZS9LZXl3b3JkUGFyYW1ldGVyc09yZGVyOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgdGhhdCBvcHRpb25hbCBrZXl3b3JkIHBhcmFtZXRlcnMgYXJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbWV0ZXJzIGxpc3QuJwogIFN0eWxlR3VpZGU6ICcja2V5d29yZC1wYXJhbWV0ZXJzLW9yZGVyJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjkwJwogIFZlcnNpb25DaGFuZ2VkOiAnMS43JwoKU3R5bGUvTGFtYmRhOgogIERlc2NyaXB0aW9uOiAnVXNlIHRoZSBuZXcgbGFtYmRhIGxpdGVyYWwgc3ludGF4IGZvciBzaW5nbGUtbGluZSBibG9ja3MuJwogIFN0eWxlR3VpZGU6ICcjbGFtYmRhLW11bHRpLWxpbmUnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuNDAnCiAgRW5mb3JjZWRTdHlsZTogbGluZV9jb3VudF9kZXBlbmRlbnQKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGxpbmVfY291bnRfZGVwZW5kZW50CiAgICAtIGxhbWJkYQogICAgLSBsaXRlcmFsCgpTdHlsZS9MYW1iZGFDYWxsOgogIERlc2NyaXB0aW9uOiAnVXNlIGxhbWJkYS5jYWxsKC4uLikgaW5zdGVhZCBvZiBsYW1iZGEuKC4uLikuJwogIFN0eWxlR3VpZGU6ICcjcHJvYy1jYWxsJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEzJwogIFZlcnNpb25DaGFuZ2VkOiAnMC4xNCcKICBFbmZvcmNlZFN0eWxlOiBjYWxsCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBjYWxsCiAgICAtIGJyYWNlcwoKU3R5bGUvTGluZUVuZENvbmNhdGVuYXRpb246CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgVXNlIFwgaW5zdGVhZCBvZiArIG9yIDw8IHRvIGNvbmNhdGVuYXRlIHR3byBzdHJpbmcgbGl0ZXJhbHMgYXQKICAgICAgICAgICAgICAgICBsaW5lIGVuZC4KICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMTgnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjY0JwoKU3R5bGUvTWFnaWNDb21tZW50Rm9ybWF0OgogIERlc2NyaXB0aW9uOiAnVXNlIGEgY29uc2lzdGVudCBzdHlsZSBmb3IgbWFnaWMgY29tbWVudHMuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjM1JwogIEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIGBzbmFrZWAgd2lsbCBlbmZvcmNlIHRoZSBtYWdpYyBjb21tZW50IGlzIHdyaXR0ZW4KICAgICMgaW4gc25ha2UgY2FzZSAod29yZHMgc2VwYXJhdGVkIGJ5IHVuZGVyc2NvcmVzKS4KICAgICMgRWc6IGZyb3plX3N0cmluZ19saXRlcmFsOiB0cnVlCiAgICAtIHNuYWtlX2Nhc2UKICAgICMgYGtlYmFiYCB3aWxsIGVuZm9yY2UgdGhlIG1hZ2ljIGNvbW1lbnQgaXMgd3JpdHRlbgogICAgIyBpbiBrZWJhYiBjYXNlICh3b3JkcyBzZXBhcmF0ZWQgYnkgaHlwaGVucykuCiAgICAjIEVnOiBmcm96ZS1zdHJpbmctbGl0ZXJhbDogdHJ1ZQogICAgLSBrZWJhYl9jYXNlCiAgRGlyZWN0aXZlQ2FwaXRhbGl6YXRpb246IGxvd2VyY2FzZQogIFZhbHVlQ2FwaXRhbGl6YXRpb246IH4KICBTdXBwb3J0ZWRDYXBpdGFsaXphdGlvbnM6CiAgICAtIGxvd2VyY2FzZQogICAgLSB1cHBlcmNhc2UKClN0eWxlL01hcENvbXBhY3RXaXRoQ29uZGl0aW9uYWxCbG9jazoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBgc2VsZWN0YCBvciBgcmVqZWN0YCBvdmVyIGBtYXAgeyAuLi4gfS5jb21wYWN0YC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzAnCgpTdHlsZS9NYXBJbnRvQXJyYXk6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzYWdlcyBvZiBgZWFjaGAgd2l0aCBgPDxgLCBgcHVzaGAsIG9yIGBhcHBlbmRgIHdoaWNoIGNhbiBiZSByZXBsYWNlZCBieSBgbWFwYC4nCiAgU3R5bGVHdWlkZTogJyNmdW5jdGlvbmFsLWNvZGUnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNjMnCiAgU2FmZTogZmFsc2UKClN0eWxlL01hcFRvSGFzaDoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBgdG9faGAgd2l0aCBhIGJsb2NrIG92ZXIgYG1hcC50b19oYC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjQnCiAgU2FmZTogZmFsc2UKClN0eWxlL01hcFRvU2V0OgogIERlc2NyaXB0aW9uOiAnUHJlZmVyIGB0b19zZXRgIHdpdGggYSBibG9jayBvdmVyIGBtYXAudG9fc2V0YC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40MicKClN0eWxlL01ldGhvZENhbGxXaXRoQXJnc1BhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnVXNlIHBhcmVudGhlc2VzIGZvciBtZXRob2QgY2FsbHMgd2l0aCBhcmd1bWVudHMuJwogIFN0eWxlR3VpZGU6ICcjbWV0aG9kLWludm9jYXRpb24tcGFyZW5zJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC40NycKICBWZXJzaW9uQ2hhbmdlZDogJzEuNycKICBJZ25vcmVNYWNyb3M6IHRydWUKICBBbGxvd2VkTWV0aG9kczogW10KICBBbGxvd2VkUGF0dGVybnM6IFtdCiAgSW5jbHVkZWRNYWNyb3M6IFtdCiAgQWxsb3dQYXJlbnRoZXNlc0luTXVsdGlsaW5lQ2FsbDogZmFsc2UKICBBbGxvd1BhcmVudGhlc2VzSW5DaGFpbmluZzogZmFsc2UKICBBbGxvd1BhcmVudGhlc2VzSW5DYW1lbENhc2VNZXRob2Q6IGZhbHNlCiAgQWxsb3dQYXJlbnRoZXNlc0luU3RyaW5nSW50ZXJwb2xhdGlvbjogZmFsc2UKICBFbmZvcmNlZFN0eWxlOiByZXF1aXJlX3BhcmVudGhlc2VzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSByZXF1aXJlX3BhcmVudGhlc2VzCiAgICAtIG9taXRfcGFyZW50aGVzZXMKClN0eWxlL01ldGhvZENhbGxXaXRob3V0QXJnc1BhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnRG8gbm90IHVzZSBwYXJlbnRoZXNlcyBmb3IgbWV0aG9kIGNhbGxzIHdpdGggbm8gYXJndW1lbnRzLicKICBTdHlsZUd1aWRlOiAnI21ldGhvZC1pbnZvY2F0aW9uLXBhcmVucycKICBFbmFibGVkOiB0cnVlCiAgQWxsb3dlZE1ldGhvZHM6IFtdCiAgQWxsb3dlZFBhdHRlcm5zOiBbXQogIFZlcnNpb25BZGRlZDogJzAuNDcnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjU1JwoKU3R5bGUvTWV0aG9kQ2FsbGVkT25Eb0VuZEJsb2NrOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgY2hhaW5pbmcgYSBtZXRob2QgY2FsbCBvbiBhIGRvLi4uZW5kIGJsb2NrLicKICBTdHlsZUd1aWRlOiAnI3NpbmdsZS1saW5lLWJsb2NrcycKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMTQnCgpTdHlsZS9NZXRob2REZWZQYXJlbnRoZXNlczoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgaWYgdGhlIG1ldGhvZCBkZWZpbml0aW9ucyBoYXZlIG9yIGRvbid0IGhhdmUKICAgICAgICAgICAgICAgICBwYXJlbnRoZXNlcy4KICBTdHlsZUd1aWRlOiAnI21ldGhvZC1wYXJlbnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjcnCiAgRW5mb3JjZWRTdHlsZTogcmVxdWlyZV9wYXJlbnRoZXNlcwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gcmVxdWlyZV9wYXJlbnRoZXNlcwogICAgLSByZXF1aXJlX25vX3BhcmVudGhlc2VzCiAgICAtIHJlcXVpcmVfbm9fcGFyZW50aGVzZXNfZXhjZXB0X211bHRpbGluZQoKU3R5bGUvTWluTWF4OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIFVzZSBgRW51bWVyYWJsZSNtaW5tYXhgIGluc3RlYWQgb2YgYEVudW1lcmFibGUjbWluYAogICAgICAgICAgICAgICAgIGFuZCBgRW51bWVyYWJsZSNtYXhgIGluIGNvbmp1bmN0aW9uLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUwJwoKU3R5bGUvTWluTWF4Q29tcGFyaXNvbjoKICBEZXNjcmlwdGlvbjogJ0VuZm9yY2VzIHRoZSB1c2Ugb2YgYG1heGAgb3IgYG1pbmAgaW5zdGVhZCBvZiBjb21wYXJpc29uIGZvciBncmVhdGVyIG9yIGxlc3MuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuNDInCgpTdHlsZS9NaXNzaW5nRWxzZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgIFJlcXVpcmUgaWYvY2FzZSBleHByZXNzaW9ucyB0byBoYXZlIGFuIGVsc2UgYnJhbmNoZXMuCiAgICAgICAgICAgICAgICBJZiBlbmFibGVkLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0CiAgICAgICAgICAgICAgICBTdHlsZS9Vbmxlc3NFbHNlIGFuZCBTdHlsZS9FbXB0eUVsc2UgYmUgZW5hYmxlZC4KICAgICAgICAgICAgICAgIFRoaXMgd2lsbCBjb25mbGljdCB3aXRoIFN0eWxlL0VtcHR5RWxzZSBpZgogICAgICAgICAgICAgICAgU3R5bGUvRW1wdHlFbHNlIGlzIGNvbmZpZ3VyZWQgdG8gc3R5bGUgImJvdGgiLgogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzgnCiAgRW5mb3JjZWRTdHlsZTogYm90aAogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgaWYgLSB3YXJuIHdoZW4gYW4gaWYgZXhwcmVzc2lvbiBpcyBtaXNzaW5nIGFuIGVsc2UgYnJhbmNoCiAgICAjIGNhc2UgLSB3YXJuIHdoZW4gYSBjYXNlIGV4cHJlc3Npb24gaXMgbWlzc2luZyBhbiBlbHNlIGJyYW5jaAogICAgIyBib3RoIC0gd2FybiB3aGVuIGFuIGlmIG9yIGNhc2UgZXhwcmVzc2lvbiBpcyBtaXNzaW5nIGFuIGVsc2UgYnJhbmNoCiAgICAtIGlmCiAgICAtIGNhc2UKICAgIC0gYm90aAoKU3R5bGUvTWlzc2luZ1Jlc3BvbmRUb01pc3Npbmc6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIENoZWNrcyBpZiBgbWV0aG9kX21pc3NpbmdgIGlzIGltcGxlbWVudGVkCiAgICAgICAgICAgICAgICAgIHdpdGhvdXQgaW1wbGVtZW50aW5nIGByZXNwb25kX3RvX21pc3NpbmdgLgogIFN0eWxlR3VpZGU6ICcjbm8tbWV0aG9kLW1pc3NpbmcnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTYnCgpTdHlsZS9NaXhpbkdyb3VwaW5nOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBncm91cGluZyBvZiBtaXhpbnMgaW4gYGNsYXNzYCBhbmQgYG1vZHVsZWAgYm9kaWVzLicKICBTdHlsZUd1aWRlOiAnI21peGluLWdyb3VwaW5nJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ4JwogIFZlcnNpb25DaGFuZ2VkOiAnMC40OScKICBFbmZvcmNlZFN0eWxlOiBzZXBhcmF0ZWQKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIHNlcGFyYXRlZDogZWFjaCBtaXhlZCBpbiBtb2R1bGUgZ29lcyBpbiBhIHNlcGFyYXRlIHN0YXRlbWVudC4KICAgICMgZ3JvdXBlZDogbWl4ZWQgaW4gbW9kdWxlcyBhcmUgZ3JvdXBlZCBpbnRvIGEgc2luZ2xlIHN0YXRlbWVudC4KICAgIC0gc2VwYXJhdGVkCiAgICAtIGdyb3VwZWQKClN0eWxlL01peGluVXNhZ2U6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgdGhhdCBgaW5jbHVkZWAsIGBleHRlbmRgIGFuZCBgcHJlcGVuZGAgZXhpc3RzIGF0IHRoZSB0b3AgbGV2ZWwuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUxJwoKU3R5bGUvTW9kdWxlRnVuY3Rpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVzYWdlIG9mIGBleHRlbmQgc2VsZmAgaW4gbW9kdWxlcy4nCiAgU3R5bGVHdWlkZTogJyNtb2R1bGUtZnVuY3Rpb24nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjY1JwogIEVuZm9yY2VkU3R5bGU6IG1vZHVsZV9mdW5jdGlvbgogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gbW9kdWxlX2Z1bmN0aW9uCiAgICAtIGV4dGVuZF9zZWxmCiAgICAtIGZvcmJpZGRlbgogIEF1dG9jb3JyZWN0OiBmYWxzZQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKClN0eWxlL011bHRpbGluZUJsb2NrQ2hhaW46CiAgRGVzY3JpcHRpb246ICdBdm9pZCBtdWx0aS1saW5lIGNoYWlucyBvZiBibG9ja3MuJwogIFN0eWxlR3VpZGU6ICcjc2luZ2xlLWxpbmUtYmxvY2tzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEzJwoKU3R5bGUvTXVsdGlsaW5lSWZNb2RpZmllcjoKICBEZXNjcmlwdGlvbjogJ09ubHkgdXNlIGlmL3VubGVzcyBtb2RpZmllcnMgb24gc2luZ2xlIGxpbmUgc3RhdGVtZW50cy4nCiAgU3R5bGVHdWlkZTogJyNuby1tdWx0aWxpbmUtaWYtbW9kaWZpZXJzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjQ1JwoKU3R5bGUvTXVsdGlsaW5lSWZUaGVuOgogIERlc2NyaXB0aW9uOiAnRG8gbm90IHVzZSB0aGVuIGZvciBtdWx0aS1saW5lIGlmL3VubGVzcy4nCiAgU3R5bGVHdWlkZTogJyNuby10aGVuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjI2JwoKU3R5bGUvTXVsdGlsaW5lSW5QYXR0ZXJuVGhlbjoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCB1c2UgYHRoZW5gIGZvciBtdWx0aS1saW5lIGBpbmAgc3RhdGVtZW50LicKICBTdHlsZUd1aWRlOiAnI25vLXRoZW4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMTYnCgpTdHlsZS9NdWx0aWxpbmVNZW1vaXphdGlvbjoKICBEZXNjcmlwdGlvbjogJ1dyYXAgbXVsdGlsaW5lIG1lbW9pemF0aW9ucyBpbiBhIGBiZWdpbmAgYW5kIGBlbmRgIGJsb2NrLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40NCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuNDgnCiAgRW5mb3JjZWRTdHlsZToga2V5d29yZAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0ga2V5d29yZAogICAgLSBicmFjZXMKClN0eWxlL011bHRpbGluZU1ldGhvZFNpZ25hdHVyZToKICBEZXNjcmlwdGlvbjogJ0F2b2lkIG11bHRpLWxpbmUgbWV0aG9kIHNpZ25hdHVyZXMuJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC41OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuNycKClN0eWxlL011bHRpbGluZVRlcm5hcnlPcGVyYXRvcjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBBdm9pZCBtdWx0aS1saW5lID86ICh0aGUgdGVybmFyeSBvcGVyYXRvcik7CiAgICAgICAgICAgICAgICAgdXNlIGlmL3VubGVzcyBpbnN0ZWFkLgogIFN0eWxlR3VpZGU6ICcjbm8tbXVsdGlsaW5lLXRlcm5hcnknCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuODYnCgpTdHlsZS9NdWx0aWxpbmVXaGVuVGhlbjoKICBEZXNjcmlwdGlvbjogJ0RvIG5vdCB1c2UgdGhlbiBmb3IgbXVsdGktbGluZSB3aGVuIHN0YXRlbWVudC4nCiAgU3R5bGVHdWlkZTogJyNuby10aGVuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjczJwoKU3R5bGUvTXVsdGlwbGVDb21wYXJpc29uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEF2b2lkIGNvbXBhcmluZyBhIHZhcmlhYmxlIHdpdGggbXVsdGlwbGUgaXRlbXMgaW4gYSBjb25kaXRpb25hbCwKICAgICAgICAgICAgICAgICB1c2UgQXJyYXkjaW5jbHVkZT8gaW5zdGVhZC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuMScKICBBbGxvd01ldGhvZENvbXBhcmlzb246IHRydWUKICBDb21wYXJpc29uc1RocmVzaG9sZDogMgoKU3R5bGUvTXV0YWJsZUNvbnN0YW50OgogIERlc2NyaXB0aW9uOiAnRG8gbm90IGFzc2lnbiBtdXRhYmxlIG9iamVjdHMgdG8gY29uc3RhbnRzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNCcKICBWZXJzaW9uQ2hhbmdlZDogJzEuOCcKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgRW5mb3JjZWRTdHlsZTogbGl0ZXJhbHMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIGxpdGVyYWxzOiBmcmVlemUgbGl0ZXJhbHMgYXNzaWduZWQgdG8gY29uc3RhbnRzCiAgICAjIHN0cmljdDogZnJlZXplIGFsbCBjb25zdGFudHMKICAgICMgU3RyaWN0IG1vZGUgaXMgY29uc2lkZXJlZCBhbiBleHBlcmltZW50YWwgZmVhdHVyZS4gSXQgaGFzIG5vdCBiZWVuIHVwZGF0ZWQKICAgICMgd2l0aCBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgYWxsIG1ldGhvZHMgdGhhdCB3aWxsIHByb2R1Y2UgZnJvemVuIG9iamVjdHMgc28KICAgICMgdGhlcmUgaXMgYSBkZWNlbnQgY2hhbmNlIG9mIGdldHRpbmcgc29tZSBmYWxzZSBwb3NpdGl2ZXMuIEx1Y2tpbHksIHRoZXJlIGlzCiAgICAjIG5vIGhhcm0gaW4gZnJlZXppbmcgYW4gYWxyZWFkeSBmcm96ZW4gb2JqZWN0LgogICAgLSBsaXRlcmFscwogICAgLSBzdHJpY3QKClN0eWxlL05lZ2F0ZWRJZjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBGYXZvciB1bmxlc3Mgb3ZlciBpZiBmb3IgbmVnYXRpdmUgY29uZGl0aW9ucwogICAgICAgICAgICAgICAgIChvciBjb250cm9sIGZsb3cgb3IpLgogIFN0eWxlR3VpZGU6ICcjdW5sZXNzLWZvci1uZWdhdGl2ZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjAnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ4JwogIEVuZm9yY2VkU3R5bGU6IGJvdGgKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAjIGJvdGg6IHByZWZpeCBhbmQgcG9zdGZpeCBuZWdhdGVkIGBpZmAgc2hvdWxkIGJvdGggdXNlIGB1bmxlc3NgCiAgICAjIHByZWZpeDogb25seSB1c2UgYHVubGVzc2AgZm9yIG5lZ2F0ZWQgYGlmYCBzdGF0ZW1lbnRzIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBib2R5IG9mIHRoZSBzdGF0ZW1lbnQKICAgICMgcG9zdGZpeDogb25seSB1c2UgYHVubGVzc2AgZm9yIG5lZ2F0ZWQgYGlmYCBzdGF0ZW1lbnRzIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGJvZHkgb2YgdGhlIHN0YXRlbWVudAogICAgLSBib3RoCiAgICAtIHByZWZpeAogICAgLSBwb3N0Zml4CgpTdHlsZS9OZWdhdGVkSWZFbHNlQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB1c2VzIG9mIGBpZi1lbHNlYCBhbmQgdGVybmFyeSBvcGVyYXRvcnMgd2l0aCBhIG5lZ2F0ZWQgY29uZGl0aW9uCiAgICAgICAgICAgICAgICB3aGljaCBjYW4gYmUgc2ltcGxpZmllZCBieSBpbnZlcnRpbmcgY29uZGl0aW9uIGFuZCBzd2FwcGluZyBicmFuY2hlcy4KICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4yJwoKU3R5bGUvTmVnYXRlZFVubGVzczoKICBEZXNjcmlwdGlvbjogJ0Zhdm9yIGlmIG92ZXIgdW5sZXNzIGZvciBuZWdhdGl2ZSBjb25kaXRpb25zLicKICBTdHlsZUd1aWRlOiAnI2lmLWZvci1uZWdhdGl2ZXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNjknCiAgRW5mb3JjZWRTdHlsZTogYm90aAogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgYm90aDogcHJlZml4IGFuZCBwb3N0Zml4IG5lZ2F0ZWQgYHVubGVzc2Agc2hvdWxkIGJvdGggdXNlIGBpZmAKICAgICMgcHJlZml4OiBvbmx5IHVzZSBgaWZgIGZvciBuZWdhdGVkIGB1bmxlc3NgIHN0YXRlbWVudHMgcG9zaXRpb25lZCBiZWZvcmUgdGhlIGJvZHkgb2YgdGhlIHN0YXRlbWVudAogICAgIyBwb3N0Zml4OiBvbmx5IHVzZSBgaWZgIGZvciBuZWdhdGVkIGB1bmxlc3NgIHN0YXRlbWVudHMgcG9zaXRpb25lZCBhZnRlciB0aGUgYm9keSBvZiB0aGUgc3RhdGVtZW50CiAgICAtIGJvdGgKICAgIC0gcHJlZml4CiAgICAtIHBvc3RmaXgKClN0eWxlL05lZ2F0ZWRXaGlsZToKICBEZXNjcmlwdGlvbjogJ0Zhdm9yIHVudGlsIG92ZXIgd2hpbGUgZm9yIG5lZ2F0aXZlIGNvbmRpdGlvbnMuJwogIFN0eWxlR3VpZGU6ICcjdW50aWwtZm9yLW5lZ2F0aXZlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yMCcKClN0eWxlL05lc3RlZEZpbGVEaXJuYW1lOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBuZXN0ZWQgYEZpbGUuZGlybmFtZWAuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjI2JwoKU3R5bGUvTmVzdGVkTW9kaWZpZXI6CiAgRGVzY3JpcHRpb246ICdBdm9pZCB1c2luZyBuZXN0ZWQgbW9kaWZpZXJzLicKICBTdHlsZUd1aWRlOiAnI25vLW5lc3RlZC1tb2RpZmllcnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzUnCgpTdHlsZS9OZXN0ZWRQYXJlbnRoZXNpemVkQ2FsbHM6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgUGFyZW50aGVzaXplIG1ldGhvZCBjYWxscyB3aGljaCBhcmUgbmVzdGVkIGluc2lkZSB0aGUKICAgICAgICAgICAgICAgICBhcmd1bWVudCBsaXN0IG9mIGFub3RoZXIgcGFyZW50aGVzaXplZCBtZXRob2QgY2FsbC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzcnCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIGJlCiAgICAtIGJlX2EKICAgIC0gYmVfYW4KICAgIC0gYmVfYmV0d2VlbgogICAgLSBiZV9mYWxzZXkKICAgIC0gYmVfa2luZF9vZgogICAgLSBiZV9pbnN0YW5jZV9vZgogICAgLSBiZV90cnV0aHkKICAgIC0gYmVfd2l0aGluCiAgICAtIGVxCiAgICAtIGVxbAogICAgLSBlbmRfd2l0aAogICAgLSBpbmNsdWRlCiAgICAtIG1hdGNoCiAgICAtIHJhaXNlX2Vycm9yCiAgICAtIHJlc3BvbmRfdG8KICAgIC0gc3RhcnRfd2l0aAoKU3R5bGUvTmVzdGVkVGVybmFyeU9wZXJhdG9yOgogIERlc2NyaXB0aW9uOiAnVXNlIG9uZSBleHByZXNzaW9uIHBlciBicmFuY2ggaW4gYSB0ZXJuYXJ5IG9wZXJhdG9yLicKICBTdHlsZUd1aWRlOiAnI25vLW5lc3RlZC10ZXJuYXJ5JwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjg2JwoKU3R5bGUvTmV4dDoKICBEZXNjcmlwdGlvbjogJ1VzZSBgbmV4dGAgdG8gc2tpcCBpdGVyYXRpb24gaW5zdGVhZCBvZiBhIGNvbmRpdGlvbiBhdCB0aGUgZW5kLicKICBTdHlsZUd1aWRlOiAnI25vLW5lc3RlZC1jb25kaXRpb25hbHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMjInCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjM1JwogICMgV2l0aCBgYWx3YXlzYCBhbGwgY29uZGl0aW9ucyBhdCB0aGUgZW5kIG9mIGFuIGl0ZXJhdGlvbiBuZWVkcyB0byBiZQogICMgcmVwbGFjZWQgYnkgbmV4dCAtIHdpdGggYHNraXBfbW9kaWZpZXJfaWZzYCB0aGUgbW9kaWZpZXIgaWYgbGlrZSB0aGlzIG9uZQogICMgYXJlIGlnbm9yZWQ6IFsxLCAyXS5lYWNoIHsgfGF8IHJldHVybiAneWVzJyBpZiBhID09IDEgfQogIEVuZm9yY2VkU3R5bGU6IHNraXBfbW9kaWZpZXJfaWZzCiAgIyBgTWluQm9keUxlbmd0aGAgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGxpbmVzIG9mIHRoZSBhIGJvZHkgb2YgYW4gYGlmYCBvciBgdW5sZXNzYAogICMgbmVlZHMgdG8gaGF2ZSB0byB0cmlnZ2VyIHRoaXMgY29wCiAgTWluQm9keUxlbmd0aDogMwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc2tpcF9tb2RpZmllcl9pZnMKICAgIC0gYWx3YXlzCgpTdHlsZS9OaWxDb21wYXJpc29uOgogIERlc2NyaXB0aW9uOiAnUHJlZmVyIHgubmlsPyB0byB4ID09IG5pbC4nCiAgU3R5bGVHdWlkZTogJyNwcmVkaWNhdGUtbWV0aG9kcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xMicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNTknCiAgRW5mb3JjZWRTdHlsZTogcHJlZGljYXRlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBwcmVkaWNhdGUKICAgIC0gY29tcGFyaXNvbgoKU3R5bGUvTmlsTGFtYmRhOgogIERlc2NyaXB0aW9uOiAnUHJlZmVyIGAtPiB7fWAgdG8gYC0+IHsgbmlsIH1gLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4zJwogIFZlcnNpb25DaGFuZ2VkOiAnMS4xNScKClN0eWxlL05vbk5pbENoZWNrOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWR1bmRhbnQgbmlsIGNoZWNrcy4nCiAgU3R5bGVHdWlkZTogJyNuby1ub24tbmlsLWNoZWNrcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4yMCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuMjInCiAgIyBXaXRoIGBJbmNsdWRlU2VtYW50aWNDaGFuZ2VzYCBzZXQgdG8gYHRydWVgLCB0aGlzIGNvcCByZXBvcnRzIG9mZmVuc2VzIGZvcgogICMgYCF4Lm5pbD9gIGFuZCBhdXRvY29ycmVjdHMgdGhhdCBhbmQgYHggIT0gbmlsYCB0byBzb2xlbHkgYHhgLCB3aGljaCBpcwogICMgKip1c3VhbGx5KiogT0ssIGJ1dCBtaWdodCBjaGFuZ2UgYmVoYXZpb3IuCiAgIwogICMgV2l0aCBgSW5jbHVkZVNlbWFudGljQ2hhbmdlc2Agc2V0IHRvIGBmYWxzZWAsIHRoaXMgY29wIGRvZXMgbm90IHJlcG9ydAogICMgb2ZmZW5zZXMgZm9yIGAheC5uaWw/YCBhbmQgZG9lcyBubyBjaGFuZ2VzIHRoYXQgbWlnaHQgY2hhbmdlIGJlaGF2aW9yLgogIEluY2x1ZGVTZW1hbnRpY0NoYW5nZXM6IGZhbHNlCgpTdHlsZS9Ob3Q6CiAgRGVzY3JpcHRpb246ICdVc2UgISBpbnN0ZWFkIG9mIG5vdC4nCiAgU3R5bGVHdWlkZTogJyNiYW5nLW5vdC1ub3QnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMjAnCgpTdHlsZS9OdW1iZXJlZFBhcmFtZXRlcnM6CiAgRGVzY3JpcHRpb246ICdSZXN0cmljdCB0aGUgdXNhZ2Ugb2YgbnVtYmVyZWQgcGFyYW1ldGVycy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMjInCiAgRW5mb3JjZWRTdHlsZTogYWxsb3dfc2luZ2xlX2xpbmUKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGFsbG93X3NpbmdsZV9saW5lCiAgICAtIGRpc2FsbG93CgpTdHlsZS9OdW1iZXJlZFBhcmFtZXRlcnNMaW1pdDoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIGV4Y2Vzc2l2ZSBudW1iZXJlZCBwYXJhbXMgaW4gYSBzaW5nbGUgYmxvY2suJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjIyJwogIE1heDogMQoKU3R5bGUvTnVtZXJpY0xpdGVyYWxQcmVmaXg6CiAgRGVzY3JpcHRpb246ICdVc2Ugc21hbGxjYXNlIHByZWZpeGVzIGZvciBudW1lcmljIGxpdGVyYWxzLicKICBTdHlsZUd1aWRlOiAnI251bWVyaWMtbGl0ZXJhbC1wcmVmaXhlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40MScKICBFbmZvcmNlZE9jdGFsU3R5bGU6IHplcm9fd2l0aF9vCiAgU3VwcG9ydGVkT2N0YWxTdHlsZXM6CiAgICAtIHplcm9fd2l0aF9vCiAgICAtIHplcm9fb25seQoKU3R5bGUvTnVtZXJpY0xpdGVyYWxzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEFkZCB1bmRlcnNjb3JlcyB0byBsYXJnZSBudW1lcmljIGxpdGVyYWxzIHRvIGltcHJvdmUgdGhlaXIKICAgICAgICAgICAgICAgICByZWFkYWJpbGl0eS4KICBTdHlsZUd1aWRlOiAnI3VuZGVyc2NvcmVzLWluLW51bWVyaWNzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ4JwogIE1pbkRpZ2l0czogNQogIFN0cmljdDogZmFsc2UKICAjIFlvdSBjYW4gc3BlY2lmeSBhbGxvd2VkIG51bWJlcnMuIChlLmcuIHBvcnQgbnVtYmVyIDMwMDAsIDgwODAsIGFuZCBldGMpCiAgQWxsb3dlZE51bWJlcnM6IFtdCiAgQWxsb3dlZFBhdHRlcm5zOiBbXQoKU3R5bGUvTnVtZXJpY1ByZWRpY2F0ZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIHRoZSB1c2Ugb2YgcHJlZGljYXRlLSBvciBjb21wYXJpc29uIG1ldGhvZHMgZm9yCiAgICAgICAgICAgICAgICAgbnVtZXJpYyBjb21wYXJpc29ucy4KICBTdHlsZUd1aWRlOiAnI3ByZWRpY2F0ZS1tZXRob2RzJwogICMgVGhpcyB3aWxsIGNoYW5nZSB0byBhIG5ldyBtZXRob2QgY2FsbCB3aGljaCBpc24ndCBndWFyYW50ZWVkIHRvIGJlIG9uIHRoZQogICMgb2JqZWN0LiBTd2l0Y2hpbmcgdGhlc2UgbWV0aG9kcyBoYXMgdG8gYmUgZG9uZSB3aXRoIGtub3dsZWRnZSBvZiB0aGUgdHlwZXMKICAjIG9mIHRoZSB2YXJpYWJsZXMgd2hpY2ggcnVib2NvcCBkb2Vzbid0IGhhdmUuCiAgU2FmZTogZmFsc2UKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC40MicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNTknCiAgRW5mb3JjZWRTdHlsZTogcHJlZGljYXRlCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBwcmVkaWNhdGUKICAgIC0gY29tcGFyaXNvbgogIEFsbG93ZWRNZXRob2RzOiBbXQogIEFsbG93ZWRQYXR0ZXJuczogW10KICAjIEV4Y2x1ZGUgUlNwZWMgc3BlY3MgYmVjYXVzZSBhc3NlcnRpb25zIGxpa2UgYGV4cGVjdCgxKS50byBiZSA+IDBgIGNhdXNlCiAgIyBmYWxzZSBwb3NpdGl2ZXMuCiAgRXhjbHVkZToKICAgIC0gJ3NwZWMvKiovKicKClN0eWxlL09iamVjdFRoZW46CiAgRGVzY3JpcHRpb246ICdFbmZvcmNlcyB0aGUgdXNlIG9mIGNvbnNpc3RlbnQgbWV0aG9kIG5hbWVzIGBPYmplY3QjeWllbGRfc2VsZmAgb3IgYE9iamVjdCN0aGVuYC4nCiAgU3R5bGVHdWlkZTogJyNvYmplY3QteWllbGQtc2VsZi12cy1vYmplY3QtdGhlbicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4yOCcKICAjIFVzZSBgT2JqZWN0I3lpZWxkX3NlbGZgIG9yIGBPYmplY3QjdGhlbmA/CiAgIyBQcmVmZXIgYE9iamVjdCN5aWVsZF9zZWxmYCB0byBgT2JqZWN0I3RoZW5gICh5aWVsZF9zZWxmKQogICMgUHJlZmVyIGBPYmplY3QjdGhlbmAgdG8gYE9iamVjdCN5aWVsZF9zZWxmYCAodGhlbikKICBFbmZvcmNlZFN0eWxlOiAndGhlbicKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHRoZW4KICAgIC0geWllbGRfc2VsZgoKU3R5bGUvT25lTGluZUNvbmRpdGlvbmFsOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIEZhdm9yIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yICg/Oikgb3IgbXVsdGktbGluZSBjb25zdHJ1Y3RzIG92ZXIKICAgICAgICAgICAgICAgICBzaW5nbGUtbGluZSBpZi90aGVuL2Vsc2UvZW5kIGNvbnN0cnVjdHMuCiAgU3R5bGVHdWlkZTogJyN0ZXJuYXJ5LW9wZXJhdG9yJwogIEVuYWJsZWQ6IHRydWUKICBBbHdheXNDb3JyZWN0VG9NdWx0aWxpbmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC45MCcKClN0eWxlL09wZW5TdHJ1Y3RVc2U6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQXZvaWQgdXNpbmcgT3BlblN0cnVjdC4gQXMgb2YgUnVieSAzLjAsIHVzZSBpcyBvZmZpY2lhbGx5IGRpc2NvdXJhZ2VkIGR1ZSB0byBwZXJmb3JtYW5jZSwKICAgICAgICAgICAgICAgICB2ZXJzaW9uIGNvbXBhdGliaWxpdHksIGFuZCBwb3RlbnRpYWwgc2VjdXJpdHkgaXNzdWVzLgogIFJlZmVyZW5jZToKICAgIC0gaHR0cHM6Ly9kb2NzLnJ1YnktbGFuZy5vcmcvZW4vMy4wLjAvT3BlblN0cnVjdC5odG1sI2NsYXNzLU9wZW5TdHJ1Y3QtbGFiZWwtQ2F2ZWF0cwoKICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjIzJwogIFZlcnNpb25DaGFuZ2VkOiAnMS41MScKClN0eWxlL09wZXJhdG9yTWV0aG9kQ2FsbDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcmVkdW5kYW50IGRvdCBiZWZvcmUgb3BlcmF0b3IgbWV0aG9kIGNhbGwuJwogIFN0eWxlR3VpZGU6ICcjb3BlcmF0b3ItbWV0aG9kLWNhbGwnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzcnCgpTdHlsZS9PcHRpb25IYXNoOgogIERlc2NyaXB0aW9uOiAiRG9uJ3QgdXNlIG9wdGlvbiBoYXNoZXMgd2hlbiB5b3UgY2FuIHVzZSBrZXl3b3JkIGFyZ3VtZW50cy4iCiAgU3R5bGVHdWlkZTogJyNrZXl3b3JkLWFyZ3VtZW50cy12cy1vcHRpb24taGFzaGVzJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMycKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzQnCiAgIyBBIGxpc3Qgb2YgcGFyYW1ldGVyIG5hbWVzIHRoYXQgd2lsbCBiZSBmbGFnZ2VkIGJ5IHRoaXMgY29wLgogIFN1c3BpY2lvdXNQYXJhbU5hbWVzOgogICAgLSBvcHRpb25zCiAgICAtIG9wdHMKICAgIC0gYXJncwogICAgLSBwYXJhbXMKICAgIC0gcGFyYW1ldGVycwogIEFsbG93bGlzdDogW10KClN0eWxlL09wdGlvbmFsQXJndW1lbnRzOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3Igb3B0aW9uYWwgYXJndW1lbnRzIHRoYXQgZG8gbm90IGFwcGVhciBhdCB0aGUgZW5kCiAgICAgICAgICAgICAgICAgb2YgdGhlIGFyZ3VtZW50IGxpc3QuCiAgU3R5bGVHdWlkZTogJyNvcHRpb25hbC1hcmd1bWVudHMnCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMycKICBWZXJzaW9uQ2hhbmdlZDogJzAuODMnCgpTdHlsZS9PcHRpb25hbEJvb2xlYW5QYXJhbWV0ZXI6CiAgRGVzY3JpcHRpb246ICdVc2Uga2V5d29yZCBhcmd1bWVudHMgd2hlbiBkZWZpbmluZyBtZXRob2Qgd2l0aCBib29sZWFuIGFyZ3VtZW50LicKICBTdHlsZUd1aWRlOiAnI2Jvb2xlYW4ta2V5d29yZC1hcmd1bWVudHMnCiAgRW5hYmxlZDogdHJ1ZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44OScKICBBbGxvd2VkTWV0aG9kczoKICAgIC0gcmVzcG9uZF90b19taXNzaW5nPwoKU3R5bGUvT3JBc3NpZ25tZW50OgogIERlc2NyaXB0aW9uOiAnUmVjb21tZW5kIHVzYWdlIG9mIGRvdWJsZSBwaXBlIGVxdWFscyAofHw9KSB3aGVyZSBhcHBsaWNhYmxlLicKICBTdHlsZUd1aWRlOiAnI2RvdWJsZS1waXBlLWZvci11bmluaXQnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTAnCgpTdHlsZS9QYXJhbGxlbEFzc2lnbm1lbnQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIENoZWNrIGZvciBzaW1wbGUgdXNhZ2VzIG9mIHBhcmFsbGVsIGFzc2lnbm1lbnQuCiAgICAgICAgICAgICAgICAgIEl0IHdpbGwgb25seSB3YXJuIHdoZW4gdGhlIG51bWJlciBvZiB2YXJpYWJsZXMKICAgICAgICAgICAgICAgICAgbWF0Y2hlcyBvbiBib3RoIHNpZGVzIG9mIHRoZSBhc3NpZ25tZW50LgogIFN0eWxlR3VpZGU6ICcjcGFyYWxsZWwtYXNzaWdubWVudCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMicKClN0eWxlL1BhcmVudGhlc2VzQXJvdW5kQ29uZGl0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIERvbid0IHVzZSBwYXJlbnRoZXNlcyBhcm91bmQgdGhlIGNvbmRpdGlvbiBvZiBhbgogICAgICAgICAgICAgICAgIGlmL3VubGVzcy93aGlsZS4KICBTdHlsZUd1aWRlOiAnI25vLXBhcmVucy1hcm91bmQtY29uZGl0aW9uJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjU2JwogIEFsbG93U2FmZUFzc2lnbm1lbnQ6IHRydWUKICBBbGxvd0luTXVsdGlsaW5lQ29uZGl0aW9uczogZmFsc2UKClN0eWxlL1BlcmNlbnRMaXRlcmFsRGVsaW1pdGVyczoKICBEZXNjcmlwdGlvbjogJ1VzZSBgJWAtbGl0ZXJhbCBkZWxpbWl0ZXJzIGNvbnNpc3RlbnRseS4nCiAgU3R5bGVHdWlkZTogJyNwZXJjZW50LWxpdGVyYWwtYnJhY2VzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjE5JwogICMgU3BlY2lmeSB0aGUgZGVmYXVsdCBwcmVmZXJyZWQgZGVsaW1pdGVyIGZvciBhbGwgdHlwZXMgd2l0aCB0aGUgJ2RlZmF1bHQnIGtleQogICMgT3ZlcnJpZGUgaW5kaXZpZHVhbCBkZWxpbWl0ZXJzIChldmVuIHdpdGggZGVmYXVsdCBzcGVjaWZpZWQpIGJ5IHNwZWNpZnlpbmcKICAjIGFuIGluZGl2aWR1YWwga2V5CiAgUHJlZmVycmVkRGVsaW1pdGVyczoKICAgIGRlZmF1bHQ6ICgpCiAgICAnJWknOiAnW10nCiAgICAnJUknOiAnW10nCiAgICAnJXInOiAne30nCiAgICAnJXcnOiAnW10nCiAgICAnJVcnOiAnW10nCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ4JwoKU3R5bGUvUGVyY2VudFFMaXRlcmFsczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBpZiB1c2VzIG9mICVRLyVxIG1hdGNoIHRoZSBjb25maWd1cmVkIHByZWZlcmVuY2UuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjI1JwogIEVuZm9yY2VkU3R5bGU6IGxvd2VyX2Nhc2VfcQogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gbG93ZXJfY2FzZV9xICMgVXNlIGAlcWAgd2hlbiBwb3NzaWJsZSwgYCVRYCB3aGVuIG5lY2Vzc2FyeQogICAgLSB1cHBlcl9jYXNlX3EgIyBBbHdheXMgdXNlIGAlUWAKClN0eWxlL1BlcmxCYWNrcmVmczoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIFBlcmwtc3R5bGUgcmVnZXggYmFjayByZWZlcmVuY2VzLicKICBTdHlsZUd1aWRlOiAnI25vLXBlcmwtcmVnZXhwLWxhc3QtbWF0Y2hlcnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTMnCgpTdHlsZS9QcmVmZXJyZWRIYXNoTWV0aG9kczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyB1c2Ugb2YgYGhhc19rZXk/YCBhbmQgYGhhc192YWx1ZT9gIEhhc2ggbWV0aG9kcy4nCiAgU3R5bGVHdWlkZTogJyNoYXNoLWtleScKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjQxJwogIFZlcnNpb25DaGFuZ2VkOiAnMC43MCcKICBFbmZvcmNlZFN0eWxlOiBzaG9ydAogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc2hvcnQKICAgIC0gdmVyYm9zZQoKU3R5bGUvUHJvYzoKICBEZXNjcmlwdGlvbjogJ1VzZSBwcm9jIGluc3RlYWQgb2YgUHJvYy5uZXcuJwogIFN0eWxlR3VpZGU6ICcjcHJvYycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4xOCcKClN0eWxlL1F1b3RlZFN5bWJvbHM6CiAgRGVzY3JpcHRpb246ICdVc2UgYSBjb25zaXN0ZW50IHN0eWxlIGZvciBxdW90ZWQgc3ltYm9scy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMTYnCiAgRW5mb3JjZWRTdHlsZTogc2FtZV9hc19zdHJpbmdfbGl0ZXJhbHMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNhbWVfYXNfc3RyaW5nX2xpdGVyYWxzCiAgICAtIHNpbmdsZV9xdW90ZXMKICAgIC0gZG91YmxlX3F1b3RlcwoKU3R5bGUvUmFpc2VBcmdzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHJhaXNlL2ZhaWwuJwogIFN0eWxlR3VpZGU6ICcjZXhjZXB0aW9uLWNsYXNzLW1lc3NhZ2VzJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMTQnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYxJwogIEVuZm9yY2VkU3R5bGU6IGV4cGxvZGVkCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBjb21wYWN0ICMgcmFpc2UgRXhjZXB0aW9uLm5ldyhtc2cpCiAgICAtIGV4cGxvZGVkICMgcmFpc2UgRXhjZXB0aW9uLCBtc2cKICBBbGxvd2VkQ29tcGFjdFR5cGVzOiBbXQoKU3R5bGUvUmFuZG9tV2l0aE9mZnNldDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBQcmVmZXIgdG8gdXNlIHJhbmdlcyB3aGVuIGdlbmVyYXRpbmcgcmFuZG9tIG51bWJlcnMgaW5zdGVhZCBvZgogICAgICAgICAgICAgICAgIGludGVnZXJzIHdpdGggb2Zmc2V0cy4KICBTdHlsZUd1aWRlOiAnI3JhbmRvbS1udW1iZXJzJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwoKU3R5bGUvUmVkdW5kYW50QXJndW1lbnQ6CiAgRGVzY3JpcHRpb246ICdDaGVjayBmb3IgYSByZWR1bmRhbnQgYXJndW1lbnQgcGFzc2VkIHRvIGNlcnRhaW4gbWV0aG9kcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40JwogIFZlcnNpb25DaGFuZ2VkOiAnMS41NScKICBNZXRob2RzOgogICAgIyBBcnJheSNqb2luCiAgICBqb2luOiAnJwogICAgIyBBcnJheSNzdW0KICAgIHN1bTogMAogICAgIyBLZXJuZWwuI2V4aXQKICAgIGV4aXQ6IHRydWUKICAgICMgS2VybmVsLiNleGl0IQogICAgZXhpdCE6IGZhbHNlCiAgICAjIFN0cmluZyNzcGxpdAogICAgc3BsaXQ6ICcgJwogICAgIyBTdHJpbmcjY2hvbXAKICAgIGNob21wOiAiXG4iCiAgICAjIFN0cmluZyNjaG9tcCEKICAgIGNob21wITogIlxuIgoKU3R5bGUvUmVkdW5kYW50QXJyYXlDb25zdHJ1Y3RvcjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdGhlIGluc3RhbnRpYXRpb24gb2YgYXJyYXkgdXNpbmcgcmVkdW5kYW50IGBBcnJheWAgY29uc3RydWN0b3IuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjUyJwoKU3R5bGUvUmVkdW5kYW50QXNzaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcmVkdW5kYW50IGFzc2lnbm1lbnQgYmVmb3JlIHJldHVybmluZy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuODcnCgpTdHlsZS9SZWR1bmRhbnRCZWdpbjoKICBEZXNjcmlwdGlvbjogIkRvbid0IHVzZSBiZWdpbiBibG9ja3Mgd2hlbiB0aGV5IGFyZSBub3QgbmVlZGVkLiIKICBTdHlsZUd1aWRlOiAnI2JlZ2luLWltcGxpY2l0JwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEwJwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yMScKClN0eWxlL1JlZHVuZGFudENhcGl0YWxXOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciAlVyB3aGVuIGludGVycG9sYXRpb24gaXMgbm90IG5lZWRlZC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNzYnCgpTdHlsZS9SZWR1bmRhbnRDb25kaXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHVubmVjZXNzYXJ5IGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC43NicKClN0eWxlL1JlZHVuZGFudENvbmRpdGlvbmFsOgogIERlc2NyaXB0aW9uOiAiRG9uJ3QgcmV0dXJuIHRydWUvZmFsc2UgZnJvbSBhIGNvbmRpdGlvbmFsLiIKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKClN0eWxlL1JlZHVuZGFudENvbnN0YW50QmFzZToKICBEZXNjcmlwdGlvbjogQXZvaWQgcmVkdW5kYW50IGA6OmAgcHJlZml4IG9uIGNvbnN0YW50LgogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjQwJwoKU3R5bGUvUmVkdW5kYW50Q3VycmVudERpcmVjdG9yeUluUGF0aDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlcyBhIHJlZHVuZGFudCBjdXJyZW50IGRpcmVjdG9yeSBpbiBwYXRoLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41MycKClN0eWxlL1JlZHVuZGFudERvdWJsZVNwbGF0SGFzaEJyYWNlczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcmVkdW5kYW50IHVzZXMgb2YgZG91YmxlIHNwbGF0IGhhc2ggYnJhY2VzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS40MScKClN0eWxlL1JlZHVuZGFudEVhY2g6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBgZWFjaGAuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMzgnCgpTdHlsZS9SZWR1bmRhbnRFeGNlcHRpb246CiAgRGVzY3JpcHRpb246ICJDaGVja3MgZm9yIGFuIG9ic29sZXRlIFJ1bnRpbWVFeGNlcHRpb24gYXJndW1lbnQgaW4gcmFpc2UvZmFpbC4iCiAgU3R5bGVHdWlkZTogJyNuby1leHBsaWNpdC1ydW50aW1lZXJyb3InCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTQnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjI5JwoKU3R5bGUvUmVkdW5kYW50RmV0Y2hCbG9jazoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgVXNlIGBmZXRjaChrZXksIHZhbHVlKWAgaW5zdGVhZCBvZiBgZmV0Y2goa2V5KSB7IHZhbHVlIH1gCiAgICAgICAgICAgICAgICAgIHdoZW4gdmFsdWUgaGFzIE51bWVyaWMsIFJhdGlvbmFsLCBDb21wbGV4LCBTeW1ib2wgb3IgU3RyaW5nIHR5cGUsIGBmYWxzZWAsIGB0cnVlYCwgYG5pbGAgb3IgaXMgYSBjb25zdGFudC4KICBSZWZlcmVuY2U6ICdodHRwczovL2dpdGh1Yi5jb20vZmFzdHJ1YnkvZmFzdC1ydWJ5I2hhc2hmZXRjaC13aXRoLWFyZ3VtZW50LXZzLWhhc2hmZXRjaC0tYmxvY2stY29kZScKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICAjIElmIGVuYWJsZWQsIHRoaXMgY29wIHdpbGwgYXV0b2NvcnJlY3QgdXNhZ2VzIG9mCiAgIyBgZmV0Y2hgIGJlaW5nIGNhbGxlZCB3aXRoIGJsb2NrIHJldHVybmluZyBhIGNvbnN0YW50LgogICMgVGhpcyBjYW4gYmUgZGFuZ2Vyb3VzIHNpbmNlIGNvbnN0YW50cyB3aWxsIG5vdCBiZSBkZWZpbmVkIGF0IHRoYXQgbW9tZW50LgogIFNhZmVGb3JDb25zdGFudHM6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC44NicKClN0eWxlL1JlZHVuZGFudEZpbGVFeHRlbnNpb25JblJlcXVpcmU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIHN1cGVyZmx1b3VzIGAucmJgIGV4dGVuc2lvbiBpbgogICAgICAgICAgICAgICAgICB0aGUgZmlsZW5hbWUgcHJvdmlkZWQgdG8gYHJlcXVpcmVgIGFuZCBgcmVxdWlyZV9yZWxhdGl2ZWAuCiAgU3R5bGVHdWlkZTogJyNuby1leHBsaWNpdC1yYi10by1yZXF1aXJlJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjg4JwoKU3R5bGUvUmVkdW5kYW50RmlsdGVyQ2hhaW46CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIElkZW50aWZpZXMgdXNhZ2VzIG9mIGBhbnk/YCwgYGVtcHR5P2AsIGBub25lP2Agb3IgYG9uZT9gIHByZWRpY2F0ZSBtZXRob2RzIGNoYWluZWQgdG8KICAgICAgICAgICAgICAgICAgYHNlbGVjdGAvYGZpbHRlcmAvYGZpbmRfYWxsYCBhbmQgY2hhbmdlIHRoZW0gdG8gdXNlIHByZWRpY2F0ZSBtZXRob2QgaW5zdGVhZC4KICBFbmFibGVkOiBwZW5kaW5nCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuNTInCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjU3JwoKU3R5bGUvUmVkdW5kYW50RnJlZXplOgogIERlc2NyaXB0aW9uOiAiQ2hlY2tzIHVzYWdlcyBvZiBPYmplY3QjZnJlZXplIG9uIGltbXV0YWJsZSBvYmplY3RzLiIKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuNjYnCgpTdHlsZS9SZWR1bmRhbnRIZXJlZG9jRGVsaW1pdGVyUXVvdGVzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWR1bmRhbnQgaGVyZWRvYyBkZWxpbWl0ZXIgcXVvdGVzLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS40NScKClN0eWxlL1JlZHVuZGFudEluaXRpYWxpemU6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBgaW5pdGlhbGl6ZWAgbWV0aG9kcy4nCiAgRW5hYmxlZDogcGVuZGluZwogIEF1dG9Db3JyZWN0OiBjb250ZXh0dWFsCiAgU2FmZTogZmFsc2UKICBBbGxvd0NvbW1lbnRzOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMS4yNycKICBWZXJzaW9uQ2hhbmdlZDogJzEuNjEnCgpTdHlsZS9SZWR1bmRhbnRJbnRlcnBvbGF0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciBzdHJpbmdzIHRoYXQgYXJlIGp1c3QgYW4gaW50ZXJwb2xhdGVkIGV4cHJlc3Npb24uJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC43NicKICBWZXJzaW9uQ2hhbmdlZDogJzEuMzAnCgpTdHlsZS9SZWR1bmRhbnRMaW5lQ29udGludWF0aW9uOgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgZm9yIHJlZHVuZGFudCBsaW5lIGNvbnRpbnVhdGlvbi4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuNDknCgpTdHlsZS9SZWR1bmRhbnRQYXJlbnRoZXNlczoKICBEZXNjcmlwdGlvbjogIkNoZWNrcyBmb3IgcGFyZW50aGVzZXMgdGhhdCBzZWVtIG5vdCB0byBzZXJ2ZSBhbnkgcHVycG9zZS4iCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzYnCgpTdHlsZS9SZWR1bmRhbnRQZXJjZW50UToKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgJXEvJVEgd2hlbiBzaW5nbGUgcXVvdGVzIG9yIGRvdWJsZSBxdW90ZXMgd291bGQgZG8uJwogIFN0eWxlR3VpZGU6ICcjcGVyY2VudC1xJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjc2JwoKU3R5bGUvUmVkdW5kYW50UmVnZXhwQXJndW1lbnQ6CiAgRGVzY3JpcHRpb246ICdJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBhcmd1bWVudCBjYW4gYmUgcmVwbGFjZWQgZnJvbSBhIGRldGVybWluaXN0aWMgcmVnZXhwIHRvIGEgc3RyaW5nLicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41MycKClN0eWxlL1JlZHVuZGFudFJlZ2V4cENoYXJhY3RlckNsYXNzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1bm5lY2Vzc2FyeSBzaW5nbGUtZWxlbWVudCBSZWdleHAgY2hhcmFjdGVyIGNsYXNzZXMuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjg1JwoKU3R5bGUvUmVkdW5kYW50UmVnZXhwQ29uc3RydWN0b3I6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHRoZSBpbnN0YW50aWF0aW9uIG9mIHJlZ2V4cCB1c2luZyByZWR1bmRhbnQgYFJlZ2V4cC5uZXdgIG9yIGBSZWdleHAuY29tcGlsZWAuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjUyJwoKU3R5bGUvUmVkdW5kYW50UmVnZXhwRXNjYXBlOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciByZWR1bmRhbnQgZXNjYXBlcyBpbiBSZWdleHBzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44NScKClN0eWxlL1JlZHVuZGFudFJldHVybjoKICBEZXNjcmlwdGlvbjogIkRvbid0IHVzZSByZXR1cm4gd2hlcmUgaXQncyBub3QgcmVxdWlyZWQuIgogIFN0eWxlR3VpZGU6ICcjbm8tZXhwbGljaXQtcmV0dXJuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjEwJwogIFZlcnNpb25DaGFuZ2VkOiAnMC4xNCcKICAjIFdoZW4gYHRydWVgIGFsbG93cyBjb2RlIGxpa2UgYHJldHVybiB4LCB5YC4KICBBbGxvd011bHRpcGxlUmV0dXJuVmFsdWVzOiBmYWxzZQoKU3R5bGUvUmVkdW5kYW50U2VsZjoKICBEZXNjcmlwdGlvbjogIkRvbid0IHVzZSBzZWxmIHdoZXJlIGl0J3Mgbm90IG5lZWRlZC4iCiAgU3R5bGVHdWlkZTogJyNuby1zZWxmLXVubGVzcy1yZXF1aXJlZCcKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xMCcKICBWZXJzaW9uQ2hhbmdlZDogJzAuMTMnCgpTdHlsZS9SZWR1bmRhbnRTZWxmQXNzaWdubWVudDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIHJlZHVuZGFudCBhc3NpZ25tZW50cyBhcmUgbWFkZSBmb3IgaW4gcGxhY2UgbW9kaWZpY2F0aW9uIG1ldGhvZHMuJwogIEVuYWJsZWQ6IHRydWUKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuOTAnCgpTdHlsZS9SZWR1bmRhbnRTZWxmQXNzaWdubWVudEJyYW5jaDoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIGNvbmRpdGlvbmFsIGJyYW5jaCBtYWtlcyByZWR1bmRhbnQgc2VsZi1hc3NpZ25tZW50LicKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS4xOScKClN0eWxlL1JlZHVuZGFudFNvcnQ6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgIFVzZSBgbWluYCBpbnN0ZWFkIG9mIGBzb3J0LmZpcnN0YCwKICAgICAgICAgICAgICAgICAgYG1heF9ieWAgaW5zdGVhZCBvZiBgc29ydF9ieS4uLmxhc3RgLCBldGMuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNzYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjIyJwogIFNhZmU6IGZhbHNlCgpTdHlsZS9SZWR1bmRhbnRTb3J0Qnk6CiAgRGVzY3JpcHRpb246ICdVc2UgYHNvcnRgIGluc3RlYWQgb2YgYHNvcnRfYnkgeyB8eHwgeCB9YC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzYnCgpTdHlsZS9SZWR1bmRhbnRTdHJpbmdFc2NhcGU6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBlc2NhcGVzIGluIHN0cmluZyBsaXRlcmFscy4nCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMzcnCgpTdHlsZS9SZWdleHBMaXRlcmFsOgogIERlc2NyaXB0aW9uOiAnVXNlIC8gb3IgJXIgYXJvdW5kIHJlZ3VsYXIgZXhwcmVzc2lvbnMuJwogIFN0eWxlR3VpZGU6ICcjcGVyY2VudC1yJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjMwJwogIEVuZm9yY2VkU3R5bGU6IHNsYXNoZXMKICAjIHNsYXNoZXM6IEFsd2F5cyB1c2Ugc2xhc2hlcy4KICAjIHBlcmNlbnRfcjogQWx3YXlzIHVzZSBgJXJgLgogICMgbWl4ZWQ6IFVzZSBzbGFzaGVzIG9uIHNpbmdsZS1saW5lIHJlZ2V4ZXMsIGFuZCBgJXJgIG9uIG11bHRpLWxpbmUgcmVnZXhlcy4KICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNsYXNoZXMKICAgIC0gcGVyY2VudF9yCiAgICAtIG1peGVkCiAgIyBJZiBgZmFsc2VgLCB0aGUgY29wIHdpbGwgYWx3YXlzIHJlY29tbWVuZCB1c2luZyBgJXJgIGlmIG9uZSBvciBtb3JlIHNsYXNoZXMKICAjIGFyZSBmb3VuZCBpbiB0aGUgcmVnZXhwIHN0cmluZy4KICBBbGxvd0lubmVyU2xhc2hlczogZmFsc2UKClN0eWxlL1JlcXVpcmVPcmRlcjoKICBEZXNjcmlwdGlvbjogU29ydCBgcmVxdWlyZWAgYW5kIGByZXF1aXJlX3JlbGF0aXZlYCBpbiBhbHBoYWJldGljYWwgb3JkZXIuCiAgRW5hYmxlZDogZmFsc2UKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40MCcKClN0eWxlL1Jlc2N1ZU1vZGlmaWVyOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgdXNpbmcgcmVzY3VlIGluIGl0cyBtb2RpZmllciBmb3JtLicKICBTdHlsZUd1aWRlOiAnI25vLXJlc2N1ZS1tb2RpZmllcnMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzQnCgpTdHlsZS9SZXNjdWVTdGFuZGFyZEVycm9yOgogIERlc2NyaXB0aW9uOiAnQXZvaWQgcmVzY3Vpbmcgd2l0aG91dCBzcGVjaWZ5aW5nIGFuIGVycm9yIGNsYXNzLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MicKICBFbmZvcmNlZFN0eWxlOiBleHBsaWNpdAogICMgaW1wbGljaXQ6IERvIG5vdCBpbmNsdWRlIHRoZSBlcnJvciBjbGFzcywgYHJlc2N1ZWAKICAjIGV4cGxpY2l0OiBSZXF1aXJlIGFuIGVycm9yIGNsYXNzIGByZXNjdWUgU3RhbmRhcmRFcnJvcmAKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIGltcGxpY2l0CiAgICAtIGV4cGxpY2l0CgpTdHlsZS9SZXR1cm5OaWw6CiAgRGVzY3JpcHRpb246ICdVc2UgcmV0dXJuIGluc3RlYWQgb2YgcmV0dXJuIG5pbC4nCiAgRW5hYmxlZDogZmFsc2UKICBFbmZvcmNlZFN0eWxlOiByZXR1cm4KICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHJldHVybgogICAgLSByZXR1cm5fbmlsCiAgVmVyc2lvbkFkZGVkOiAnMC41MCcKClN0eWxlL1JldHVybk5pbEluUHJlZGljYXRlTWV0aG9kRGVmaW5pdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBpZiB1c2VzIG9mIGByZXR1cm5gIG9yIGByZXR1cm4gbmlsYCBpbiBwcmVkaWNhdGUgbWV0aG9kIGRlZmluaXRpb24uJwogIFN0eWxlR3VpZGU6ICcjYm9vbC1tZXRob2RzLXFtYXJrJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgQWxsb3dlZE1ldGhvZHM6IFtdCiAgQWxsb3dlZFBhdHRlcm5zOiBbXQogIFZlcnNpb25BZGRlZDogJzEuNTMnCgpTdHlsZS9TYWZlTmF2aWdhdGlvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtcyB1c2FnZXMgb2YgYSBtZXRob2QgY2FsbCBzYWZlZ3VhcmRlZCBieQogICAgICAgICAgICAgICAgICBhIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBvYmplY3QgdG8KICAgICAgICAgICAgICAgICAgc2FmZSBuYXZpZ2F0aW9uIChgJi5gKS4KICAgICAgICAgICAgICAgICAgQXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGFzIGl0IGFzc3VtZXMgdGhlIG9iamVjdCB3aWxsCiAgICAgICAgICAgICAgICAgIGJlIGBuaWxgIG9yIHRydXRoeSwgYnV0IG5ldmVyIGBmYWxzZWAuCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDMnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjI3JwogICMgU2FmZSBuYXZpZ2F0aW9uIG1heSBjYXVzZSBhIHN0YXRlbWVudCB0byBzdGFydCByZXR1cm5pbmcgYG5pbGAgaW4gYWRkaXRpb24KICAjIHRvIHdoYXRldmVyIGl0IHVzZWQgdG8gcmV0dXJuLgogIENvbnZlcnRDb2RlVGhhdENhblN0YXJ0VG9SZXR1cm5OaWw6IGZhbHNlCiAgQWxsb3dlZE1ldGhvZHM6CiAgICAtIHByZXNlbnQ/CiAgICAtIGJsYW5rPwogICAgLSBwcmVzZW5jZQogICAgLSB0cnkKICAgIC0gdHJ5IQogIFNhZmVBdXRvQ29ycmVjdDogZmFsc2UKICAjIE1heGltdW0gbGVuZ3RoIG9mIG1ldGhvZCBjaGFpbnMgZm9yIHJlZ2lzdGVyIGFuIG9mZmVuc2UuCiAgTWF4Q2hhaW5MZW5ndGg6IDIKClN0eWxlL1NhbXBsZToKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICAgVXNlIGBzYW1wbGVgIGluc3RlYWQgb2YgYHNodWZmbGUuZmlyc3RgLAogICAgICAgICAgICAgICAgICBgc2h1ZmZsZS5sYXN0YCwgYW5kIGBzaHVmZmxlW0ludGVnZXJdYC4KICBSZWZlcmVuY2U6ICdodHRwczovL2dpdGh1Yi5jb20vZmFzdHJ1YnkvZmFzdC1ydWJ5I2FycmF5c2h1ZmZsZWZpcnN0LXZzLWFycmF5c2FtcGxlLWNvZGUnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzAnCgpTdHlsZS9TZWxlY3RCeVJlZ2V4cDoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBncmVwL2dyZXBfdiB0byBzZWxlY3QvcmVqZWN0IHdpdGggYSByZWdleHAgbWF0Y2guJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS4yMicKClN0eWxlL1NlbGZBc3NpZ25tZW50OgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIHNlbGYtYXNzaWdubWVudCBzaG9ydGhhbmQgc2hvdWxkIGhhdmUKICAgICAgICAgICAgICAgICBiZWVuIHVzZWQuCiAgU3R5bGVHdWlkZTogJyNzZWxmLWFzc2lnbm1lbnQnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjI5JwoKU3R5bGUvU2VtaWNvbG9uOgogIERlc2NyaXB0aW9uOiAiRG9uJ3QgdXNlIHNlbWljb2xvbnMgdG8gdGVybWluYXRlIGV4cHJlc3Npb25zLiIKICBTdHlsZUd1aWRlOiAnI25vLXNlbWljb2xvbicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4xOScKICAjIEFsbG93IGA7YCB0byBzZXBhcmF0ZSBzZXZlcmFsIGV4cHJlc3Npb25zIG9uIHRoZSBzYW1lIGxpbmUuCiAgQWxsb3dBc0V4cHJlc3Npb25TZXBhcmF0b3I6IGZhbHNlCgpTdHlsZS9TZW5kOgogIERlc2NyaXB0aW9uOiAnUHJlZmVyIGBPYmplY3QjX19zZW5kX19gIG9yIGBPYmplY3QjcHVibGljX3NlbmRgIHRvIGBzZW5kYCwgYXMgYHNlbmRgIG1heSBvdmVybGFwIHdpdGggZXhpc3RpbmcgbWV0aG9kcy4nCiAgU3R5bGVHdWlkZTogJyNwcmVmZXItcHVibGljLXNlbmQnCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjMzJwoKU3R5bGUvU2VuZFdpdGhMaXRlcmFsTWV0aG9kTmFtZToKICBEZXNjcmlwdGlvbjogJ0RldGVjdHMgdGhlIHVzZSBvZiB0aGUgYHB1YmxpY19zZW5kYCBtZXRob2Qgd2l0aCBhIHN0YXRpYyBtZXRob2QgbmFtZSBhcmd1bWVudC4nCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgQWxsb3dTZW5kOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMS42NCcKClN0eWxlL1NpZ25hbEV4Y2VwdGlvbjoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgcHJvcGVyIHVzYWdlIG9mIGZhaWwgYW5kIHJhaXNlLicKICBTdHlsZUd1aWRlOiAnI3ByZWZlci1yYWlzZS1vdmVyLWZhaWwnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMTEnCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjM3JwogIEVuZm9yY2VkU3R5bGU6IG9ubHlfcmFpc2UKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIG9ubHlfcmFpc2UKICAgIC0gb25seV9mYWlsCiAgICAtIHNlbWFudGljCgpTdHlsZS9TaW5nbGVBcmd1bWVudERpZzoKICBEZXNjcmlwdGlvbjogJ0F2b2lkIHVzaW5nIHNpbmdsZSBhcmd1bWVudCBkaWcgbWV0aG9kLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44OScKICBTYWZlOiBmYWxzZQoKU3R5bGUvU2luZ2xlTGluZUJsb2NrUGFyYW1zOgogIERlc2NyaXB0aW9uOiAnRW5mb3JjZXMgdGhlIG5hbWVzIG9mIHNvbWUgYmxvY2sgcGFyYW1zLicKICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMTYnCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjYnCiAgTWV0aG9kczoKICAgIC0gcmVkdWNlOgogICAgICAgIC0gYWNjCiAgICAgICAgLSBlbGVtCiAgICAtIGluamVjdDoKICAgICAgICAtIGFjYwogICAgICAgIC0gZWxlbQoKU3R5bGUvU2luZ2xlTGluZURvRW5kQmxvY2s6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHNpbmdsZS1saW5lIGBkb2AuLi5gZW5kYCBibG9ja3MuJwogIFN0eWxlR3VpZGU6ICcjc2luZ2xlLWxpbmUtZG8tZW5kLWJsb2NrJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjU3JwoKU3R5bGUvU2luZ2xlTGluZU1ldGhvZHM6CiAgRGVzY3JpcHRpb246ICdBdm9pZCBzaW5nbGUtbGluZSBtZXRob2RzLicKICBTdHlsZUd1aWRlOiAnI25vLXNpbmdsZS1saW5lLW1ldGhvZHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzEuOCcKICBBbGxvd0lmTWV0aG9kSXNFbXB0eTogdHJ1ZQoKU3R5bGUvU2xpY2luZ1dpdGhSYW5nZToKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBhcnJheSBzbGljaW5nIGlzIGRvbmUgd2l0aCByZWR1bmRhbnQsIGVuZGxlc3MsIGFuZCBiZWdpbmxlc3MgcmFuZ2VzIHdoZW4gc3VpdGFibGUuJwogIFN0eWxlR3VpZGU6ICcjc2xpY2luZy13aXRoLXJhbmdlcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44MycKICBTYWZlOiBmYWxzZQoKU3R5bGUvU29sZU5lc3RlZENvbmRpdGlvbmFsOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgICBGaW5kcyBzb2xlIG5lc3RlZCBjb25kaXRpb25hbCBub2RlcwogICAgICAgICAgICAgICAgICB3aGljaCBjYW4gYmUgbWVyZ2VkIGludG8gb3V0ZXIgY29uZGl0aW9uYWwgbm9kZS4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC44OScKICBWZXJzaW9uQ2hhbmdlZDogJzEuNScKICBBbGxvd01vZGlmaWVyOiBmYWxzZQoKU3R5bGUvU3BlY2lhbEdsb2JhbFZhcnM6CiAgRGVzY3JpcHRpb246ICdBdm9pZCBQZXJsLXN0eWxlIGdsb2JhbCB2YXJpYWJsZXMuJwogIFN0eWxlR3VpZGU6ICcjbm8tY3J5cHRpYy1wZXJsaXNtcycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4xMycKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzYnCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFJlcXVpcmVFbmdsaXNoOiB0cnVlCiAgRW5mb3JjZWRTdHlsZTogdXNlX2VuZ2xpc2hfbmFtZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHVzZV9wZXJsX25hbWVzCiAgICAtIHVzZV9lbmdsaXNoX25hbWVzCiAgICAtIHVzZV9idWlsdGluX2VuZ2xpc2hfbmFtZXMKClN0eWxlL1N0YWJieUxhbWJkYVBhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2sgZm9yIHRoZSB1c2FnZSBvZiBwYXJlbnRoZXNlcyBhcm91bmQgc3RhYmJ5IGxhbWJkYSBhcmd1bWVudHMuJwogIFN0eWxlR3VpZGU6ICcjc3RhYmJ5LWxhbWJkYS13aXRoLWFyZ3MnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuMzUnCiAgRW5mb3JjZWRTdHlsZTogcmVxdWlyZV9wYXJlbnRoZXNlcwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gcmVxdWlyZV9wYXJlbnRoZXNlcwogICAgLSByZXF1aXJlX25vX3BhcmVudGhlc2VzCgpTdHlsZS9TdGF0aWNDbGFzczoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBtb2R1bGVzIHRvIGNsYXNzZXMgd2l0aCBvbmx5IGNsYXNzIG1ldGhvZHMuJwogIFN0eWxlR3VpZGU6ICcjbW9kdWxlcy12cy1jbGFzc2VzJwogIEVuYWJsZWQ6IGZhbHNlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcxLjMnCgpTdHlsZS9TdGRlcnJQdXRzOgogIERlc2NyaXB0aW9uOiAnVXNlIGB3YXJuYCBpbnN0ZWFkIG9mIGAkc3RkZXJyLnB1dHNgLicKICBTdHlsZUd1aWRlOiAnI3dhcm4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTEnCgpTdHlsZS9TdHJpbmdDaGFyczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBmb3IgdXNlcyBvZiBgU3RyaW5nI3NwbGl0YCB3aXRoIGVtcHR5IHN0cmluZyBvciByZWdleHAgbGl0ZXJhbCBhcmd1bWVudC4nCiAgU3R5bGVHdWlkZTogJyNzdHJpbmctY2hhcnMnCiAgRW5hYmxlZDogcGVuZGluZwogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS4xMicKClN0eWxlL1N0cmluZ0NvbmNhdGVuYXRpb246CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHBsYWNlcyB3aGVyZSBzdHJpbmcgY29uY2F0ZW5hdGlvbiBjYW4gYmUgcmVwbGFjZWQgd2l0aCBzdHJpbmcgaW50ZXJwb2xhdGlvbi4nCiAgU3R5bGVHdWlkZTogJyNzdHJpbmctaW50ZXJwb2xhdGlvbicKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjg5JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4xOCcKICBNb2RlOiBhZ2dyZXNzaXZlCgpTdHlsZS9TdHJpbmdIYXNoS2V5czoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBzeW1ib2xzIGluc3RlYWQgb2Ygc3RyaW5ncyBhcyBoYXNoIGtleXMuJwogIFN0eWxlR3VpZGU6ICcjc3ltYm9scy1hcy1rZXlzJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMC41MicKICBWZXJzaW9uQ2hhbmdlZDogJzAuNzUnCiAgU2FmZTogZmFsc2UKClN0eWxlL1N0cmluZ0xpdGVyYWxzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGlmIHVzZXMgb2YgcXVvdGVzIG1hdGNoIHRoZSBjb25maWd1cmVkIHByZWZlcmVuY2UuJwogIFN0eWxlR3VpZGU6ICcjY29uc2lzdGVudC1zdHJpbmctbGl0ZXJhbHMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzYnCiAgRW5mb3JjZWRTdHlsZTogc2luZ2xlX3F1b3RlcwogIFN1cHBvcnRlZFN0eWxlczoKICAgIC0gc2luZ2xlX3F1b3RlcwogICAgLSBkb3VibGVfcXVvdGVzCiAgIyBJZiBgdHJ1ZWAsIHN0cmluZ3Mgd2hpY2ggc3BhbiBtdWx0aXBsZSBsaW5lcyB1c2luZyBgXGAgZm9yIGNvbnRpbnVhdGlvbiBtdXN0CiAgIyB1c2UgdGhlIHNhbWUgdHlwZSBvZiBxdW90ZXMgb24gZWFjaCBsaW5lLgogIENvbnNpc3RlbnRRdW90ZXNJbk11bHRpbGluZTogZmFsc2UKClN0eWxlL1N0cmluZ0xpdGVyYWxzSW5JbnRlcnBvbGF0aW9uOgogIERlc2NyaXB0aW9uOiA+LQogICAgICAgICAgICAgICAgIENoZWNrcyBpZiB1c2VzIG9mIHF1b3RlcyBpbnNpZGUgZXhwcmVzc2lvbnMgaW4gaW50ZXJwb2xhdGVkCiAgICAgICAgICAgICAgICAgc3RyaW5ncyBtYXRjaCB0aGUgY29uZmlndXJlZCBwcmVmZXJlbmNlLgogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjI3JwogIEVuZm9yY2VkU3R5bGU6IHNpbmdsZV9xdW90ZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHNpbmdsZV9xdW90ZXMKICAgIC0gZG91YmxlX3F1b3RlcwoKU3R5bGUvU3RyaW5nTWV0aG9kczoKICBEZXNjcmlwdGlvbjogJ0NoZWNrcyBpZiBjb25maWd1cmVkIHByZWZlcnJlZCBtZXRob2RzIGFyZSB1c2VkIG92ZXIgbm9uLXByZWZlcnJlZC4nCiAgRW5hYmxlZDogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjM0JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4zNCcKICAjIE1hcHBpbmcgZnJvbSB1bmRlc2lyZWQgbWV0aG9kIHRvIGRlc2lyZWRfbWV0aG9kCiAgIyBlLmcuIHRvIHVzZSBgdG9fc3ltYCBvdmVyIGBpbnRlcm5gOgogICMKICAjIFN0cmluZ01ldGhvZHM6CiAgIyAgIFByZWZlcnJlZE1ldGhvZHM6CiAgIyAgICAgaW50ZXJuOiB0b19zeW0KICBQcmVmZXJyZWRNZXRob2RzOgogICAgaW50ZXJuOiB0b19zeW0KClN0eWxlL1N0cmlwOgogIERlc2NyaXB0aW9uOiAnVXNlIGBzdHJpcGAgaW5zdGVhZCBvZiBgbHN0cmlwLnJzdHJpcGAuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjM2JwoKU3R5bGUvU3RydWN0SW5oZXJpdGFuY2U6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIGluaGVyaXRhbmNlIGZyb20gU3RydWN0Lm5ldy4nCiAgU3R5bGVHdWlkZTogJyNuby1leHRlbmQtc3RydWN0LW5ldycKICBFbmFibGVkOiB0cnVlCiAgU2FmZUF1dG9Db3JyZWN0OiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuMjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcxLjIwJwoKU3R5bGUvU3VwZXJBcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICdDYWxsIGBzdXBlcmAgd2l0aG91dCBhcmd1bWVudHMgYW5kIHBhcmVudGhlc2VzIHdoZW4gdGhlIHNpZ25hdHVyZSBpcyBpZGVudGljYWwuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjY0JwoKU3R5bGUvU3VwZXJXaXRoQXJnc1BhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnVXNlIHBhcmVudGhlc2VzIGZvciBgc3VwZXJgIHdpdGggYXJndW1lbnRzLicKICBTdHlsZUd1aWRlOiAnI3N1cGVyLXdpdGgtYXJncycKICBFbmFibGVkOiBwZW5kaW5nCiAgVmVyc2lvbkFkZGVkOiAnMS41OCcKClN0eWxlL1N3YXBWYWx1ZXM6CiAgRGVzY3JpcHRpb246ICdFbmZvcmNlcyB0aGUgdXNlIG9mIHNob3J0aGFuZC1zdHlsZSBzd2FwcGluZyBvZiAyIHZhcmlhYmxlcy4nCiAgU3R5bGVHdWlkZTogJyN2YWx1ZXMtc3dhcHBpbmcnCiAgRW5hYmxlZDogcGVuZGluZwogIFZlcnNpb25BZGRlZDogJzEuMScKICBTYWZlQXV0b0NvcnJlY3Q6IGZhbHNlCgpTdHlsZS9TeW1ib2xBcnJheToKICBEZXNjcmlwdGlvbjogJ1VzZSAlaSBvciAlSSBmb3IgYXJyYXlzIG9mIHN5bWJvbHMuJwogIFN0eWxlR3VpZGU6ICcjcGVyY2VudC1pJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ5JwogIEVuZm9yY2VkU3R5bGU6IHBlcmNlbnQKICBNaW5TaXplOiAyCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBwZXJjZW50CiAgICAtIGJyYWNrZXRzCgpTdHlsZS9TeW1ib2xMaXRlcmFsOgogIERlc2NyaXB0aW9uOiAnVXNlIHBsYWluIHN5bWJvbHMgaW5zdGVhZCBvZiBzdHJpbmcgc3ltYm9scyB3aGVuIHBvc3NpYmxlLicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMCcKClN0eWxlL1N5bWJvbFByb2M6CiAgRGVzY3JpcHRpb246ICdVc2Ugc3ltYm9scyBhcyBwcm9jcyBpbnN0ZWFkIG9mIGJsb2NrcyB3aGVuIHBvc3NpYmxlLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjI2JwogIFZlcnNpb25DaGFuZ2VkOiAnMS42NCcKICBBbGxvd01ldGhvZHNXaXRoQXJndW1lbnRzOiBmYWxzZQogICMgQSBsaXN0IG9mIG1ldGhvZCBuYW1lcyB0byBiZSBhbHdheXMgYWxsb3dlZCBieSB0aGUgY2hlY2suCiAgIyBUaGUgbmFtZXMgc2hvdWxkIGJlIGZhaXJseSB1bmlxdWUsIG90aGVyd2lzZSB5b3UnbGwgZW5kIHVwIGlnbm9yaW5nIGxvdHMgb2YgY29kZS4KICBBbGxvd2VkTWV0aG9kczoKICAgIC0gZGVmaW5lX21ldGhvZAogIEFsbG93ZWRQYXR0ZXJuczogW10KICBBbGxvd0NvbW1lbnRzOiBmYWxzZQoKU3R5bGUvVGVybmFyeVBhcmVudGhlc2VzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2Ugb2YgcGFyZW50aGVzZXMgYXJvdW5kIHRlcm5hcnkgY29uZGl0aW9ucy4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNDInCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjQ2JwogIEVuZm9yY2VkU3R5bGU6IHJlcXVpcmVfbm9fcGFyZW50aGVzZXMKICBTdXBwb3J0ZWRTdHlsZXM6CiAgICAtIHJlcXVpcmVfcGFyZW50aGVzZXMKICAgIC0gcmVxdWlyZV9ub19wYXJlbnRoZXNlcwogICAgLSByZXF1aXJlX3BhcmVudGhlc2VzX3doZW5fY29tcGxleAogIEFsbG93U2FmZUFzc2lnbm1lbnQ6IHRydWUKClN0eWxlL1RvcExldmVsTWV0aG9kRGVmaW5pdGlvbjoKICBEZXNjcmlwdGlvbjogJ0xvb2tzIGZvciB0b3AtbGV2ZWwgbWV0aG9kIGRlZmluaXRpb25zLicKICBTdHlsZUd1aWRlOiAnI3RvcC1sZXZlbC1tZXRob2RzJwogIEVuYWJsZWQ6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS4xNScKClN0eWxlL1RyYWlsaW5nQm9keU9uQ2xhc3M6CiAgRGVzY3JpcHRpb246ICdDbGFzcyBib2R5IGdvZXMgYmVsb3cgY2xhc3Mgc3RhdGVtZW50LicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKClN0eWxlL1RyYWlsaW5nQm9keU9uTWV0aG9kRGVmaW5pdGlvbjoKICBEZXNjcmlwdGlvbjogJ01ldGhvZCBib2R5IGdvZXMgYmVsb3cgZGVmaW5pdGlvbi4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTInCgpTdHlsZS9UcmFpbGluZ0JvZHlPbk1vZHVsZToKICBEZXNjcmlwdGlvbjogJ01vZHVsZSBib2R5IGdvZXMgYmVsb3cgbW9kdWxlIHN0YXRlbWVudC4nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCgpTdHlsZS9UcmFpbGluZ0NvbW1hSW5Bcmd1bWVudHM6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHRyYWlsaW5nIGNvbW1hIGluIGFyZ3VtZW50IGxpc3RzLicKICBTdHlsZUd1aWRlOiAnI25vLXRyYWlsaW5nLXBhcmFtcy1jb21tYScKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zNicKICAjIElmIGBjb21tYWAsIHRoZSBjb3AgcmVxdWlyZXMgYSBjb21tYSBhZnRlciB0aGUgbGFzdCBhcmd1bWVudCwgYnV0IG9ubHkgZm9yCiAgIyBwYXJlbnRoZXNpemVkIG1ldGhvZCBjYWxscyB3aGVyZSBlYWNoIGFyZ3VtZW50IGlzIG9uIGl0cyBvd24gbGluZS4KICAjIElmIGBjb25zaXN0ZW50X2NvbW1hYCwgdGhlIGNvcCByZXF1aXJlcyBhIGNvbW1hIGFmdGVyIHRoZSBsYXN0IGFyZ3VtZW50LAogICMgZm9yIGFsbCBwYXJlbnRoZXNpemVkIG1ldGhvZCBjYWxscyB3aXRoIGFyZ3VtZW50cy4KICBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBub19jb21tYQogIFN1cHBvcnRlZFN0eWxlc0Zvck11bHRpbGluZToKICAgIC0gY29tbWEKICAgIC0gY29uc2lzdGVudF9jb21tYQogICAgLSBub19jb21tYQoKU3R5bGUvVHJhaWxpbmdDb21tYUluQXJyYXlMaXRlcmFsOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB0cmFpbGluZyBjb21tYSBpbiBhcnJheSBsaXRlcmFscy4nCiAgU3R5bGVHdWlkZTogJyNuby10cmFpbGluZy1hcnJheS1jb21tYXMnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuNTMnCiAgIyBJZiBgY29tbWFgLCB0aGUgY29wIHJlcXVpcmVzIGEgY29tbWEgYWZ0ZXIgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheSwKICAjIGJ1dCBvbmx5IHdoZW4gZWFjaCBpdGVtIGlzIG9uIGl0cyBvd24gbGluZS4KICAjIElmIGBjb25zaXN0ZW50X2NvbW1hYCwgdGhlIGNvcCByZXF1aXJlcyBhIGNvbW1hIGFmdGVyIHRoZSBsYXN0IGl0ZW0gb2YgYWxsCiAgIyBub24tZW1wdHksIG11bHRpbGluZSBhcnJheSBsaXRlcmFscy4KICBFbmZvcmNlZFN0eWxlRm9yTXVsdGlsaW5lOiBub19jb21tYQogIFN1cHBvcnRlZFN0eWxlc0Zvck11bHRpbGluZToKICAgIC0gY29tbWEKICAgIC0gY29uc2lzdGVudF9jb21tYQogICAgLSBub19jb21tYQoKU3R5bGUvVHJhaWxpbmdDb21tYUluQmxvY2tBcmdzOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB1c2VsZXNzIHRyYWlsaW5nIGNvbW1hcyBpbiBibG9jayBhcmd1bWVudHMuJwogIEVuYWJsZWQ6IGZhbHNlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjgxJwoKU3R5bGUvVHJhaWxpbmdDb21tYUluSGFzaExpdGVyYWw6CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHRyYWlsaW5nIGNvbW1hIGluIGhhc2ggbGl0ZXJhbHMuJwogIEVuYWJsZWQ6IHRydWUKICAjIElmIGBjb21tYWAsIHRoZSBjb3AgcmVxdWlyZXMgYSBjb21tYSBhZnRlciB0aGUgbGFzdCBpdGVtIGluIGEgaGFzaCwKICAjIGJ1dCBvbmx5IHdoZW4gZWFjaCBpdGVtIGlzIG9uIGl0cyBvd24gbGluZS4KICAjIElmIGBjb25zaXN0ZW50X2NvbW1hYCwgdGhlIGNvcCByZXF1aXJlcyBhIGNvbW1hIGFmdGVyIHRoZSBsYXN0IGl0ZW0gb2YgYWxsCiAgIyBub24tZW1wdHksIG11bHRpbGluZSBoYXNoIGxpdGVyYWxzLgogIEVuZm9yY2VkU3R5bGVGb3JNdWx0aWxpbmU6IG5vX2NvbW1hCiAgU3VwcG9ydGVkU3R5bGVzRm9yTXVsdGlsaW5lOgogICAgLSBjb21tYQogICAgLSBjb25zaXN0ZW50X2NvbW1hCiAgICAtIG5vX2NvbW1hCiAgVmVyc2lvbkFkZGVkOiAnMC41MycKClN0eWxlL1RyYWlsaW5nTWV0aG9kRW5kU3RhdGVtZW50OgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB0cmFpbGluZyBlbmQgc3RhdGVtZW50IG9uIGxpbmUgb2YgbWV0aG9kIGJvZHkuJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjUyJwoKU3R5bGUvVHJhaWxpbmdVbmRlcnNjb3JlVmFyaWFibGU6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB0aGUgdXNhZ2Ugb2YgdW5uZWVkZWQgdHJhaWxpbmcgdW5kZXJzY29yZXMgYXQgdGhlCiAgICAgICAgICAgICAgICAgZW5kIG9mIHBhcmFsbGVsIHZhcmlhYmxlIGFzc2lnbm1lbnQuCiAgQWxsb3dOYW1lZFVuZGVyc2NvcmVWYXJpYWJsZXM6IHRydWUKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC4zMScKICBWZXJzaW9uQ2hhbmdlZDogJzAuMzUnCgojIGBUcml2aWFsQWNjZXNzb3JzYCByZXF1aXJlcyBleGFjdCBuYW1lIG1hdGNoZXMgYW5kIGRvZXNuJ3QgYWxsb3cKIyBwcmVkaWNhdGVkIG1ldGhvZHMgYnkgZGVmYXVsdC4KU3R5bGUvVHJpdmlhbEFjY2Vzc29yczoKICBEZXNjcmlwdGlvbjogJ1ByZWZlciBhdHRyXyogbWV0aG9kcyB0byB0cml2aWFsIHJlYWRlcnMvd3JpdGVycy4nCiAgU3R5bGVHdWlkZTogJyNhdHRyX2ZhbWlseScKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4xNScKICAjIFdoZW4gc2V0IHRvIGBmYWxzZWAgdGhlIGNvcCB3aWxsIHN1Z2dlc3QgdGhlIHVzZSBvZiBhY2Nlc3NvciBtZXRob2RzCiAgIyBpbiBzaXR1YXRpb25zIGxpa2U6CiAgIwogICMgZGVmIG5hbWUKICAjICAgQG90aGVyX25hbWUKICAjIGVuZAogICMKICAjIFRoaXMgd2F5IHlvdSBjYW4gdW5jb3ZlciAiaGlkZGVuIiBhdHRyaWJ1dGVzIGluIHlvdXIgY29kZS4KICBFeGFjdE5hbWVNYXRjaDogdHJ1ZQogIEFsbG93UHJlZGljYXRlczogdHJ1ZQogICMgQWxsb3dzIHRyaXZpYWwgd3JpdGVycyB0aGF0IGRvbid0IGVuZCBpbiBhbiBlcXVhbCBzaWduLiBlLmcuCiAgIwogICMgZGVmIG9uX2V4Y2VwdGlvbihhY3Rpb24pCiAgIyAgIEBvbl9leGNlcHRpb249YWN0aW9uCiAgIyBlbmQKICAjIG9uX2V4Y2VwdGlvbiA6cmVzdGFydAogICMKICAjIENvbW1vbmx5IHVzZWQgaW4gRFNMcwogIEFsbG93RFNMV3JpdGVyczogdHJ1ZQogIElnbm9yZUNsYXNzTWV0aG9kczogZmFsc2UKICBBbGxvd2VkTWV0aG9kczoKICAgIC0gdG9fYXJ5CiAgICAtIHRvX2EKICAgIC0gdG9fYwogICAgLSB0b19lbnVtCiAgICAtIHRvX2gKICAgIC0gdG9faGFzaAogICAgLSB0b19pCiAgICAtIHRvX2ludAogICAgLSB0b19pbwogICAgLSB0b19vcGVuCiAgICAtIHRvX3BhdGgKICAgIC0gdG9fcHJvYwogICAgLSB0b19yCiAgICAtIHRvX3JlZ2V4cAogICAgLSB0b19zdHIKICAgIC0gdG9fcwogICAgLSB0b19zeW0KClN0eWxlL1VubGVzc0Vsc2U6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgRG8gbm90IHVzZSB1bmxlc3Mgd2l0aCBlbHNlLiBSZXdyaXRlIHRoZXNlIHdpdGggdGhlIHBvc2l0aXZlCiAgICAgICAgICAgICAgICAgY2FzZSBmaXJzdC4KICBTdHlsZUd1aWRlOiAnI25vLWVsc2Utd2l0aC11bmxlc3MnCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKClN0eWxlL1VubGVzc0xvZ2ljYWxPcGVyYXRvcnM6CiAgRGVzY3JpcHRpb246ID4tCiAgICAgICAgICAgICAgICAgQ2hlY2tzIGZvciB1c2Ugb2YgbG9naWNhbCBvcGVyYXRvcnMgaW4gYW4gdW5sZXNzIGNvbmRpdGlvbi4KICBFbmFibGVkOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzEuMTEnCiAgRW5mb3JjZWRTdHlsZTogZm9yYmlkX21peGVkX2xvZ2ljYWxfb3BlcmF0b3JzCiAgU3VwcG9ydGVkU3R5bGVzOgogICAgLSBmb3JiaWRfbWl4ZWRfbG9naWNhbF9vcGVyYXRvcnMKICAgIC0gZm9yYmlkX2xvZ2ljYWxfb3BlcmF0b3JzCgpTdHlsZS9VbnBhY2tGaXJzdDoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBDaGVja3MgZm9yIGFjY2Vzc2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgU3RyaW5nI3VucGFja2AKICAgICAgICAgICAgICAgICBpbnN0ZWFkIG9mIHVzaW5nIGB1bnBhY2sxYC4KICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC41NCcKClN0eWxlL1ZhcmlhYmxlSW50ZXJwb2xhdGlvbjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBEb24ndCBpbnRlcnBvbGF0ZSBnbG9iYWwsIGluc3RhbmNlIGFuZCBjbGFzcyB2YXJpYWJsZXMKICAgICAgICAgICAgICAgICBkaXJlY3RseSBpbiBzdHJpbmdzLgogIFN0eWxlR3VpZGU6ICcjY3VybGllcy1pbnRlcnBvbGF0ZScKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4yMCcKClN0eWxlL1doZW5UaGVuOgogIERlc2NyaXB0aW9uOiAnVXNlIHdoZW4geCB0aGVuIC4uLiBmb3Igb25lLWxpbmUgY2FzZXMuJwogIFN0eWxlR3VpZGU6ICcjbm8td2hlbi1zZW1pY29sb25zJwogIEVuYWJsZWQ6IHRydWUKICBWZXJzaW9uQWRkZWQ6ICcwLjknCgpTdHlsZS9XaGlsZVVudGlsRG86CiAgRGVzY3JpcHRpb246ICdDaGVja3MgZm9yIHJlZHVuZGFudCBkbyBhZnRlciB3aGlsZSBvciB1bnRpbC4nCiAgU3R5bGVHdWlkZTogJyNuby1tdWx0aWxpbmUtd2hpbGUtZG8nCiAgRW5hYmxlZDogdHJ1ZQogIFZlcnNpb25BZGRlZDogJzAuOScKClN0eWxlL1doaWxlVW50aWxNb2RpZmllcjoKICBEZXNjcmlwdGlvbjogPi0KICAgICAgICAgICAgICAgICBGYXZvciBtb2RpZmllciB3aGlsZS91bnRpbCB1c2FnZSB3aGVuIHlvdSBoYXZlIGEKICAgICAgICAgICAgICAgICBzaW5nbGUtbGluZSBib2R5LgogIFN0eWxlR3VpZGU6ICcjd2hpbGUtYXMtYS1tb2RpZmllcicKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4zMCcKClN0eWxlL1dvcmRBcnJheToKICBEZXNjcmlwdGlvbjogJ1VzZSAldyBvciAlVyBmb3IgYXJyYXlzIG9mIHdvcmRzLicKICBTdHlsZUd1aWRlOiAnI3BlcmNlbnQtdycKICBFbmFibGVkOiB0cnVlCiAgVmVyc2lvbkFkZGVkOiAnMC45JwogIFZlcnNpb25DaGFuZ2VkOiAnMS4xOScKICBFbmZvcmNlZFN0eWxlOiBwZXJjZW50CiAgU3VwcG9ydGVkU3R5bGVzOgogICAgIyBwZXJjZW50IHN0eWxlOiAldyh3b3JkMSB3b3JkMikKICAgIC0gcGVyY2VudAogICAgIyBicmFja2V0IHN0eWxlOiBbJ3dvcmQxJywgJ3dvcmQyJ10KICAgIC0gYnJhY2tldHMKICAjIFRoZSBgTWluU2l6ZWAgb3B0aW9uIGNhdXNlcyB0aGUgYFdvcmRBcnJheWAgcnVsZSB0byBiZSBpZ25vcmVkIGZvciBhcnJheXMKICAjIHNtYWxsZXIgdGhhbiBhIGNlcnRhaW4gc2l6ZS4gVGhlIHJ1bGUgaXMgb25seSBhcHBsaWVkIHRvIGFycmF5cwogICMgd2hvc2UgZWxlbWVudCBjb3VudCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYE1pblNpemVgLgogIE1pblNpemU6IDIKICAjIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gYFdvcmRSZWdleGAgZGVjaWRlcyB3aGF0IGlzIGNvbnNpZGVyZWQgYSB3b3JkLgogIFdvcmRSZWdleDogIXJ1YnkvcmVnZXhwICcvXEEoPzpccHtXb3JkfXxccHtXb3JkfS1ccHtXb3JkfXxcbnxcdCkrXHovJwoKU3R5bGUvWUFNTEZpbGVSZWFkOgogIERlc2NyaXB0aW9uOiAnQ2hlY2tzIGZvciB0aGUgdXNlIG9mIGBZQU1MLmxvYWRgLCBgWUFNTC5zYWZlX2xvYWRgLCBhbmQgYFlBTUwucGFyc2VgIHdpdGggYEZpbGUucmVhZGAgYXJndW1lbnQuJwogIEVuYWJsZWQ6IHBlbmRpbmcKICBWZXJzaW9uQWRkZWQ6ICcxLjUzJwoKU3R5bGUvWW9kYUNvbmRpdGlvbjoKICBEZXNjcmlwdGlvbjogJ0ZvcmJpZCBvciBlbmZvcmNlIHlvZGEgY29uZGl0aW9ucy4nCiAgUmVmZXJlbmNlOiAnaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWW9kYV9jb25kaXRpb25zJwogIEVuYWJsZWQ6IHRydWUKICBFbmZvcmNlZFN0eWxlOiBmb3JiaWRfZm9yX2FsbF9jb21wYXJpc29uX29wZXJhdG9ycwogIFN1cHBvcnRlZFN0eWxlczoKICAgICMgY2hlY2sgYWxsIGNvbXBhcmlzb24gb3BlcmF0b3JzCiAgICAtIGZvcmJpZF9mb3JfYWxsX2NvbXBhcmlzb25fb3BlcmF0b3JzCiAgICAjIGNoZWNrIG9ubHkgZXF1YWxpdHkgb3BlcmF0b3JzOiBgIT1gIGFuZCBgPT1gCiAgICAtIGZvcmJpZF9mb3JfZXF1YWxpdHlfb3BlcmF0b3JzX29ubHkKICAgICMgZW5mb3JjZSB5b2RhIGZvciBhbGwgY29tcGFyaXNvbiBvcGVyYXRvcnMKICAgIC0gcmVxdWlyZV9mb3JfYWxsX2NvbXBhcmlzb25fb3BlcmF0b3JzCiAgICAjIGVuZm9yY2UgeW9kYSBvbmx5IGZvciBlcXVhbGl0eSBvcGVyYXRvcnM6IGAhPWAgYW5kIGA9PWAKICAgIC0gcmVxdWlyZV9mb3JfZXF1YWxpdHlfb3BlcmF0b3JzX29ubHkKICBTYWZlOiBmYWxzZQogIFZlcnNpb25BZGRlZDogJzAuNDknCiAgVmVyc2lvbkNoYW5nZWQ6ICcwLjc1JwoKU3R5bGUvWW9kYUV4cHJlc3Npb246CiAgRGVzY3JpcHRpb246ICdGb3JiaWQgdGhlIHVzZSBvZiB5b2RhIGV4cHJlc3Npb25zLicKICBFbmFibGVkOiBmYWxzZQogIFNhZmU6IGZhbHNlCiAgVmVyc2lvbkFkZGVkOiAnMS40MicKICBWZXJzaW9uQ2hhbmdlZDogJzEuNDMnCiAgU3VwcG9ydGVkT3BlcmF0b3JzOgogICAgLSAnKicKICAgIC0gJysnCiAgICAtICcmJwogICAgLSAnfCcKICAgIC0gJ14nCgpTdHlsZS9aZXJvTGVuZ3RoUHJlZGljYXRlOgogIERlc2NyaXB0aW9uOiAnVXNlICNlbXB0eT8gd2hlbiB0ZXN0aW5nIGZvciBvYmplY3RzIG9mIGxlbmd0aCAwLicKICBFbmFibGVkOiB0cnVlCiAgU2FmZTogZmFsc2UKICBWZXJzaW9uQWRkZWQ6ICcwLjM3JwogIFZlcnNpb25DaGFuZ2VkOiAnMC4zOScK
  recorded_at: Mon, 27 May 2024 05:30:41 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-minitest/v0.35.0/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '4688'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"b134cca5e6426fbfc4801f80d04852b720b5d563bf622c8d287a4390ed2ca619"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - C7B6:23E66:1397602:14D0702:66541A71
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:41 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230111-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787842.796924,VS0,VE173
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - d0451d36186f81a5c07ec7b7a69b64e34d28d4f1
      Expires:
      - Mon, 27 May 2024 05:35:41 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        = Cops

        In RuboCop lingo the various checks performed on the code are called cops.
        Each cop is responsible for detecting one particular offense.
        RuboCop Minitest has only one Minitest department.

        == Minitest

        Minitest cops check for Minitest best practices and coding conventions. Many of the them are
        based on the https://minitest.rubystyle.guide/[Minitest Style Guide].

        // START_COP_LIST

        === Department xref:cops_minitest.adoc[Minitest]

        * xref:cops_minitest.adoc#minitestassertempty[Minitest/AssertEmpty]
        * xref:cops_minitest.adoc#minitestassertemptyliteral[Minitest/AssertEmptyLiteral]
        * xref:cops_minitest.adoc#minitestassertequal[Minitest/AssertEqual]
        * xref:cops_minitest.adoc#minitestassertindelta[Minitest/AssertInDelta]
        * xref:cops_minitest.adoc#minitestassertincludes[Minitest/AssertIncludes]
        * xref:cops_minitest.adoc#minitestassertinstanceof[Minitest/AssertInstanceOf]
        * xref:cops_minitest.adoc#minitestassertkindof[Minitest/AssertKindOf]
        * xref:cops_minitest.adoc#minitestassertmatch[Minitest/AssertMatch]
        * xref:cops_minitest.adoc#minitestassertnil[Minitest/AssertNil]
        * xref:cops_minitest.adoc#minitestassertoperator[Minitest/AssertOperator]
        * xref:cops_minitest.adoc#minitestassertoutput[Minitest/AssertOutput]
        * xref:cops_minitest.adoc#minitestassertpathexists[Minitest/AssertPathExists]
        * xref:cops_minitest.adoc#minitestassertpredicate[Minitest/AssertPredicate]
        * xref:cops_minitest.adoc#minitestassertraisescompoundbody[Minitest/AssertRaisesCompoundBody]
        * xref:cops_minitest.adoc#minitestassertraiseswithregexpargument[Minitest/AssertRaisesWithRegexpArgument]
        * xref:cops_minitest.adoc#minitestassertrespondto[Minitest/AssertRespondTo]
        * xref:cops_minitest.adoc#minitestassertsame[Minitest/AssertSame]
        * xref:cops_minitest.adoc#minitestassertsilent[Minitest/AssertSilent]
        * xref:cops_minitest.adoc#minitestasserttruthy[Minitest/AssertTruthy]
        * xref:cops_minitest.adoc#minitestassertwithexpectedargument[Minitest/AssertWithExpectedArgument]
        * xref:cops_minitest.adoc#minitestassertioninlifecyclehook[Minitest/AssertionInLifecycleHook]
        * xref:cops_minitest.adoc#minitestduplicatetestrun[Minitest/DuplicateTestRun]
        * xref:cops_minitest.adoc#minitestemptylinebeforeassertionmethods[Minitest/EmptyLineBeforeAssertionMethods]
        * xref:cops_minitest.adoc#minitestfocus[Minitest/Focus]
        * xref:cops_minitest.adoc#minitestglobalexpectations[Minitest/GlobalExpectations]
        * xref:cops_minitest.adoc#minitestlifecyclehooksorder[Minitest/LifecycleHooksOrder]
        * xref:cops_minitest.adoc#minitestliteralasactualargument[Minitest/LiteralAsActualArgument]
        * xref:cops_minitest.adoc#minitestmultipleassertions[Minitest/MultipleAssertions]
        * xref:cops_minitest.adoc#minitestnoassertions[Minitest/NoAssertions]
        * xref:cops_minitest.adoc#minitestnotestcases[Minitest/NoTestCases]
        * xref:cops_minitest.adoc#minitestnonexecutabletestmethod[Minitest/NonExecutableTestMethod]
        * xref:cops_minitest.adoc#minitestnonpublictestmethod[Minitest/NonPublicTestMethod]
        * xref:cops_minitest.adoc#minitestredundantmessageargument[Minitest/RedundantMessageArgument]
        * xref:cops_minitest.adoc#minitestrefuteempty[Minitest/RefuteEmpty]
        * xref:cops_minitest.adoc#minitestrefuteequal[Minitest/RefuteEqual]
        * xref:cops_minitest.adoc#minitestrefutefalse[Minitest/RefuteFalse]
        * xref:cops_minitest.adoc#minitestrefuteindelta[Minitest/RefuteInDelta]
        * xref:cops_minitest.adoc#minitestrefuteincludes[Minitest/RefuteIncludes]
        * xref:cops_minitest.adoc#minitestrefuteinstanceof[Minitest/RefuteInstanceOf]
        * xref:cops_minitest.adoc#minitestrefutekindof[Minitest/RefuteKindOf]
        * xref:cops_minitest.adoc#minitestrefutematch[Minitest/RefuteMatch]
        * xref:cops_minitest.adoc#minitestrefutenil[Minitest/RefuteNil]
        * xref:cops_minitest.adoc#minitestrefuteoperator[Minitest/RefuteOperator]
        * xref:cops_minitest.adoc#minitestrefutepathexists[Minitest/RefutePathExists]
        * xref:cops_minitest.adoc#minitestrefutepredicate[Minitest/RefutePredicate]
        * xref:cops_minitest.adoc#minitestrefuterespondto[Minitest/RefuteRespondTo]
        * xref:cops_minitest.adoc#minitestrefutesame[Minitest/RefuteSame]
        * xref:cops_minitest.adoc#minitestreturnintestmethod[Minitest/ReturnInTestMethod]
        * xref:cops_minitest.adoc#minitestskipensure[Minitest/SkipEnsure]
        * xref:cops_minitest.adoc#minitestskipwithoutreason[Minitest/SkipWithoutReason]
        * xref:cops_minitest.adoc#minitesttestfilename[Minitest/TestFileName]
        * xref:cops_minitest.adoc#minitesttestmethodname[Minitest/TestMethodName]
        * xref:cops_minitest.adoc#minitestunreachableassertion[Minitest/UnreachableAssertion]
        * xref:cops_minitest.adoc#minitestunspecifiedexception[Minitest/UnspecifiedException]
        * xref:cops_minitest.adoc#minitestuselessassertion[Minitest/UselessAssertion]

        // END_COP_LIST
  recorded_at: Mon, 27 May 2024 05:30:42 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-minitest/v0.35.0/docs/modules/ROOT/pages/cops_minitest.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '35151'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"b54dc1d953a81501869bc89fb38cb428e416c684c0812456e6f31568a40e6fb0"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 2FD0:6D2AE:1313ABF:144BECE:66541A80
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:42 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230109-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787842.059262,VS0,VE184
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 4dc925d8524d310312045639974ebcd28a4ba03f
      Expires:
      - Mon, 27 May 2024 05:35:42 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Minitest

        == Minitest/AssertEmpty

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.2
        | -
        |===

        Enforces the test to use `assert_empty` instead of using `assert(object.empty?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(object.empty?)
        assert(object.empty?, 'message')

        # good
        assert_empty(object)
        assert_empty(object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-empty

        == Minitest/AssertEmptyLiteral

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.5
        | 0.11
        |===

        Enforces the test to use `assert_empty`
        instead of using `assert_equal([], object)` or `assert_equal({}, object)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal([], object)
        assert_equal({}, object)

        # good
        assert_empty(object)
        ----

        == Minitest/AssertEqual

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.4
        | -
        |===

        Enforces the use of `assert_equal(expected, actual)`
        over `assert(expected == actual)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert("rubocop-minitest" == actual)
        assert_operator("rubocop-minitest", :==, actual)

        # good
        assert_equal("rubocop-minitest", actual)
        ----

        === References

        * https://minitest.rubystyle.guide#assert-equal-arguments-order

        == Minitest/AssertInDelta

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces the test to use `assert_in_delta`
        instead of using `assert_equal` to compare floats.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal(0.2, actual)
        assert_equal(0.2, actual, 'message')

        # good
        assert_in_delta(0.2, actual)
        assert_in_delta(0.2, actual, 0.001, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#assert-in-delta

        == Minitest/AssertIncludes

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.2
        | -
        |===

        Enforces the test to use `assert_includes`
        instead of using `assert(collection.include?(object))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(collection.include?(object))
        assert(collection.include?(object), 'message')

        # good
        assert_includes(collection, object)
        assert_includes(collection, object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-includes

        == Minitest/AssertInstanceOf

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.4
        | -
        |===

        Enforces the test to use `assert_instance_of(Class, object)`
        over `assert(object.instance_of?(Class))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(object.instance_of?(Class))
        assert(object.instance_of?(Class), 'message')

        # bad
        assert_equal(Class, object.class)
        assert_equal(Class, object.class, 'message')

        # good
        assert_instance_of(Class, object)
        assert_instance_of(Class, object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-instance-of

        == Minitest/AssertKindOf

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | 0.34
        |===

        Enforces the test to use `assert_kind_of(Class, object)`
        over `assert(object.kind_of?(Class))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(object.kind_of?(Class))
        assert(object.kind_of?(Class), 'message')

        # bad
        # `is_a?` is an alias for `kind_of?`
        assert(object.is_a?(Class))
        assert(object.is_a?(Class), 'message')

        # good
        assert_kind_of(Class, object)
        assert_kind_of(Class, object, 'message')
        ----

        === References

        * https://github.com/rubocop/minitest-style-guide#assert-kind-of

        == Minitest/AssertMatch

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.6
        | -
        |===

        Enforces the test to use `assert_match`
        instead of using `assert(matcher.match(string))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(matcher.match(string))
        assert(matcher.match?(string))
        assert(matcher =~ string)
        assert_operator(matcher, :=~, string)
        assert(matcher.match(string), 'message')

        # good
        assert_match(regex, string)
        assert_match(matcher, string, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-match

        == Minitest/AssertNil

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.1
        | -
        |===

        Enforces the test to use `assert_nil` instead of using
        `assert_equal(nil, something)`, `assert(something.nil?)`, or `assert_predicate(something, :nil?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal(nil, actual)
        assert_equal(nil, actual, 'message')
        assert(object.nil?)
        assert(object.nil?, 'message')
        assert_predicate(object, :nil?)
        assert_predicate(object, :nil?, 'message')

        # good
        assert_nil(actual)
        assert_nil(actual, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-nil

        == Minitest/AssertOperator

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.32
        | -
        |===

        Enforces the use of `assert_operator(expected, :<, actual)` over `assert(expected < actual)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(expected < actual)

        # good
        assert_operator(expected, :<, actual)
        ----

        === References

        * https://minitest.rubystyle.guide#assert-operator

        == Minitest/AssertOutput

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.10
        | -
        |===

        Checks for opportunities to use `assert_output`.

        === Examples

        [source,ruby]
        ----
        # bad
        $stdout = StringIO.new
        puts object.method
        $stdout.rewind
        assert_match expected, $stdout.read

        # good
        assert_output(expected) { puts object.method }
        ----

        === References

        * https://minitest.rubystyle.guide/#assert-output

        == Minitest/AssertPathExists

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces the test to use `assert_path_exists` instead of using `assert(File.exist?(path))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(File.exist?(path))
        assert(File.exist?(path), 'message')

        # good
        assert_path_exists(path)
        assert_path_exists(path, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#assert-path-exists

        == Minitest/AssertPredicate

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.18
        | -
        |===

        Enforces the test to use `assert_predicate`
        instead of using `assert(obj.a_predicate_method?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(obj.one?)
        assert(obj.one?, 'message')

        # good
        assert_predicate(obj, :one?)
        assert_predicate(obj, :one?, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#assert-predicate

        == Minitest/AssertRaisesCompoundBody

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.21
        | -
        |===

        Enforces the block body of `assert_raises { ... }` to be reduced to only the raising code.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_raises(MyError) do
          foo
          bar
        end

        # good
        assert_raises(MyError) do
          foo
        end

        # good
        assert_raises(MyError) do
          foo do
            bar
            baz
          end
        end
        ----

        == Minitest/AssertRaisesWithRegexpArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.22
        | 0.26
        |===

        Checks for `assert_raises` with arguments of regular expression literals.
        Arguments should be exception classes.
        Optionally the last argument can be a custom message string to help explain failures.
        Either way, it's not the argument that `exception.message` is compared to.
        The raised exception is returned and can be used
        to match against a regular expression.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_raises FooError, /some message/ do
          obj.occur_error
        end

        # good
        exception = assert_raises FooError do
          obj.occur_error
        end
        assert_match(/some message/, exception.message)
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/AssertRespondTo

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.3
        | -
        |===

        Enforces the use of `assert_respond_to(object, :do_something)`
        over `assert(object.respond_to?(:do_something))`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(object.respond_to?(:do_something))
        assert(object.respond_to?(:do_something), 'message')
        assert(respond_to?(:do_something))

        # good
        assert_respond_to(object, :do_something)
        assert_respond_to(object, :do_something, 'message')
        assert_respond_to(self, :do_something)
        ----

        === References

        * https://minitest.rubystyle.guide#assert-responds-to-method

        == Minitest/AssertSame

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.26
        | -
        |===

        Enforces the use of `assert_same(expected, actual)`
        over `assert(expected.equal?(actual))`.

        NOTE: Use `assert_same` only when there is a need to compare by identity.
              Otherwise, use `assert_equal`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(expected.equal?(actual))
        assert_equal(expected.object_id, actual.object_id)

        # good
        assert_same(expected, actual)
        ----

        === References

        * https://minitest.rubystyle.guide#assert-same

        == Minitest/AssertSilent

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces the test to use `assert_silent { ... }`
        instead of using `assert_output('', '') { ... }`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_output('', '') { puts object.do_something }

        # good
        assert_silent { puts object.do_something }
        ----

        === References

        * https://github.com/rubocop/minitest-style-guide#assert-silent

        == Minitest/AssertTruthy

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 0.2
        | 0.27
        |===

        Enforces the test to use `assert(actual)` instead of using `assert_equal(true, actual)`.

        === Safety

        This cop is unsafe because true might be expected instead of truthy.
        False positives cannot be prevented when this is a variable or method return value.

        [source,ruby]
        ----
        assert_equal(true, 'truthy') # failure
        assert('truthy')             # success
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal(true, actual)
        assert_equal(true, actual, 'message')

        # good
        assert(actual)
        assert(actual, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#assert-truthy

        == Minitest/AssertWithExpectedArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | No
        | 0.11
        | 0.26
        |===

        Tries to detect when a user accidentally used
        `assert` when they meant to use `assert_equal`.

        NOTE: The second argument to the `assert` method named `message` and `msg` is allowed.
              Because their names are inferred as message arguments.

        === Safety

        This cop is unsafe because it is not possible to determine
        whether the second argument of `assert` is a message or not.

        === Examples

        [source,ruby]
        ----
        # bad
        assert(3, my_list.length)
        assert(expected, actual)

        # good
        assert_equal(3, my_list.length)
        assert_equal(expected, actual)
        assert(foo, 'message')
        assert(foo, message)
        assert(foo, msg)
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/AssertionInLifecycleHook

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.10
        | -
        |===

        Checks for usage of assertions in lifecycle hooks.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def setup
            assert_equal(foo, bar)
          end
        end

        # good
        class FooTest < Minitest::Test
          def test_something
            assert_equal(foo, bar)
          end
        end
        ----

        == Minitest/DuplicateTestRun

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.19
        | -
        |===

        If a Minitest class inherits from another class,
        it will also inherit its methods causing Minitest to run the parent's tests methods twice.

        This cop detects when there are two tests classes, one inherits from the other, and both have tests methods.
        This cop will add an offense to the Child class in such a case.

        === Examples

        [source,ruby]
        ----
        # bad
        class ParentTest < Minitest::Test
          def test_parent # it will run this test twice.
          end
        end

        class ChildTest < ParentTest
          def test_child
          end
        end

        # good
        class ParentTest < Minitest::Test
          def test_parent
          end
        end

        class ChildTest < Minitest::Test
          def test_child
          end
        end

        # good
        class ParentTest < Minitest::Test
        end

        class ChildTest
          def test_child
          end

          def test_parent
          end
        end
        ----

        === References

        * https://minitest.rubystyle.guide/#subclassing-test-cases

        == Minitest/EmptyLineBeforeAssertionMethods

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.23
        | -
        |===

        Enforces empty line before assertion methods because it separates assertion phase.

        === Examples

        [source,ruby]
        ----
        # bad
        do_something
        assert_equal(expected, actual)

        # good
        do_something

        assert_equal(expected, actual)
        ----

        == Minitest/Focus

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Command-line only
        | 0.35
        | -
        |===

        Enforces tests are not focused.

        === Examples

        [source,ruby]
        ----
        # bad
        focus test 'foo' do
        end

        # bad
        focus
        test 'foo' do
        end

        # good
        test 'foo' do
        end
        ----

        == Minitest/GlobalExpectations

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.7
        | 0.26
        |===

        Checks for deprecated global expectations
        and autocorrects them to use expect format.

        === Examples

        ==== EnforcedStyle: any (default)

        [source,ruby]
        ----
        # bad
        musts.must_equal expected_musts
        wonts.wont_match expected_wonts
        musts.must_raise TypeError

        # good
        _(musts).must_equal expected_musts
        _(wonts).wont_match expected_wonts
        _ { musts }.must_raise TypeError

        expect(musts).must_equal expected_musts
        expect(wonts).wont_match expected_wonts
        expect { musts }.must_raise TypeError

        value(musts).must_equal expected_musts
        value(wonts).wont_match expected_wonts
        value { musts }.must_raise TypeError
        ----

        ==== EnforcedStyle: _

        [source,ruby]
        ----
        # bad
        musts.must_equal expected_musts
        wonts.wont_match expected_wonts
        musts.must_raise TypeError

        expect(musts).must_equal expected_musts
        expect(wonts).wont_match expected_wonts
        expect { musts }.must_raise TypeError

        value(musts).must_equal expected_musts
        value(wonts).wont_match expected_wonts
        value { musts }.must_raise TypeError

        # good
        _(musts).must_equal expected_musts
        _(wonts).wont_match expected_wonts
        _ { musts }.must_raise TypeError
        ----

        ==== EnforcedStyle: expect

        [source,ruby]
        ----
        # bad
        musts.must_equal expected_musts
        wonts.wont_match expected_wonts
        musts.must_raise TypeError

        _(musts).must_equal expected_musts
        _(wonts).wont_match expected_wonts
        _ { musts }.must_raise TypeError

        value(musts).must_equal expected_musts
        value(wonts).wont_match expected_wonts
        value { musts }.must_raise TypeError

        # good
        expect(musts).must_equal expected_musts
        expect(wonts).wont_match expected_wonts
        expect { musts }.must_raise TypeError
        ----

        ==== EnforcedStyle: value

        [source,ruby]
        ----
        # bad
        musts.must_equal expected_musts
        wonts.wont_match expected_wonts
        musts.must_raise TypeError

        _(musts).must_equal expected_musts
        _(wonts).wont_match expected_wonts
        _ { musts }.must_raise TypeError

        expect(musts).must_equal expected_musts
        expect(wonts).wont_match expected_wonts
        expect { musts }.must_raise TypeError

        # good
        value(musts).must_equal expected_musts
        value(wonts).wont_match expected_wonts
        value { musts }.must_raise TypeError
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String

        | EnforcedStyle
        | `any`
        | `_`, `any`, `expect`, `value`

        | Include
        | `+**/test/**/*+`, `+**/*_test.rb+`, `+**/spec/**/*+`, `+**/*_spec.rb+`
        | Array
        |===

        === References

        * https://minitest.rubystyle.guide#global-expectations

        == Minitest/LifecycleHooksOrder

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.28
        | -
        |===

        Checks that lifecycle hooks are declared in the order in which they will be executed.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def teardown; end
          def setup; end
        end

        # good
        class FooTest < Minitest::Test
          def setup; end
          def teardown; end
        end

        # bad (after test cases)
        class FooTest < Minitest::Test
          def test_something
            assert foo
          end
          def setup; end
          def teardown; end
        end

        # good
        class FooTest < Minitest::Test
          def setup; end
          def teardown; end
          def test_something
            assert foo
          end
        end

        # good (after non test case methods)
        class FooTest < Minitest::Test
          def do_something; end
          def setup; end
          def teardown; end
        end
        ----

        === References

        * https://minitest.rubystyle.guide/#hooks-ordering

        == Minitest/LiteralAsActualArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces correct order of expected and
        actual arguments for `assert_equal`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal foo, 2
        assert_equal foo, [1, 2]
        assert_equal foo, [1, 2], 'message'

        # good
        assert_equal 2, foo
        assert_equal [1, 2], foo
        assert_equal [1, 2], foo, 'message'
        ----

        === References

        * https://minitest.rubystyle.guide/#assert-equal-arguments-order

        == Minitest/MultipleAssertions

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.10
        | -
        |===

        Checks if test cases contain too many assertion calls. If conditional code with assertions
        is used, the branch with maximum assertions is counted.
        The maximum allowed assertion calls is configurable.

        === Examples

        ==== Max: 1

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def test_asserts_twice
            assert_equal(42, do_something)
            assert_empty(array)
          end
        end

        # good
        class FooTest < Minitest::Test
          def test_asserts_once
            assert_equal(42, do_something)
          end

          def test_another_asserts_once
            assert_empty(array)
          end
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Max
        | `3`
        | Integer
        |===

        == Minitest/NoAssertions

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 0.12
        | -
        |===

        Checks if test cases contain any assertion calls.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def test_the_truth
          end
        end

        # good
        class FooTest < Minitest::Test
          def test_the_truth
            assert true
          end
        end
        ----

        == Minitest/NoTestCases

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 0.30
        | -
        |===

        Checks if test class contains any test cases.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def do_something
          end
        end

        # good
        class FooTest < Minitest::Test
          def test_something
            assert true
          end
        end
        ----

        == Minitest/NonExecutableTestMethod

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.34
        | -
        |===

        Checks for the use of test methods outside of a test class.

        Test methods should be defined within a test class to ensure their execution.

        NOTE: This cop assumes that classes whose superclass name includes the word
        "`Test`" are test classes, in order to prevent false positives.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
        end
        def test_method_should_be_inside_test_class
        end

        # good
        class FooTest < Minitest::Test
          def test_method_should_be_inside_test_class
          end
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/NonPublicTestMethod

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.27
        | -
        |===

        Detects non `public` (marked as `private` or `protected`) test methods.
        Minitest runs only test methods which are `public`.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest
          private # or protected
          def test_does_something
            assert_equal 42, do_something
          end
        end

        # good
        class FooTest
          def test_does_something
            assert_equal 42, do_something
          end
        end

        # good (not a test case name)
        class FooTest
          private # or protected
          def does_something
            assert_equal 42, do_something
          end
        end

        # good (no assertions)
        class FooTest
          private # or protected
          def test_does_something
            do_something
          end
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/RedundantMessageArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.34
        | -
        |===

        Detects redundant message argument in assertion methods.
        The message argument `nil` is redundant because it is the default value.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal(expected, actual, nil)

        # good
        assert_equal(expected, actual)
        assert_equal(expected, actual, 'message')
        ----

        == Minitest/RefuteEmpty

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.3
        | -
        |===

        Enforces to use `refute_empty` instead of using `refute(object.empty?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(object.empty?)
        refute(object.empty?, 'message')

        # good
        refute_empty(object)
        refute_empty(object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-empty

        == Minitest/RefuteEqual

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.3
        | -
        |===

        Enforces the use of `refute_equal(expected, object)`
        over `assert(expected != actual)` or `assert(! expected == actual)`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert("rubocop-minitest" != actual)
        refute("rubocop-minitest" == actual)
        assert_operator("rubocop-minitest", :!=, actual)
        refute_operator("rubocop-minitest", :==, actual)

        # good
        refute_equal("rubocop-minitest", actual)
        ----

        === References

        * https://minitest.rubystyle.guide#refute-equal

        == Minitest/RefuteFalse

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 0.3
        | 0.27
        |===

        Enforces the use of `refute(object)` over `assert_equal(false, object)`.

        === Safety

        This cop is unsafe because it cannot detect failure when second argument is `nil`.
        False positives cannot be prevented when this is a variable or method return value.

        [source,ruby]
        ----
        assert_equal(false, nil) # failure
        refute(nil)              # success
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        assert_equal(false, actual)
        assert_equal(false, actual, 'message')

        assert(!test)
        assert(!test, 'message')

        # good
        refute(actual)
        refute(actual, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-false

        == Minitest/RefuteInDelta

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces the test to use `refute_in_delta`
        instead of using `refute_equal` to compare floats.

        === Examples

        [source,ruby]
        ----
        # bad
        refute_equal(0.2, actual)
        refute_equal(0.2, actual, 'message')

        # good
        refute_in_delta(0.2, actual)
        refute_in_delta(0.2, actual, 0.001, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#refute-in-delta

        == Minitest/RefuteIncludes

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.3
        | -
        |===

        Enforces the test to use `refute_includes`
        instead of using `refute(collection.include?(object))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(collection.include?(object))
        refute(collection.include?(object), 'message')

        # good
        refute_includes(collection, object)
        refute_includes(collection, object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-includes

        == Minitest/RefuteInstanceOf

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.4
        | -
        |===

        Enforces the use of `refute_instance_of(Class, object)`
        over `refute(object.instance_of?(Class))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(object.instance_of?(Class))
        refute(object.instance_of?(Class), 'message')

        # bad
        refute_equal(Class, object.class)
        refute_equal(Class, object.class, 'message')

        # good
        refute_instance_of(Class, object)
        refute_instance_of(Class, object, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-instance-of

        == Minitest/RefuteKindOf

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | 0.34
        |===

        Enforces the use of `refute_kind_of(Class, object)`
        over `refute(object.kind_of?(Class))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(object.kind_of?(Class))
        refute(object.kind_of?(Class), 'message')

        # bad
        # `is_a?` is an alias for `kind_of?`
        refute(object.is_of?(Class))
        refute(object.is_of?(Class), 'message')

        # good
        refute_kind_of(Class, object)
        refute_kind_of(Class, object, 'message')
        ----

        === References

        * https://github.com/rubocop/minitest-style-guide#refute-kind-of

        == Minitest/RefuteMatch

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.6
        | -
        |===

        Enforces the test to use `refute_match`
        instead of using `refute(matcher.match(string))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(matcher.match(string))
        refute(matcher.match?(string))
        refute(matcher =~ string)
        refute_operator(matcher, :=~, string)
        assert_operator(matcher, :!~, string)
        refute(matcher.match(string), 'message')

        # good
        refute_match(matcher, string)
        refute_match(matcher, string, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-match

        == Minitest/RefuteNil

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.2
        | -
        |===

        Enforces the test to use `refute_nil` instead of using
        `refute_equal(nil, something)`, `refute(something.nil?)`, or `refute_predicate(something, :nil?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute_equal(nil, actual)
        refute_equal(nil, actual, 'message')
        refute(actual.nil?)
        refute(actual.nil?, 'message')
        refute_predicate(object, :nil?)
        refute_predicate(object, :nil?, 'message')

        # good
        refute_nil(actual)
        refute_nil(actual, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide#refute-nil

        == Minitest/RefuteOperator

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.32
        | -
        |===

        Enforces the use of `refute_operator(expected, :<, actual)` over `refute(expected < actual)`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(expected < actual)

        # good
        refute_operator(expected, :<, actual)
        ----

        === References

        * https://minitest.rubystyle.guide#refute-operator

        == Minitest/RefutePathExists

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces the test to use `refute_path_exists` instead of using `refute(File.exist?(path))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(File.exist?(path))
        refute(File.exist?(path), 'message')

        # good
        refute_path_exists(path)
        refute_path_exists(path, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#refute-path-exists

        == Minitest/RefutePredicate

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.18
        | -
        |===

        Enforces the test to use `refute_predicate`
        instead of using `refute(obj.a_predicate_method?)`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(obj.one?)
        refute(obj.one?, 'message')

        # good
        refute_predicate(obj, :one?)
        refute_predicate(obj, :one?, 'message')
        ----

        === References

        * https://minitest.rubystyle.guide/#refute-predicate

        == Minitest/RefuteRespondTo

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.4
        | -
        |===

        Enforces the test to use `refute_respond_to(object, :do_something)`
        over `refute(object.respond_to?(:do_something))`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(object.respond_to?(:do_something))
        refute(object.respond_to?(:do_something), 'message')
        refute(respond_to?(:do_something))

        # good
        refute_respond_to(object, :do_something)
        refute_respond_to(object, :do_something, 'message')
        refute_respond_to(self, :do_something)
        ----

        === References

        * https://minitest.rubystyle.guide#refute-respond-to

        == Minitest/RefuteSame

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.26
        | -
        |===

        Enforces the use of `refute_same(expected, object)`
        over `refute(expected.equal?(actual))`.

        NOTE: Use `refute_same` only when there is a need to compare by identity.
              Otherwise, use `refute_equal`.

        === Examples

        [source,ruby]
        ----
        # bad
        refute(expected.equal?(actual))
        refute_equal(expected.object_id, actual.object_id)

        # good
        refute_same(expected, actual)
        ----

        === References

        * https://minitest.rubystyle.guide#refute-same

        == Minitest/ReturnInTestMethod

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.31
        | -
        |===

        Enforces the use of `skip` instead of `return` in test methods.

        === Examples

        [source,ruby]
        ----
        # bad
        def test_something
          return if condition?
          assert_equal(42, something)
        end

        # good
        def test_something
          skip if condition?
          assert_equal(42, something)
        end
        ----

        === References

        * https://minitest.rubystyle.guide/#skipping-runnable-methods

        == Minitest/SkipEnsure

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.20
        | 0.26
        |===

        Checks that `ensure` call even if `skip`. It is unexpected that `ensure` will be called when skipping test.
        If conditional `skip` is used, it checks that `ensure` is also called conditionally.

        On the other hand, it accepts `skip` used in `rescue` because `ensure` may be teardown process to `begin`
        setup process.

        === Examples

        [source,ruby]
        ----
        # bad
        def test_skip
          skip 'This test is skipped.'

          assert 'foo'.present?
        ensure
          do_something
        end

        # bad
        def test_conditional_skip
          skip 'This test is skipped.' if condition

          assert do_something
        ensure
          do_teardown
        end

        # good
        def test_skip
          skip 'This test is skipped.'

          begin
            assert 'foo'.present?
          ensure
            do_something
          end
        end

        # good
        def test_conditional_skip
          skip 'This test is skipped.' if condition

          assert do_something
        ensure
          if condition
            do_teardown
          end
        end

        # good
        def test_skip_is_used_in_rescue
          do_setup
          assert do_something
        rescue
          skip 'This test is skipped.'
        ensure
          do_teardown
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/SkipWithoutReason

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.24
        | -
        |===

        Checks for skipped tests missing the skipping reason.

        === Examples

        [source,ruby]
        ----
        # bad
        skip
        skip('')

        # bad
        if condition?
          skip
        else
          skip
        end

        # good
        skip("Reason why the test was skipped")

        # good
        skip if condition?
        ----

        == Minitest/TestFileName

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.26
        | -
        |===

        Checks if test file names start with `test_` or end with `_test.rb`.
        Files which define classes having names ending with `Test` are checked.
        Not following this convention may result in tests not being run.

        === Examples

        [source,ruby]
        ----
        # bad
        my_class.rb

        # good
        my_class_test.rb
        test_my_class.rb
        ----

        === References

        * https://minitest.rubystyle.guide/#file-naming

        == Minitest/TestMethodName

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 0.10
        | -
        |===

        Enforces that test method names start with `test_` prefix.
        It aims to prevent tests that aren't executed by forgetting to start test method name with `test_`.

        === Examples

        [source,ruby]
        ----
        # bad
        class FooTest < Minitest::Test
          def does_something
            assert_equal 42, do_something
          end
        end

        # good
        class FooTest < Minitest::Test
          def test_does_something
            assert_equal 42, do_something
          end
        end

        # good
        class FooTest < Minitest::Test
          def helper_method(argument)
          end
        end
        ----

        == Minitest/UnreachableAssertion

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.14
        | 0.26
        |===

        Checks for `assert_raises` has an assertion method at
        the bottom of block because the assertion will be never reached.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_raises FooError do
          obj.occur_error
          assert_equal('foo', obj.bar) # Never asserted.
        end

        # good
        assert_raises FooError do
          obj.occur_error
        end
        assert_equal('foo', obj.bar)
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | Severity
        | `warning`
        | String
        |===

        == Minitest/UnspecifiedException

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.10
        | -
        |===

        Checks for a specified error in `assert_raises`.

        === Examples

        [source,ruby]
        ----
        # bad
        assert_raises { raise FooException }
        assert_raises('This should have raised') { raise FooException }

        # good
        assert_raises(FooException) { raise FooException }
        assert_raises(FooException, 'This should have raised') { raise FooException }
        ----

        === References

        * https://minitest.rubystyle.guide#unspecified-exception

        == Minitest/UselessAssertion

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 0.26
        | -
        |===

        Detects useless assertions (assertions that either always pass or always fail).

        === Examples

        [source,ruby]
        ----
        # bad
        assert true
        assert_equal @foo, @foo
        assert_nil [foo, bar]

        # good
        assert something
        assert_equal foo, bar
        assert_nil foo
        assert false, "My message"
        ----
  recorded_at: Mon, 27 May 2024 05:30:42 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-minitest/v0.35.0/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '12767'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"f9dc1b99a3821a4c98b47e747a20ccd583388be003fa1c4012a9632a86202836"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - E1DE:12DE69:31D795:359431:66541A82
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:42 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230159-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787842.371460,VS0,VE156
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 3f259b38c88c7784556ba68ca774dbf0c203008a
      Expires:
      - Mon, 27 May 2024 05:35:42 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        Minitest:
          Enabled: true
          DocumentationBaseURL: https://docs.rubocop.org/rubocop-minitest
          Include:
            - '**/test/**/*'
            - '**/*_test.rb'

        Minitest/AssertEmpty:
          Description: 'This cop enforces the test to use `assert_empty` instead of using `assert(object.empty?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-empty'
          Enabled: true
          VersionAdded: '0.2'

        Minitest/AssertEmptyLiteral:
          Description: 'This cop enforces the test to use `assert_empty` instead of using `assert_equal([], object)`.'
          Enabled: true
          VersionAdded: '0.5'
          VersionChanged: '0.11'

        Minitest/AssertEqual:
          Description: 'This cop enforces the test to use `assert_equal` instead of using `assert(expected == actual)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-equal-arguments-order'
          Enabled: true
          VersionAdded: '0.4'

        Minitest/AssertInDelta:
          Description: 'This cop enforces the test to use `assert_in_delta` instead of using `assert_equal` to compare floats.'
          StyleGuide: 'https://minitest.rubystyle.guide/#assert-in-delta'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/AssertIncludes:
          Description: 'This cop enforces the test to use `assert_includes` instead of using `assert(collection.include?(object))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-includes'
          Enabled: true
          VersionAdded: '0.2'

        Minitest/AssertInstanceOf:
          Description: 'This cop enforces the test to use `assert_instance_of(Class, object)` over `assert(object.instance_of?(Class))`'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-instance-of'
          Enabled: true
          VersionAdded: '0.4'

        Minitest/AssertKindOf:
          Description: 'This cop enforces the test to use `assert_kind_of(Class, object)` over `assert(object.kind_of?(Class))`'
          StyleGuide: 'https://github.com/rubocop/minitest-style-guide#assert-kind-of'
          Enabled: 'pending'
          VersionAdded: '0.10'
          VersionChanged: '0.34'

        Minitest/AssertMatch:
          Description: 'This cop enforces the test to use `assert_match` instead of using `assert(matcher.match(object))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-match'
          Enabled: true
          VersionAdded: '0.6'

        Minitest/AssertNil:
          Description: 'This cop enforces the test to use `assert_nil` instead of using `assert_equal(nil, something)` or `assert(something.nil?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-nil'
          Enabled: true
          VersionAdded: '0.1'

        Minitest/AssertOperator:
          Description: 'This cop enforces the use of `assert_operator(expected, :<, actual)` over `assert(expected < actual)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-operator'
          Enabled: pending
          VersionAdded: '0.32'

        Minitest/AssertOutput:
          Description: 'This cop checks for opportunities to use `assert_output`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#assert-output'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/AssertPathExists:
          Description: 'This cop enforces the test to use `assert_path_exists` instead of using `assert(File.exist?(path))`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#assert-path-exists'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/AssertPredicate:
          Description: 'This cop enforces the test to use `assert_predicate` instead of using `assert(obj.a_predicate_method?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#assert-predicate'
          Enabled: pending
          VersionAdded: '0.18'

        Minitest/AssertRaisesCompoundBody:
          Description: 'This cop enforces the block body of `assert_raises { ... }` to be reduced to only the raising code.'
          Enabled: pending
          VersionAdded: '0.21'

        Minitest/AssertRaisesWithRegexpArgument:
          Description: 'This cop enforces checks for regular expression literals passed to `assert_raises`.'
          Enabled: pending
          Severity: warning
          VersionAdded: '0.22'
          VersionChanged: '0.26'

        Minitest/AssertRespondTo:
          Description: 'This cop enforces the test to use `assert_respond_to(object, :do_something)` over `assert(object.respond_to?(:do_something))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-responds-to-method'
          Enabled: true
          VersionAdded: '0.3'

        Minitest/AssertSame:
          Description: 'Enforces the use of `assert_same(expected, actual)` over `assert(expected.equal?(actual))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-same'
          Enabled: pending
          VersionAdded: '0.26'

        Minitest/AssertSilent:
          Description: "This cop enforces the test to use `assert_silent { ... }` instead of using `assert_output('', '') { ... }`."
          StyleGuide: 'https://github.com/rubocop/minitest-style-guide#assert-silent'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/AssertTruthy:
          Description: 'This cop enforces the test to use `assert(actual)` instead of using `assert_equal(true, actual)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#assert-truthy'
          Enabled: true
          Safe: false
          VersionAdded: '0.2'
          VersionChanged: '0.27'

        Minitest/AssertWithExpectedArgument:
          Description: 'This cop tries to detect when a user accidentally used `assert` when they meant to use `assert_equal`.'
          Enabled: pending
          Severity: warning
          Safe: false
          VersionAdded: '0.11'
          VersionChanged: '0.26'

        Minitest/AssertionInLifecycleHook:
          Description: 'This cop checks for usage of assertions in lifecycle hooks.'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/DuplicateTestRun:
          Description: 'This cop detects duplicate test runs caused by one test class inheriting from another.'
          StyleGuide: 'https://minitest.rubystyle.guide/#subclassing-test-cases'
          Enabled: pending
          VersionAdded: '0.19'

        Minitest/EmptyLineBeforeAssertionMethods:
          Description: 'Add empty line before assertion methods.'
          Enabled: pending
          VersionAdded: '0.23'

        Minitest/Focus:
          Description: 'Checks for focused tests.'
          Enabled: pending
          AutoCorrect: contextual
          VersionAdded: '0.35'

        Minitest/GlobalExpectations:
          Description: 'This cop checks for deprecated global expectations.'
          StyleGuide: 'https://minitest.rubystyle.guide#global-expectations'
          Enabled: true
          Severity: warning
          EnforcedStyle: any
          Include:
            - '**/test/**/*'
            - '**/*_test.rb'
            - '**/spec/**/*'
            - '**/*_spec.rb'
          SupportedStyles:
            - _
            - any
            - expect
            - value
          VersionAdded: '0.7'
          VersionChanged: '0.26'

        Minitest/LifecycleHooksOrder:
          Description: 'Checks that lifecycle hooks are declared in the order in which they will be executed.'
          StyleGuide: 'https://minitest.rubystyle.guide/#hooks-ordering'
          Enabled: pending
          VersionAdded: '0.28'

        Minitest/LiteralAsActualArgument:
          Description: 'This cop enforces correct order of `expected` and `actual` arguments for `assert_equal`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#assert-equal-arguments-order'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/MultipleAssertions:
          Description: 'This cop checks if test cases contain too many assertion calls.'
          Enabled: 'pending'
          VersionAdded: '0.10'
          Max: 3

        Minitest/NoAssertions:
          Description: 'This cop checks for at least one assertion (or flunk) in tests.'
          Enabled: false
          VersionAdded: '0.12'

        Minitest/NoTestCases:
          Description: 'Checks if test class contains any test cases.'
          Enabled: false
          VersionAdded: '0.30'

        Minitest/NonExecutableTestMethod:
          Description: 'Checks uses of test methods outside test class.'
          Enabled: pending
          Severity: warning
          VersionAdded: '0.34'

        Minitest/NonPublicTestMethod:
          Description: 'Detects non `public` (marked as `private` or `protected`) test methods.'
          Enabled: pending
          Severity: warning
          VersionAdded: '0.27'

        Minitest/RedundantMessageArgument:
          Description: 'Detects redundant message argument in assertion methods.'
          Enabled: pending
          VersionAdded: '0.34'

        Minitest/RefuteEmpty:
          Description: 'This cop enforces to use `refute_empty` instead of using `refute(object.empty?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-empty'
          Enabled: true
          VersionAdded: '0.3'

        Minitest/RefuteEqual:
          Description: 'Check if your test uses `refute_equal` instead of `assert(expected != object)` or `assert(! expected == object))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-equal'
          Enabled: true
          VersionAdded: '0.3'

        Minitest/RefuteFalse:
          Description: 'Check if your test uses `refute(actual)` instead of `assert_equal(false, actual)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-false'
          Enabled: true
          Safe: false
          VersionAdded: '0.3'
          VersionChanged: '0.27'

        Minitest/RefuteInDelta:
          Description: 'This cop enforces the test to use `refute_in_delta` instead of using `refute_equal` to compare floats.'
          StyleGuide: 'https://minitest.rubystyle.guide/#refute-in-delta'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/RefuteIncludes:
          Description: 'This cop enforces the test to use `refute_includes` instead of using `refute(collection.include?(object))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-includes'
          Enabled: true
          VersionAdded: '0.3'

        Minitest/RefuteInstanceOf:
          Description: 'This cop enforces the test to use `refute_instance_of(Class, object)` over `refute(object.instance_of?(Class))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-instance-of'
          Enabled: true
          VersionAdded: '0.4'

        Minitest/RefuteKindOf:
          Description: 'This cop enforces the test to use `refute_kind_of(Class, object)` over `refute(object.kind_of?(Class))`.'
          StyleGuide: 'https://github.com/rubocop/minitest-style-guide#refute-kind-of'
          Enabled: 'pending'
          VersionAdded: '0.10'
          VersionChanged: '0.34'

        Minitest/RefuteMatch:
          Description: 'This cop enforces the test to use `refute_match` instead of using `refute(matcher.match(object))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-match'
          Enabled: true
          VersionAdded: '0.6'

        Minitest/RefuteNil:
          Description: 'This cop enforces the test to use `refute_nil` instead of using `refute_equal(nil, something)` or `refute(something.nil?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-nil'
          Enabled: true
          VersionAdded: '0.2'

        Minitest/RefuteOperator:
          Description: 'This cop enforces the use of `refute_operator(expected, :<, actual)` over `refute(expected < actual)`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-operator'
          Enabled: pending
          VersionAdded: '0.32'

        Minitest/RefutePathExists:
          Description: 'This cop enforces the test to use `refute_path_exists` instead of using `refute(File.exist?(path))`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#refute-path-exists'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/RefutePredicate:
          Description: 'This cop enforces the test to use `refute_predicate` instead of using `refute(obj.a_predicate_method?)`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#refute-predicate'
          Enabled: pending
          VersionAdded: '0.18'

        Minitest/RefuteRespondTo:
          Description: 'This cop enforces the test to use `refute_respond_to(object, :do_something)` over `refute(object.respond_to?(:do_something))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-respond-to'
          Enabled: true
          VersionAdded: '0.4'

        Minitest/RefuteSame:
          Description: 'Enforces the use of `refute_same(expected, actual)` over `refute(expected.equal?(actual))`.'
          StyleGuide: 'https://minitest.rubystyle.guide#refute-same'
          Enabled: pending
          VersionAdded: '0.26'

        Minitest/ReturnInTestMethod:
          Description: 'Enforces the use of `skip` instead of `return` in test methods.'
          StyleGuide: 'https://minitest.rubystyle.guide/#skipping-runnable-methods'
          Enabled: pending
          VersionAdded: '0.31'

        Minitest/SkipEnsure:
          Description: 'Checks that `ensure` call even if `skip`.'
          Enabled: pending
          Severity: warning
          VersionAdded: '0.20'
          VersionChanged: '0.26'

        Minitest/SkipWithoutReason:
          Description: 'Checks for skipped tests missing the skipping reason.'
          Enabled: pending
          VersionAdded: '0.24'

        Minitest/TestFileName:
          Description: 'Checks if test file names start with `test_` or end with `_test.rb`.'
          StyleGuide: 'https://minitest.rubystyle.guide/#file-naming'
          Enabled: pending
          VersionAdded: '0.26'

        Minitest/TestMethodName:
          Description: 'This cop enforces that test method names start with `test_` prefix.'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/UnreachableAssertion:
          Description: 'This cop checks for an `assert_raises` block containing any unreachable assertions.'
          Enabled: pending
          Severity: warning
          VersionAdded: '0.14'
          VersionChanged: '0.26'

        Minitest/UnspecifiedException:
          Description: 'This cop checks for a specified error in `assert_raises`.'
          StyleGuide: 'https://minitest.rubystyle.guide#unspecified-exception'
          Enabled: 'pending'
          VersionAdded: '0.10'

        Minitest/UselessAssertion:
          Description: 'Detects useless assertions (assertions that either always pass or always fail).'
          Enabled: pending
          VersionAdded: '0.26'
  recorded_at: Mon, 27 May 2024 05:30:42 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-performance/v1.21.0/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '4550'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"f14299f901f830002d5facd08d5663ec669ba9786af6ea68bf66c64d389cc4c2"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - DDAA:3DF3CA:13E2A83:151AEB8:66541A81
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:42 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230143-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787843.643988,VS0,VE163
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 5b7fcf4a24eb203d7e9f48909f50fdec12e752e2
      Expires:
      - Mon, 27 May 2024 05:35:42 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        = Cops

        In RuboCop lingo the various checks performed on the code are called cops.
        Each cop is responsible for detecting one particular offense.
        RuboCop Performance has only one Performance department.

        == Performance

        Performance cops optimization analysis for your projects.

        // START_COP_LIST

        === Department xref:cops_performance.adoc[Performance]

        * xref:cops_performance.adoc#performanceancestorsinclude[Performance/AncestorsInclude]
        * xref:cops_performance.adoc#performancearraysemiinfiniterangeslice[Performance/ArraySemiInfiniteRangeSlice]
        * xref:cops_performance.adoc#performancebigdecimalwithnumericargument[Performance/BigDecimalWithNumericArgument]
        * xref:cops_performance.adoc#performancebindcall[Performance/BindCall]
        * xref:cops_performance.adoc#performanceblockgivenwithexplicitblock[Performance/BlockGivenWithExplicitBlock]
        * xref:cops_performance.adoc#performancecaller[Performance/Caller]
        * xref:cops_performance.adoc#performancecasewhensplat[Performance/CaseWhenSplat]
        * xref:cops_performance.adoc#performancecasecmp[Performance/Casecmp]
        * xref:cops_performance.adoc#performancechainarrayallocation[Performance/ChainArrayAllocation]
        * xref:cops_performance.adoc#performancecollectionliteralinloop[Performance/CollectionLiteralInLoop]
        * xref:cops_performance.adoc#performancecomparewithblock[Performance/CompareWithBlock]
        * xref:cops_performance.adoc#performanceconcurrentmonotonictime[Performance/ConcurrentMonotonicTime]
        * xref:cops_performance.adoc#performanceconstantregexp[Performance/ConstantRegexp]
        * xref:cops_performance.adoc#performancecount[Performance/Count]
        * xref:cops_performance.adoc#performancedeleteprefix[Performance/DeletePrefix]
        * xref:cops_performance.adoc#performancedeletesuffix[Performance/DeleteSuffix]
        * xref:cops_performance.adoc#performancedetect[Performance/Detect]
        * xref:cops_performance.adoc#performancedoublestartendwith[Performance/DoubleStartEndWith]
        * xref:cops_performance.adoc#performanceendwith[Performance/EndWith]
        * xref:cops_performance.adoc#performancefixedsize[Performance/FixedSize]
        * xref:cops_performance.adoc#performanceflatmap[Performance/FlatMap]
        * xref:cops_performance.adoc#performanceinefficienthashsearch[Performance/InefficientHashSearch]
        * xref:cops_performance.adoc#performanceioreadlines[Performance/IoReadlines]
        * xref:cops_performance.adoc#performancemapcompact[Performance/MapCompact]
        * xref:cops_performance.adoc#performancemapmethodchain[Performance/MapMethodChain]
        * xref:cops_performance.adoc#performancemethodobjectasblock[Performance/MethodObjectAsBlock]
        * xref:cops_performance.adoc#performanceopenstruct[Performance/OpenStruct]
        * xref:cops_performance.adoc#performancerangeinclude[Performance/RangeInclude]
        * xref:cops_performance.adoc#performanceredundantblockcall[Performance/RedundantBlockCall]
        * xref:cops_performance.adoc#performanceredundantequalitycomparisonblock[Performance/RedundantEqualityComparisonBlock]
        * xref:cops_performance.adoc#performanceredundantmatch[Performance/RedundantMatch]
        * xref:cops_performance.adoc#performanceredundantmerge[Performance/RedundantMerge]
        * xref:cops_performance.adoc#performanceredundantsortblock[Performance/RedundantSortBlock]
        * xref:cops_performance.adoc#performanceredundantsplitregexpargument[Performance/RedundantSplitRegexpArgument]
        * xref:cops_performance.adoc#performanceredundantstringchars[Performance/RedundantStringChars]
        * xref:cops_performance.adoc#performanceregexpmatch[Performance/RegexpMatch]
        * xref:cops_performance.adoc#performancereverseeach[Performance/ReverseEach]
        * xref:cops_performance.adoc#performancereversefirst[Performance/ReverseFirst]
        * xref:cops_performance.adoc#performanceselectmap[Performance/SelectMap]
        * xref:cops_performance.adoc#performancesize[Performance/Size]
        * xref:cops_performance.adoc#performancesortreverse[Performance/SortReverse]
        * xref:cops_performance.adoc#performancesqueeze[Performance/Squeeze]
        * xref:cops_performance.adoc#performancestartwith[Performance/StartWith]
        * xref:cops_performance.adoc#performancestringidentifierargument[Performance/StringIdentifierArgument]
        * xref:cops_performance.adoc#performancestringinclude[Performance/StringInclude]
        * xref:cops_performance.adoc#performancestringreplacement[Performance/StringReplacement]
        * xref:cops_performance.adoc#performancesum[Performance/Sum]
        * xref:cops_performance.adoc#performancetimesmap[Performance/TimesMap]
        * xref:cops_performance.adoc#performanceunfreezestring[Performance/UnfreezeString]
        * xref:cops_performance.adoc#performanceuridefaultparser[Performance/UriDefaultParser]

        // END_COP_LIST
  recorded_at: Mon, 27 May 2024 05:30:43 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-performance/v1.21.0/docs/modules/ROOT/pages/cops_performance.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '43745'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"f86e2b511c0085e321da92d1b355d1af52598b21e028567200d81aedd82322e7"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - FB54:312987:13024FD:143B4BA:66541A82
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:43 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230097-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787843.956315,VS0,VE186
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 3e8caa1b2c307a0300efb56d2419977fe96c2bf2
      Expires:
      - Mon, 27 May 2024 05:35:43 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ////
          Do NOT edit this file by hand directly, as it is automatically generated.

          Please make any necessary changes to the cop documentation within the source files themselves.
        ////

        = Performance

        == Performance/AncestorsInclude

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | Always (Unsafe)
        | 1.7
        | -
        |===

        Identifies usages of `ancestors.include?` and change them to use `<=` instead.

        === Safety

        This cop is unsafe because it can't tell whether the receiver is a class or an object.
        e.g. the false positive was for `Nokogiri::XML::Node#ancestors`.

        === Examples

        [source,ruby]
        ----
        # bad
        A.ancestors.include?(B)

        # good
        A <= B
        ----

        === References

        * https://github.com/fastruby/fast-ruby#ancestorsinclude-vs--code

        == Performance/ArraySemiInfiniteRangeSlice

        NOTE: Required Ruby version: 2.7

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | No
        | Always (Unsafe)
        | 1.9
        | -
        |===

        Identifies places where slicing arrays with semi-infinite ranges
        can be replaced by `Array#take` and `Array#drop`.
        This cop was created due to a mistake in microbenchmark and hence is disabled by default.
        Refer https://github.com/rubocop/rubocop-performance/pull/175#issuecomment-731892717

        === Safety

        This cop is unsafe for string slices because strings do not have `#take` and `#drop` methods.

        === Examples

        [source,ruby]
        ----
        # bad
        array[..2]
        array[...2]
        array[2..]
        array[2...]
        array.slice(..2)

        # good
        array.take(3)
        array.take(2)
        array.drop(2)
        array.drop(2)
        array.take(3)
        ----

        == Performance/BigDecimalWithNumericArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where numeric argument to BigDecimal should be
        converted to string. Initializing from String is faster
        than from Numeric for BigDecimal.

        === Examples

        [source,ruby]
        ----
        # bad
        BigDecimal(1, 2)
        4.to_d(6)
        BigDecimal(1.2, 3, exception: true)
        4.5.to_d(6, exception: true)

        # good
        BigDecimal('1', 2)
        BigDecimal('4', 6)
        BigDecimal('1.2', 3, exception: true)
        BigDecimal('4.5', 6, exception: true)
        ----

        == Performance/BindCall

        NOTE: Required Ruby version: 2.7

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 1.6
        | -
        |===

        In Ruby 2.7, `UnboundMethod#bind_call` has been added.

        This cop identifies places where `bind(obj).call(args, ...)`
        can be replaced by `bind_call(obj, args, ...)`.

        The `bind_call(obj, args, ...)` method is faster than
        `bind(obj).call(args, ...)`.

        === Examples

        [source,ruby]
        ----
        # bad
        umethod.bind(obj).call(foo, bar)
        umethod.bind(obj).(foo, bar)

        # good
        umethod.bind_call(obj, foo, bar)
        ----

        == Performance/BlockGivenWithExplicitBlock

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.9
        | -
        |===

        Identifies unnecessary use of a `block_given?` where explicit check
        of block argument would suffice.

        === Examples

        [source,ruby]
        ----
        # bad
        def method(&block)
          do_something if block_given?
        end

        # good
        def method(&block)
          do_something if block
        end

        # good - block is reassigned
        def method(&block)
          block ||= -> { do_something }
          warn "Using default ..." unless block_given?
          # ...
        end
        ----

        == Performance/Caller

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.49
        | 1.9
        |===

        Identifies places where `caller[n]` can be replaced by `caller(n..n).first`.

        === Examples

        [source,ruby]
        ----
        # bad
        caller[1]
        caller.first
        caller_locations[1]
        caller_locations.first

        # good
        caller(2..2).first
        caller(1..1).first
        caller_locations(2..2).first
        caller_locations(1..1).first
        ----

        == Performance/CaseWhenSplat

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | Always (Unsafe)
        | 0.34
        | 1.13
        |===

        Reordering `when` conditions with a splat to the end
        of the `when` branches can improve performance.

        Ruby has to allocate memory for the splat expansion every time
        that the `case` `when` statement is run. Since Ruby does not support
        fall through inside of `case` `when`, like some other languages do,
        the order of the `when` branches should not matter. By placing any
        splat expansions at the end of the list of `when` branches we will
        reduce the number of times that memory has to be allocated for
        the expansion. The exception to this is if multiple of your `when`
        conditions can be true for any given condition. A likely scenario for
        this defining a higher level when condition to override a condition
        that is inside of the splat expansion.

        === Safety

        This cop is not unsafe autocorrection because it is not a guaranteed
        performance improvement. If the data being processed by the `case` condition is
        normalized in a manner that favors hitting a condition in the splat expansion,
        it is possible that moving the splat condition to the end will use more memory,
        and run slightly slower.
        See for more details: https://github.com/rubocop/rubocop/pull/6163

        === Examples

        [source,ruby]
        ----
        # bad
        case foo
        when *condition
          bar
        when baz
          foobar
        end

        case foo
        when *[1, 2, 3, 4]
          bar
        when 5
          baz
        end

        # good
        case foo
        when baz
          foobar
        when *condition
          bar
        end

        case foo
        when 1, 2, 3, 4
          bar
        when 5
          baz
        end
        ----

        == Performance/Casecmp

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | No
        | Always (Unsafe)
        | 0.36
        | 1.21
        |===

        Identifies places where a case-insensitive string comparison
        can better be implemented using `casecmp`.

        This cop is disabled by default because `String#casecmp` only works with
        ASCII characters. See https://github.com/rubocop/rubocop/issues/9753.

        If you are working only with ASCII characters, then this cop can be
        safely enabled.

        === Safety

        This cop is unsafe because `String#casecmp` and `String#casecmp?` behave
        differently when using Non-ASCII characters.

        === Examples

        [source,ruby]
        ----
        # bad
        str.downcase == 'abc'
        str.upcase.eql? 'ABC'
        'abc' == str.downcase
        'ABC'.eql? str.upcase
        str.downcase == str.downcase

        # good
        str.casecmp('ABC').zero?
        'abc'.casecmp(str).zero?
        ----

        === References

        * https://github.com/fastruby/fast-ruby#stringcasecmp-vs--stringcasecmp-vs-stringdowncase---code

        == Performance/ChainArrayAllocation

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 0.59
        | -
        |===

        Identifies usages of `array.compact.flatten.map { |x| x.downcase }`.
        Each of these methods (`compact`, `flatten`, `map`) will generate a new intermediate array
        that is promptly thrown away. Instead it is faster to mutate when we know it's safe.

        === Examples

        [source,ruby]
        ----
        # bad
        array = ["a", "b", "c"]
        array.compact.flatten.map { |x| x.downcase }

        # good
        array = ["a", "b", "c"]
        array.compact!
        array.flatten!
        array.map! { |x| x.downcase }
        array
        ----

        === References

        * https://twitter.com/schneems/status/1034123879978029057

        == Performance/CollectionLiteralInLoop

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 1.8
        | -
        |===

        Identifies places where Array and Hash literals are used within loops.
        It is better to extract them into a local variable or constant
        to avoid unnecessary allocations on each iteration.

        You can set the minimum number of elements to consider
        an offense with `MinSize`.

        === Examples

        [source,ruby]
        ----
        # bad
        users.select do |user|
          %i[superadmin admin].include?(user.role)
        end

        # good
        admin_roles = %i[superadmin admin]
        users.select do |user|
          admin_roles.include?(user.role)
        end

        # good
        ADMIN_ROLES = %i[superadmin admin]
        ...
        users.select do |user|
          ADMIN_ROLES.include?(user.role)
        end
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | MinSize
        | `1`
        | Integer
        |===

        == Performance/CompareWithBlock

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.46
        | -
        |===

        Identifies places where `sort { |a, b| a.foo <=> b.foo }`
        can be replaced by `sort_by(&:foo)`.
        This cop also checks `sort!`, `min`, `max` and `minmax` methods.

        === Examples

        [source,ruby]
        ----
        # bad
        array.sort   { |a, b| a.foo <=> b.foo }
        array.sort!  { |a, b| a.foo <=> b.foo }
        array.max    { |a, b| a.foo <=> b.foo }
        array.min    { |a, b| a.foo <=> b.foo }
        array.minmax { |a, b| a.foo <=> b.foo }
        array.sort   { |a, b| a[:foo] <=> b[:foo] }

        # good
        array.sort_by(&:foo)
        array.sort_by!(&:foo)
        array.sort_by { |v| v.foo }
        array.sort_by do |var|
          var.foo
        end
        array.max_by(&:foo)
        array.min_by(&:foo)
        array.minmax_by(&:foo)
        array.sort_by { |a| a[:foo] }
        ----

        == Performance/ConcurrentMonotonicTime

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.12
        | -
        |===

        Identifies places where `Concurrent.monotonic_time`
        can be replaced by `Process.clock_gettime(Process::CLOCK_MONOTONIC)`.

        === Examples

        [source,ruby]
        ----
        # bad
        Concurrent.monotonic_time

        # good
        Process.clock_gettime(Process::CLOCK_MONOTONIC)
        ----

        === References

        * https://github.com/rails/rails/pull/43502

        == Performance/ConstantRegexp

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.9
        | 1.10
        |===

        Finds regular expressions with dynamic components that are all constants.

        Ruby allocates a new Regexp object every time it executes a code containing such
        a regular expression. It is more efficient to extract it into a constant,
        memoize it, or add an `/o` option to perform `#{}` interpolation only once and
        reuse that Regexp object.

        === Examples

        [source,ruby]
        ----
        # bad
        def tokens(pattern)
          pattern.scan(TOKEN).reject { |token| token.match?(/\A#{SEPARATORS}\Z/) }
        end

        # good
        ALL_SEPARATORS = /\A#{SEPARATORS}\Z/
        def tokens(pattern)
          pattern.scan(TOKEN).reject { |token| token.match?(ALL_SEPARATORS) }
        end

        # good
        def tokens(pattern)
          pattern.scan(TOKEN).reject { |token| token.match?(/\A#{SEPARATORS}\Z/o) }
        end

        # good
        def separators
          @separators ||= /\A#{SEPARATORS}\Z/
        end
        ----

        == Performance/Count

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.31
        | 1.8
        |===

        Identifies usages of `count` on an `Enumerable` that
        follow calls to `select`, `find_all`, `filter` or `reject`. Querying logic can instead be
        passed to the `count` call.

        === Safety

        This cop is unsafe because it has known compatibility issues with `ActiveRecord` and other
        frameworks. Before Rails 5.1, `ActiveRecord` will ignore the block that is passed to `count`.
        Other methods, such as `select`, will convert the association to an
        array and then run the block on the array. A simple work around to
        make `count` work with a block is to call `to_a.count {...}`.

        For example:

        [source,ruby]
        ----
        `Model.where(id: [1, 2, 3]).select { |m| m.method == true }.size`
        ----

        becomes:

        [source,ruby]
        ----
        `Model.where(id: [1, 2, 3]).to_a.count { |m| m.method == true }`
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        [1, 2, 3].select { |e| e > 2 }.size
        [1, 2, 3].reject { |e| e > 2 }.size
        [1, 2, 3].select { |e| e > 2 }.length
        [1, 2, 3].reject { |e| e > 2 }.length
        [1, 2, 3].select { |e| e > 2 }.count { |e| e.odd? }
        [1, 2, 3].reject { |e| e > 2 }.count { |e| e.even? }
        array.select(&:value).count

        # good
        [1, 2, 3].count { |e| e > 2 }
        [1, 2, 3].count { |e| e < 2 }
        [1, 2, 3].count { |e| e > 2 && e.odd? }
        [1, 2, 3].count { |e| e < 2 && e.even? }
        Model.select('field AS field_one').count
        Model.select(:value).count
        ----

        == Performance/DeletePrefix

        NOTE: Required Ruby version: 2.5

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 1.6
        | 1.11
        |===

        In Ruby 2.5, `String#delete_prefix` has been added.

        This cop identifies places where `gsub(/\Aprefix/, '')` and `sub(/\Aprefix/, '')`
        can be replaced by `delete_prefix('prefix')`.

        This cop has `SafeMultiline` configuration option that `true` by default because
        `^prefix` is unsafe as it will behave incompatible with `delete_prefix`
        for receiver is multiline string.

        The `delete_prefix('prefix')` method is faster than `gsub(/\Aprefix/, '')`.

        === Safety

        This cop is unsafe because `Pathname` has `sub` but not `delete_prefix`.

        === Examples

        [source,ruby]
        ----
        # bad
        str.gsub(/\Aprefix/, '')
        str.gsub!(/\Aprefix/, '')

        str.sub(/\Aprefix/, '')
        str.sub!(/\Aprefix/, '')

        # good
        str.delete_prefix('prefix')
        str.delete_prefix!('prefix')
        ----

        ==== SafeMultiline: true (default)

        [source,ruby]
        ----
        # good
        str.gsub(/^prefix/, '')
        str.gsub!(/^prefix/, '')
        str.sub(/^prefix/, '')
        str.sub!(/^prefix/, '')
        ----

        ==== SafeMultiline: false

        [source,ruby]
        ----
        # bad
        str.gsub(/^prefix/, '')
        str.gsub!(/^prefix/, '')
        str.sub(/^prefix/, '')
        str.sub!(/^prefix/, '')
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | SafeMultiline
        | `true`
        | Boolean
        |===

        == Performance/DeleteSuffix

        NOTE: Required Ruby version: 2.5

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 1.6
        | 1.11
        |===

        In Ruby 2.5, `String#delete_suffix` has been added.

        This cop identifies places where `gsub(/suffix\z/, '')` and `sub(/suffix\z/, '')`
        can be replaced by `delete_suffix('suffix')`.

        This cop has `SafeMultiline` configuration option that `true` by default because
        `suffix$` is unsafe as it will behave incompatible with `delete_suffix?`
        for receiver is multiline string.

        The `delete_suffix('suffix')` method is faster than `gsub(/suffix\z/, '')`.

        === Safety

        This cop is unsafe because `Pathname` has `sub` but not `delete_suffix`.

        === Examples

        [source,ruby]
        ----
        # bad
        str.gsub(/suffix\z/, '')
        str.gsub!(/suffix\z/, '')

        str.sub(/suffix\z/, '')
        str.sub!(/suffix\z/, '')

        # good
        str.delete_suffix('suffix')
        str.delete_suffix!('suffix')
        ----

        ==== SafeMultiline: true (default)

        [source,ruby]
        ----
        # good
        str.gsub(/suffix$/, '')
        str.gsub!(/suffix$/, '')
        str.sub(/suffix$/, '')
        str.sub!(/suffix$/, '')
        ----

        ==== SafeMultiline: false

        [source,ruby]
        ----
        # bad
        str.gsub(/suffix$/, '')
        str.gsub!(/suffix$/, '')
        str.sub(/suffix$/, '')
        str.sub!(/suffix$/, '')
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | SafeMultiline
        | `true`
        | Boolean
        |===

        == Performance/Detect

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.30
        | 1.8
        |===

        Identifies usages of `first`, `last`, `[0]` or `[-1]`
        chained to `select`, `find_all` or `filter` and change them to use
        `detect` instead.

        === Safety

        This cop is unsafe because it assumes that the receiver is an
        `Array` or equivalent, but can't reliably detect it. For example,
        if the receiver is a `Hash`, it may report a false positive.

        === Examples

        [source,ruby]
        ----
        # bad
        [].select { |item| true }.first
        [].select { |item| true }.last
        [].find_all { |item| true }.first
        [].find_all { |item| true }.last
        [].filter { |item| true }.first
        [].filter { |item| true }.last
        [].filter { |item| true }[0]
        [].filter { |item| true }[-1]

        # good
        [].detect { |item| true }
        [].reverse.detect { |item| true }
        ----

        === References

        * https://github.com/fastruby/fast-ruby#enumerabledetect-vs-enumerableselectfirst-code

        == Performance/DoubleStartEndWith

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.36
        | 0.48
        |===

        Checks for double `#start_with?` or `#end_with?` calls
        separated by `||`. In some cases such calls can be replaced
        with an single `#start_with?`/`#end_with?` call.

        `IncludeActiveSupportAliases` configuration option is used to check for
        `starts_with?` and `ends_with?`. These methods are defined by Active Support.

        === Examples

        [source,ruby]
        ----
        # bad
        str.start_with?("a") || str.start_with?(Some::CONST)
        str.start_with?("a", "b") || str.start_with?("c")
        str.end_with?(var1) || str.end_with?(var2)

        # good
        str.start_with?("a", Some::CONST)
        str.start_with?("a", "b", "c")
        str.end_with?(var1, var2)
        ----

        ==== IncludeActiveSupportAliases: false (default)

        [source,ruby]
        ----
        # good
        str.starts_with?("a", "b") || str.starts_with?("c")
        str.ends_with?(var1) || str.ends_with?(var2)

        str.starts_with?("a", "b", "c")
        str.ends_with?(var1, var2)
        ----

        ==== IncludeActiveSupportAliases: true

        [source,ruby]
        ----
        # bad
        str.starts_with?("a", "b") || str.starts_with?("c")
        str.ends_with?(var1) || str.ends_with?(var2)

        # good
        str.starts_with?("a", "b", "c")
        str.ends_with?(var1, var2)
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | IncludeActiveSupportAliases
        | `false`
        | Boolean
        |===

        == Performance/EndWith

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.36
        | 1.10
        |===

        Identifies unnecessary use of a regex where `String#end_with?` would suffice.

        This cop has `SafeMultiline` configuration option that `true` by default because
        `end$` is unsafe as it will behave incompatible with `end_with?`
        for receiver is multiline string.

        === Safety

        This will change to a new method call which isn't guaranteed to be on the
        object. Switching these methods has to be done with knowledge of the types
        of the variables which rubocop doesn't have.

        === Examples

        [source,ruby]
        ----
        # bad
        'abc'.match?(/bc\Z/)
        /bc\Z/.match?('abc')
        'abc' =~ /bc\Z/
        /bc\Z/ =~ 'abc'
        'abc'.match(/bc\Z/)
        /bc\Z/.match('abc')

        # good
        'abc'.end_with?('bc')
        ----

        ==== SafeMultiline: true (default)

        [source,ruby]
        ----
        # good
        'abc'.match?(/bc$/)
        /bc$/.match?('abc')
        'abc' =~ /bc$/
        /bc$/ =~ 'abc'
        'abc'.match(/bc$/)
        /bc$/.match('abc')
        ----

        ==== SafeMultiline: false

        [source,ruby]
        ----
        # bad
        'abc'.match?(/bc$/)
        /bc$/.match?('abc')
        'abc' =~ /bc$/
        /bc$/ =~ 'abc'
        'abc'.match(/bc$/)
        /bc$/.match('abc')
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | SafeMultiline
        | `true`
        | Boolean
        |===

        === References

        * https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end

        == Performance/FixedSize

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | No
        | 0.35
        | -
        |===

        Do not compute the size of statically sized objects.

        === Examples

        [source,ruby]
        ----
        # String methods
        # bad
        'foo'.size
        %q[bar].count
        %(qux).length

        # Symbol methods
        # bad
        :fred.size
        :'baz'.length

        # Array methods
        # bad
        [1, 2, thud].count
        %W(1, 2, bar).size

        # Hash methods
        # bad
        { a: corge, b: grault }.length

        # good
        foo.size
        bar.count
        qux.length

        # good
        :"#{fred}".size
        CONST = :baz.length

        # good
        [1, 2, *thud].count
        garply = [1, 2, 3]
        garply.size

        # good
        { a: corge, **grault }.length
        waldo = { a: corge, b: grault }
        waldo.size
        ----

        == Performance/FlatMap

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.30
        | -
        |===

        Identifies usages of `map { ... }.flatten` and
        change them to use `flat_map { ... }` instead.

        === Examples

        [source,ruby]
        ----
        # bad
        [1, 2, 3, 4].map { |e| [e, e] }.flatten(1)
        [1, 2, 3, 4].collect { |e| [e, e] }.flatten(1)

        # good
        [1, 2, 3, 4].flat_map { |e| [e, e] }
        [1, 2, 3, 4].map { |e| [e, e] }.flatten
        [1, 2, 3, 4].collect { |e| [e, e] }.flatten
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | EnabledForFlattenWithoutParams
        | `false`
        | Boolean
        |===

        === References

        * https://github.com/fastruby/fast-ruby#enumerablemaparrayflatten-vs-enumerableflat_map-code

        == Performance/InefficientHashSearch

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 0.56
        | -
        |===

        Checks for inefficient searching of keys and values within
        hashes.

        `Hash#keys.include?` is less efficient than `Hash#key?` because
        the former allocates a new array and then performs an O(n) search
        through that array, while `Hash#key?` does not allocate any array and
        performs a faster O(1) search for the key.

        `Hash#values.include?` is less efficient than `Hash#value?`. While they
        both perform an O(n) search through all of the values, calling `values`
        allocates a new array while using `value?` does not.

        === Safety

        This cop is unsafe because it can't tell whether the receiver is a hash object.

        === Examples

        [source,ruby]
        ----
        # bad
        { a: 1, b: 2 }.keys.include?(:a)
        { a: 1, b: 2 }.keys.include?(:z)
        h = { a: 1, b: 2 }; h.keys.include?(100)

        # good
        { a: 1, b: 2 }.key?(:a)
        { a: 1, b: 2 }.has_key?(:z)
        h = { a: 1, b: 2 }; h.key?(100)

        # bad
        { a: 1, b: 2 }.values.include?(2)
        { a: 1, b: 2 }.values.include?('garbage')
        h = { a: 1, b: 2 }; h.values.include?(nil)

        # good
        { a: 1, b: 2 }.value?(2)
        { a: 1, b: 2 }.has_value?('garbage')
        h = { a: 1, b: 2 }; h.value?(nil)
        ----

        === References

        * https://github.com/fastruby/fast-ruby#hashkey-instead-of-hashkeysinclude-code

        == Performance/IoReadlines

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where inefficient `readlines` method
        can be replaced by `each_line` to avoid fully loading file content into memory.

        === Examples

        [source,ruby]
        ----
        # bad
        File.readlines('testfile').each { |l| puts l }
        IO.readlines('testfile', chomp: true).each { |l| puts l }

        conn.readlines(10).map { |l| l.size }
        file.readlines.find { |l| l.start_with?('#') }
        file.readlines.each { |l| puts l }

        # good
        File.open('testfile', 'r').each_line { |l| puts l }
        IO.open('testfile').each_line(chomp: true) { |l| puts l }

        conn.each_line(10).map { |l| l.size }
        file.each_line.find { |l| l.start_with?('#') }
        file.each_line { |l| puts l }
        ----

        === References

        * https://docs.gitlab.com/ee/development/performance.html#reading-from-files-and-other-data-sources

        == Performance/MapCompact

        NOTE: Required Ruby version: 2.7

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always (Unsafe)
        | 1.11
        | -
        |===

        In Ruby 2.7, `Enumerable#filter_map` has been added.

        This cop identifies places where `map { ... }.compact` can be replaced by `filter_map`.

        [source,ruby]
        ----
        [true, false, nil].compact              #=> [true, false]
        [true, false, nil].filter_map(&:itself) #=> [true]
        ----

        === Safety

        This cop's autocorrection is unsafe because `map { ... }.compact` that is not
        compatible with `filter_map`.

        === Examples

        [source,ruby]
        ----
        # bad
        ary.map(&:foo).compact
        ary.collect(&:foo).compact

        # good
        ary.filter_map(&:foo)
        ary.map(&:foo).compact!
        ary.compact.map(&:foo)
        ----

        == Performance/MapMethodChain

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | No
        | 1.19
        | -
        |===

        Checks if the map method is used in a chain.

        Autocorrection is not supported because an appropriate block variable name cannot be determined automatically.

        [source,ruby]
        ----
        class X
          def initialize
            @@num = 0
          end

          def foo
            @@num += 1
            self
          end

          def bar
            @@num * 2
          end
        end

        [X.new, X.new].map(&:foo).map(&:bar) # => [4, 4]
        [X.new, X.new].map { |x| x.foo.bar } # => [2, 4]
        ----

        === Safety

        This cop is unsafe because false positives occur if the number of times the first method is executed
        affects the return value of subsequent methods.

        === Examples

        [source,ruby]
        ----
        # bad
        array.map(&:foo).map(&:bar)

        # good
        array.map { |item| item.foo.bar }
        ----

        == Performance/MethodObjectAsBlock

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | No
        | 1.9
        | -
        |===

        Identifies places where methods are converted to blocks, with the
        use of `&method`, and passed as arguments to method calls.
        It is faster to replace those with explicit blocks, calling those methods inside.

        === Examples

        [source,ruby]
        ----
        # bad
        array.map(&method(:do_something))
        [1, 2, 3].each(&out.method(:puts))

        # good
        array.map { |x| do_something(x) }
        [1, 2, 3].each { |x| out.puts(x) }
        ----

        === References

        * https://github.com/fastruby/fast-ruby#normal-way-to-apply-method-vs-method-code

        == Performance/OpenStruct

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | No
        | No
        | 0.61
        | -
        |===

        Checks for `OpenStruct.new` calls.
        Instantiation of an `OpenStruct` invalidates
        Ruby global method cache as it causes dynamic method
        definition during program runtime.
        This could have an effect on performance,
        especially in case of single-threaded
        applications with multiple `OpenStruct` instantiations.

        === Safety

        This cop is unsafe because `OpenStruct.new` and `Struct.new`
        are not equivalent.

        === Examples

        [source,ruby]
        ----
        # bad
        class MyClass
          def my_method
            OpenStruct.new(my_key1: 'my_value1', my_key2: 'my_value2')
          end
        end

        # good
        class MyClass
          MyStruct = Struct.new(:my_key1, :my_key2)
          def my_method
            MyStruct.new('my_value1', 'my_value2')
          end
        end
        ----

        == Performance/RangeInclude

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 0.36
        | 1.7
        |===

        Identifies uses of `Range#include?` and `Range#member?`, which iterates over each
        item in a `Range` to see if a specified item is there. In contrast,
        `Range#cover?` simply compares the target item with the beginning and
        end points of the `Range`. In a great majority of cases, this is what
        is wanted.

        === Safety

        This cop is unsafe because `Range#include?` (or `Range#member?`) and `Range#cover?`
        are not equivalent behavior.
        Example of a case where `Range#cover?` may not provide the desired result:

        [source,ruby]
        ----
        ('a'..'z').cover?('yellow') # => true
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        ('a'..'z').include?('b') # => true
        ('a'..'z').member?('b')  # => true

        # good
        ('a'..'z').cover?('b') # => true
        ----

        === References

        * https://github.com/fastruby/fast-ruby#cover-vs-include-code

        == Performance/RedundantBlockCall

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.36
        | -
        |===

        Identifies the use of a `&block` parameter and `block.call`
        where `yield` would do just as well.

        === Examples

        [source,ruby]
        ----
        # bad
        def method(&block)
          block.call
        end
        def another(&func)
          func.call 1, 2, 3
        end

        # good
        def method
          yield
        end
        def another
          yield 1, 2, 3
        end
        ----

        === References

        * https://github.com/fastruby/fast-ruby#proccall-and-block-arguments-vs-yieldcode

        == Performance/RedundantEqualityComparisonBlock

        NOTE: Required Ruby version: 2.5

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | No
        | Always (Unsafe)
        | 1.10
        | -
        |===

        Checks for uses `Enumerable#all?`, `Enumerable#any?`, `Enumerable#one?`,
        and `Enumerable#none?` are compared with `===` or similar methods in block.

        By default, `Object#===` behaves the same as `Object#==`, but this
        behavior is appropriately overridden in subclass. For example,
        `Range#===` returns `true` when argument is within the range.

        This cop has `AllowRegexpMatch` option and it is true by default because
        `regexp.match?('string')` often used in block changes to the opposite result:

        [source,ruby]
        ----
        [/pattern/].all? { |regexp| regexp.match?('pattern') } # => true
        [/pattern/].all? { |regexp| regexp =~ 'pattern' }      # => true
        [/pattern/].all?('pattern')                            # => false
        ----

        === Safety

        This cop is unsafe because `===` and `==` do not always behave the same.

        === Examples

        [source,ruby]
        ----
        # bad
        items.all? { |item| pattern === item }
        items.all? { |item| item == other }
        items.all? { |item| item.is_a?(Klass) }
        items.all? { |item| item.kind_of?(Klass) }

        # good
        items.all?(pattern)
        items.all?(Klass)
        ----

        ==== AllowRegexpMatch: true (default)

        [source,ruby]
        ----
        # good
        items.all? { |item| item =~ pattern }
        items.all? { |item| item.match?(pattern) }
        ----

        ==== AllowRegexpMatch: false

        [source,ruby]
        ----
        # bad
        items.all? { |item| item =~ pattern }
        items.all? { |item| item.match?(pattern) }
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | AllowRegexpMatch
        | `true`
        | Boolean
        |===

        === References

        * https://github.com/rails/rails/pull/41363

        == Performance/RedundantMatch

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.36
        | -
        |===

        Identifies the use of `Regexp#match` or `String#match`, which
        returns `#<MatchData>`/`nil`. The return value of `=~` is an integral
        index/`nil` and is more performant.

        === Examples

        [source,ruby]
        ----
        # bad
        do_something if str.match(/regex/)
        while regex.match('str')
          do_something
        end

        # good
        method(str =~ /regex/)
        return value unless regex =~ 'str'
        ----

        == Performance/RedundantMerge

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | No
        | Always (Unsafe)
        | 0.36
        | 1.11
        |===

        Identifies places where `Hash#merge!` can be replaced by `Hash#[]=`.
        You can set the maximum number of key-value pairs to consider
        an offense with `MaxKeyValuePairs`.

        === Safety

        This cop is unsafe because RuboCop cannot determine if the
        receiver of `merge!` is actually a hash or not.

        === Examples

        [source,ruby]
        ----
        # bad
        hash.merge!(a: 1)
        hash.merge!({'key' => 'value'})

        # good
        hash[:a] = 1
        hash['key'] = 'value'
        ----

        ==== MaxKeyValuePairs: 2 (default)

        [source,ruby]
        ----
        # bad
        hash.merge!(a: 1, b: 2)

        # good
        hash[:a] = 1
        hash[:b] = 2
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | MaxKeyValuePairs
        | `2`
        | Integer
        |===

        === References

        * https://github.com/fastruby/fast-ruby#hashmerge-vs-hash-code

        == Performance/RedundantSortBlock

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where `sort { |a, b| a <=> b }` can be replaced with `sort`.

        === Examples

        [source,ruby]
        ----
        # bad
        array.sort { |a, b| a <=> b }

        # good
        array.sort
        ----

        == Performance/RedundantSplitRegexpArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.10
        | -
        |===

        Identifies places where `split` argument can be replaced from
        a deterministic regexp to a string.

        === Examples

        [source,ruby]
        ----
        # bad
        'a,b,c'.split(/,/)

        # good
        'a,b,c'.split(',')
        ----

        == Performance/RedundantStringChars

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Checks for redundant `String#chars`.

        === Examples

        [source,ruby]
        ----
        # bad
        str.chars[0..2]
        str.chars.slice(0..2)
        str.chars.last

        # good
        str[0..2].chars

        # bad
        str.chars.first
        str.chars.first(2)

        # good
        str[0]
        str[0...2].chars
        str[-1]

        # bad
        str.chars.take(2)
        str.chars.length
        str.chars.size
        str.chars.empty?

        # good
        str[0...2].chars
        str.length
        str.size
        str.empty?

        # For example, if the receiver is an empty string, it will be incompatible.
        # If a negative value is specified for the receiver, `nil` is returned.
        str.chars.last(2) # Incompatible with `str[-2..-1].chars`.
        str.chars.drop(2) # Incompatible with `str[2..-1].chars`.
        ----

        == Performance/RegexpMatch

        NOTE: Required Ruby version: 2.4

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.47
        | -
        |===

        In Ruby 2.4, `String#match?`, `Regexp#match?`, and `Symbol#match?`
        have been added. The methods are faster than `match`.
        Because the methods avoid creating a `MatchData` object or saving
        backref.
        So, when `MatchData` is not used, use `match?` instead of `match`.

        === Examples

        [source,ruby]
        ----
        # bad
        def foo
          if x =~ /re/
            do_something
          end
        end

        # bad
        def foo
          if x !~ /re/
            do_something
          end
        end

        # bad
        def foo
          if x.match(/re/)
            do_something
          end
        end

        # bad
        def foo
          if /re/ === x
            do_something
          end
        end

        # good
        def foo
          if x.match?(/re/)
            do_something
          end
        end

        # good
        def foo
          if !x.match?(/re/)
            do_something
          end
        end

        # good
        def foo
          if x =~ /re/
            do_something(Regexp.last_match)
          end
        end

        # good
        def foo
          if x.match(/re/)
            do_something($~)
          end
        end

        # good
        def foo
          if /re/ === x
            do_something($~)
          end
        end
        ----

        === References

        * https://github.com/fastruby/fast-ruby#regexp-vs-regexpmatch-vs-regexpmatch-vs-stringmatch-vs-string-vs-stringmatch-code-

        == Performance/ReverseEach

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.30
        | -
        |===

        Identifies usages of `reverse.each` and change them to use `reverse_each` instead.

        If the return value is used, it will not be detected because the result will be different.

        [source,ruby]
        ----
        [1, 2, 3].reverse.each {} #=> [3, 2, 1]
        [1, 2, 3].reverse_each {} #=> [1, 2, 3]
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        items.reverse.each

        # good
        items.reverse_each
        ----

        === References

        * https://github.com/fastruby/fast-ruby#enumerablereverseeach-vs-enumerablereverse_each-code

        == Performance/ReverseFirst

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where `reverse.first(n)` and `reverse.first`
        can be replaced by `last(n).reverse` and `last`.

        === Examples

        [source,ruby]
        ----
        # bad
        array.reverse.first(5)
        array.reverse.first

        # good
        array.last(5).reverse
        array.last
        ----

        == Performance/SelectMap

        NOTE: Required Ruby version: 2.7

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Disabled
        | Yes
        | No
        | 1.11
        | -
        |===

        In Ruby 2.7, `Enumerable#filter_map` has been added.

        This cop identifies places where `select.map` can be replaced by `filter_map`.

        === Examples

        [source,ruby]
        ----
        # bad
        ary.select(&:foo).map(&:bar)
        ary.filter(&:foo).map(&:bar)

        # good
        ary.filter_map { |o| o.bar if o.foo }
        ----

        == Performance/Size

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.30
        | -
        |===

        Identifies usages of `count` on an `Array` and `Hash` and change them to `size`.

        TODO: Add advanced detection of variables that could
        have been assigned to an array or a hash.

        === Examples

        [source,ruby]
        ----
        # bad
        [1, 2, 3].count
        (1..3).to_a.count
        Array[*1..3].count
        Array(1..3).count

        # bad
        {a: 1, b: 2, c: 3}.count
        [[:foo, :bar], [1, 2]].to_h.count
        Hash[*('a'..'z')].count
        Hash(key: :value).count

        # good
        [1, 2, 3].size
        (1..3).to_a.size
        Array[*1..3].size
        Array(1..3).size

        # good
        {a: 1, b: 2, c: 3}.size
        [[:foo, :bar], [1, 2]].to_h.size
        Hash[*('a'..'z')].size
        Hash(key: :value).size

        # good
        [1, 2, 3].count { |e| e > 2 }
        ----

        === References

        * https://github.com/fastruby/fast-ruby#arraylength-vs-arraysize-vs-arraycount-code

        == Performance/SortReverse

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where `sort { |a, b| b <=> a }`
        can be replaced by a faster `sort.reverse`.

        === Examples

        [source,ruby]
        ----
        # bad
        array.sort { |a, b| b <=> a }

        # good
        array.sort.reverse
        ----

        == Performance/Squeeze

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.7
        | -
        |===

        Identifies places where `gsub(/a+/, 'a')` and `gsub!(/a+/, 'a')`
        can be replaced by `squeeze('a')` and `squeeze!('a')`.

        The `squeeze('a')` method is faster than `gsub(/a+/, 'a')`.

        === Examples

        [source,ruby]
        ----
        # bad
        str.gsub(/a+/, 'a')
        str.gsub!(/a+/, 'a')

        # good
        str.squeeze('a')
        str.squeeze!('a')
        ----

        === References

        * https://github.com/fastruby/fast-ruby#remove-extra-spaces-or-other-contiguous-characters-code

        == Performance/StartWith

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.36
        | 1.10
        |===

        Identifies unnecessary use of a regex where `String#start_with?` would suffice.

        This cop has `SafeMultiline` configuration option that `true` by default because
        `^start` is unsafe as it will behave incompatible with `start_with?`
        for receiver is multiline string.

        === Safety

        This will change to a new method call which isn't guaranteed to be on the
        object. Switching these methods has to be done with knowledge of the types
        of the variables which rubocop doesn't have.

        === Examples

        [source,ruby]
        ----
        # bad
        'abc'.match?(/\Aab/)
        /\Aab/.match?('abc')
        'abc' =~ /\Aab/
        /\Aab/ =~ 'abc'
        'abc'.match(/\Aab/)
        /\Aab/.match('abc')

        # good
        'abc'.start_with?('ab')
        ----

        ==== SafeMultiline: true (default)

        [source,ruby]
        ----
        # good
        'abc'.match?(/^ab/)
        /^ab/.match?('abc')
        'abc' =~ /^ab/
        /^ab/ =~ 'abc'
        'abc'.match(/^ab/)
        /^ab/.match('abc')
        ----

        ==== SafeMultiline: false

        [source,ruby]
        ----
        # bad
        'abc'.match?(/^ab/)
        /^ab/.match?('abc')
        'abc' =~ /^ab/
        /^ab/ =~ 'abc'
        'abc'.match(/^ab/)
        /^ab/.match('abc')
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | SafeMultiline
        | `true`
        | Boolean
        |===

        === References

        * https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end

        == Performance/StringIdentifierArgument

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always
        | 1.13
        | -
        |===

        Identifies places where string identifier argument can be replaced
        by symbol identifier argument.
        It prevents the redundancy of the internal string-to-symbol conversion.

        This cop targets methods that take identifier (e.g. method name) argument
        and the following examples are parts of it.

        === Examples

        [source,ruby]
        ----
        # bad
        send('do_something')
        attr_accessor 'do_something'
        instance_variable_get('@ivar')
        respond_to?("string_#{interpolation}")

        # good
        send(:do_something)
        attr_accessor :do_something
        instance_variable_get(:@ivar)
        respond_to?(:"string_#{interpolation}")

        # good - these methods don't support namespaced symbols
        const_get("#{module_path}::Base")
        const_source_location("#{module_path}::Base")
        const_defined?("#{module_path}::Base")
        ----

        == Performance/StringInclude

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always (Unsafe)
        | 1.7
        | 1.12
        |===

        Identifies unnecessary use of a regex where `String#include?` would suffice.

        === Safety

        This cop's offenses are not safe to autocorrect if a receiver is nil or a Symbol.

        === Examples

        [source,ruby]
        ----
        # bad
        str.match?(/ab/)
        /ab/.match?(str)
        str =~ /ab/
        /ab/ =~ str
        str.match(/ab/)
        /ab/.match(str)
        /ab/ === str

        # good
        str.include?('ab')
        ----

        == Performance/StringReplacement

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.33
        | -
        |===

        Identifies places where `gsub` can be replaced by `tr` or `delete`.

        === Examples

        [source,ruby]
        ----
        # bad
        'abc'.gsub('b', 'd')
        'abc'.gsub('a', '')
        'abc'.gsub(/a/, 'd')
        'abc'.gsub!('a', 'd')

        # good
        'abc'.gsub(/.*/, 'a')
        'abc'.gsub(/a+/, 'd')
        'abc'.tr('b', 'd')
        'a b c'.delete(' ')
        ----

        === References

        * https://github.com/fastruby/fast-ruby#stringgsub-vs-stringtr-code

        == Performance/Sum

        NOTE: Required Ruby version: 2.4

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Pending
        | Yes
        | Always (Unsafe)
        | 1.8
        | 1.13
        |===

        Identifies places where custom code finding the sum of elements
        in some Enumerable object can be replaced by `Enumerable#sum` method.

        === Safety

        Autocorrections are unproblematic wherever an initial value is provided explicitly:

        [source,ruby]
        ----
        [1, 2, 3].reduce(4, :+) # => 10
        [1, 2, 3].sum(4) # => 10

        [].reduce(4, :+) # => 4
        [].sum(4) # => 4
        ----

        This also holds true for non-numeric types which implement a `:+` method:

        [source,ruby]
        ----
        ['l', 'o'].reduce('Hel', :+) # => "Hello"
        ['l', 'o'].sum('Hel') # => "Hello"
        ----

        When no initial value is provided though, `Enumerable#reduce` will pick the first enumerated value
        as initial value and successively add all following values to it, whereas
        `Enumerable#sum` will set an initial value of `0` (`Integer`) which can lead to a `TypeError`:

        [source,ruby]
        ----
        [].reduce(:+) # => nil
        [1, 2, 3].reduce(:+) # => 6
        ['H', 'e', 'l', 'l', 'o'].reduce(:+) # => "Hello"

        [].sum # => 0
        [1, 2, 3].sum # => 6
        ['H', 'e', 'l', 'l', 'o'].sum # => in `+': String can't be coerced into Integer (TypeError)
        ----

        === Examples

        ==== OnlySumOrWithInitialValue: false (default)

        [source,ruby]
        ----
        # bad
        [1, 2, 3].inject(:+)                        # Autocorrections for cases without initial value are unsafe
        [1, 2, 3].inject(&:+)                       # and will only be performed when using the `-A` option.
        [1, 2, 3].reduce { |acc, elem| acc + elem } # They can be prohibited completely using `SafeAutoCorrect: true`.
        [1, 2, 3].reduce(10, :+)
        [1, 2, 3].map { |elem| elem ** 2 }.sum
        [1, 2, 3].collect(&:count).sum(10)

        # good
        [1, 2, 3].sum
        [1, 2, 3].sum(10)
        [1, 2, 3].sum { |elem| elem ** 2 }
        [1, 2, 3].sum(10, &:count)
        ----

        ==== OnlySumOrWithInitialValue: true

        [source,ruby]
        ----
        # bad
        [1, 2, 3].reduce(10, :+)
        [1, 2, 3].map { |elem| elem ** 2 }.sum
        [1, 2, 3].collect(&:count).sum(10)

        # good
        [1, 2, 3].sum(10)
        [1, 2, 3].sum { |elem| elem ** 2 }
        [1, 2, 3].sum(10, &:count)
        ----

        === Configurable attributes

        |===
        | Name | Default value | Configurable values

        | OnlySumOrWithInitialValue
        | `false`
        | Boolean
        |===

        === References

        * https://blog.bigbinary.com/2016/11/02/ruby-2-4-introduces-enumerable-sum.html

        == Performance/TimesMap

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.36
        | 1.13
        |===

        Checks for .times.map calls.
        In most cases such calls can be replaced
        with an explicit array creation.

        === Safety

        This cop's autocorrection is unsafe because `Integer#times` does nothing if receiver is 0
        or less. However, `Array.new` raises an error if argument is less than 0.

        For example:

        [source,ruby]
        ----
        -1.times{}    # does nothing
        Array.new(-1) # ArgumentError: negative array size
        ----

        === Examples

        [source,ruby]
        ----
        # bad
        9.times.map do |i|
          i.to_s
        end

        # good
        Array.new(9) do |i|
          i.to_s
        end
        ----

        == Performance/UnfreezeString

        NOTE: Required Ruby version: 2.3

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always (Unsafe)
        | 0.50
        | 1.9
        |===

        In Ruby 2.3 or later, use unary plus operator to unfreeze a string
        literal instead of `String#dup` and `String.new`.
        Unary plus operator is faster than `String#dup`.

        === Safety

        This cop's autocorrection is unsafe because `String.new` (without operator) is not
        exactly the same as `+''`. These differ in encoding. `String.new.encoding` is always
        `ASCII-8BIT`. However, `(+'').encoding` is the same as script encoding(e.g. `UTF-8`).
        if you expect `ASCII-8BIT` encoding, disable this cop.

        === Examples

        [source,ruby]
        ----
        # bad
        ''.dup          # when Ruby 3.2 or lower
        "something".dup # when Ruby 3.2 or lower
        String.new
        String.new('')
        String.new('something')

        # good
        +'something'
        +''
        ----

        == Performance/UriDefaultParser

        |===
        | Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

        | Enabled
        | Yes
        | Always
        | 0.50
        | -
        |===

        Identifies places where `URI::Parser.new` can be replaced by `URI::DEFAULT_PARSER`.

        === Examples

        [source,ruby]
        ----
        # bad
        URI::Parser.new

        # good
        URI::DEFAULT_PARSER
        ----
  recorded_at: Mon, 27 May 2024 05:30:43 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-performance/v1.21.0/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '13344'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"d70422d2e1ad40ac9f3b4fce3ca964adb6b3eeaa62d148582f8918bc0ee7bcd4"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 8096:3BC15A:133204B:146B022:66541A7C
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:43 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230089-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787843.293776,VS0,VE181
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 7af1a31d89cc1fa0503ebec07214ee3c490b25fa
      Expires:
      - Mon, 27 May 2024 05:35:43 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        # This is the default configuration file.

        Performance:
          Enabled: true
          DocumentationBaseURL: https://docs.rubocop.org/rubocop-performance

        Performance/AncestorsInclude:
          Description: 'Use `A <= B` instead of `A.ancestors.include?(B)`.'
          Reference: 'https://github.com/fastruby/fast-ruby#ancestorsinclude-vs--code'
          Enabled: 'pending'
          Safe: false
          VersionAdded: '1.7'

        Performance/ArraySemiInfiniteRangeSlice:
          Description: 'Identifies places where slicing arrays with semi-infinite ranges can be replaced by `Array#take` and `Array#drop`.'
          # This cop was created due to a mistake in microbenchmark.
          # Refer https://github.com/rubocop/rubocop-performance/pull/175#issuecomment-731892717
          Enabled: false
          # Unsafe for string slices because strings do not have `#take` and `#drop` methods.
          Safe: false
          VersionAdded: '1.9'

        Performance/BigDecimalWithNumericArgument:
          Description: 'Convert numeric literal to string and pass it to `BigDecimal`.'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/BindCall:
          Description: 'Use `bind_call(obj, args, ...)` instead of `bind(obj).call(args, ...)`.'
          Enabled: true
          VersionAdded: '1.6'

        Performance/BlockGivenWithExplicitBlock:
          Description: 'Check block argument explicitly instead of using `block_given?`.'
          Enabled: pending
          VersionAdded: '1.9'

        Performance/Caller:
          Description: >-
                     Use `caller(n..n)` instead of `caller`.
          Enabled: true
          VersionAdded: '0.49'
          VersionChanged: '1.9'

        Performance/CaseWhenSplat:
          Description: >-
                         Reordering `when` conditions with a splat to the end
                         of the `when` branches can improve performance.
          Enabled: false
          SafeAutoCorrect: false
          VersionAdded: '0.34'
          VersionChanged: '1.13'

        Performance/Casecmp:
          Description: >-
                     Use `casecmp` rather than `downcase ==`, `upcase ==`, `== downcase`, or `== upcase`..
          Reference: 'https://github.com/fastruby/fast-ruby#stringcasecmp-vs--stringcasecmp-vs-stringdowncase---code'
          Enabled: false
          Safe: false
          VersionAdded: '0.36'
          VersionChanged: '1.21'

        Performance/ChainArrayAllocation:
          Description: >-
                          Instead of chaining array methods that allocate new arrays, mutate an
                          existing array.
          Reference: 'https://twitter.com/schneems/status/1034123879978029057'
          Enabled: false
          VersionAdded: '0.59'

        Performance/CollectionLiteralInLoop:
          Description: 'Extract Array and Hash literals outside of loops into local variables or constants.'
          Enabled: 'pending'
          VersionAdded: '1.8'
          # Min number of elements to consider an offense
          MinSize: 1

        Performance/CompareWithBlock:
          Description: 'Use `sort_by(&:foo)` instead of `sort { |a, b| a.foo <=> b.foo }`.'
          Enabled: true
          VersionAdded: '0.46'

        Performance/ConcurrentMonotonicTime:
          Description: 'Use `Process.clock_gettime(Process::CLOCK_MONOTONIC)` instead of `Concurrent.monotonic_time`.'
          Reference: 'https://github.com/rails/rails/pull/43502'
          Enabled: pending
          VersionAdded: '1.12'

        Performance/ConstantRegexp:
          Description: 'Finds regular expressions with dynamic components that are all constants.'
          Enabled: pending
          VersionAdded: '1.9'
          VersionChanged: '1.10'

        Performance/Count:
          Description: >-
                          Use `count` instead of `{select,find_all,filter,reject}...{size,count,length}`.
          # This cop has known compatibility issues with `ActiveRecord` and other
          # frameworks. ActiveRecord's `count` ignores the block that is passed to it.
          # For more information, see the documentation in the cop itself.
          SafeAutoCorrect: false
          Enabled: true
          VersionAdded: '0.31'
          VersionChanged: '1.8'

        Performance/DeletePrefix:
          Description: 'Use `delete_prefix` instead of `gsub`.'
          Enabled: true
          Safe: false
          SafeMultiline: true
          VersionAdded: '1.6'
          VersionChanged: '1.11'

        Performance/DeleteSuffix:
          Description: 'Use `delete_suffix` instead of `gsub`.'
          Enabled: true
          Safe: false
          SafeMultiline: true
          VersionAdded: '1.6'
          VersionChanged: '1.11'

        Performance/Detect:
          Description: >-
                          Use `detect` instead of `select.first`, `find_all.first`, `filter.first`,
                          `select.last`, `find_all.last`, and `filter.last`.
          Reference: 'https://github.com/fastruby/fast-ruby#enumerabledetect-vs-enumerableselectfirst-code'
          # This cop has known compatibility issues with `ActiveRecord` and other
          # frameworks. `ActiveRecord` does not implement a `detect` method and `find`
          # has its own meaning. Correcting `ActiveRecord` methods with this cop
          # should be considered unsafe.
          SafeAutoCorrect: false
          Enabled: true
          VersionAdded: '0.30'
          VersionChanged: '1.8'

        Performance/DoubleStartEndWith:
          Description: >-
                          Use `str.{start,end}_with?(x, ..., y, ...)`
                          instead of `str.{start,end}_with?(x, ...) || str.{start,end}_with?(y, ...)`.
          Enabled: true
          VersionAdded: '0.36'
          VersionChanged: '0.48'
          # Used to check for `starts_with?` and `ends_with?`.
          # These methods are defined by Active Support.
          IncludeActiveSupportAliases: false

        Performance/EndWith:
          Description: 'Use `end_with?` instead of a regex match anchored to the end of a string.'
          Reference: 'https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end'
          # This will change to a new method call which isn't guaranteed to be on the
          # object. Switching these methods has to be done with knowledge of the types
          # of the variables which rubocop doesn't have.
          SafeAutoCorrect: false
          Enabled: true
          SafeMultiline: true
          VersionAdded: '0.36'
          VersionChanged: '1.10'

        Performance/FixedSize:
          Description: 'Do not compute the size of statically sized objects except in constants.'
          Enabled: true
          VersionAdded: '0.35'

        Performance/FlatMap:
          Description: >-
                          Use `Enumerable#flat_map`
                          instead of `Enumerable#map...Array#flatten(1)`
                          or `Enumerable#collect..Array#flatten(1)`.
          Reference: 'https://github.com/fastruby/fast-ruby#enumerablemaparrayflatten-vs-enumerableflat_map-code'
          Enabled: true
          VersionAdded: '0.30'
          EnabledForFlattenWithoutParams: false
          # If enabled, this cop will warn about usages of
          # `flatten` being called without any parameters.
          # This can be dangerous since `flat_map` will only flatten 1 level, and
          # `flatten` without any parameters can flatten multiple levels.

        Performance/InefficientHashSearch:
          Description: 'Use `key?` or `value?` instead of `keys.include?` or `values.include?`.'
          Reference: 'https://github.com/fastruby/fast-ruby#hashkey-instead-of-hashkeysinclude-code'
          Enabled: true
          VersionAdded: '0.56'
          Safe: false

        Performance/IoReadlines:
          Description: 'Use `IO.each_line` (`IO#each_line`) instead of `IO.readlines` (`IO#readlines`).'
          Reference: 'https://docs.gitlab.com/ee/development/performance.html#reading-from-files-and-other-data-sources'
          Enabled: false
          VersionAdded: '1.7'

        Performance/MapCompact:
          Description: 'Use `filter_map` instead of `collection.map(&:do_something).compact`.'
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '1.11'

        Performance/MapMethodChain:
          Description: 'Checks if the `map` method is used in a chain.'
          Enabled: pending
          Safe: false
          VersionAdded: '1.19'

        Performance/MethodObjectAsBlock:
          Description: 'Use block explicitly instead of block-passing a method object.'
          Reference: 'https://github.com/fastruby/fast-ruby#normal-way-to-apply-method-vs-method-code'
          Enabled: pending
          VersionAdded: '1.9'

        Performance/OpenStruct:
          Description: 'Use `Struct` instead of `OpenStruct`.'
          Enabled: false
          VersionAdded: '0.61'
          Safe: false

        Performance/RangeInclude:
          Description: 'Use `Range#cover?` instead of `Range#include?` (or `Range#member?`).'
          Reference: 'https://github.com/fastruby/fast-ruby#cover-vs-include-code'
          Enabled: true
          VersionAdded: '0.36'
          VersionChanged: '1.7'
          Safe: false

        Performance/RedundantBlockCall:
          Description: 'Use `yield` instead of `block.call`.'
          Reference: 'https://github.com/fastruby/fast-ruby#proccall-and-block-arguments-vs-yieldcode'
          Enabled: true
          VersionAdded: '0.36'

        Performance/RedundantEqualityComparisonBlock:
          Description: >-
                          Checks for uses `Enumerable#all?`, `Enumerable#any?`, `Enumerable#one?`,
                          or `Enumerable#none?` are compared with `===` or similar methods in block.
          Reference: 'https://github.com/rails/rails/pull/41363'
          Enabled: pending
          Safe: false
          AllowRegexpMatch: true
          VersionAdded: '1.10'

        Performance/RedundantMatch:
          Description: >-
                          Use `=~` instead of `String#match` or `Regexp#match` in a context where the
                          returned `MatchData` is not needed.
          Enabled: true
          VersionAdded: '0.36'

        Performance/RedundantMerge:
          Description: 'Use Hash#[]=, rather than Hash#merge! with a single key-value pair.'
          Reference: 'https://github.com/fastruby/fast-ruby#hashmerge-vs-hash-code'
          Enabled: true
          Safe: false
          VersionAdded: '0.36'
          VersionChanged: '1.11'
          # Max number of key-value pairs to consider an offense
          MaxKeyValuePairs: 2

        Performance/RedundantSortBlock:
          Description: 'Use `sort` instead of `sort { |a, b| a <=> b }`.'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/RedundantSplitRegexpArgument:
          Description: 'Identifies places where `split` argument can be replaced from a deterministic regexp to a string.'
          Enabled: pending
          VersionAdded: '1.10'

        Performance/RedundantStringChars:
          Description: 'Checks for redundant `String#chars`.'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/RegexpMatch:
          Description: >-
                          Use `match?` instead of `Regexp#match`, `String#match`, `Symbol#match`,
                          `Regexp#===`, or `=~` when `MatchData` is not used.
          Reference: 'https://github.com/fastruby/fast-ruby#regexp-vs-regexpmatch-vs-regexpmatch-vs-stringmatch-vs-string-vs-stringmatch-code-'
          Enabled: true
          VersionAdded: '0.47'

        Performance/ReverseEach:
          Description: 'Use `reverse_each` instead of `reverse.each`.'
          Reference: 'https://github.com/fastruby/fast-ruby#enumerablereverseeach-vs-enumerablereverse_each-code'
          Enabled: true
          VersionAdded: '0.30'

        Performance/ReverseFirst:
          Description: 'Use `last(n).reverse` instead of `reverse.first(n)`.'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/SelectMap:
          Description: 'Use `filter_map` instead of `ary.select(&:foo).map(&:bar)`.'
          Enabled: false
          VersionAdded: '1.11'

        Performance/Size:
          Description: >-
                          Use `size` instead of `count` for counting
                          the number of elements in `Array` and `Hash`.
          Reference: 'https://github.com/fastruby/fast-ruby#arraylength-vs-arraysize-vs-arraycount-code'
          Enabled: true
          VersionAdded: '0.30'

        Performance/SortReverse:
          Description: 'Use `sort.reverse` instead of `sort { |a, b| b <=> a }`.'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/Squeeze:
          Description: "Use `squeeze('a')` instead of `gsub(/a+/, 'a')`."
          Reference: 'https://github.com/fastruby/fast-ruby#remove-extra-spaces-or-other-contiguous-characters-code'
          Enabled: 'pending'
          VersionAdded: '1.7'

        Performance/StartWith:
          Description: 'Use `start_with?` instead of a regex match anchored to the beginning of a string.'
          Reference: 'https://github.com/fastruby/fast-ruby#stringmatch-vs-stringmatch-vs-stringstart_withstringend_with-code-start-code-end'
          # This will change to a new method call which isn't guaranteed to be on the
          # object. Switching these methods has to be done with knowledge of the types
          # of the variables which rubocop doesn't have.
          SafeAutoCorrect: false
          Enabled: true
          SafeMultiline: true
          VersionAdded: '0.36'
          VersionChanged: '1.10'

        Performance/StringIdentifierArgument:
          Description: 'Use symbol identifier argument instead of string identifier argument.'
          Enabled: pending
          VersionAdded: '1.13'

        Performance/StringInclude:
          Description: 'Use `String#include?` instead of a regex match with literal-only pattern.'
          Enabled: 'pending'
          SafeAutoCorrect: false
          VersionAdded: '1.7'
          VersionChanged: '1.12'

        Performance/StringReplacement:
          Description: >-
                          Use `tr` instead of `gsub` when you are replacing the same
                          number of characters. Use `delete` instead of `gsub` when
                          you are deleting characters.
          Reference: 'https://github.com/fastruby/fast-ruby#stringgsub-vs-stringtr-code'
          Enabled: true
          VersionAdded: '0.33'

        Performance/Sum:
          Description: 'Use `sum` instead of a custom array summation.'
          SafeAutoCorrect: false
          Reference: 'https://blog.bigbinary.com/2016/11/02/ruby-2-4-introduces-enumerable-sum.html'
          Enabled: 'pending'
          VersionAdded: '1.8'
          VersionChanged: '1.13'
          OnlySumOrWithInitialValue: false

        Performance/TimesMap:
          Description: 'Checks for .times.map calls.'
          Enabled: true
          # See https://github.com/rubocop/rubocop/issues/4658
          SafeAutoCorrect: false
          VersionAdded: '0.36'
          VersionChanged: '1.13'

        Performance/UnfreezeString:
          Description: 'Use unary plus to get an unfrozen string literal.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.50'
          VersionChanged: '1.9'

        Performance/UriDefaultParser:
          Description: 'Use `URI::DEFAULT_PARSER` instead of `URI::Parser.new`.'
          Enabled: true
          VersionAdded: '0.50'
  recorded_at: Mon, 27 May 2024 05:30:43 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rails/v2.25.0/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '9460'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"c39b737456ce772594861fd0b02d39f1e49ff46e93bc85e4eaf9a9baae823c68"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 21D8:70030:130B566:144394F:66541A83
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:43 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230115-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787844.581403,VS0,VE183
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - d80f54e12d6542ac28e48a2f5af9f1badac80e33
      Expires:
      - Mon, 27 May 2024 05:35:43 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        = Cops

        In RuboCop lingo the various checks performed on the code are called cops.
        Each cop is responsible for detecting one particular offense.
        RuboCop Rails has only one Rails department.

        Some of the Rails cops have configuration options, allowing them to
        enforce different coding conventions.

        == Rails

        Rails cops check for Rails best practices and coding conventions. Many of the them are
        based on the https://rails.rubystyle.guide/[Rails Style Guide].

        // START_COP_LIST

        === Department xref:cops_rails.adoc[Rails]

        * xref:cops_rails.adoc#railsactioncontrollerflashbeforerender[Rails/ActionControllerFlashBeforeRender]
        * xref:cops_rails.adoc#railsactioncontrollertestcase[Rails/ActionControllerTestCase]
        * xref:cops_rails.adoc#railsactionfilter[Rails/ActionFilter]
        * xref:cops_rails.adoc#railsactionorder[Rails/ActionOrder]
        * xref:cops_rails.adoc#railsactiverecordaliases[Rails/ActiveRecordAliases]
        * xref:cops_rails.adoc#railsactiverecordcallbacksorder[Rails/ActiveRecordCallbacksOrder]
        * xref:cops_rails.adoc#railsactiverecordoverride[Rails/ActiveRecordOverride]
        * xref:cops_rails.adoc#railsactivesupportaliases[Rails/ActiveSupportAliases]
        * xref:cops_rails.adoc#railsactivesupportonload[Rails/ActiveSupportOnLoad]
        * xref:cops_rails.adoc#railsaddcolumnindex[Rails/AddColumnIndex]
        * xref:cops_rails.adoc#railsaftercommitoverride[Rails/AfterCommitOverride]
        * xref:cops_rails.adoc#railsapplicationcontroller[Rails/ApplicationController]
        * xref:cops_rails.adoc#railsapplicationjob[Rails/ApplicationJob]
        * xref:cops_rails.adoc#railsapplicationmailer[Rails/ApplicationMailer]
        * xref:cops_rails.adoc#railsapplicationrecord[Rails/ApplicationRecord]
        * xref:cops_rails.adoc#railsarelstar[Rails/ArelStar]
        * xref:cops_rails.adoc#railsassertnot[Rails/AssertNot]
        * xref:cops_rails.adoc#railsattributedefaultblockvalue[Rails/AttributeDefaultBlockValue]
        * xref:cops_rails.adoc#railsbelongsto[Rails/BelongsTo]
        * xref:cops_rails.adoc#railsblank[Rails/Blank]
        * xref:cops_rails.adoc#railsbulkchangetable[Rails/BulkChangeTable]
        * xref:cops_rails.adoc#railscompactblank[Rails/CompactBlank]
        * xref:cops_rails.adoc#railscontenttag[Rails/ContentTag]
        * xref:cops_rails.adoc#railscreatetablewithtimestamps[Rails/CreateTableWithTimestamps]
        * xref:cops_rails.adoc#railsdangerouscolumnnames[Rails/DangerousColumnNames]
        * xref:cops_rails.adoc#railsdate[Rails/Date]
        * xref:cops_rails.adoc#railsdefaultscope[Rails/DefaultScope]
        * xref:cops_rails.adoc#railsdelegate[Rails/Delegate]
        * xref:cops_rails.adoc#railsdelegateallowblank[Rails/DelegateAllowBlank]
        * xref:cops_rails.adoc#railsdeprecatedactivemodelerrorsmethods[Rails/DeprecatedActiveModelErrorsMethods]
        * xref:cops_rails.adoc#railsdotseparatedkeys[Rails/DotSeparatedKeys]
        * xref:cops_rails.adoc#railsduplicateassociation[Rails/DuplicateAssociation]
        * xref:cops_rails.adoc#railsduplicatescope[Rails/DuplicateScope]
        * xref:cops_rails.adoc#railsdurationarithmetic[Rails/DurationArithmetic]
        * xref:cops_rails.adoc#railsdynamicfindby[Rails/DynamicFindBy]
        * xref:cops_rails.adoc#railseagerevaluationlogmessage[Rails/EagerEvaluationLogMessage]
        * xref:cops_rails.adoc#railsenumhash[Rails/EnumHash]
        * xref:cops_rails.adoc#railsenumuniqueness[Rails/EnumUniqueness]
        * xref:cops_rails.adoc#railsenvlocal[Rails/EnvLocal]
        * xref:cops_rails.adoc#railsenvironmentcomparison[Rails/EnvironmentComparison]
        * xref:cops_rails.adoc#railsenvironmentvariableaccess[Rails/EnvironmentVariableAccess]
        * xref:cops_rails.adoc#railsexit[Rails/Exit]
        * xref:cops_rails.adoc#railsexpandeddaterange[Rails/ExpandedDateRange]
        * xref:cops_rails.adoc#railsfilepath[Rails/FilePath]
        * xref:cops_rails.adoc#railsfindby[Rails/FindBy]
        * xref:cops_rails.adoc#railsfindbyid[Rails/FindById]
        * xref:cops_rails.adoc#railsfindeach[Rails/FindEach]
        * xref:cops_rails.adoc#railsfreezetime[Rails/FreezeTime]
        * xref:cops_rails.adoc#railshasandbelongstomany[Rails/HasAndBelongsToMany]
        * xref:cops_rails.adoc#railshasmanyorhasonedependent[Rails/HasManyOrHasOneDependent]
        * xref:cops_rails.adoc#railshelperinstancevariable[Rails/HelperInstanceVariable]
        * xref:cops_rails.adoc#railshttppositionalarguments[Rails/HttpPositionalArguments]
        * xref:cops_rails.adoc#railshttpstatus[Rails/HttpStatus]
        * xref:cops_rails.adoc#railsi18nlazylookup[Rails/I18nLazyLookup]
        * xref:cops_rails.adoc#railsi18nlocaleassignment[Rails/I18nLocaleAssignment]
        * xref:cops_rails.adoc#railsi18nlocaletexts[Rails/I18nLocaleTexts]
        * xref:cops_rails.adoc#railsignoredcolumnsassignment[Rails/IgnoredColumnsAssignment]
        * xref:cops_rails.adoc#railsignoredskipactionfilteroption[Rails/IgnoredSkipActionFilterOption]
        * xref:cops_rails.adoc#railsindexby[Rails/IndexBy]
        * xref:cops_rails.adoc#railsindexwith[Rails/IndexWith]
        * xref:cops_rails.adoc#railsinquiry[Rails/Inquiry]
        * xref:cops_rails.adoc#railsinverseof[Rails/InverseOf]
        * xref:cops_rails.adoc#railslexicallyscopedactionfilter[Rails/LexicallyScopedActionFilter]
        * xref:cops_rails.adoc#railslinktoblank[Rails/LinkToBlank]
        * xref:cops_rails.adoc#railsmailername[Rails/MailerName]
        * xref:cops_rails.adoc#railsmatchroute[Rails/MatchRoute]
        * xref:cops_rails.adoc#railsmigrationclassname[Rails/MigrationClassName]
        * xref:cops_rails.adoc#railsnegateinclude[Rails/NegateInclude]
        * xref:cops_rails.adoc#railsnotnullcolumn[Rails/NotNullColumn]
        * xref:cops_rails.adoc#railsorderbyid[Rails/OrderById]
        * xref:cops_rails.adoc#railsoutput[Rails/Output]
        * xref:cops_rails.adoc#railsoutputsafety[Rails/OutputSafety]
        * xref:cops_rails.adoc#railspick[Rails/Pick]
        * xref:cops_rails.adoc#railspluck[Rails/Pluck]
        * xref:cops_rails.adoc#railspluckid[Rails/PluckId]
        * xref:cops_rails.adoc#railspluckinwhere[Rails/PluckInWhere]
        * xref:cops_rails.adoc#railspluralizationgrammar[Rails/PluralizationGrammar]
        * xref:cops_rails.adoc#railspresence[Rails/Presence]
        * xref:cops_rails.adoc#railspresent[Rails/Present]
        * xref:cops_rails.adoc#railsrakeenvironment[Rails/RakeEnvironment]
        * xref:cops_rails.adoc#railsreadwriteattribute[Rails/ReadWriteAttribute]
        * xref:cops_rails.adoc#railsredundantactiverecordallmethod[Rails/RedundantActiveRecordAllMethod]
        * xref:cops_rails.adoc#railsredundantallownil[Rails/RedundantAllowNil]
        * xref:cops_rails.adoc#railsredundantforeignkey[Rails/RedundantForeignKey]
        * xref:cops_rails.adoc#railsredundantpresencevalidationonbelongsto[Rails/RedundantPresenceValidationOnBelongsTo]
        * xref:cops_rails.adoc#railsredundantreceiverinwithoptions[Rails/RedundantReceiverInWithOptions]
        * xref:cops_rails.adoc#railsredundanttravelback[Rails/RedundantTravelBack]
        * xref:cops_rails.adoc#railsreflectionclassname[Rails/ReflectionClassName]
        * xref:cops_rails.adoc#railsrefutemethods[Rails/RefuteMethods]
        * xref:cops_rails.adoc#railsrelativedateconstant[Rails/RelativeDateConstant]
        * xref:cops_rails.adoc#railsrenderinline[Rails/RenderInline]
        * xref:cops_rails.adoc#railsrenderplaintext[Rails/RenderPlainText]
        * xref:cops_rails.adoc#railsrequestreferer[Rails/RequestReferer]
        * xref:cops_rails.adoc#railsrequiredependency[Rails/RequireDependency]
        * xref:cops_rails.adoc#railsresponseparsedbody[Rails/ResponseParsedBody]
        * xref:cops_rails.adoc#railsreversiblemigration[Rails/ReversibleMigration]
        * xref:cops_rails.adoc#railsreversiblemigrationmethoddefinition[Rails/ReversibleMigrationMethodDefinition]
        * xref:cops_rails.adoc#railsrootjoinchain[Rails/RootJoinChain]
        * xref:cops_rails.adoc#railsrootpathnamemethods[Rails/RootPathnameMethods]
        * xref:cops_rails.adoc#railsrootpublicpath[Rails/RootPublicPath]
        * xref:cops_rails.adoc#railssafenavigation[Rails/SafeNavigation]
        * xref:cops_rails.adoc#railssafenavigationwithblank[Rails/SafeNavigationWithBlank]
        * xref:cops_rails.adoc#railssavebang[Rails/SaveBang]
        * xref:cops_rails.adoc#railsschemacomment[Rails/SchemaComment]
        * xref:cops_rails.adoc#railsscopeargs[Rails/ScopeArgs]
        * xref:cops_rails.adoc#railsselectmap[Rails/SelectMap]
        * xref:cops_rails.adoc#railsshorti18n[Rails/ShortI18n]
        * xref:cops_rails.adoc#railsskipsmodelvalidations[Rails/SkipsModelValidations]
        * xref:cops_rails.adoc#railssquishedsqlheredocs[Rails/SquishedSQLHeredocs]
        * xref:cops_rails.adoc#railsstripheredoc[Rails/StripHeredoc]
        * xref:cops_rails.adoc#railstablenameassignment[Rails/TableNameAssignment]
        * xref:cops_rails.adoc#railsthreestatebooleancolumn[Rails/ThreeStateBooleanColumn]
        * xref:cops_rails.adoc#railstimezone[Rails/TimeZone]
        * xref:cops_rails.adoc#railstimezoneassignment[Rails/TimeZoneAssignment]
        * xref:cops_rails.adoc#railstoformatteds[Rails/ToFormattedS]
        * xref:cops_rails.adoc#railstoswithargument[Rails/ToSWithArgument]
        * xref:cops_rails.adoc#railstoplevelhashwithindifferentaccess[Rails/TopLevelHashWithIndifferentAccess]
        * xref:cops_rails.adoc#railstransactionexitstatement[Rails/TransactionExitStatement]
        * xref:cops_rails.adoc#railsuniqbeforepluck[Rails/UniqBeforePluck]
        * xref:cops_rails.adoc#railsuniquevalidationwithoutindex[Rails/UniqueValidationWithoutIndex]
        * xref:cops_rails.adoc#railsunknownenv[Rails/UnknownEnv]
        * xref:cops_rails.adoc#railsunusedignoredcolumns[Rails/UnusedIgnoredColumns]
        * xref:cops_rails.adoc#railsunusedrendercontent[Rails/UnusedRenderContent]
        * xref:cops_rails.adoc#railsvalidation[Rails/Validation]
        * xref:cops_rails.adoc#railswhereequals[Rails/WhereEquals]
        * xref:cops_rails.adoc#railswhereexists[Rails/WhereExists]
        * xref:cops_rails.adoc#railswheremissing[Rails/WhereMissing]
        * xref:cops_rails.adoc#railswherenot[Rails/WhereNot]
        * xref:cops_rails.adoc#railswherenotwithmultipleconditions[Rails/WhereNotWithMultipleConditions]
        * xref:cops_rails.adoc#railswhererange[Rails/WhereRange]

        // END_COP_LIST
  recorded_at: Mon, 27 May 2024 05:30:43 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rails/v2.25.0/docs/modules/ROOT/pages/cops_rails.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '128878'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"841dc4fb5532ebf23c8e88fede59e18f6c2bc43222ca07d4f7f066812b495e76"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 0FF2:6D2AE:1313B44:144BF58:66541A82
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:44 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230095-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787844.878462,VS0,VE199
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - af118d6c78b29ca30c9d2c2652283886d88702a8
      Expires:
      - Mon, 27 May 2024 05:35:44 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: !binary |-
        Ly8vLwogIERvIE5PVCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kIGRpcmVjdGx5LCBhcyBpdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC4KCiAgUGxlYXNlIG1ha2UgYW55IG5lY2Vzc2FyeSBjaGFuZ2VzIHRvIHRoZSBjb3AgZG9jdW1lbnRhdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBmaWxlcyB0aGVtc2VsdmVzLgovLy8vCgo9IFJhaWxzCgo9PSBSYWlscy9BY3Rpb25Db250cm9sbGVyRmxhc2hCZWZvcmVSZW5kZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjE2CnwgLQp8PT09CgpVc2luZyBgZmxhc2hgIGFzc2lnbm1lbnQgYmVmb3JlIGByZW5kZXJgIGluIFJhaWxzIGNvbnRyb2xsZXJzIHdpbGwgcGVyc2lzdCB0aGUgbWVzc2FnZSBmb3IgdG9vIGxvbmcuCkNoZWNrIGh0dHBzOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy9hY3Rpb25fY29udHJvbGxlcl9vdmVydmlldy5odG1sI2ZsYXNoLW5vdwoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBpdCByZXBsYWNlcyBgZmxhc2hgIGJ5IGBmbGFzaC5ub3dgLgpFdmVuIHRob3VnaCBpdCBpcyB1c3VhbGx5IGEgbWlzdGFrZSwgaXQgbWlnaHQgYmUgdXNlZCBpbnRlbnRpb25hbGx5LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgSG9tZUNvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBkZWYgY3JlYXRlCiAgICBmbGFzaFs6YWxlcnRdID0gIm1zZyIKICAgIHJlbmRlciA6aW5kZXgKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgSG9tZUNvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBkZWYgY3JlYXRlCiAgICBmbGFzaC5ub3dbOmFsZXJ0XSA9ICJtc2ciCiAgICByZW5kZXIgOmluZGV4CiAgZW5kCmVuZAotLS0tCgo9PSBSYWlscy9BY3Rpb25Db250cm9sbGVyVGVzdENhc2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjE0CnwgLQp8PT09CgpVc2luZyBgQWN0aW9uQ29udHJvbGxlcjo6VGVzdENhc2VgIGlzIGRpc2NvdXJhZ2VkIGFuZCBzaG91bGQgYmUgcmVwbGFjZWQgYnkKYEFjdGlvbkRpc3BhdGNoOjpJbnRlZ3JhdGlvblRlc3RgLiBDb250cm9sbGVyIHRlc3RzIGFyZSB0b28gY2xvc2UgdG8gdGhlCmludGVybmFscyBvZiBhIGNvbnRyb2xsZXIgd2hlcmVhcyBpbnRlZ3JhdGlvbiB0ZXN0cyBtaW1pYyB0aGUgYnJvd3Nlci91c2VyLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSB0aGUgQVBJIG9mIGVhY2ggdGVzdCBjYXNlIGNsYXNzIGlzIGRpZmZlcmVudC4KTWFrZSBzdXJlIHRvIHVwZGF0ZSBlYWNoIHRlc3Qgb2YgeW91ciBjb250cm9sbGVyIHRlc3QgY2FzZXMgYWZ0ZXIgY2hhbmdpbmcgdGhlIHN1cGVyY2xhc3MuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBNeUNvbnRyb2xsZXJUZXN0IDwgQWN0aW9uQ29udHJvbGxlcjo6VGVzdENhc2UKZW5kCgojIGdvb2QKY2xhc3MgTXlDb250cm9sbGVyVGVzdCA8IEFjdGlvbkRpc3BhdGNoOjpJbnRlZ3JhdGlvblRlc3QKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCsqKi90ZXN0LyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNpbnRlZ3JhdGlvbi10ZXN0aW5nCiogaHR0cHM6Ly9hcGkucnVieW9ucmFpbHMub3JnL2NsYXNzZXMvQWN0aW9uQ29udHJvbGxlci9UZXN0Q2FzZS5odG1sCgo9PSBSYWlscy9BY3Rpb25GaWx0ZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4xOQp8IDIuMjIKfD09PQoKRW5mb3JjZXMgdGhlIGNvbnNpc3RlbnQgdXNlIG9mIGFjdGlvbiBmaWx0ZXIgbWV0aG9kcy4KClRoZSBjb3AgaXMgY29uZmlndXJhYmxlIGFuZCBjYW4gZW5mb3JjZSB0aGUgdXNlIG9mIHRoZSBvbGRlcgpzb21ldGhpbmdfZmlsdGVyIG1ldGhvZHMgb3IgdGhlIG5ld2VyIHNvbWV0aGluZ19hY3Rpb24gbWV0aG9kcy4KCklNUE9SVEFOVDogVGhpcyBjb3AgaXMgZGVwcmVjYXRlZC4gQmVjYXVzZSB0aGUgYCpfZmlsdGVyYCBtZXRob2RzIHdlcmUgcmVtb3ZlZCBpbiBSYWlscyA0LjIsCmFuZCB0aGF0IFJhaWxzIHZlcnNpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBSdWJvQ29wIFJhaWxzLiBUaGlzIGNvcCB3aWxsIGJlIHJlbW92ZWQgaW4gUnVib0NvcCBSYWlscyAzLjAuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogYWN0aW9uIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFmdGVyX2ZpbHRlciA6ZG9fc3R1ZmYKYXBwZW5kX2Fyb3VuZF9maWx0ZXIgOmRvX3N0dWZmCnNraXBfYWZ0ZXJfZmlsdGVyIDpkb19zdHVmZgoKIyBnb29kCmFmdGVyX2FjdGlvbiA6ZG9fc3R1ZmYKYXBwZW5kX2Fyb3VuZF9hY3Rpb24gOmRvX3N0dWZmCnNraXBfYWZ0ZXJfYWN0aW9uIDpkb19zdHVmZgotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGZpbHRlcgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFmdGVyX2FjdGlvbiA6ZG9fc3R1ZmYKYXBwZW5kX2Fyb3VuZF9hY3Rpb24gOmRvX3N0dWZmCnNraXBfYWZ0ZXJfYWN0aW9uIDpkb19zdHVmZgoKIyBnb29kCmFmdGVyX2ZpbHRlciA6ZG9fc3R1ZmYKYXBwZW5kX2Fyb3VuZF9maWx0ZXIgOmRvX3N0dWZmCnNraXBfYWZ0ZXJfZmlsdGVyIDpkb19zdHVmZgotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBhY3Rpb25gCnwgYGFjdGlvbmAsIGBmaWx0ZXJgCgp8IEluY2x1ZGUKfCBgK2FwcC9jb250cm9sbGVycy8qKi8qLnJiK2AsIGArYXBwL21haWxlcnMvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvQWN0aW9uT3JkZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjE3CnwgLQp8PT09CgpFbmZvcmNlcyBjb25zaXN0ZW50IG9yZGVyaW5nIG9mIHRoZSBzdGFuZGFyZCBSYWlscyBSRVNUZnVsIGNvbnRyb2xsZXIgYWN0aW9ucy4KClRoZSBjb3AgaXMgY29uZmlndXJhYmxlIGFuZCBjYW4gZW5mb3JjZSBhbnkgb3JkZXJpbmcgb2YgdGhlIHN0YW5kYXJkIGFjdGlvbnMuCkFsbCBvdGhlciBtZXRob2RzIGFyZSBpZ25vcmVkLiBTbywgdGhlIGFjdGlvbnMgc3BlY2lmaWVkIGluIGBFeHBlY3RlZE9yZGVyYCBzaG91bGQgYmUKZGVmaW5lZCBiZWZvcmUgYWN0aW9ucyBub3Qgc3BlY2lmaWVkLgoKW3NvdXJjZSx5YW1sXQotLS0tCiBSYWlscy9BY3Rpb25PcmRlcjoKICAgRXhwZWN0ZWRPcmRlcjoKICAgICAtIGluZGV4CiAgICAgLSBzaG93CiAgICAgLSBuZXcKICAgICAtIGVkaXQKICAgICAtIGNyZWF0ZQogICAgIC0gdXBkYXRlCiAgICAgLSBkZXN0cm95Ci0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBpbmRleDsgZW5kCmRlZiBkZXN0cm95OyBlbmQKZGVmIHNob3c7IGVuZAoKIyBnb29kCmRlZiBpbmRleDsgZW5kCmRlZiBzaG93OyBlbmQKZGVmIGRlc3Ryb3k7IGVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRXhwZWN0ZWRPcmRlcgp8IGBpbmRleGAsIGBzaG93YCwgYG5ld2AsIGBlZGl0YCwgYGNyZWF0ZWAsIGB1cGRhdGVgLCBgZGVzdHJveWAKfCBBcnJheQoKfCBJbmNsdWRlCnwgYCthcHAvY29udHJvbGxlcnMvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvQWN0aXZlUmVjb3JkQWxpYXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNTMKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IEFjdGl2ZVJlY29yZCBhbGlhc2VzIGFyZSBub3QgdXNlZC4gVGhlIGRpcmVjdCBtZXRob2QgbmFtZXMKYXJlIG1vcmUgY2xlYXIgYW5kIGVhc2llciB0byByZWFkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgY3VzdG9tIGB1cGRhdGVfYXR0cmlidXRlc2AgbWV0aG9kIGNhbGwgd2FzIGNoYW5nZWQgdG8KYHVwZGF0ZWAgYnV0IHRoZSBtZXRob2QgbmFtZSByZW1haW5lZCBzYW1lIGluIHRoZSBtZXRob2QgZGVmaW5pdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJvb2sudXBkYXRlX2F0dHJpYnV0ZXMhKGF1dGhvcjogJ0FsaWNlJykKCiMgZ29vZApib29rLnVwZGF0ZSEoYXV0aG9yOiAnQWxpY2UnKQotLS0tCgo9PSBSYWlscy9BY3RpdmVSZWNvcmRDYWxsYmFja3NPcmRlcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuNwp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgQWN0aXZlIFJlY29yZCBjYWxsYmFja3MgYXJlIGRlY2xhcmVkCmluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdpbGwgYmUgZXhlY3V0ZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBQZXJzb24gPCBBcHBsaWNhdGlvblJlY29yZAogIGFmdGVyX2NvbW1pdCA6YWZ0ZXJfY29tbWl0X2NhbGxiYWNrCiAgYmVmb3JlX3ZhbGlkYXRpb24gOmJlZm9yZV92YWxpZGF0aW9uX2NhbGxiYWNrCmVuZAoKIyBnb29kCmNsYXNzIFBlcnNvbiA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVmb3JlX3ZhbGlkYXRpb24gOmJlZm9yZV92YWxpZGF0aW9uX2NhbGxiYWNrCiAgYWZ0ZXJfY29tbWl0IDphZnRlcl9jb21taXRfY2FsbGJhY2sKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbW9kZWxzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNjYWxsYmFja3Mtb3JkZXIKCj09IFJhaWxzL0FjdGl2ZVJlY29yZE92ZXJyaWRlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjY3CnwgMi4xOAp8PT09CgpDaGVja3MgZm9yIG92ZXJyaWRpbmcgYnVpbHQtaW4gQWN0aXZlIFJlY29yZCBtZXRob2RzIGluc3RlYWQgb2YgdXNpbmcKY2FsbGJhY2tzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgQm9vayA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgZGVmIHNhdmUKICAgIHNlbGYudGl0bGUgPSB0aXRsZS51cGNhc2UhCiAgICBzdXBlcgogIGVuZAplbmQKCiMgZ29vZApjbGFzcyBCb29rIDwgQXBwbGljYXRpb25SZWNvcmQKICBiZWZvcmVfc2F2ZSA6dXBjYXNlX3RpdGxlCgogIGRlZiB1cGNhc2VfdGl0bGUKICAgIHNlbGYudGl0bGUgPSB0aXRsZS51cGNhc2UhCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU2V2ZXJpdHkKfCBgd2FybmluZ2AKfCBTdHJpbmcKCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9BY3RpdmVTdXBwb3J0QWxpYXNlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNDgKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IEFjdGl2ZVN1cHBvcnQgYWxpYXNlcyB0byBjb3JlIHJ1YnkgbWV0aG9kcwphcmUgbm90IHVzZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKJ3NvbWVfc3RyaW5nJy5zdGFydF93aXRoPygncHJlZml4JykKJ3NvbWVfc3RyaW5nJy5lbmRfd2l0aD8oJ3N1ZmZpeCcpClsxLCAyLCAnYSddIDw8ICdiJwpbMSwgMiwgJ2EnXS51bnNoaWZ0KCdiJykKCiMgYmFkCidzb21lX3N0cmluZycuc3RhcnRzX3dpdGg/KCdwcmVmaXgnKQonc29tZV9zdHJpbmcnLmVuZHNfd2l0aD8oJ3N1ZmZpeCcpClsxLCAyLCAnYSddLmFwcGVuZCgnYicpClsxLCAyLCAnYSddLnByZXBlbmQoJ2InKQotLS0tCgo9PSBSYWlscy9BY3RpdmVTdXBwb3J0T25Mb2FkCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMi4xNgp8IDIuMjQKfD09PQoKQ2hlY2tzIGZvciBSYWlscyBmcmFtZXdvcmsgY2xhc3NlcyB0aGF0IGFyZSBwYXRjaGVkIGRpcmVjdGx5IGluc3RlYWQgb2YgdXNpbmcgQWN0aXZlIFN1cHBvcnQgbG9hZCBob29rcy4gRGlyZWN0CnBhdGNoaW5nIGZvcmNpYmx5IGxvYWRzIHRoZSBmcmFtZXdvcmsgcmVmZXJlbmNlZCwgdXNpbmcgaG9va3MgZGVmZXJzIGxvYWRpbmcgdW50aWwgaXQncyBhY3R1YWxseSBuZWVkZWQuCgo9PT0gU2FmZXR5CgpXaGlsZSB1c2luZyBsYXp5IGxvYWQgaG9va3MgaXMgcmVjb21tZW5kZWQsIGl0IGNoYW5nZXMgdGhlIG9yZGVyIGluIHdoaWNoIGlzIGNvZGUgaXMgbG9hZGVkIGFuZCBtYXkgcmV2ZWFsCmxvYWQgb3JkZXIgZGVwZW5kZW5jeSBidWdzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKQWN0aXZlUmVjb3JkOjpCYXNlLmluY2x1ZGUoTXlDbGFzcykKCiMgZ29vZApBY3RpdmVTdXBwb3J0Lm9uX2xvYWQoOmFjdGl2ZV9yZWNvcmQpIHsgaW5jbHVkZSBNeUNsYXNzIH0KLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9hcGkucnVieW9ucmFpbHMub3JnL2NsYXNzZXMvQWN0aXZlU3VwcG9ydC9MYXp5TG9hZEhvb2tzLmh0bWwKKiBodHRwczovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvZW5naW5lcy5odG1sI2F2YWlsYWJsZS1sb2FkLWhvb2tzCgo9PSBSYWlscy9BZGRDb2x1bW5JbmRleAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTEKfCAyLjIwCnw9PT0KCkNoZWNrcyBmb3IgbWlncmF0aW9ucyB1c2luZyBgYWRkX2NvbHVtbmAgdGhhdCBoYXZlIGFuIGBpbmRleGAKa2V5LiBgYWRkX2NvbHVtbmAgZG9lcyBub3QgYWNjZXB0IGBpbmRleGAsIGJ1dCBhbHNvIGRvZXMgbm90IHJhaXNlIGFuCmVycm9yIGZvciBleHRyYSBrZXlzLCBzbyBpdCBpcyBwb3NzaWJsZSB0byBtaXN0YWtlbmx5IGFkZCB0aGUga2V5IHdpdGhvdXQKcmVhbGl6aW5nIGl0IHdpbGwgbm90IGFjdHVhbGx5IGFkZCBhbiBpbmRleC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkICh3aWxsIG5vdCBhZGQgYW4gaW5kZXgpCmFkZF9jb2x1bW4gOnRhYmxlLCA6Y29sdW1uLCA6aW50ZWdlciwgaW5kZXg6IHRydWUKCiMgZ29vZAphZGRfY29sdW1uIDp0YWJsZSwgOmNvbHVtbiwgOmludGVnZXIKYWRkX2luZGV4IDp0YWJsZSwgOmNvbHVtbgotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArZGIvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvQWZ0ZXJDb21taXRPdmVycmlkZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IE5vCnwgMi44CnwgLQp8PT09CgpFbmZvcmNlcyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGNhbGwgdG8gYGFmdGVyX2NvbW1pdGAKKGFuZCBpdHMgYWxpYXNlcyAtIGBhZnRlcl9jcmVhdGVfY29tbWl0YCwgYGFmdGVyX3VwZGF0ZV9jb21taXRgLAphbmQgYGFmdGVyX2Rlc3Ryb3lfY29tbWl0YCkgd2l0aCB0aGUgc2FtZSBjYWxsYmFjayBuYW1lIHBlciBtb2RlbC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgVGhpcyB3b24ndCBiZSB0cmlnZ2VyZWQuCmFmdGVyX2NyZWF0ZV9jb21taXQgOmxvZ19hY3Rpb24KCiMgVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBjYWxsYmFjayBhZGRlZCBieQojIGFmdGVyX2NyZWF0ZV9jb21taXQuCmFmdGVyX3VwZGF0ZV9jb21taXQgOmxvZ19hY3Rpb24KCiMgYmFkCiMgVGhpcyB3b24ndCBiZSB0cmlnZ2VyZWQuCmFmdGVyX2NvbW1pdCA6bG9nX2FjdGlvbiwgb246IDpjcmVhdGUKIyBUaGlzIHdvbid0IGJlIHRyaWdnZXJlZC4KYWZ0ZXJfdXBkYXRlX2NvbW1pdCA6bG9nX2FjdGlvbgojIFRoaXMgd2lsbCBvdmVycmlkZSBib3RoIHByZXZpb3VzIGNhbGxiYWNrcy4KYWZ0ZXJfY29tbWl0IDpsb2dfYWN0aW9uLCBvbjogOmRlc3Ryb3kKCiMgZ29vZAphZnRlcl9zYXZlX2NvbW1pdCA6bG9nX2FjdGlvbgoKIyBnb29kCmFmdGVyX2NyZWF0ZV9jb21taXQgOmxvZ19jcmVhdGVfYWN0aW9uCmFmdGVyX3VwZGF0ZV9jb21taXQgOmxvZ191cGRhdGVfYWN0aW9uCi0tLS0KCj09IFJhaWxzL0FwcGxpY2F0aW9uQ29udHJvbGxlcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuNAp8IDIuNQp8PT09CgpDaGVja3MgdGhhdCBjb250cm9sbGVycyBzdWJjbGFzcyBgQXBwbGljYXRpb25Db250cm9sbGVyYC4KCj09PSBTYWZldHkKClRoaXMgY29wJ3MgYXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaXQgbWF5IGxldCB0aGUgbG9naWMgZnJvbSBgQXBwbGljYXRpb25Db250cm9sbGVyYApzbmVhayBpbnRvIGEgY29udHJvbGxlciB0aGF0IGlzIG5vdCBwdXJwb3NlZCB0byBpbmhlcml0IGxvZ2ljIGNvbW1vbiBhbW9uZyBvdGhlciBjb250cm9sbGVycy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBNeUNvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICAjIC4uLgplbmQKCiMgYmFkCmNsYXNzIE15Q29udHJvbGxlciA8IEFjdGlvbkNvbnRyb2xsZXI6OkJhc2UKICAjIC4uLgplbmQKLS0tLQoKPT0gUmFpbHMvQXBwbGljYXRpb25Kb2IKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjQ5CnwgMi41Cnw9PT0KCkNoZWNrcyB0aGF0IGpvYnMgc3ViY2xhc3MgYEFwcGxpY2F0aW9uSm9iYCB3aXRoIFJhaWxzIDUuMC4KCj09PSBTYWZldHkKClRoaXMgY29wJ3MgYXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaXQgbWF5IGxldCB0aGUgbG9naWMgZnJvbSBgQXBwbGljYXRpb25Kb2JgCnNuZWFrIGludG8gYSBqb2IgdGhhdCBpcyBub3QgcHVycG9zZWQgdG8gaW5oZXJpdCBsb2dpYyBjb21tb24gYW1vbmcgb3RoZXIgam9icy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBSYWlsczVKb2IgPCBBcHBsaWNhdGlvbkpvYgogICMgLi4uCmVuZAoKIyBiYWQKY2xhc3MgUmFpbHM0Sm9iIDwgQWN0aXZlSm9iOjpCYXNlCiAgIyAuLi4KZW5kCi0tLS0KCj09IFJhaWxzL0FwcGxpY2F0aW9uTWFpbGVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMi40CnwgMi41Cnw9PT0KCkNoZWNrcyB0aGF0IG1haWxlcnMgc3ViY2xhc3MgYEFwcGxpY2F0aW9uTWFpbGVyYCB3aXRoIFJhaWxzIDUuMC4KCj09PSBTYWZldHkKClRoaXMgY29wJ3MgYXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaXQgbWF5IGxldCB0aGUgbG9naWMgZnJvbSBgQXBwbGljYXRpb25NYWlsZXJgCnNuZWFrIGludG8gYSBtYWlsZXIgdGhhdCBpcyBub3QgcHVycG9zZWQgdG8gaW5oZXJpdCBsb2dpYyBjb21tb24gYW1vbmcgb3RoZXIgbWFpbGVycy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApjbGFzcyBNeU1haWxlciA8IEFwcGxpY2F0aW9uTWFpbGVyCiAgIyAuLi4KZW5kCgojIGJhZApjbGFzcyBNeU1haWxlciA8IEFjdGlvbk1haWxlcjo6QmFzZQogICMgLi4uCmVuZAotLS0tCgo9PSBSYWlscy9BcHBsaWNhdGlvblJlY29yZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNDkKfCAyLjUKfD09PQoKQ2hlY2tzIHRoYXQgbW9kZWxzIHN1YmNsYXNzIGBBcHBsaWNhdGlvblJlY29yZGAgd2l0aCBSYWlscyA1LjAuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0IG1heSBsZXQgdGhlIGxvZ2ljIGZyb20gYEFwcGxpY2F0aW9uUmVjb3JkYApzbmVhayBpbnRvIGFuIEFjdGl2ZSBSZWNvcmQgbW9kZWwgdGhhdCBpcyBub3QgcHVycG9zZWQgdG8gaW5oZXJpdCBsb2dpYyBjb21tb24gYW1vbmcgb3RoZXIKQWN0aXZlIFJlY29yZCBtb2RlbHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKY2xhc3MgUmFpbHM1TW9kZWwgPCBBcHBsaWNhdGlvblJlY29yZAogICMgLi4uCmVuZAoKIyBiYWQKY2xhc3MgUmFpbHM0TW9kZWwgPCBBY3RpdmVSZWNvcmQ6OkJhc2UKICAjIC4uLgplbmQKLS0tLQoKPT0gUmFpbHMvQXJlbFN0YXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjkKfCAtCnw9PT0KClByZXZlbnRzIHVzYWdlIG9mIGAiKiJgIG9uIGFuIEFyZWw6OlRhYmxlIGNvbHVtbiByZWZlcmVuY2UuCgpVc2luZyBgYXJlbF90YWJsZVsiKiJdYCBjYXVzZXMgdGhlIG91dHB1dHRlZCBzdHJpbmcgdG8gYmUgYSBsaXRlcmFsCnF1b3RlZCBhc3RlcmlzayAoZS5nLiA8dHQ+YG15X21vZGVsYC5gKmA8L3R0PikuIFRoaXMgY2F1c2VzIHRoZQpkYXRhYmFzZSB0byBsb29rIGZvciBhIGNvbHVtbiBuYW1lZCA8dHQ+YCpgPC90dD4gKG9yIGAiKiJgKSBhcyBvcHBvc2VkCnRvIGV4cGFuZGluZyB0aGUgY29sdW1uIGxpc3QgYXMgb25lIHdvdWxkIGxpa2VseSBleHBlY3QuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0IHR1cm5zIGEgcXVvdGVkIGAqYCBpbnRvCmFuIFNRTCBgKmAsIHVucXVvdGVkLiBgKmAgaXMgYSB2YWxpZCBjb2x1bW4gbmFtZSBpbiBjZXJ0YWluIGRhdGFiYXNlcwpzdXBwb3J0ZWQgYnkgUmFpbHMsIGFuZCBldmVuIHRob3VnaCBpdCBpcyB1c3VhbGx5IGEgbWlzdGFrZSwKaXQgbWlnaHQgZGVub3RlIGxlZ2l0aW1hdGUgYWNjZXNzIHRvIGEgY29sdW1uIG5hbWVkIGAqYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCk15VGFibGUuYXJlbF90YWJsZVsiKiJdCgojIGdvb2QKTXlUYWJsZS5hcmVsX3RhYmxlW0FyZWwuc3Rhcl0KLS0tLQoKPT0gUmFpbHMvQXNzZXJ0Tm90Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Ngp8IC0KfD09PQoKVXNlIGBhc3NlcnRfbm90YCBpbnN0ZWFkIG9mIGBhc3NlcnQgIWAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphc3NlcnQgIXgKCiMgZ29vZAphc3NlcnRfbm90IHgKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgKyoqL3Rlc3QvKiovKitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvQXR0cmlidXRlRGVmYXVsdEJsb2NrVmFsdWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjkKfCAtCnw9PT0KCkxvb2tzIGZvciBgYXR0cmlidXRlYCBjbGFzcyBtZXRob2RzIHRoYXQgc3BlY2lmeSBhIGA6ZGVmYXVsdGAgb3B0aW9uCndoaWNoIHZhbHVlIGlzIGFuIGFycmF5LCBzdHJpbmcgbGl0ZXJhbCBvciBtZXRob2QgY2FsbCB3aXRob3V0IGEgYmxvY2suCkl0IHdpbGwgYWNjZXB0IGFsbCBvdGhlciB2YWx1ZXMsIHN1Y2ggYXMgc3RyaW5nLCBzeW1ib2wsIGludGVnZXIgYW5kIGZsb2F0IGxpdGVyYWxzCmFzIHdlbGwgYXMgY29uc3RhbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgVXNlciA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYXR0cmlidXRlIDpjb25maXJtZWRfYXQsIDpkYXRldGltZSwgZGVmYXVsdDogVGltZS56b25lLm5vdwplbmQKCiMgZ29vZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBhdHRyaWJ1dGUgOmNvbmZpcm1lZF9hdCwgOmRhdGV0aW1lLCBkZWZhdWx0OiAtPiB7IFRpbWUuem9uZS5ub3cgfQplbmQKCiMgYmFkCmNsYXNzIFVzZXIgPCBBcHBsaWNhdGlvblJlY29yZAogIGF0dHJpYnV0ZSA6cm9sZXMsIDpzdHJpbmcsIGFycmF5OiB0cnVlLCBkZWZhdWx0OiBbXQplbmQKCiMgZ29vZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBhdHRyaWJ1dGUgOnJvbGVzLCA6c3RyaW5nLCBhcnJheTogdHJ1ZSwgZGVmYXVsdDogLT4geyBbXSB9CmVuZAoKIyBiYWQKY2xhc3MgVXNlciA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYXR0cmlidXRlIDpjb25maWd1cmF0aW9uLCBkZWZhdWx0OiB7fQplbmQKCiMgZ29vZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBhdHRyaWJ1dGUgOmNvbmZpZ3VyYXRpb24sIGRlZmF1bHQ6IC0+IHsge30gfQplbmQKCiMgZ29vZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBhdHRyaWJ1dGUgOnJvbGUsIDpzdHJpbmcsIGRlZmF1bHQ6IDpjdXN0b21lcgplbmQKCiMgZ29vZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBhdHRyaWJ1dGUgOmFjdGl2YXRlZCwgOmJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlCmVuZAoKIyBnb29kCmNsYXNzIFVzZXIgPCBBcHBsaWNhdGlvblJlY29yZAogIGF0dHJpYnV0ZSA6bG9naW5fY291bnQsIDppbnRlZ2VyLCBkZWZhdWx0OiAwCmVuZAoKIyBnb29kCmNsYXNzIFVzZXIgPCBBcHBsaWNhdGlvblJlY29yZAogIEZPTyA9IDEyMwogIGF0dHJpYnV0ZSA6Y3VzdG9tX2F0dHJpYnV0ZSwgOmludGVnZXIsIGRlZmF1bHQ6IEZPTwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2FwcC9tb2RlbHMvKiovKitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvQmVsb25nc1RvCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC42Mgp8IC0KfD09PQoKTG9va3MgZm9yIGJlbG9uZ3NfdG8gYXNzb2NpYXRpb25zIHdoZXJlIHdlIGNvbnRyb2wgd2hldGhlciB0aGUKYXNzb2NpYXRpb24gaXMgcmVxdWlyZWQgdmlhIHRoZSBkZXByZWNhdGVkIGByZXF1aXJlZGAgb3B0aW9uIGluc3RlYWQuCgpTaW5jZSBSYWlscyA1LCBiZWxvbmdzX3RvIGFzc29jaWF0aW9ucyBhcmUgcmVxdWlyZWQgYnkgZGVmYXVsdCBhbmQgdGhpcwpjYW4gYmUgY29udHJvbGxlZCB0aHJvdWdoIHRoZSB1c2Ugb2YgYG9wdGlvbmFsOiB0cnVlYC4KCkZyb20gdGhlIHJlbGVhc2Ugbm90ZXM6CgogICAgYmVsb25nc190byB3aWxsIG5vdyB0cmlnZ2VyIGEgdmFsaWRhdGlvbiBlcnJvciBieSBkZWZhdWx0IGlmIHRoZQogICAgYXNzb2NpYXRpb24gaXMgbm90IHByZXNlbnQuIFlvdSBjYW4gdHVybiB0aGlzIG9mZiBvbiBhCiAgICBwZXItYXNzb2NpYXRpb24gYmFzaXMgd2l0aCBvcHRpb25hbDogdHJ1ZS4gQWxzbyBkZXByZWNhdGUgcmVxdWlyZWQKICAgIG9wdGlvbiBpbiBmYXZvciBvZiBvcHRpb25hbCBmb3IgYmVsb25nc190by4gKFB1bGwgUmVxdWVzdCkKCkluIHRoZSBjYXNlIHRoYXQgdGhlIGRldmVsb3BlciBpcyBkb2luZyBgcmVxdWlyZWQ6IGZhbHNlYCwgd2UKZGVmaW5pdGVseSB3YW50IHRvIGF1dG9jb3JyZWN0IHRvIGBvcHRpb25hbDogdHJ1ZWAuCgpIb3dldmVyLCB3aXRob3V0IGtub3dpbmcgd2hldGhlciB0aGV5J3ZlIHNldCBvdmVycmlkZGVuIHRoZSBkZWZhdWx0CnZhbHVlIG9mIGBjb25maWcuYWN0aXZlX3JlY29yZC5iZWxvbmdzX3RvX3JlcXVpcmVkX2J5X2RlZmF1bHRgLCB3ZQpjYW4ndCBzYXkgd2hldGhlciBpdCdzIHNhZmUgdG8gcmVtb3ZlIGByZXF1aXJlZDogdHJ1ZWAgb3Igd2hldGhlciB3ZQpzaG91bGQgcmVwbGFjZSBpdCB3aXRoIGBvcHRpb25hbDogZmFsc2VgIChvciwgc2ltaWxhcmx5LCByZW1vdmUgYQpzdXBlcmZsdW91cyBgb3B0aW9uYWw6IGZhbHNlYCkuIFRoZXJlZm9yZSwgaW4gdGhlIGNhc2VzIHdlJ3JlIHVzaW5nCmByZXF1aXJlZDogdHJ1ZWAsIHdlJ2xsIHNpbXBseSBpbnZlcnQgaXQgdG8gYG9wdGlvbmFsOiBmYWxzZWAgYW5kIHRoZQp1c2VyIGNhbiByZW1vdmUgZGVwZW5kaW5nIG9uIHRoZWlyIGRlZmF1bHRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgUG9zdCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVsb25nc190byA6YmxvZywgcmVxdWlyZWQ6IGZhbHNlCmVuZAoKIyBnb29kCmNsYXNzIFBvc3QgPCBBcHBsaWNhdGlvblJlY29yZAogIGJlbG9uZ3NfdG8gOmJsb2csIG9wdGlvbmFsOiB0cnVlCmVuZAoKIyBiYWQKY2xhc3MgUG9zdCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVsb25nc190byA6YmxvZywgcmVxdWlyZWQ6IHRydWUKZW5kCgojIGdvb2QKY2xhc3MgUG9zdCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVsb25nc190byA6YmxvZywgb3B0aW9uYWw6IGZhbHNlCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvNV8wX3JlbGVhc2Vfbm90ZXMuaHRtbAoqIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWlscy9yYWlscy9wdWxsLzE4OTM3Cgo9PSBSYWlscy9CbGFuawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNDgKfCAyLjEwCnw9PT0KCkNoZWNrcyBmb3IgY29kZSB0aGF0IGNhbiBiZSB3cml0dGVuIHdpdGggc2ltcGxlciBjb25kaXRpb25hbHMKdXNpbmcgYE9iamVjdCNibGFuaz9gIGRlZmluZWQgYnkgQWN0aXZlIFN1cHBvcnQuCgpJbnRlcmFjdGlvbiB3aXRoIGBTdHlsZS9Vbmxlc3NFbHNlYDoKVGhlIGNvbmZpZ3VyYXRpb24gb2YgYE5vdFByZXNlbnRgIHdpbGwgbm90IHByb2R1Y2UgYW4gb2ZmZW5zZSBpbiB0aGUKY29udGV4dCBvZiBgdW5sZXNzIGVsc2VgIGlmIGBTdHlsZS9Vbmxlc3NFbHNlYCBpcyBlbmFibGVkLiBUaGlzIGlzCnRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGJldHdlZW4gdGhlIGF1dG9jb3JyZWN0aW9uIG9mIHRoZSB0d28gY29wcy4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBhdXRvY29ycmVjdGlvbiwgYmVjYXVzZSBgJyAnLmVtcHR5P2AgcmV0dXJucyBmYWxzZSwKYnV0IGAnICcuYmxhbms/YCByZXR1cm5zIHRydWUuIFRoZXJlZm9yZSwgYXV0b2NvcnJlY3Rpb24gaXMgbm90IGNvbXBhdGlibGUKaWYgdGhlIHJlY2VpdmVyIGlzIGEgbm9uLWVtcHR5IGJsYW5rIHN0cmluZywgdGFiLCBvciBuZXdsaW5lIG1ldGEgY2hhcmFjdGVycy4KCj09PSBFeGFtcGxlcwoKPT09PSBOaWxPckVtcHR5OiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgQ29udmVydHMgdXNhZ2VzIG9mIGBuaWw/IHx8IGVtcHR5P2AgdG8gYGJsYW5rP2AKCiMgYmFkCmZvby5uaWw/IHx8IGZvby5lbXB0eT8KZm9vID09IG5pbCB8fCBmb28uZW1wdHk/CgojIGdvb2QKZm9vLmJsYW5rPwotLS0tCgo9PT09IE5vdFByZXNlbnQ6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBDb252ZXJ0cyB1c2FnZXMgb2YgYCFwcmVzZW50P2AgdG8gYGJsYW5rP2AKCiMgYmFkCiFmb28ucHJlc2VudD8KCiMgZ29vZApmb28uYmxhbms/Ci0tLS0KCj09PT0gVW5sZXNzUHJlc2VudDogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIENvbnZlcnRzIHVzYWdlcyBvZiBgdW5sZXNzIHByZXNlbnQ/YCB0byBgaWYgYmxhbms/YAoKIyBiYWQKc29tZXRoaW5nIHVubGVzcyBmb28ucHJlc2VudD8KCiMgZ29vZApzb21ldGhpbmcgaWYgZm9vLmJsYW5rPwoKIyBiYWQKdW5sZXNzIGZvby5wcmVzZW50PwogIHNvbWV0aGluZwplbmQKCiMgZ29vZAppZiBmb28uYmxhbms/CiAgc29tZXRoaW5nCmVuZAoKIyBnb29kCmRlZiBibGFuaz8KICAhcHJlc2VudD8KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBOaWxPckVtcHR5CnwgYHRydWVgCnwgQm9vbGVhbgoKfCBOb3RQcmVzZW50CnwgYHRydWVgCnwgQm9vbGVhbgoKfCBVbmxlc3NQcmVzZW50CnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PSBSYWlscy9CdWxrQ2hhbmdlVGFibGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNTcKfCAyLjIwCnw9PT0KCkNoZWNrcyB3aGV0aGVyIGFsdGVyIHF1ZXJpZXMgYXJlIGNvbWJpbmFibGUuCklmIGNvbWJpbmFibGUgcXVlcmllcyBhcmUgZGV0ZWN0ZWQsIGl0IHN1Z2dlc3RzIHRvIHlvdQp0byB1c2UgYGNoYW5nZV90YWJsZWAgd2l0aCBgYnVsazogdHJ1ZWAgaW5zdGVhZC4KVGhpcyBvcHRpb24gY2F1c2VzIHRoZSBtaWdyYXRpb24gdG8gZ2VuZXJhdGUgYSBzaW5nbGUKQUxURVIgVEFCTEUgc3RhdGVtZW50IGNvbWJpbmluZyBtdWx0aXBsZSBjb2x1bW4gYWx0ZXJhdGlvbnMuCgpUaGUgYGJ1bGtgIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0aGUgTXlTUUwgYW5kCnRoZSBQb3N0Z3JlU1FMICg1LjIgbGF0ZXIpIGFkYXB0ZXI7IHRodXMgaXQgd2lsbAphdXRvbWF0aWNhbGx5IGRldGVjdCBhbiBhZGFwdGVyIGZyb20gYGRldmVsb3BtZW50YCBlbnZpcm9ubWVudAppbiBgY29uZmlnL2RhdGFiYXNlLnltbGAgb3IgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGBEQVRBQkFTRV9VUkxgCndoZW4gdGhlIGBEYXRhYmFzZWAgb3B0aW9uIGlzIG5vdCBzZXQuCklmIHRoZSBhZGFwdGVyIGlzIG5vdCBgbXlzcWwyYCwgYHRyaWxvZ3lgLCBgcG9zdGdyZXNxbGAsIG9yIGBwb3N0Z2lzYCwKdGhpcyBDb3AgaWdub3JlcyBvZmZlbnNlcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBjaGFuZ2UKICBhZGRfY29sdW1uIDp1c2VycywgOm5hbWUsIDpzdHJpbmcsIG51bGw6IGZhbHNlCiAgYWRkX2NvbHVtbiA6dXNlcnMsIDpuaWNrbmFtZSwgOnN0cmluZwoKICAjIEFMVEVSIFRBQkxFIGB1c2Vyc2AgQUREIGBuYW1lYCB2YXJjaGFyKDI1NSkgTk9UIE5VTEwKICAjIEFMVEVSIFRBQkxFIGB1c2Vyc2AgQUREIGBuaWNrbmFtZWAgdmFyY2hhcigyNTUpCmVuZAoKIyBnb29kCmRlZiBjaGFuZ2UKICBjaGFuZ2VfdGFibGUgOnVzZXJzLCBidWxrOiB0cnVlIGRvIHx0fAogICAgdC5zdHJpbmcgOm5hbWUsIG51bGw6IGZhbHNlCiAgICB0LnN0cmluZyA6bmlja25hbWUKICBlbmQKCiAgIyBBTFRFUiBUQUJMRSBgdXNlcnNgIEFERCBgbmFtZWAgdmFyY2hhcigyNTUpIE5PVCBOVUxMLAogICMgICAgICAgICAgICAgICAgICAgICBBREQgYG5pY2tuYW1lYCB2YXJjaGFyKDI1NSkKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgY2hhbmdlCiAgY2hhbmdlX3RhYmxlIDp1c2VycyBkbyB8dHwKICAgIHQuc3RyaW5nIDpuYW1lLCBudWxsOiBmYWxzZQogICAgdC5zdHJpbmcgOm5pY2tuYW1lCiAgZW5kCmVuZAoKIyBnb29kCmRlZiBjaGFuZ2UKICBjaGFuZ2VfdGFibGUgOnVzZXJzLCBidWxrOiB0cnVlIGRvIHx0fAogICAgdC5zdHJpbmcgOm5hbWUsIG51bGw6IGZhbHNlCiAgICB0LnN0cmluZyA6bmlja25hbWUKICBlbmQKZW5kCgojIGdvb2QKIyBXaGVuIHlvdSBkb24ndCB3YW50IHRvIGNvbWJpbmUgYWx0ZXIgcXVlcmllcy4KZGVmIGNoYW5nZQogIGNoYW5nZV90YWJsZSA6dXNlcnMsIGJ1bGs6IGZhbHNlIGRvIHx0fAogICAgdC5zdHJpbmcgOm5hbWUsIG51bGw6IGZhbHNlCiAgICB0LnN0cmluZyA6bmlja25hbWUKICBlbmQKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBEYXRhYmFzZQp8IGA8bm9uZT5gCnwgYG15c3FsYCwgYHBvc3RncmVzcWxgCgp8IEluY2x1ZGUKfCBgK2RiLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vYXBpLnJ1YnlvbnJhaWxzLm9yZy9jbGFzc2VzL0FjdGl2ZVJlY29yZC9Db25uZWN0aW9uQWRhcHRlcnMvU2NoZW1hU3RhdGVtZW50cy5odG1sI21ldGhvZC1pLWNoYW5nZV90YWJsZQoqIGh0dHBzOi8vYXBpLnJ1YnlvbnJhaWxzLm9yZy9jbGFzc2VzL0FjdGl2ZVJlY29yZC9Db25uZWN0aW9uQWRhcHRlcnMvVGFibGUuaHRtbAoKPT0gUmFpbHMvQ29tcGFjdEJsYW5rCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAyLjEzCnwgLQp8PT09CgpDaGVja3MgaWYgY29sbGVjdGlvbiBjYW4gYmUgYmxhbmstY29tcGFjdGVkIHdpdGggYGNvbXBhY3RfYmxhbmtgLgoKPT09IFNhZmV0eQoKSXQgaXMgdW5zYWZlIGJ5IGRlZmF1bHQgYmVjYXVzZSBmYWxzZSBwb3NpdGl2ZXMgbWF5IG9jY3VyIGluIHRoZQpibGFuayBjaGVjayBvZiBibG9jayBhcmd1bWVudHMgdG8gdGhlIHJlY2VpdmVyIG9iamVjdC4KCkZvciBleGFtcGxlLCBgW1sxLCAyXSwgWzMsIG5pbF1dLnJlamVjdCB7IHxmaXJzdCwgc2Vjb25kfCBzZWNvbmQuYmxhbms/IH1gIGFuZApgW1sxLCAyXSwgWzMsIG5pbF1dLmNvbXBhY3RfYmxhbmtgIGFyZSBub3QgY29tcGF0aWJsZS4gVGhlIHNhbWUgaXMgdHJ1ZSBmb3IgYGJsYW5rP2AuClRoaXMgd2lsbCB3b3JrIGZpbmUgd2hlbiB0aGUgcmVjZWl2ZXIgaXMgYSBoYXNoIG9iamVjdC4KCkFuZCBgY29tcGFjdF9ibGFuayFgIGhhcyBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgLCBgSGFzaGAsIGFuZApgQWN0aW9uQ29udHJvbGxlcjo6UGFyYW1ldGVyc2AuCmBBcnJheSNjb21wYWN0X2JsYW5rIWAsIGBIYXNoI2NvbXBhY3RfYmxhbmshYCBhcmUgZXF1aXZhbGVudCB0byBgZGVsZXRlX2lmKCY6Ymxhbms/KWAuCmBBY3Rpb25Db250cm9sbGVyOjpQYXJhbWV0ZXJzI2NvbXBhY3RfYmxhbmshYCBpcyBlcXVpdmFsZW50IHRvIGByZWplY3QhKCY6Ymxhbms/KWAuCklmIHRoZSBjb3AgbWFrZXMgYSBtaXN0YWtlLCBhdXRvY29ycmVjdGVkIGNvZGUgbWF5IGdldCB1bmV4cGVjdGVkIGJlaGF2aW9yLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY29sbGVjdGlvbi5yZWplY3QoJjpibGFuaz8pCmNvbGxlY3Rpb24ucmVqZWN0IHsgfF9rLCB2fCB2LmJsYW5rPyB9CgojIGdvb2QKY29sbGVjdGlvbi5jb21wYWN0X2JsYW5rCgojIGJhZApjb2xsZWN0aW9uLmRlbGV0ZV9pZigmOmJsYW5rPykgICAgICAgICAgICAjIFNhbWUgYmVoYXZpb3IgYXMgYEFycmF5I2NvbXBhY3RfYmxhbmshYCBhbmQgYEhhc2gjY29tcGFjdF9ibGFuayFgCmNvbGxlY3Rpb24uZGVsZXRlX2lmIHsgfF9rLCB2fCB2LmJsYW5rPyB9ICMgU2FtZSBiZWhhdmlvciBhcyBgQXJyYXkjY29tcGFjdF9ibGFuayFgIGFuZCBgSGFzaCNjb21wYWN0X2JsYW5rIWAKY29sbGVjdGlvbi5yZWplY3QhKCY6Ymxhbms/KSAgICAgICAgICAgICAgIyBTYW1lIGJlaGF2aW9yIGFzIGBBY3Rpb25Db250cm9sbGVyOjpQYXJhbWV0ZXJzI2NvbXBhY3RfYmxhbmshYApjb2xsZWN0aW9uLnJlamVjdCEgeyB8X2ssIHZ8IHYuYmxhbms/IH0gICAjIFNhbWUgYmVoYXZpb3IgYXMgYEFjdGlvbkNvbnRyb2xsZXI6OlBhcmFtZXRlcnMjY29tcGFjdF9ibGFuayFgCgojIGdvb2QKY29sbGVjdGlvbi5jb21wYWN0X2JsYW5rIQotLS0tCgo9PSBSYWlscy9Db250ZW50VGFnCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMi42CnwgMi4xMgp8PT09CgpDaGVja3MgbGVnYWN5IHN5bnRheCB1c2FnZSBvZiBgdGFnYAoKTk9URTogQWxsb3cgYHRhZ2Agd2hlbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSB2YXJpYWJsZSBiZWNhdXNlCmB0YWcobmFtZSlgIGlzIHNpbXBsZXIgcmF0aGVyIHRoYW4gYHRhZy5wdWJsaWNfc2VuZChuYW1lKWAuCkFuZCB0aGlzIGNvcCB3aWxsIGJlIHJlbmFtZWQgdG8gc29tZXRoaW5nIGxpa2UgYExlZ2FjeVRhZ2AgaW4gdGhlIGZ1dHVyZS4gKGUuZy4gUnVib0NvcCBSYWlscyAzLjApCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp0YWcoOnApCnRhZyg6YnIsIGNsYXNzOiAnY2xhc3NuYW1lJykKCiMgZ29vZAp0YWcucAp0YWcuYnIoY2xhc3M6ICdjbGFzc25hbWUnKQp0YWcobmFtZSwgY2xhc3M6ICdjbGFzc25hbWUnKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRXhjbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AsIGArY29uZmlnLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vZ2l0aHViLmNvbS9ydWJvY29wL3J1Ym9jb3AtcmFpbHMvaXNzdWVzLzI2MAoqIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWlscy9yYWlscy9pc3N1ZXMvMjUxOTUKKiBodHRwczovL2FwaS5ydWJ5b25yYWlscy5vcmcvY2xhc3Nlcy9BY3Rpb25WaWV3L0hlbHBlcnMvVGFnSGVscGVyLmh0bWwjbWV0aG9kLWktY29udGVudF90YWcKCj09IFJhaWxzL0NyZWF0ZVRhYmxlV2l0aFRpbWVzdGFtcHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNTIKfCAyLjIwCnw9PT0KCkNoZWNrcyB0aGUgbWlncmF0aW9uIGZvciB3aGljaCB0aW1lc3RhbXBzIGFyZSBub3QgaW5jbHVkZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB0YWJsZS4KSW4gbWFueSBjYXNlcywgdGltZXN0YW1wcyBhcmUgdXNlZnVsIGluZm9ybWF0aW9uIGFuZCBzaG91bGQgYmUgYWRkZWQuCgpOT1RFOiBBbGxvdyBgdGltZXN0YW1wc2Agbm90IHdyaXR0ZW4gd2hlbiBgaWQ6IGZhbHNlYCBiZWNhdXNlIHRoaXMgZW1waGFzaXplcyByZXNwZWN0aW5nCnVzZXIncyBlZGl0aW5nIGludGVudGlvbnMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjcmVhdGVfdGFibGUgOnVzZXJzCgojIGJhZApjcmVhdGVfdGFibGUgOnVzZXJzIGRvIHx0fAogIHQuc3RyaW5nIDpuYW1lCiAgdC5zdHJpbmcgOmVtYWlsCmVuZAoKIyBnb29kCmNyZWF0ZV90YWJsZSA6dXNlcnMgZG8gfHR8CiAgdC5zdHJpbmcgOm5hbWUKICB0LnN0cmluZyA6ZW1haWwKCiAgdC50aW1lc3RhbXBzCmVuZAoKIyBnb29kCmNyZWF0ZV90YWJsZSA6dXNlcnMgZG8gfHR8CiAgdC5zdHJpbmcgOm5hbWUKICB0LnN0cmluZyA6ZW1haWwKCiAgdC5kYXRldGltZSA6Y3JlYXRlZF9hdCwgZGVmYXVsdDogLT4geyAnQ1VSUkVOVF9USU1FU1RBTVAnIH0KZW5kCgojIGdvb2QKY3JlYXRlX3RhYmxlIDp1c2VycyBkbyB8dHwKICB0LnN0cmluZyA6bmFtZQogIHQuc3RyaW5nIDplbWFpbAoKICB0LmRhdGV0aW1lIDp1cGRhdGVkX2F0LCBkZWZhdWx0OiAtPiB7ICdDVVJSRU5UX1RJTUVTVEFNUCcgfQplbmQKCiMgZ29vZApjcmVhdGVfdGFibGUgOnVzZXJzLCBhcnRpY2xlcywgaWQ6IGZhbHNlIGRvIHx0fAogIHQuaW50ZWdlciA6dXNlcl9pZAogIHQuaW50ZWdlciA6YXJ0aWNsZV9pZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2RiLyoqLyoucmIrYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgK2RiLyoqLypfY3JlYXRlX2FjdGl2ZV9zdG9yYWdlX3RhYmxlcy5hY3RpdmVfc3RvcmFnZS5yYitgLCBgK2RiLyoqLypfY3JlYXRlX2FjdGl2ZV9zdG9yYWdlX3ZhcmlhbnRfcmVjb3Jkcy5hY3RpdmVfc3RvcmFnZS5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvRGFuZ2Vyb3VzQ29sdW1uTmFtZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMjEKfCAtCnw9PT0KCkF2b2lkIGRhbmdlcm91cyBjb2x1bW4gbmFtZXMuCgpTb21lIGNvbHVtbiBuYW1lcyBhcmUgY29uc2lkZXJlZCBkYW5nZXJvdXMgYmVjYXVzZSB0aGV5IHdvdWxkIG92ZXJ3cml0ZSBtZXRob2RzIGFscmVhZHkgZGVmaW5lZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFkZF9jb2x1bW4gOnVzZXJzLCA6c2F2ZQoKIyBnb29kCmFkZF9jb2x1bW4gOnVzZXJzLCA6c2F2ZWQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFNldmVyaXR5CnwgYHdhcm5pbmdgCnwgU3RyaW5nCgp8IEluY2x1ZGUKfCBgK2RiLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL0RhdGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAwLjMwCnwgMi4xMQp8PT09CgpDaGVja3MgZm9yIHRoZSBjb3JyZWN0IHVzZSBvZiBEYXRlIG1ldGhvZHMsCnN1Y2ggYXMgRGF0ZS50b2RheSwgRGF0ZS5jdXJyZW50IGV0Yy4KClVzaW5nIGBEYXRlLnRvZGF5YCBpcyBkYW5nZXJvdXMsIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IGFueXRoaW5nIGFib3V0ClJhaWxzIHRpbWUgem9uZS4gWW91IG11c3QgdXNlIGBUaW1lLnpvbmUudG9kYXlgIGluc3RlYWQuCgpUaGUgY29wIGFsc28gcmVwb3J0cyB3YXJuaW5ncyB3aGVuIHlvdSBhcmUgdXNpbmcgYHRvX3RpbWVgIG1ldGhvZCwKYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgYWJvdXQgUmFpbHMgdGltZSB6b25lIGVpdGhlci4KClR3byBzdHlsZXMgYXJlIHN1cHBvcnRlZCBmb3IgdGhpcyBjb3AuIFdoZW4gYEVuZm9yY2VkU3R5bGVgIGlzICdzdHJpY3QnCnRoZW4gdGhlIERhdGUgbWV0aG9kcyBgdG9kYXlgLCBgY3VycmVudGAsIGB5ZXN0ZXJkYXlgLCBhbmQgYHRvbW9ycm93YAphcmUgcHJvaGliaXRlZCBhbmQgdGhlIHVzYWdlIG9mIGJvdGggYHRvX3RpbWVgCmFuZCAndG9fdGltZV9pbl9jdXJyZW50X3pvbmUnIGFyZSByZXBvcnRlZCBhcyB3YXJuaW5nLgoKV2hlbiBgRW5mb3JjZWRTdHlsZWAgaXMgYGZsZXhpYmxlYCB0aGVuIG9ubHkgYERhdGUudG9kYXlgIGlzIHByb2hpYml0ZWQuCgpBbmQgeW91IGNhbiBzZXQgYSB3YXJuaW5nIGZvciBgdG9fdGltZWAgd2l0aCBgQWxsb3dUb1RpbWU6IGZhbHNlYC4KYEFsbG93VG9UaW1lYCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdCB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlIG9uIGBEYXRlVGltZWAgb2JqZWN0LgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBpdCBtYXkgY2hhbmdlIGhhbmRsaW5nIHRpbWUuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogZmxleGlibGUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRGF0ZS50b2RheQoKIyBnb29kClRpbWUuem9uZS50b2RheQpUaW1lLnpvbmUudG9kYXkgLSAxLmRheQpEYXRlLmN1cnJlbnQKRGF0ZS55ZXN0ZXJkYXkKZGF0ZS5pbl90aW1lX3pvbmUKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBzdHJpY3QKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApEYXRlLmN1cnJlbnQKRGF0ZS55ZXN0ZXJkYXkKRGF0ZS50b2RheQoKIyBnb29kClRpbWUuem9uZS50b2RheQpUaW1lLnpvbmUudG9kYXkgLSAxLmRheQotLS0tCgo9PT09IEFsbG93VG9UaW1lOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkYXRlLnRvX3RpbWUKLS0tLQoKPT09PSBBbGxvd1RvVGltZTogZmFsc2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkYXRlLnRvX3RpbWUKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZmxleGlibGVgCnwgYHN0cmljdGAsIGBmbGV4aWJsZWAKCnwgQWxsb3dUb1RpbWUKfCBgdHJ1ZWAKfCBCb29sZWFuCnw9PT0KCj09IFJhaWxzL0RlZmF1bHRTY29wZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDIuNwp8IC0KfD09PQoKTG9va3MgZm9yIHVzZXMgb2YgYGRlZmF1bHRfc2NvcGVgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmYXVsdF9zY29wZSAtPiB7IHdoZXJlKGhpZGRlbjogZmFsc2UpIH0KCiMgZ29vZApzY29wZSA6cHVibGlzaGVkLCAtPiB7IHdoZXJlKGhpZGRlbjogZmFsc2UpIH0KCiMgYmFkCmRlZiBzZWxmLmRlZmF1bHRfc2NvcGUKICB3aGVyZShoaWRkZW46IGZhbHNlKQplbmQKCiMgZ29vZApkZWYgc2VsZi5wdWJsaXNoZWQKICB3aGVyZShoaWRkZW46IGZhbHNlKQplbmQKLS0tLQoKPT0gUmFpbHMvRGVsZWdhdGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjIxCnwgMC41MAp8PT09CgpMb29rcyBmb3IgZGVsZWdhdGlvbnMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gY3JlYXRlZAphdXRvbWF0aWNhbGx5IHdpdGggdGhlIGBkZWxlZ2F0ZWAgbWV0aG9kLgoKU2FmZSBuYXZpZ2F0aW9uIGAmLmAgaXMgaWdub3JlZCBiZWNhdXNlIFJhaWxzJyBgYWxsb3dfbmlsYApvcHRpb24gY2hlY2tzIG5vdCBqdXN0IGZvciBuaWwgYnV0IGFsc28gZGVsZWdhdGVzIGlmIG5pbApyZXNwb25kcyB0byB0aGUgZGVsZWdhdGVkIG1ldGhvZC4KClRoZSBgRW5mb3JjZUZvclByZWZpeGVkYCBvcHRpb24gKGRlZmF1bHRlZCB0byBgdHJ1ZWApIG1lYW5zIHRoYXQKdXNpbmcgdGhlIHRhcmdldCBvYmplY3QgYXMgYSBwcmVmaXggb2YgdGhlIG1ldGhvZCBuYW1lCndpdGhvdXQgdXNpbmcgdGhlIGBkZWxlZ2F0ZWAgbWV0aG9kIHdpbGwgYmUgYSB2aW9sYXRpb24uCldoZW4gc2V0IHRvIGBmYWxzZWAsIHRoaXMgY2FzZSBpcyBsZWdhbC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBiYXIKICBmb28uYmFyCmVuZAoKIyBnb29kCmRlbGVnYXRlIDpiYXIsIHRvOiA6Zm9vCgojIGJhZApkZWYgYmFyCiAgc2VsZi5iYXIKZW5kCgojIGdvb2QKZGVsZWdhdGUgOmJhciwgdG86IDpzZWxmCgojIGdvb2QKZGVmIGJhcgogIGZvbyYuYmFyCmVuZAoKIyBnb29kCnByaXZhdGUKZGVmIGJhcgogIGZvby5iYXIKZW5kCi0tLS0KCj09PT0gRW5mb3JjZUZvclByZWZpeGVkOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlZiBmb29fYmFyCiAgZm9vLmJhcgplbmQKCiMgZ29vZApkZWxlZ2F0ZSA6YmFyLCB0bzogOmZvbywgcHJlZml4OiB0cnVlCi0tLS0KCj09PT0gRW5mb3JjZUZvclByZWZpeGVkOiBmYWxzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApkZWYgZm9vX2JhcgogIGZvby5iYXIKZW5kCgojIGdvb2QKZGVsZWdhdGUgOmJhciwgdG86IDpmb28sIHByZWZpeDogdHJ1ZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZUZvclByZWZpeGVkCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PSBSYWlscy9EZWxlZ2F0ZUFsbG93QmxhbmsKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ0CnwgLQp8PT09CgpMb29rcyBmb3IgZGVsZWdhdGlvbnMgdGhhdCBwYXNzIDphbGxvd19ibGFuayBhcyBhbiBvcHRpb24KaW5zdGVhZCBvZiA6YWxsb3dfbmlsLiA6YWxsb3dfYmxhbmsgaXMgbm90IGEgdmFsaWQgb3B0aW9uIHRvIHBhc3MKdG8gQWN0aXZlU3VwcG9ydCNkZWxlZ2F0ZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlbGVnYXRlIDpmb28sIHRvOiA6YmFyLCBhbGxvd19ibGFuazogdHJ1ZQoKIyBnb29kCmRlbGVnYXRlIDpmb28sIHRvOiA6YmFyLCBhbGxvd19uaWw6IHRydWUKLS0tLQoKPT0gUmFpbHMvRGVwcmVjYXRlZEFjdGl2ZU1vZGVsRXJyb3JzTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMi4xNAp8IDIuMTgKfD09PQoKQ2hlY2tzIGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgQWN0aXZlTW9kZWwjZXJyb3JzIGFzIGhhc2guClRoZXNlIG9wZXJhdGlvbnMgYXJlIGRlcHJlY2F0ZWQgaW4gUmFpbHMgNi4xIGFuZCB3aWxsIG5vdCB3b3JrIGluIFJhaWxzIDcuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW4gcmVwb3J0IGBlcnJvcnNgIG1hbmlwdWxhdGlvbiBvbiBub24tQWN0aXZlTW9kZWwsCndoaWNoIGlzIG9idmlvdXNseSB2YWxpZC4KVGhlIGNvcCBoYXMgbm8gd2F5IG9mIGtub3dpbmcgd2hldGhlciBhIHZhcmlhYmxlIGlzIGFuIEFjdGl2ZU1vZGVsIG9yIG5vdC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnVzZXIuZXJyb3JzWzpuYW1lXSA8PCAnbXNnJwp1c2VyLmVycm9ycy5tZXNzYWdlc1s6bmFtZV0gPDwgJ21zZycKCiMgZ29vZAp1c2VyLmVycm9ycy5hZGQoOm5hbWUsICdtc2cnKQoKIyBiYWQKdXNlci5lcnJvcnNbOm5hbWVdLmNsZWFyCnVzZXIuZXJyb3JzLm1lc3NhZ2VzWzpuYW1lXS5jbGVhcgoKIyBnb29kCnVzZXIuZXJyb3JzLmRlbGV0ZSg6bmFtZSkKCiMgYmFkCnVzZXIuZXJyb3JzLmtleXMuaW5jbHVkZT8oOmF0dHIpCgojIGdvb2QKdXNlci5lcnJvcnMuYXR0cmlidXRlX25hbWVzLmluY2x1ZGU/KDphdHRyKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU2V2ZXJpdHkKfCBgd2FybmluZ2AKfCBTdHJpbmcKfD09PQoKPT0gUmFpbHMvRG90U2VwYXJhdGVkS2V5cwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTUKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSB1c2Ugb2YgZG90LXNlcGFyYXRlZCBsb2NhbGUga2V5cyBpbnN0ZWFkIG9mIHNwZWNpZnlpbmcgdGhlIGA6c2NvcGVgIG9wdGlvbgp3aXRoIGFuIGFycmF5IG9yIGEgc2luZ2xlIHN5bWJvbCBpbiBgSTE4bmAgdHJhbnNsYXRpb24gbWV0aG9kcy4KRG90LXNlcGFyYXRlZCBub3RhdGlvbiBpcyBlYXNpZXIgdG8gcmVhZCBhbmQgdHJhY2UgdGhlIGhpZXJhcmNoeS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkkxOG4udCA6cmVjb3JkX2ludmFsaWQsIHNjb3BlOiBbOmFjdGl2ZXJlY29yZCwgOmVycm9ycywgOm1lc3NhZ2VzXQpJMThuLnQgOnRpdGxlLCBzY29wZTogOmludml0YXRpb24KCiMgZ29vZApJMThuLnQgJ2FjdGl2ZXJlY29yZC5lcnJvcnMubWVzc2FnZXMucmVjb3JkX2ludmFsaWQnCkkxOG4udCA6cmVjb3JkX2ludmFsaWQsIHNjb3BlOiAnYWN0aXZlcmVjb3JkLmVycm9ycy5tZXNzYWdlcycKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2RvdC1zZXBhcmF0ZWQta2V5cwoKPT0gUmFpbHMvRHVwbGljYXRlQXNzb2NpYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjE0CnwgMi4xOAp8PT09CgpMb29rcyBmb3IgYXNzb2NpYXRpb25zIHRoYXQgaGF2ZSBiZWVuIGRlZmluZWQgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgZmlsZS4KCldoZW4gYW4gYXNzb2NpYXRpb24gaXMgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyBvbiBhIG1vZGVsLCBBY3RpdmUgUmVjb3JkIG92ZXJyaWRlcyB0aGUKcHJldmlvdXNseSBkZWZpbmVkIGFzc29jaWF0aW9uIHdpdGggdGhlIG5ldyBvbmUuIEJlY2F1c2Ugb2YgdGhpcywgdGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbgpzaW1wbHkga2VlcHMgdGhlIGxhc3Qgb2YgYW55IGR1cGxpY2F0ZXMgYW5kIGRpc2NhcmRzIHRoZSByZXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYmVsb25nc190byA6Zm9vCmJlbG9uZ3NfdG8gOmJhcgpoYXNfb25lIDpmb28KCiMgZ29vZApiZWxvbmdzX3RvIDpiYXIKaGFzX29uZSA6Zm9vCgojIGJhZApoYXNfbWFueSA6Zm9vLCBjbGFzc19uYW1lOiAnRm9vJwpoYXNfbWFueSA6YmFyLCBjbGFzc19uYW1lOiAnRm9vJwpoYXNfb25lIDpiYXoKCiMgZ29vZApoYXNfbWFueSA6YmFyLCBjbGFzc19uYW1lOiAnRm9vJwpoYXNfb25lIDpmb28KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFNldmVyaXR5CnwgYHdhcm5pbmdgCnwgU3RyaW5nCnw9PT0KCj09IFJhaWxzL0R1cGxpY2F0ZVNjb3BlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjE0CnwgMi4xOAp8PT09CgpDaGVja3MgZm9yIG11bHRpcGxlIHNjb3BlcyBpbiBhIG1vZGVsIHRoYXQgaGF2ZSB0aGUgc2FtZSBgd2hlcmVgIGNsYXVzZS4gVGhpcwpvZnRlbiBtZWFucyB5b3UgY29weS9wYXN0ZWQgYSBzY29wZSwgdXBkYXRlZCB0aGUgbmFtZSwgYW5kIGZvcmdvdCB0byBjaGFuZ2UgdGhlIGNvbmRpdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnNjb3BlIDp2aXNpYmxlLCAtPiB7IHdoZXJlKHZpc2libGU6IHRydWUpIH0Kc2NvcGUgOmhpZGRlbiwgLT4geyB3aGVyZSh2aXNpYmxlOiB0cnVlKSB9CgojIGdvb2QKc2NvcGUgOnZpc2libGUsIC0+IHsgd2hlcmUodmlzaWJsZTogdHJ1ZSkgfQpzY29wZSA6aGlkZGVuLCAtPiB7IHdoZXJlKHZpc2libGU6IGZhbHNlKSB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBTZXZlcml0eQp8IGB3YXJuaW5nYAp8IFN0cmluZwp8PT09Cgo9PSBSYWlscy9EdXJhdGlvbkFyaXRobWV0aWMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjEzCnwgLQp8PT09CgpDaGVja3MgaWYgYSBkdXJhdGlvbiBpcyBhZGRlZCB0byBvciBzdWJ0cmFjdGVkIGZyb20gYFRpbWUuY3VycmVudGAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApUaW1lLmN1cnJlbnQgLSAxLm1pbnV0ZQpUaW1lLmN1cnJlbnQgKyAyLmRheXMKCiMgZ29vZCAtIHVzaW5nIHJlbGF0aXZlIHdvdWxkIG1ha2UgaXQgaGFyZGVyIHRvIGV4cHJlc3MgYW5kIHJlYWQKRGF0ZS55ZXN0ZXJkYXkgKyAzLmRheXMKY3JlYXRlZF9hdCAtIDEubWludXRlCjMuZGF5cyAtIDEuaG91cgoKIyBnb29kCjEubWludXRlLmFnbwoyLmRheXMuZnJvbV9ub3cKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjZHVyYXRpb24tYXJpdGhtZXRpYwoKPT0gUmFpbHMvRHluYW1pY0ZpbmRCeQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC40NAp8IDIuMTAKfD09PQoKQ2hlY2tzIGR5bmFtaWMgYGZpbmRfYnlfKmAgbWV0aG9kcy4KVXNlIGBmaW5kX2J5YCBpbnN0ZWFkIG9mIGR5bmFtaWMgbWV0aG9kLgpTZWUuIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlI2ZpbmRfYnkKCj09PSBTYWZldHkKCkl0IGlzIGNlcnRhaW5seSB1bnNhZmUgd2hlbiBub3QgY29uZmlndXJlZCBwcm9wZXJseSwgaS5lLiB1c2VyLWRlZmluZWQgYGZpbmRfYnlfeHh4YAptZXRob2QgaXMgbm90IGFkZGVkIHRvIGNvcCdzIGBBbGxvd2VkTWV0aG9kc2AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApVc2VyLmZpbmRfYnlfbmFtZShuYW1lKQpVc2VyLmZpbmRfYnlfbmFtZV9hbmRfZW1haWwobmFtZSkKVXNlci5maW5kX2J5X2VtYWlsIShuYW1lKQoKIyBnb29kClVzZXIuZmluZF9ieShuYW1lOiBuYW1lKQpVc2VyLmZpbmRfYnkobmFtZTogbmFtZSwgZW1haWw6IGVtYWlsKQpVc2VyLmZpbmRfYnkhKGVtYWlsOiBlbWFpbCkKLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogWydmaW5kX2J5X3NxbCcsICdmaW5kX2J5X3Rva2VuX2ZvciddIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClVzZXIuZmluZF9ieV9xdWVyeSh1c2Vyc19xdWVyeSkKVXNlci5maW5kX2J5X3Rva2VuX2Zvcig6cGFzc3dvcmRfcmVzZXQsIHRva2VuKQoKIyBnb29kClVzZXIuZmluZF9ieV9zcWwodXNlcnNfc3FsKQpVc2VyLmZpbmRfYnlfdG9rZW5fZm9yKDpwYXNzd29yZF9yZXNldCwgdG9rZW4pCi0tLS0KCj09PT0gQWxsb3dlZFJlY2VpdmVyczogWydHZW06OlNwZWNpZmljYXRpb24nLCAncGFnZSddIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClNwZWNpZmljYXRpb24uZmluZF9ieV9uYW1lKCdiYWNrZW5kJykuZ2VtX2RpcgpwYWdlLmZpbmRfYnlfaWQoJ2FfZG9tX2lkJykuY2xpY2sKCiMgZ29vZApHZW06OlNwZWNpZmljYXRpb24uZmluZF9ieV9uYW1lKCdiYWNrZW5kJykuZ2VtX2RpcgpwYWdlLmZpbmRfYnlfaWQoJ2FfZG9tX2lkJykuY2xpY2sKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFdoaXRlbGlzdAp8IGBmaW5kX2J5X3NxbGAsIGBmaW5kX2J5X3Rva2VuX2ZvcmAKfCBBcnJheQoKfCBBbGxvd2VkTWV0aG9kcwp8IGBmaW5kX2J5X3NxbGAsIGBmaW5kX2J5X3Rva2VuX2ZvcmAKfCBBcnJheQoKfCBBbGxvd2VkUmVjZWl2ZXJzCnwgYEdlbTo6U3BlY2lmaWNhdGlvbmAsIGBwYWdlYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlI2ZpbmRfYnkKCj09IFJhaWxzL0VhZ2VyRXZhbHVhdGlvbkxvZ01lc3NhZ2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjExCnwgLQp8PT09CgpDaGVja3MgdGhhdCBibG9ja3MgYXJlIHVzZWQgZm9yIGludGVycG9sYXRlZCBzdHJpbmdzIHBhc3NlZCB0bwpgUmFpbHMubG9nZ2VyLmRlYnVnYC4KCkJ5IGRlZmF1bHQsIFJhaWxzIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHVzZSB0aGUgYDppbmZvYCBsb2cgbGV2ZWwuCkF0IHRoZSBgOmluZm9gIGxvZyBsZXZlbCwgYFJhaWxzLmxvZ2dlci5kZWJ1Z2Agc3RhdGVtZW50cyBkbyBub3QgcmVzdWx0CmluIGxvZyBvdXRwdXQuIEhvd2V2ZXIsIFJ1YnkgbXVzdCBlYWdlcmx5IGV2YWx1YXRlIGludGVycG9sYXRlZCBzdHJpbmcKYXJndW1lbnRzIHBhc3NlZCBhcyBtZXRob2QgYXJndW1lbnRzLiBQYXNzaW5nIGEgYmxvY2sgdG8KYFJhaWxzLmxvZ2dlci5kZWJ1Z2AgcHJldmVudHMgY29zdGx5IGV2YWx1YXRpb24gb2YgaW50ZXJwb2xhdGVkIHN0cmluZ3MKd2hlbiBubyBvdXRwdXQgd291bGQgYmUgcHJvZHVjZWQgYW55d2F5LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKUmFpbHMubG9nZ2VyLmRlYnVnICJUaGUgdGltZSBpcyAje1RpbWUuem9uZS5ub3d9LiIKCiMgZ29vZApSYWlscy5sb2dnZXIuZGVidWcgeyAiVGhlIHRpbWUgaXMgI3tUaW1lLnpvbmUubm93fS4iIH0KLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ndWlkZXMucnVieW9ucmFpbHMub3JnL2RlYnVnZ2luZ19yYWlsc19hcHBsaWNhdGlvbnMuaHRtbCNpbXBhY3Qtb2YtbG9ncy1vbi1wZXJmb3JtYW5jZQoKPT0gUmFpbHMvRW51bUhhc2gKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAyLjMKfCAtCnw9PT0KCkxvb2tzIGZvciBlbnVtcyB3cml0dGVuIHdpdGggYXJyYXkgc3ludGF4LgoKV2hlbiB1c2luZyBhcnJheSBzeW50YXgsIGFkZGluZyBhbiBlbGVtZW50IGluIGEKcG9zaXRpb24gb3RoZXIgdGhhbiB0aGUgbGFzdCBjYXVzZXMgYWxsIHByZXZpb3VzCmRlZmluaXRpb25zIHRvIHNoaWZ0LiBFeHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlCnZhbHVlIGZvciBlYWNoIGtleSBwcmV2ZW50cyB0aGlzIGZyb20gaGFwcGVuaW5nLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZW51bSBzdGF0dXM6IFs6YWN0aXZlLCA6YXJjaGl2ZWRdCgojIGdvb2QKZW51bSBzdGF0dXM6IHsgYWN0aXZlOiAwLCBhcmNoaXZlZDogMSB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbW9kZWxzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlI2VudW1zCgo9PSBSYWlscy9FbnVtVW5pcXVlbmVzcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC40Ngp8IC0KfD09PQoKTG9va3MgZm9yIGR1cGxpY2F0ZSB2YWx1ZXMgaW4gZW51bSBkZWNsYXJhdGlvbnMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAplbnVtIHN0YXR1czogeyBhY3RpdmU6IDAsIGFyY2hpdmVkOiAwIH0KCiMgZ29vZAplbnVtIHN0YXR1czogeyBhY3RpdmU6IDAsIGFyY2hpdmVkOiAxIH0KCiMgYmFkCmVudW0gc3RhdHVzOiBbOmFjdGl2ZSwgOmFyY2hpdmVkLCA6YWN0aXZlXQoKIyBnb29kCmVudW0gc3RhdHVzOiBbOmFjdGl2ZSwgOmFyY2hpdmVkXQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9FbnZMb2NhbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMjIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdXNhZ2Ugb2YgYFJhaWxzLmVudi5kZXZlbG9wbWVudD8gfHwgUmFpbHMuZW52LnRlc3Q/YCB3aGljaApjYW4gYmUgcmVwbGFjZWQgd2l0aCBgUmFpbHMuZW52LmxvY2FsP2AsIGludHJvZHVjZWQgaW4gUmFpbHMgNy4xLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKUmFpbHMuZW52LmRldmVsb3BtZW50PyB8fCBSYWlscy5lbnYudGVzdD8KCiMgZ29vZApSYWlscy5lbnYubG9jYWw/Ci0tLS0KCj09IFJhaWxzL0Vudmlyb25tZW50Q29tcGFyaXNvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNTIKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IFJhaWxzLmVudiBpcyBjb21wYXJlZCB1c2luZyBgLnByb2R1Y3Rpb24/YC1saWtlCm1ldGhvZHMgaW5zdGVhZCBvZiBlcXVhbGl0eSBhZ2FpbnN0IGEgc3RyaW5nIG9yIHN5bWJvbC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJhaWxzLmVudiA9PSAncHJvZHVjdGlvbicKCiMgYmFkLCBhbHdheXMgcmV0dXJucyBmYWxzZQpSYWlscy5lbnYgPT0gOnRlc3QKCiMgZ29vZApSYWlscy5lbnYucHJvZHVjdGlvbj8KLS0tLQoKPT0gUmFpbHMvRW52aXJvbm1lbnRWYXJpYWJsZUFjY2VzcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDIuMTAKfCAyLjI0Cnw9PT0KCkxvb2tzIGZvciBkaXJlY3QgYWNjZXNzIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aHJvdWdoIHRoZQpgRU5WYCB2YXJpYWJsZSB3aXRoaW4gdGhlIGFwcGxpY2F0aW9uIGNvZGUuIFRoaXMgY2FuIGxlYWQgdG8gcnVudGltZQplcnJvcnMgZHVlIHRvIG1pc2NvbmZpZ3VyYXRpb24gdGhhdCBjb3VsZCBoYXZlIGJlZW4gZGlzY292ZXJlZCBhdCBib290CnRpbWUgaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3ZXJlIGxvYWRlZCBhcyBwYXJ0IG9mIGluaXRpYWxpemF0aW9uCmFuZCBjb3BpZWQgaW50byB0aGUgYXBwbGljYXRpb24ncyBjb25maWd1cmF0aW9uIG9yIHNlY3JldHMuIFRoZSBjb3AgY2FuCmJlIGNvbmZpZ3VyZWQgdG8gYWxsb3cgZWl0aGVyIHJlYWRzIG9yIHdyaXRlcyBpZiByZXF1aXJlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApSYWlscy5hcHBsaWNhdGlvbi5jb25maWcuZm9vClJhaWxzLmFwcGxpY2F0aW9uLmNvbmZpZy54LmZvby5iYXIKUmFpbHMuYXBwbGljYXRpb24uc2VjcmV0cy5mb28KUmFpbHMuYXBwbGljYXRpb24uY29uZmlnLmZvbyA9ICJiYXIiCi0tLS0KCj09PT0gQWxsb3dSZWFkczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRU5WWyJGT08iXQpFTlYuZmV0Y2goIkZPTyIpCi0tLS0KCj09PT0gQWxsb3dSZWFkczogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApFTlZbIkZPTyJdCkVOVi5mZXRjaCgiRk9PIikKLS0tLQoKPT09PSBBbGxvd1dyaXRlczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRU5WWyJGT08iXSA9ICJiYXIiCi0tLS0KCj09PT0gQWxsb3dXcml0ZXM6IHRydWUKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKRU5WWyJGT08iXSA9ICJiYXIiCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvKiovKi5yYitgLCBgK2NvbmZpZy9pbml0aWFsaXplcnMvKiovKi5yYitgLCBgK2xpYi8qKi8qLnJiK2AKfCBBcnJheQoKfCBFeGNsdWRlCnwgYCtsaWIvKiovKi5yYWtlK2AKfCBBcnJheQoKfCBBbGxvd1JlYWRzCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgQWxsb3dXcml0ZXMKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PSBSYWlscy9FeGl0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjQxCnwgLQp8PT09CgpFbmZvcmNlcyB0aGF0IGBleGl0YCBjYWxscyBhcmUgbm90IHVzZWQgd2l0aGluIGEgcmFpbHMgYXBwLgpWYWxpZCBvcHRpb25zIGFyZSBpbnN0ZWFkIHRvIHJhaXNlIGFuIGVycm9yLCBicmVhaywgcmV0dXJuLCBvciBzb21lCm90aGVyIGZvcm0gb2Ygc3RvcHBpbmcgZXhlY3V0aW9uIG9mIGN1cnJlbnQgcmVxdWVzdC4KClRoZXJlIGFyZSB0d28gb2J2aW91cyBjYXNlcyB3aGVyZSBgZXhpdGAgaXMgcGFydGljdWxhcmx5IGhhcm1mdWw6CgoqIFVzYWdlIGluIGxpYnJhcnkgY29kZSBmb3IgeW91ciBhcHBsaWNhdGlvbi4gRXZlbiB0aG91Z2ggUmFpbHMgd2lsbApyZXNjdWUgZnJvbSBhIGBTeXN0ZW1FeGl0YCBhbmQgY29udGludWUgb24sIHVuaXQgdGVzdGluZyB0aGF0IGxpYnJhcnkKY29kZSB3aWxsIHJlc3VsdCBpbiBzcGVjcyBleGl0aW5nIChwb3RlbnRpYWxseSBzaWxlbnRseSBpZiBgZXhpdCgwKWAKaXMgdXNlZC4pCiogVXNhZ2UgaW4gYXBwbGljYXRpb24gY29kZSBvdXRzaWRlIG9mIHRoZSB3ZWIgcHJvY2VzcyBjb3VsZCByZXN1bHQgaW4KdGhlIHByb2dyYW0gZXhpdGluZywgd2hpY2ggY291bGQgcmVzdWx0IGluIHRoZSBjb2RlIGZhaWxpbmcgdG8gcnVuIGFuZApkbyBpdHMgam9iLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZXhpdCgwKQoKIyBnb29kCnJhaXNlICdhIGJhZCBlcnJvciBoYXMgaGFwcGVuZWQnCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvKiovKi5yYitgLCBgK2NvbmZpZy8qKi8qLnJiK2AsIGArbGliLyoqLyoucmIrYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgK2xpYi8qKi8qLnJha2UrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL0V4cGFuZGVkRGF0ZVJhbmdlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4xMQp8IC0KfD09PQoKQ2hlY2tzIGZvciBleHBhbmRlZCBkYXRlIHJhbmdlLiBJdCBvbmx5IGNvbXBhdGlibGUgYC4uYCByYW5nZSBpcyB0YXJnZXRlZC4KSW5jb21wYXRpYmxlIGAuLi5gIHJhbmdlIGlzIGlnbm9yZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkYXRlLmJlZ2lubmluZ19vZl9kYXkuLmRhdGUuZW5kX29mX2RheQpkYXRlLmJlZ2lubmluZ19vZl93ZWVrLi5kYXRlLmVuZF9vZl93ZWVrCmRhdGUuYmVnaW5uaW5nX29mX21vbnRoLi5kYXRlLmVuZF9vZl9tb250aApkYXRlLmJlZ2lubmluZ19vZl9xdWFydGVyLi5kYXRlLmVuZF9vZl9xdWFydGVyCmRhdGUuYmVnaW5uaW5nX29mX3llYXIuLmRhdGUuZW5kX29mX3llYXIKCiMgZ29vZApkYXRlLmFsbF9kYXkKZGF0ZS5hbGxfd2VlawpkYXRlLmFsbF9tb250aApkYXRlLmFsbF9xdWFydGVyCmRhdGUuYWxsX3llYXIKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2RhdGUtdGltZS1yYW5nZQoKPT0gUmFpbHMvRmlsZVBhdGgKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ3CnwgMi40Cnw9PT0KCklkZW50aWZpZXMgdXNhZ2VzIG9mIGZpbGUgcGF0aCBqb2luaW5nIHByb2Nlc3MgdG8gdXNlIGBSYWlscy5yb290LmpvaW5gIGNsYXVzZS4KSXQgaXMgdXNlZCB0byBhZGQgdW5pZm9ybWl0eSB3aGVuIGpvaW5pbmcgcGF0aHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc2xhc2hlcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSYWlscy5yb290LmpvaW4oJ2FwcCcsICdtb2RlbHMnLCAnZ29vYmVyJykKCiMgZ29vZApSYWlscy5yb290LmpvaW4oJ2FwcC9tb2RlbHMvZ29vYmVyJykKCiMgYmFkCkZpbGUuam9pbihSYWlscy5yb290LCAnYXBwL21vZGVscy9nb29iZXInKQoiI3tSYWlscy5yb290fS9hcHAvbW9kZWxzL2dvb2JlciIKCiMgZ29vZApSYWlscy5yb290LmpvaW4oJ2FwcC9tb2RlbHMvZ29vYmVyJykudG9fcwotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFyZ3VtZW50cwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJhaWxzLnJvb3Quam9pbignYXBwL21vZGVscy9nb29iZXInKQoKIyBnb29kClJhaWxzLnJvb3Quam9pbignYXBwJywgJ21vZGVscycsICdnb29iZXInKQoKIyBiYWQKRmlsZS5qb2luKFJhaWxzLnJvb3QsICdhcHAvbW9kZWxzL2dvb2JlcicpCiIje1JhaWxzLnJvb3R9L2FwcC9tb2RlbHMvZ29vYmVyIgoKIyBnb29kClJhaWxzLnJvb3Quam9pbignYXBwJywgJ21vZGVscycsICdnb29iZXInKS50b19zCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHNsYXNoZXNgCnwgYHNsYXNoZXNgLCBgYXJndW1lbnRzYAp8PT09Cgo9PSBSYWlscy9GaW5kQnkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjMwCnwgMi4yMQp8PT09CgpJZGVudGlmaWVzIHVzYWdlcyBvZiBgd2hlcmUudGFrZWAgYW5kIGNoYW5nZSB0aGVtIHRvIHVzZSBgZmluZF9ieWAgaW5zdGVhZC4KCkFuZCBgd2hlcmUoLi4uKS5maXJzdGAgY2FuIHJldHVybiBkaWZmZXJlbnQgcmVzdWx0cyBmcm9tIGBmaW5kX2J5YC4KKFRoZXkgb3JkZXIgcmVjb3JkcyBkaWZmZXJlbnRseSwgc28gdGhlICJmaXJzdCIgcmVjb3JkIGNhbiBiZSBkaWZmZXJlbnQuKQoKSWYgeW91IGFsc28gd2FudCB0byBkZXRlY3QgYHdoZXJlLmZpcnN0YCwgeW91IGNhbiBzZXQgYElnbm9yZVdoZXJlRmlyc3RgIHRvIGZhbHNlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVXNlci53aGVyZShuYW1lOiAnQnJ1Y2UnKS50YWtlCgojIGdvb2QKVXNlci5maW5kX2J5KG5hbWU6ICdCcnVjZScpCi0tLS0KCj09PT0gSWdub3JlV2hlcmVGaXJzdDogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKVXNlci53aGVyZShuYW1lOiAnQnJ1Y2UnKS5maXJzdAotLS0tCgo9PT09IElnbm9yZVdoZXJlRmlyc3Q6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVXNlci53aGVyZShuYW1lOiAnQnJ1Y2UnKS5maXJzdAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSWdub3JlV2hlcmVGaXJzdAp8IGB0cnVlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjZmluZF9ieQoKPT0gUmFpbHMvRmluZEJ5SWQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjcKfCAtCnw9PT0KCkVuZm9yY2VzIHRoYXQgYEFjdGl2ZVJlY29yZCNmaW5kYCBpcyB1c2VkIGluc3RlYWQgb2YKYHdoZXJlLnRha2UhYCwgYGZpbmRfYnkhYCwgYW5kIGBmaW5kX2J5X2lkIWAgdG8gcmV0cmlldmUgYSBzaW5nbGUgcmVjb3JkCmJ5IHByaW1hcnkga2V5IHdoZW4geW91IGV4cGVjdCBpdCB0byBiZSBmb3VuZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClVzZXIud2hlcmUoaWQ6IGlkKS50YWtlIQpVc2VyLmZpbmRfYnlfaWQhKGlkKQpVc2VyLmZpbmRfYnkhKGlkOiBpZCkKCiMgZ29vZApVc2VyLmZpbmQoaWQpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNmaW5kCgo9PSBSYWlscy9GaW5kRWFjaAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4zMAp8IDIuMjEKfD09PQoKSWRlbnRpZmllcyB1c2FnZXMgb2YgYGFsbC5lYWNoYCBhbmQgY2hhbmdlIHRoZW0gdG8gdXNlIGBhbGwuZmluZF9lYWNoYCBpbnN0ZWFkLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGlmIHRoZSByZWNlaXZlciBvYmplY3QgaXMgbm90IGFuIEFjdGl2ZSBSZWNvcmQgb2JqZWN0LgpBbHNvLCBgYWxsLmVhY2hgIHJldHVybnMgYW4gYEFycmF5YCBpbnN0YW5jZSBhbmQgYGFsbC5maW5kX2VhY2hgIHJldHVybnMgbmlsLApzbyB0aGUgcmV0dXJuIHZhbHVlcyBhcmUgZGlmZmVyZW50LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVXNlci5hbGwuZWFjaAoKIyBnb29kClVzZXIuYWxsLmZpbmRfZWFjaAotLS0tCgo9PT09IEFsbG93ZWRNZXRob2RzOiBbJ29yZGVyJ10KCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKVXNlci5vcmRlcig6Zm9vKS5lYWNoCi0tLS0KCj09PT0gQWxsb3dlZFBhdHRlcm46IFsnb3JkZXInXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApVc2VyLm9yZGVyKDpmb28pLmVhY2gKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRNZXRob2RzCnwgYG9yZGVyYCwgYGxpbWl0YCwgYHNlbGVjdGAsIGBsb2NrYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZSNmaW5kLWVhY2gKCj09IFJhaWxzL0ZyZWV6ZVRpbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjE2CnwgLQp8PT09CgpJZGVudGlmaWVzIHVzYWdlcyBvZiBgdHJhdmVsX3RvYCB3aXRoIGFuIGFyZ3VtZW50IG9mIHRoZSBjdXJyZW50IHRpbWUgYW5kCmNoYW5nZSB0aGVtIHRvIHVzZSBgZnJlZXplX3RpbWVgIGluc3RlYWQuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcOKAmXMgYXV0b2NvcnJlY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgYGZyZWV6ZV90aW1lYCBqdXN0IGRlbGVnYXRlcyB0bwpgdHJhdmVsX3RvYCB3aXRoIGEgZGVmYXVsdCBgVGltZS5ub3dgLCBpdCBpcyBub3Qgc3RyaWN0bHkgZXF1aXZhbGVudCB0byBgVGltZS5ub3dgCmlmIHRoZSBhcmd1bWVudCBvZiBgdHJhdmVsX3RvYCBpcyB0aGUgY3VycmVudCB0aW1lIGNvbnNpZGVyaW5nIHRpbWUgem9uZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnRyYXZlbF90byhUaW1lLm5vdykKdHJhdmVsX3RvKFRpbWUubmV3KQp0cmF2ZWxfdG8oRGF0ZVRpbWUubm93KQp0cmF2ZWxfdG8oVGltZS5jdXJyZW50KQp0cmF2ZWxfdG8oVGltZS56b25lLm5vdykKdHJhdmVsX3RvKFRpbWUubm93LmluX3RpbWVfem9uZSkKdHJhdmVsX3RvKFRpbWUuY3VycmVudC50b190aW1lKQoKIyBnb29kCmZyZWV6ZV90aW1lCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNmcmVlemUtdGltZQoKPT0gUmFpbHMvSGFzQW5kQmVsb25nc1RvTWFueQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC4xMgp8IC0KfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIHRoZSBoYXNfYW5kX2JlbG9uZ3NfdG9fbWFueSBtYWNyby4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiMgaGFzX2FuZF9iZWxvbmdzX3RvX21hbnkgOmluZ3JlZGllbnRzCgojIGdvb2QKIyBoYXNfbWFueSA6aW5ncmVkaWVudHMsIHRocm91Z2g6IDpyZWNpcGVfaW5ncmVkaWVudHMKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2FwcC9tb2RlbHMvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjaGFzLW1hbnktdGhyb3VnaAoKPT0gUmFpbHMvSGFzTWFueU9ySGFzT25lRGVwZW5kZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUwCnwgLQp8PT09CgpMb29rcyBmb3IgYGhhc19tYW55YCBvciBgaGFzX29uZWAgYXNzb2NpYXRpb25zIHRoYXQgZG9uJ3QKc3BlY2lmeSBhIGA6ZGVwZW5kZW50YCBvcHRpb24uCgpJdCBkb2Vzbid0IHJlZ2lzdGVyIGFuIG9mZmVuc2UgaWYgYDp0aHJvdWdoYCBvciBgZGVwZW5kZW50OiBuaWxgCmlzIHNwZWNpZmllZCwgb3IgaWYgdGhlIG1vZGVsIGlzIHJlYWQtb25seS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFVzZXIgPCBBY3RpdmVSZWNvcmQ6OkJhc2UKICBoYXNfbWFueSA6Y29tbWVudHMKICBoYXNfb25lIDphdmF0YXIKZW5kCgojIGdvb2QKY2xhc3MgVXNlciA8IEFjdGl2ZVJlY29yZDo6QmFzZQogIGhhc19tYW55IDpjb21tZW50cywgZGVwZW5kZW50OiA6cmVzdHJpY3Rfd2l0aF9leGNlcHRpb24KICBoYXNfb25lIDphdmF0YXIsIGRlcGVuZGVudDogOmRlc3Ryb3kKICBoYXNfbWFueSA6YXJ0aWNsZXMsIGRlcGVuZGVudDogbmlsCiAgaGFzX21hbnkgOnBhdGllbnRzLCB0aHJvdWdoOiA6YXBwb2ludG1lbnRzCmVuZAoKY2xhc3MgVXNlciA8IEFjdGl2ZVJlY29yZDo6QmFzZQogIGhhc19tYW55IDpjb21tZW50cwogIGhhc19vbmUgOmF2YXRhcgoKICBkZWYgcmVhZG9ubHk/CiAgICB0cnVlCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZSNoYXNfbWFueS1oYXNfb25lLWRlcGVuZGVudC1vcHRpb24KCj09IFJhaWxzL0hlbHBlckluc3RhbmNlVmFyaWFibGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDIuMAp8IC0KfD09PQoKQ2hlY2tzIGZvciB1c2Ugb2YgdGhlIGhlbHBlciBtZXRob2RzIHdoaWNoIHJlZmVyZW5jZQppbnN0YW5jZSB2YXJpYWJsZXMuCgpSZWx5aW5nIG9uIGluc3RhbmNlIHZhcmlhYmxlcyBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gcmV1c2UgaGVscGVyCm1ldGhvZHMuCgpJZiBpdCBzZWVtcyBhd2t3YXJkIHRvIGV4cGxpY2l0bHkgcGFzcyBpbiBlYWNoIGRlcGVuZGVudAp2YXJpYWJsZSwgY29uc2lkZXIgbW92aW5nIHRoZSBiZWhhdmlvciBlbHNld2hlcmUsIGZvcgpleGFtcGxlIHRvIGEgbW9kZWwsIGRlY29yYXRvciBvciBwcmVzZW50ZXIuCgpQcm92aWRlZCB0aGF0IGEgY2xhc3MgaW5oZXJpdHMgYEFjdGlvblZpZXc6OkhlbHBlcnM6OkZvcm1CdWlsZGVyYCwKYW4gb2ZmZW5zZSB3aWxsIG5vdCBiZSByZWdpc3RlcmVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVmIHdlbGNvbWVfbWVzc2FnZQogICJIZWxsbyAje0B1c2VyLm5hbWV9IgplbmQKCiMgZ29vZApkZWYgd2VsY29tZV9tZXNzYWdlKHVzZXIpCiAgIkhlbGxvICN7dXNlci5uYW1lfSIKZW5kCgojIGdvb2QKY2xhc3MgTXlGb3JtQnVpbGRlciA8IEFjdGlvblZpZXc6OkhlbHBlcnM6OkZvcm1CdWlsZGVyCiAgQHRlbXBsYXRlLmRvX3NvbWV0aGluZwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2FwcC9oZWxwZXJzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL0h0dHBQb3NpdGlvbmFsQXJndW1lbnRzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC40NAp8IC0KfD09PQoKSWRlbnRpZmllcyB1c2FnZXMgb2YgaHR0cCBtZXRob2RzIGxpa2UgYGdldGAsIGBwb3N0YCwKYHB1dGAsIGBwYXRjaGAgd2l0aG91dCB0aGUgdXNhZ2Ugb2Yga2V5d29yZCBhcmd1bWVudHMgaW4geW91ciB0ZXN0cyBhbmQKY2hhbmdlIHRoZW0gdG8gdXNlIGtleXdvcmQgYXJncy4gVGhpcyBjb3Agb25seSBhcHBsaWVzIHRvIFJhaWxzID49IDUuCklmIHlvdSBhcmUgcnVubmluZyBSYWlscyA8IDUgeW91IHNob3VsZCBkaXNhYmxlIHRoZQpSYWlscy9IdHRwUG9zaXRpb25hbEFyZ3VtZW50cyBjb3Agb3Igc2V0IHlvdXIgVGFyZ2V0UmFpbHNWZXJzaW9uIGluIHlvdXIKLnJ1Ym9jb3AueW1sIGZpbGUgdG8gNC4yLgoKTk9URTogSXQgZG9lcyBub3QgZGV0ZWN0IGFueSBjYXNlcyB3aGVyZSBgaW5jbHVkZSBSYWNrOjpUZXN0OjpNZXRob2RzYCBpcyB1c2VkCndoaWNoIG1ha2VzIHRoZSBodHRwIG1ldGhvZHMgaW5jb21wYXRpYmxlIGJlaGF2aW9yLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZ2V0IDpuZXcsIHsgdXNlcl9pZDogMX0KCiMgZ29vZApnZXQgOm5ldywgcGFyYW1zOiB7IHVzZXJfaWQ6IDEgfQpnZXQgOm5ldywgKipvcHRpb25zCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCtzcGVjLyoqLyorYCwgYCt0ZXN0LyoqLyorYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL0h0dHBTdGF0dXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjU0CnwgMi4xMQp8PT09CgpFbmZvcmNlcyB1c2Ugb2Ygc3ltYm9saWMgb3IgbnVtZXJpYyB2YWx1ZSB0byBkZWZpbmUgSFRUUCBzdGF0dXMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc3ltYm9saWMgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVuZGVyIDpmb28sIHN0YXR1czogMjAwCnJlbmRlciA6Zm9vLCBzdGF0dXM6ICcyMDAnCnJlbmRlciBqc29uOiB7IGZvbzogJ2JhcicgfSwgc3RhdHVzOiAyMDAKcmVuZGVyIHBsYWluOiAnZm9vL2JhcicsIHN0YXR1czogMzA0CnJlZGlyZWN0X3RvIHJvb3RfdXJsLCBzdGF0dXM6IDMwMQpoZWFkIDIwMAphc3NlcnRfcmVzcG9uc2UgMjAwCmFzc2VydF9yZWRpcmVjdGVkX3RvICcvc29tZS9wYXRoJywgc3RhdHVzOiAzMDEKCiMgZ29vZApyZW5kZXIgOmZvbywgc3RhdHVzOiA6b2sKcmVuZGVyIGpzb246IHsgZm9vOiAnYmFyJyB9LCBzdGF0dXM6IDpvawpyZW5kZXIgcGxhaW46ICdmb28vYmFyJywgc3RhdHVzOiA6bm90X21vZGlmaWVkCnJlZGlyZWN0X3RvIHJvb3RfdXJsLCBzdGF0dXM6IDptb3ZlZF9wZXJtYW5lbnRseQpoZWFkIDpvawphc3NlcnRfcmVzcG9uc2UgOm9rCmFzc2VydF9yZWRpcmVjdGVkX3RvICcvc29tZS9wYXRoJywgc3RhdHVzOiA6bW92ZWRfcGVybWFuZW50bHkKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiBudW1lcmljCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVuZGVyIDpmb28sIHN0YXR1czogOm9rCnJlbmRlciBqc29uOiB7IGZvbzogJ2JhcicgfSwgc3RhdHVzOiA6bm90X2ZvdW5kCnJlbmRlciBwbGFpbjogJ2Zvby9iYXInLCBzdGF0dXM6IDpub3RfbW9kaWZpZWQKcmVkaXJlY3RfdG8gcm9vdF91cmwsIHN0YXR1czogOm1vdmVkX3Blcm1hbmVudGx5CmhlYWQgOm9rCmFzc2VydF9yZXNwb25zZSA6b2sKYXNzZXJ0X3JlZGlyZWN0ZWRfdG8gJy9zb21lL3BhdGgnLCBzdGF0dXM6IDptb3ZlZF9wZXJtYW5lbnRseQoKIyBnb29kCnJlbmRlciA6Zm9vLCBzdGF0dXM6IDIwMApyZW5kZXIganNvbjogeyBmb286ICdiYXInIH0sIHN0YXR1czogNDA0CnJlbmRlciBwbGFpbjogJ2Zvby9iYXInLCBzdGF0dXM6IDMwNApyZWRpcmVjdF90byByb290X3VybCwgc3RhdHVzOiAzMDEKaGVhZCAyMDAKYXNzZXJ0X3Jlc3BvbnNlIDIwMAphc3NlcnRfcmVkaXJlY3RlZF90byAnL3NvbWUvcGF0aCcsIHN0YXR1czogMzAxCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHN5bWJvbGljYAp8IGBudW1lcmljYCwgYHN5bWJvbGljYAp8PT09Cgo9PSBSYWlscy9JMThuTGF6eUxvb2t1cAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTQKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcGxhY2VzIHdoZXJlIEkxOG4gImxhenkiIGxvb2t1cCBjYW4gYmUgdXNlZC4KClRoaXMgY29wIGhhcyB0d28gZGlmZmVyZW50IGVuZm9yY2VtZW50IG1vZGVzLiBXaGVuIHRoZSBFbmZvcmNlZFN0eWxlCmlzIGBsYXp5YCAodGhlIGRlZmF1bHQpLCBleHBsaWNpdCBsb29rdXBzIGFyZSBhZGRlZCBhcyBvZmZlbnNlcy4KCldoZW4gdGhlIEVuZm9yY2VkU3R5bGUgaXMgYGV4cGxpY2l0YCB0aGVuIGxhenkgbG9va3VwcyBhcmUgYWRkZWQgYXMKb2ZmZW5zZXMuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogbGF6eSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGVuLnltbAojIGVuOgojICAgYm9va3M6CiMgICAgIGNyZWF0ZToKIyAgICAgICBzdWNjZXNzOiBCb29rIGNyZWF0ZWQhCgojIGJhZApjbGFzcyBCb29rc0NvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBkZWYgY3JlYXRlCiAgICAjIC4uLgogICAgcmVkaXJlY3RfdG8gYm9va3NfdXJsLCBub3RpY2U6IHQoJ2Jvb2tzLmNyZWF0ZS5zdWNjZXNzJykKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgQm9va3NDb250cm9sbGVyIDwgQXBwbGljYXRpb25Db250cm9sbGVyCiAgZGVmIGNyZWF0ZQogICAgIyAuLi4KICAgIHJlZGlyZWN0X3RvIGJvb2tzX3VybCwgbm90aWNlOiB0KCcuc3VjY2VzcycpCiAgZW5kCmVuZAotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGV4cGxpY2l0Cgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgQm9va3NDb250cm9sbGVyIDwgQXBwbGljYXRpb25Db250cm9sbGVyCiAgZGVmIGNyZWF0ZQogICAgIyAuLi4KICAgIHJlZGlyZWN0X3RvIGJvb2tzX3VybCwgbm90aWNlOiB0KCcuc3VjY2VzcycpCiAgZW5kCmVuZAoKIyBnb29kCmNsYXNzIEJvb2tzQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIGRlZiBjcmVhdGUKICAgICMgLi4uCiAgICByZWRpcmVjdF90byBib29rc191cmwsIG5vdGljZTogdCgnYm9va3MuY3JlYXRlLnN1Y2Nlc3MnKQogIGVuZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgbGF6eWAKfCBgbGF6eWAsIGBleHBsaWNpdGAKCnwgSW5jbHVkZQp8IGArYXBwL2NvbnRyb2xsZXJzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNsYXp5LWxvb2t1cAoqIGh0dHBzOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy9pMThuLmh0bWwjbGF6eS1sb29rdXAKCj09IFJhaWxzL0kxOG5Mb2NhbGVBc3NpZ25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjExCnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSB1c2Ugb2YgYEkxOG4ubG9jYWxlPWAgbWV0aG9kLgoKVGhlIGBsb2NhbGVgIGF0dHJpYnV0ZSBwZXJzaXN0cyBmb3IgdGhlIHJlc3Qgb2YgdGhlIFJ1YnkgcnVudGltZSwgcG90ZW50aWFsbHkgY2F1c2luZwp1bmV4cGVjdGVkIGJlaGF2aW9yIGF0IGEgbGF0ZXIgdGltZS4KVXNpbmcgYEkxOG4ud2l0aF9sb2NhbGVgIGVuc3VyZXMgdGhlIGNvZGUgcGFzc2VkIGluIHRoZSBibG9jayBpcyB0aGUgb25seSBwbGFjZSBgSTE4bi5sb2NhbGVgIGlzIGFmZmVjdGVkLgpJdCBlbGltaW5hdGVzIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGBsb2NhbGVgIHN0aWNraW5nIGFyb3VuZCBsb25nZXIgdGhhbiBpbnRlbmRlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkkxOG4ubG9jYWxlID0gOmZyCgojIGdvb2QKSTE4bi53aXRoX2xvY2FsZSg6ZnIpIGRvCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArc3BlYy8qKi8qLnJiK2AsIGArdGVzdC8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9JMThuTG9jYWxlVGV4dHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMTQKfCAtCnw9PT0KCkVuZm9yY2VzIHVzZSBvZiBJMThuIGFuZCBsb2NhbGUgZmlsZXMgaW5zdGVhZCBvZiBsb2NhbGUgc3BlY2lmaWMgc3RyaW5ncy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFVzZXIgPCBBcHBsaWNhdGlvblJlY29yZAogIHZhbGlkYXRlcyA6ZW1haWwsIHByZXNlbmNlOiB7IG1lc3NhZ2U6ICJtdXN0IGJlIHByZXNlbnQiIH0KZW5kCgojIGdvb2QKIyBjb25maWcvbG9jYWxlcy9lbi55bWwKIyBlbjoKIyAgIGFjdGl2ZXJlY29yZDoKIyAgICAgZXJyb3JzOgojICAgICAgIG1vZGVsczoKIyAgICAgICAgIHVzZXI6CiMgICAgICAgICAgIGJsYW5rOiAibXVzdCBiZSBwcmVzZW50IgoKY2xhc3MgVXNlciA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgdmFsaWRhdGVzIDplbWFpbCwgcHJlc2VuY2U6IHRydWUKZW5kCgojIGJhZApjbGFzcyBQb3N0c0NvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBkZWYgY3JlYXRlCiAgICAjIC4uLgogICAgcmVkaXJlY3RfdG8gcm9vdF9wYXRoLCBub3RpY2U6ICJQb3N0IGNyZWF0ZWQhIgogIGVuZAplbmQKCiMgZ29vZAojIGNvbmZpZy9sb2NhbGVzL2VuLnltbAojIGVuOgojICAgcG9zdHM6CiMgICAgIGNyZWF0ZToKIyAgICAgICBzdWNjZXNzOiAiUG9zdCBjcmVhdGVkISIKCmNsYXNzIFBvc3RzQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIGRlZiBjcmVhdGUKICAgICMgLi4uCiAgICByZWRpcmVjdF90byByb290X3BhdGgsIG5vdGljZTogdCgiLnN1Y2Nlc3MiKQogIGVuZAplbmQKCiMgYmFkCmNsYXNzIFVzZXJNYWlsZXIgPCBBcHBsaWNhdGlvbk1haWxlcgogIGRlZiB3ZWxjb21lKHVzZXIpCiAgICBtYWlsKHRvOiB1c2VyLmVtYWlsLCBzdWJqZWN0OiAiV2VsY29tZSB0byBNeSBBd2Vzb21lIFNpdGUiKQogIGVuZAplbmQKCiMgZ29vZAojIGNvbmZpZy9sb2NhbGVzL2VuLnltbAojIGVuOgojICAgdXNlcl9tYWlsZXI6CiMgICAgIHdlbGNvbWU6CiMgICAgICAgc3ViamVjdDogIldlbGNvbWUgdG8gTXkgQXdlc29tZSBTaXRlIgoKY2xhc3MgVXNlck1haWxlciA8IEFwcGxpY2F0aW9uTWFpbGVyCiAgZGVmIHdlbGNvbWUodXNlcikKICAgIG1haWwodG86IHVzZXIuZW1haWwpCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZS8jbG9jYWxlLXRleHRzCgo9PSBSYWlscy9JZ25vcmVkQ29sdW1uc0Fzc2lnbm1lbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjE3CnwgLQp8PT09CgpMb29rcyBmb3IgYXNzaWdubWVudHMgb2YgYGlnbm9yZWRfY29sdW1uc2AgdGhhdCBtYXkgb3ZlcnJpZGUgcHJldmlvdXMKYXNzaWdubWVudHMuCgpPdmVyd3JpdGluZyBwcmV2aW91cyBhc3NpZ25tZW50cyBpcyB1c3VhbGx5IGEgbWlzdGFrZSwgc2luY2UgaXQgd2lsbAp1bi1pZ25vcmUgdGhlIGZpcnN0IHNldCBvZiBjb2x1bW5zLiBTaW5jZSBkdXBsaWNhdGUgY29sdW1uIG5hbWVzIGlzIG5vdAphIHByb2JsZW0sIGl0IGlzIGJldHRlciB0byBzaW1wbHkgYXBwZW5kIHRvIHRoZSBsaXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgVXNlciA8IEFjdGl2ZVJlY29yZDo6QmFzZQogIHNlbGYuaWdub3JlZF9jb2x1bW5zID0gWzpvbmVdCmVuZAoKIyBiYWQKY2xhc3MgVXNlciA8IEFjdGl2ZVJlY29yZDo6QmFzZQogIHNlbGYuaWdub3JlZF9jb2x1bW5zID0gWzpvbmUsIDp0d29dCmVuZAoKIyBnb29kCmNsYXNzIFVzZXIgPCBBY3RpdmVSZWNvcmQ6OkJhc2UKICBzZWxmLmlnbm9yZWRfY29sdW1ucyArPSBbOm9uZSwgOnR3b10KZW5kCgojIGdvb2QKY2xhc3MgVXNlciA8IEFjdGl2ZVJlY29yZDo6QmFzZQogIHNlbGYuaWdub3JlZF9jb2x1bW5zICs9IFs6b25lXQogIHNlbGYuaWdub3JlZF9jb2x1bW5zICs9IFs6dHdvXQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2FwcGVuZC1pZ25vcmVkLWNvbHVtbnMKCj09IFJhaWxzL0lnbm9yZWRTa2lwQWN0aW9uRmlsdGVyT3B0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC42Mwp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgYGlmYCBhbmQgYG9ubHlgIChvciBgZXhjZXB0YCkgYXJlIG5vdCB1c2VkIHRvZ2V0aGVyCmFzIG9wdGlvbnMgb2YgYHNraXBfKmAgYWN0aW9uIGZpbHRlci4KClRoZSBgaWZgIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQgd2hlbiBgaWZgIGFuZCBgb25seWAgYXJlIHVzZWQgdG9nZXRoZXIuClNpbWlsYXJseSwgdGhlIGBleGNlcHRgIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQgd2hlbiBgaWZgIGFuZCBgZXhjZXB0YAphcmUgdXNlZCB0b2dldGhlci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIE15UGFnZUNvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBza2lwX2JlZm9yZV9hY3Rpb24gOmxvZ2luX3JlcXVpcmVkLAogICAgb25seTogOnNob3csIGlmOiA6dHJ1c3RlZF9vcmlnaW4/CmVuZAoKIyBnb29kCmNsYXNzIE15UGFnZUNvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBza2lwX2JlZm9yZV9hY3Rpb24gOmxvZ2luX3JlcXVpcmVkLAogICAgaWY6IC0+IHsgdHJ1c3RlZF9vcmlnaW4/ICYmIGFjdGlvbl9uYW1lID09ICJzaG93IiB9CmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgTXlQYWdlQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIHNraXBfYmVmb3JlX2FjdGlvbiA6bG9naW5fcmVxdWlyZWQsCiAgICBleGNlcHQ6IDphZG1pbiwgaWY6IDp0cnVzdGVkX29yaWdpbj8KZW5kCgojIGdvb2QKY2xhc3MgTXlQYWdlQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIHNraXBfYmVmb3JlX2FjdGlvbiA6bG9naW5fcmVxdWlyZWQsCiAgICBpZjogLT4geyB0cnVzdGVkX29yaWdpbj8gJiYgYWN0aW9uX25hbWUgIT0gImFkbWluIiB9CmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL2NvbnRyb2xsZXJzLyoqLyoucmIrYCwgYCthcHAvbWFpbGVycy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL2FwaS5ydWJ5b25yYWlscy5vcmcvY2xhc3Nlcy9BYnN0cmFjdENvbnRyb2xsZXIvQ2FsbGJhY2tzL0NsYXNzTWV0aG9kcy5odG1sI21ldGhvZC1pLV9ub3JtYWxpemVfY2FsbGJhY2tfb3B0aW9ucwoKPT0gUmFpbHMvSW5kZXhCeQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDIuNQp8IDIuOAp8PT09CgpMb29rcyBmb3IgdXNlcyBvZiBgZWFjaF93aXRoX29iamVjdCh7fSkgeyAuLi4gfWAsCmBtYXAgeyAuLi4gfS50b19oYCwgYW5kIGBIYXNoW21hcCB7IC4uLiB9XWAgdGhhdCBhcmUgdHJhbnNmb3JtaW5nCmFuIGVudW1lcmFibGUgaW50byBhIGhhc2ggd2hlcmUgdGhlIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRzLgpSYWlscyBwcm92aWRlcyB0aGUgYGluZGV4X2J5YCBtZXRob2QgZm9yIHRoaXMgcHVycG9zZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClsxLCAyLCAzXS5lYWNoX3dpdGhfb2JqZWN0KHt9KSB7IHxlbCwgaHwgaFtmb28oZWwpXSA9IGVsIH0KWzEsIDIsIDNdLnRvX2ggeyB8ZWx8IFtmb28oZWwpLCBlbF0gfQpbMSwgMiwgM10ubWFwIHsgfGVsfCBbZm9vKGVsKSwgZWxdIH0udG9faApIYXNoW1sxLCAyLCAzXS5jb2xsZWN0IHsgfGVsfCBbZm9vKGVsKSwgZWxdIH1dCgojIGdvb2QKWzEsIDIsIDNdLmluZGV4X2J5IHsgfGVsfCBmb28oZWwpIH0KLS0tLQoKPT0gUmFpbHMvSW5kZXhXaXRoCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMi41CnwgMi44Cnw9PT0KCkxvb2tzIGZvciB1c2VzIG9mIGBlYWNoX3dpdGhfb2JqZWN0KHt9KSB7IC4uLiB9YCwKYG1hcCB7IC4uLiB9LnRvX2hgLCBhbmQgYEhhc2hbbWFwIHsgLi4uIH1dYCB0aGF0IGFyZSB0cmFuc2Zvcm1pbmcKYW4gZW51bWVyYWJsZSBpbnRvIGEgaGFzaCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRzLgpSYWlscyBwcm92aWRlcyB0aGUgYGluZGV4X3dpdGhgIG1ldGhvZCBmb3IgdGhpcyBwdXJwb3NlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKWzEsIDIsIDNdLmVhY2hfd2l0aF9vYmplY3Qoe30pIHsgfGVsLCBofCBoW2VsXSA9IGZvbyhlbCkgfQpbMSwgMiwgM10udG9faCB7IHxlbHwgW2VsLCBmb28oZWwpXSB9ClsxLCAyLCAzXS5tYXAgeyB8ZWx8IFtlbCwgZm9vKGVsKV0gfS50b19oCkhhc2hbWzEsIDIsIDNdLmNvbGxlY3QgeyB8ZWx8IFtlbCwgZm9vKGVsKV0gfV0KCiMgZ29vZApbMSwgMiwgM10uaW5kZXhfd2l0aCB7IHxlbHwgZm9vKGVsKSB9Ci0tLS0KCj09IFJhaWxzL0lucXVpcnkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuNwp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgQWN0aXZlIFN1cHBvcnQncyBgaW5xdWlyeWAgbWV0aG9kIGlzIG5vdCB1c2VkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSBTdHJpbmcjaW5xdWlyeQpydWJ5ID0gJ3R3bycuaW5xdWlyeQpydWJ5LnR3bz8KCiMgZ29vZApydWJ5ID0gJ3R3bycKcnVieSA9PSAndHdvJwoKIyBiYWQgLSBBcnJheSNpbnF1aXJ5CnBldHMgPSAldyhjYXQgZG9nKS5pbnF1aXJ5CnBldHMuZ29waGVyPwoKIyBnb29kCnBldHMgPSAldyhjYXQgZG9nKQpwZXRzLmluY2x1ZGU/ICdjYXQnCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNpbnF1aXJ5Cgo9PSBSYWlscy9JbnZlcnNlT2YKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNTIKfCAtCnw9PT0KCkxvb2tzIGZvciBoYXNfKG9uZXxtYW55KSBhbmQgYmVsb25nc190byBhc3NvY2lhdGlvbnMgd2hlcmUKQWN0aXZlIFJlY29yZCBjYW4ndCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgaW52ZXJzZSBhc3NvY2lhdGlvbgpiZWNhdXNlIG9mIGEgc2NvcGUgb3IgdGhlIG9wdGlvbnMgdXNlZC4gVXNpbmcgdGhlIGJsb2cgd2l0aCBvcmRlciBzY29wZQpleGFtcGxlIGJlbG93LCB0cmF2ZXJzaW5nIHRoZSBhIEJsb2cncyBhc3NvY2lhdGlvbiBpbiBib3RoIGRpcmVjdGlvbnMKd2l0aCBgYmxvZy5wb3N0cy5maXJzdC5ibG9nYCB3b3VsZCBjYXVzZSB0aGUgYGJsb2dgIHRvIGJlIGxvYWRlZCBmcm9tCnRoZSBkYXRhYmFzZSB0d2ljZS4KCmA6aW52ZXJzZV9vZmAgbXVzdCBiZSBtYW51YWxseSBzcGVjaWZpZWQgZm9yIEFjdGl2ZSBSZWNvcmQgdG8gdXNlIHRoZQphc3NvY2lhdGVkIG9iamVjdCBpbiBtZW1vcnksIG9yIHNldCB0byBgZmFsc2VgIHRvIG9wdC1vdXQuIE5vdGUgdGhhdApzZXR0aW5nIGBuaWxgIGRvZXMgbm90IHN0b3AgQWN0aXZlIFJlY29yZCBmcm9tIHRyeWluZyB0byBkZXRlcm1pbmUgdGhlCmludmVyc2UgYXV0b21hdGljYWxseSwgYW5kIGlzIG5vdCBjb25zaWRlcmVkIGEgdmFsaWQgdmFsdWUgZm9yIHRoaXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKY2xhc3MgQmxvZyA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOnBvc3RzCmVuZAoKY2xhc3MgUG9zdCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVsb25nc190byA6YmxvZwplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEJsb2cgPCBBcHBsaWNhdGlvblJlY29yZAogIGhhc19tYW55IDpwb3N0cywgLT4geyBvcmRlcihwdWJsaXNoZWRfYXQ6IDpkZXNjKSB9CmVuZAoKY2xhc3MgUG9zdCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgYmVsb25nc190byA6YmxvZwplbmQKCiMgZ29vZApjbGFzcyBCbG9nIDwgQXBwbGljYXRpb25SZWNvcmQKICBoYXNfbWFueSg6cG9zdHMsCiAgICAgICAgICAgLT4geyBvcmRlcihwdWJsaXNoZWRfYXQ6IDpkZXNjKSB9LAogICAgICAgICAgIGludmVyc2Vfb2Y6IDpibG9nKQplbmQKCmNsYXNzIFBvc3QgPCBBcHBsaWNhdGlvblJlY29yZAogIGJlbG9uZ3NfdG8gOmJsb2cKZW5kCgojIGdvb2QKY2xhc3MgQmxvZyA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgd2l0aF9vcHRpb25zIGludmVyc2Vfb2Y6IDpibG9nIGRvCiAgICBoYXNfbWFueSA6cG9zdHMsIC0+IHsgb3JkZXIocHVibGlzaGVkX2F0OiA6ZGVzYykgfQogIGVuZAplbmQKCmNsYXNzIFBvc3QgPCBBcHBsaWNhdGlvblJlY29yZAogIGJlbG9uZ3NfdG8gOmJsb2cKZW5kCgojIGdvb2QKIyBXaGVuIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgaW52ZXJzZSBhc3NvY2lhdGlvbi4KY2xhc3MgQmxvZyA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkoOnBvc3RzLAogICAgICAgICAgIC0+IHsgb3JkZXIocHVibGlzaGVkX2F0OiA6ZGVzYykgfSwKICAgICAgICAgICBpbnZlcnNlX29mOiBmYWxzZSkKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBQaWN0dXJlIDwgQXBwbGljYXRpb25SZWNvcmQKICBiZWxvbmdzX3RvIDppbWFnZWFibGUsIHBvbHltb3JwaGljOiB0cnVlCmVuZAoKY2xhc3MgRW1wbG95ZWUgPCBBcHBsaWNhdGlvblJlY29yZAogIGhhc19tYW55IDpwaWN0dXJlcywgYXM6IDppbWFnZWFibGUKZW5kCgpjbGFzcyBQcm9kdWN0IDwgQXBwbGljYXRpb25SZWNvcmQKICBoYXNfbWFueSA6cGljdHVyZXMsIGFzOiA6aW1hZ2VhYmxlCmVuZAoKIyBnb29kCmNsYXNzIFBpY3R1cmUgPCBBcHBsaWNhdGlvblJlY29yZAogIGJlbG9uZ3NfdG8gOmltYWdlYWJsZSwgcG9seW1vcnBoaWM6IHRydWUKZW5kCgpjbGFzcyBFbXBsb3llZSA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOnBpY3R1cmVzLCBhczogOmltYWdlYWJsZSwgaW52ZXJzZV9vZjogOmltYWdlYWJsZQplbmQKCmNsYXNzIFByb2R1Y3QgPCBBcHBsaWNhdGlvblJlY29yZAogIGhhc19tYW55IDpwaWN0dXJlcywgYXM6IDppbWFnZWFibGUsIGludmVyc2Vfb2Y6IDppbWFnZWFibGUKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAojIEhvd2V2ZXIsIFJ1Ym9Db3AgY2FuIG5vdCBkZXRlY3QgdGhpcyBwYXR0ZXJuLi4uCmNsYXNzIFBoeXNpY2lhbiA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOmFwcG9pbnRtZW50cwogIGhhc19tYW55IDpwYXRpZW50cywgdGhyb3VnaDogOmFwcG9pbnRtZW50cwplbmQKCmNsYXNzIEFwcG9pbnRtZW50IDwgQXBwbGljYXRpb25SZWNvcmQKICBiZWxvbmdzX3RvIDpwaHlzaWNpYW4KICBiZWxvbmdzX3RvIDpwYXRpZW50CmVuZAoKY2xhc3MgUGF0aWVudCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOmFwcG9pbnRtZW50cwogIGhhc19tYW55IDpwaHlzaWNpYW5zLCB0aHJvdWdoOiA6YXBwb2ludG1lbnRzCmVuZAoKIyBnb29kCmNsYXNzIFBoeXNpY2lhbiA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOmFwcG9pbnRtZW50cwogIGhhc19tYW55IDpwYXRpZW50cywgdGhyb3VnaDogOmFwcG9pbnRtZW50cwplbmQKCmNsYXNzIEFwcG9pbnRtZW50IDwgQXBwbGljYXRpb25SZWNvcmQKICBiZWxvbmdzX3RvIDpwaHlzaWNpYW4sIGludmVyc2Vfb2Y6IDphcHBvaW50bWVudHMKICBiZWxvbmdzX3RvIDpwYXRpZW50LCBpbnZlcnNlX29mOiA6YXBwb2ludG1lbnRzCmVuZAoKY2xhc3MgUGF0aWVudCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOmFwcG9pbnRtZW50cwogIGhhc19tYW55IDpwaHlzaWNpYW5zLCB0aHJvdWdoOiA6YXBwb2ludG1lbnRzCmVuZAotLS0tCgo9PT09IElnbm9yZVNjb3BlczogZmFsc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgQmxvZyA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgaGFzX21hbnkgOnBvc3RzLCAtPiB7IG9yZGVyKHB1Ymxpc2hlZF9hdDogOmRlc2MpIH0KZW5kCi0tLS0KCj09PT0gSWdub3JlU2NvcGVzOiB0cnVlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmNsYXNzIEJsb2cgPCBBcHBsaWNhdGlvblJlY29yZAogIGhhc19tYW55IDpwb3N0cywgLT4geyBvcmRlcihwdWJsaXNoZWRfYXQ6IDpkZXNjKSB9CmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSWdub3JlU2NvcGVzCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvYXNzb2NpYXRpb25fYmFzaWNzLmh0bWwjYmktZGlyZWN0aW9uYWwtYXNzb2NpYXRpb25zCiogaHR0cHM6Ly9hcGkucnVieW9ucmFpbHMub3JnL2NsYXNzZXMvQWN0aXZlUmVjb3JkL0Fzc29jaWF0aW9ucy9DbGFzc01ldGhvZHMuaHRtbCNtb2R1bGUtQWN0aXZlUmVjb3JkOjpBc3NvY2lhdGlvbnM6OkNsYXNzTWV0aG9kcy1sYWJlbC1TZXR0aW5nK0ludmVyc2VzCgo9PSBSYWlscy9MZXhpY2FsbHlTY29wZWRBY3Rpb25GaWx0ZXIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IE5vCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgbWV0aG9kcyBzcGVjaWZpZWQgaW4gdGhlIGZpbHRlcidzIGBvbmx5YCBvcgpgZXhjZXB0YCBvcHRpb25zIGFyZSBkZWZpbmVkIHdpdGhpbiB0aGUgc2FtZSBjbGFzcyBvciBtb2R1bGUuCgo9PT0gU2FmZXR5CgpZb3UgY2FuIHRlY2huaWNhbGx5IHNwZWNpZnkgbWV0aG9kcyBvZiBzdXBlcmNsYXNzIG9yIG1ldGhvZHMgYWRkZWQgYnkKbWl4aW5zIG9uIHRoZSBmaWx0ZXIsIGJ1dCB0aGVzZSBjYW4gY29uZnVzZSBkZXZlbG9wZXJzLiBJZiB5b3Ugc3BlY2lmeQptZXRob2RzIHRoYXQgYXJlIGRlZmluZWQgaW4gb3RoZXIgY2xhc3NlcyBvciBtb2R1bGVzLCB5b3Ugc2hvdWxkCmRlZmluZSB0aGUgZmlsdGVyIGluIHRoYXQgY2xhc3Mgb3IgbW9kdWxlLgoKSWYgeW91IHJlbHkgb24gYmVoYXZpb3IgZGVmaW5lZCBpbiB0aGUgc3VwZXJjbGFzcyBhY3Rpb25zLCB5b3UgbXVzdApyZW1lbWJlciB0byBpbnZva2UgYHN1cGVyYCBpbiB0aGUgc3ViY2xhc3MgYWN0aW9ucy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIExvZ2luQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIGJlZm9yZV9hY3Rpb24gOnJlcXVpcmVfbG9naW4sIG9ubHk6ICVpW2luZGV4IHNldHRpbmdzIGxvZ291dF0KCiAgZGVmIGluZGV4CiAgZW5kCmVuZAoKIyBnb29kCmNsYXNzIExvZ2luQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIGJlZm9yZV9hY3Rpb24gOnJlcXVpcmVfbG9naW4sIG9ubHk6ICVpW2luZGV4IHNldHRpbmdzIGxvZ291dF0KCiAgZGVmIGluZGV4CiAgZW5kCgogIGRlZiBzZXR0aW5ncwogIGVuZAoKICBkZWYgbG9nb3V0CiAgZW5kCmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbW9kdWxlIEZvb01peGluCiAgZXh0ZW5kIEFjdGl2ZVN1cHBvcnQ6OkNvbmNlcm4KCiAgaW5jbHVkZWQgZG8KICAgIGJlZm9yZV9hY3Rpb24gcHJvYyB7IGF1dGhlbnRpY2F0ZSB9LCBvbmx5OiA6Zm9vCiAgZW5kCmVuZAoKIyBnb29kCm1vZHVsZSBGb29NaXhpbgogIGV4dGVuZCBBY3RpdmVTdXBwb3J0OjpDb25jZXJuCgogIGluY2x1ZGVkIGRvCiAgICBiZWZvcmVfYWN0aW9uIHByb2MgeyBhdXRoZW50aWNhdGUgfSwgb25seTogOmZvbwogIGVuZAoKICBkZWYgZm9vCiAgICAjIHNvbWV0aGluZwogIGVuZAplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCmNsYXNzIENvbnRlbnRDb250cm9sbGVyIDwgQXBwbGljYXRpb25Db250cm9sbGVyCiAgZGVmIHVwZGF0ZQogICAgQGNvbnRlbnQudXBkYXRlKGNvbnRlbnRfYXR0cmlidXRlcykKICBlbmQKZW5kCgpjbGFzcyBBcnRpY2xlc0NvbnRyb2xsZXIgPCBDb250ZW50Q29udHJvbGxlcgogIGJlZm9yZV9hY3Rpb24gOmxvYWRfYXJ0aWNsZSwgb25seTogWzp1cGRhdGVdCgogICMgdGhlIGNvcCByZXF1aXJlcyB0aGlzIG1ldGhvZCwgYnV0IGl0IHJlbGllcyBvbiBiZWhhdmlvciBkZWZpbmVkCiAgIyBpbiB0aGUgc3VwZXJjbGFzcywgc28gbmVlZHMgdG8gaW52b2tlIGBzdXBlcmAKICBkZWYgdXBkYXRlCiAgICBzdXBlcgogIGVuZAoKICBwcml2YXRlCgogIGRlZiBsb2FkX2FydGljbGUKICAgIEBjb250ZW50ID0gQXJ0aWNsZS5maW5kKHBhcmFtc1s6YXJ0aWNsZV9pZF0pCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL2NvbnRyb2xsZXJzLyoqLyoucmIrYCwgYCthcHAvbWFpbGVycy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZSNsZXhpY2FsbHktc2NvcGVkLWFjdGlvbi1maWx0ZXIKCj09IFJhaWxzL0xpbmtUb0JsYW5rCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC42Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciBjYWxscyB0byBgbGlua190b2AgdGhhdCBjb250YWluIGEKYHRhcmdldDogJ19ibGFuaydgIGJ1dCBubyBgcmVsOiAnbm9vcGVuZXInYC4gVGhpcyBjYW4gYmUgYSBzZWN1cml0eQpyaXNrIGFzIHRoZSBsb2FkZWQgcGFnZSB3aWxsIGhhdmUgY29udHJvbCBvdmVyIHRoZSBwcmV2aW91cyBwYWdlCmFuZCBjb3VsZCBjaGFuZ2UgaXRzIGxvY2F0aW9uIGZvciBwaGlzaGluZyBwdXJwb3Nlcy4KClRoZSBvcHRpb24gYHJlbDogJ25vcmVmZXJyZXInYCBhbHNvIGJsb2NrcyB0aGlzIGJlaGF2aW9yCmFuZCByZW1vdmVzIHRoZSBodHRwLXJlZmVycmVyIGhlYWRlci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxpbmtfdG8gJ0NsaWNrIGhlcmUnLCB1cmwsIHRhcmdldDogJ19ibGFuaycKCiMgZ29vZApsaW5rX3RvICdDbGljayBoZXJlJywgdXJsLCB0YXJnZXQ6ICdfYmxhbmsnLCByZWw6ICdub29wZW5lcicKCiMgZ29vZApsaW5rX3RvICdDbGljayBoZXJlJywgdXJsLCB0YXJnZXQ6ICdfYmxhbmsnLCByZWw6ICdub3JlZmVycmVyJwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL21hdGhpYXNieW5lbnMuZ2l0aHViLmlvL3JlbC1ub29wZW5lci8KKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9saW5rcy5odG1sI2xpbmstdHlwZS1ub29wZW5lcgoqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2xpbmtzLmh0bWwjbGluay10eXBlLW5vcmVmZXJyZXIKCj09IFJhaWxzL01haWxlck5hbWUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjcKfCAtCnw9PT0KCkVuZm9yY2VzIHRoYXQgbWFpbGVyIG5hbWVzIGVuZCB3aXRoIGBNYWlsZXJgIHN1ZmZpeC4KCldpdGhvdXQgdGhlIGBNYWlsZXJgIHN1ZmZpeCBpdCBpc24ndCBpbW1lZGlhdGVseSBhcHBhcmVudCB3aGF0J3MgYSBtYWlsZXIKYW5kIHdoaWNoIHZpZXdzIGFyZSByZWxhdGVkIHRvIHRoZSBtYWlsZXIuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIHJlbmFtaW5nIGEgY29uc3RhbnQgaXMKYWx3YXlzIGFuIHVuc2FmZSBvcGVyYXRpb24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBVc2VyIDwgQWN0aW9uTWFpbGVyOjpCYXNlCmVuZAoKY2xhc3MgVXNlciA8IEFwcGxpY2F0aW9uTWFpbGVyCmVuZAoKIyBnb29kCmNsYXNzIFVzZXJNYWlsZXIgPCBBY3Rpb25NYWlsZXI6OkJhc2UKZW5kCgpjbGFzcyBVc2VyTWFpbGVyIDwgQXBwbGljYXRpb25NYWlsZXIKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbWFpbGVycy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZS8jbWFpbGVyLW5hbWUKCj09IFJhaWxzL01hdGNoUm91dGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjcKfCAtCnw9PT0KCklkZW50aWZpZXMgcGxhY2VzIHdoZXJlIGRlZmluaW5nIHJvdXRlcyB3aXRoIGBtYXRjaGAKY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBzcGVjaWZpYyBIVFRQIG1ldGhvZC4KCkRvbid0IHVzZSBgbWF0Y2hgIHRvIGRlZmluZSBhbnkgcm91dGVzIHVubGVzcyB0aGVyZSBpcyBhIG5lZWQgdG8gbWFwIG11bHRpcGxlIHJlcXVlc3QgdHlwZXMKYW1vbmcgWzpnZXQsIDpwb3N0LCA6cGF0Y2gsIDpwdXQsIDpkZWxldGVdIHRvIGEgc2luZ2xlIGFjdGlvbiB1c2luZyB0aGUgYDp2aWFgIG9wdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm1hdGNoICc6Y29udHJvbGxlci86YWN0aW9uLzppZCcKbWF0Y2ggJ3Bob3Rvcy86aWQnLCB0bzogJ3Bob3RvcyNzaG93JywgdmlhOiA6Z2V0CgojIGdvb2QKZ2V0ICc6Y29udHJvbGxlci86YWN0aW9uLzppZCcKZ2V0ICdwaG90b3MvOmlkJywgdG86ICdwaG90b3Mjc2hvdycKbWF0Y2ggJ3Bob3Rvcy86aWQnLCB0bzogJ3Bob3RvcyNzaG93JywgdmlhOiBbOmdldCwgOnBvc3RdCm1hdGNoICdwaG90b3MvOmlkJywgdG86ICdwaG90b3Mjc2hvdycsIHZpYTogOmFsbAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGBjb25maWcvcm91dGVzLnJiYCwgYCtjb25maWcvcm91dGVzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNuby1tYXRjaC1yb3V0ZXMKCj09IFJhaWxzL01pZ3JhdGlvbkNsYXNzTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTQKfCAyLjIwCnw9PT0KCk1ha2VzIHN1cmUgdGhhdCBlYWNoIG1pZ3JhdGlvbiBmaWxlIGRlZmluZXMgYSBtaWdyYXRpb24gY2xhc3MKd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSBmaWxlIG5hbWUuCihlLmcuIGAyMDIyMDIyNDExMTExMV9jcmVhdGVfdXNlcnMucmJgIHNob3VsZCBkZWZpbmUgYENyZWF0ZVVzZXJzYCBjbGFzcy4pCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGRiL21pZ3JhdGUvMjAyMjAyMjQxMTExMTFfY3JlYXRlX3VzZXJzLnJiCgojIGJhZApjbGFzcyBTZWxsQm9va3MgPCBBY3RpdmVSZWNvcmQ6Ok1pZ3JhdGlvbls3LjBdCmVuZAoKIyBnb29kCmNsYXNzIENyZWF0ZVVzZXJzIDwgQWN0aXZlUmVjb3JkOjpNaWdyYXRpb25bNy4wXQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2RiLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL05lZ2F0ZUluY2x1ZGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuNwp8IDIuOQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGBjb2xsZWN0aW9uLmV4Y2x1ZGU/KG9iailgCm92ZXIgYCFjb2xsZWN0aW9uLmluY2x1ZGU/KG9iailgLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgZmFsc2UgcG9zaXRpdmUgd2lsbCBvY2N1ciBmb3IKcmVjZWl2ZXIgb2JqZWN0cyB0aGF0IGRvIG5vdCBoYXZlIGFuIGBleGNsdWRlP2AgbWV0aG9kLiAoZS5nLiBgSVBBZGRyYCkKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCiFhcnJheS5pbmNsdWRlPygyKQohaGFzaC5pbmNsdWRlPyg6a2V5KQoKIyBnb29kCmFycmF5LmV4Y2x1ZGU/KDIpCmhhc2guZXhjbHVkZT8oOmtleSkKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjZXhjbHVkZQoKPT0gUmFpbHMvTm90TnVsbENvbHVtbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC40Mwp8IDIuMjAKfD09PQoKQ2hlY2tzIGZvciBhZGRfY29sdW1uIGNhbGxzIHdpdGggYSBOT1QgTlVMTCBjb25zdHJhaW50IHdpdGhvdXQgYSBkZWZhdWx0CnZhbHVlLgoKVGhpcyBjb3Agb25seSBhcHBsaWVzIHdoZW4gYWRkaW5nIGEgY29sdW1uIHRvIGFuIGV4aXN0aW5nIHRhYmxlLCBzaW5jZQpleGlzdGluZyByZWNvcmRzIHdpbGwgbm90IGhhdmUgYSB2YWx1ZSBmb3IgdGhlIG5ldyBjb2x1bW4uIE5ldyB0YWJsZXMKY2FuIGZyZWVseSB1c2UgTk9UIE5VTEwgY29sdW1ucyB3aXRob3V0IGRlZmF1bHRzLCBzaW5jZSB0aGVyZSBhcmUgbm8KcmVjb3JkcyB0aGF0IGNvdWxkIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQuCgpJZiB5b3UgbmVlZCB0byBhZGQgYSBOT1QgTlVMTCBjb2x1bW4gdG8gYW4gZXhpc3RpbmcgdGFibGUsIHlvdSBtdXN0IGFkZAppdCBhcyBudWxsYWJsZSBmaXJzdCwgYmFjay1maWxsIHRoZSBkYXRhLCBhbmQgdGhlbiB1c2UKYGNoYW5nZV9jb2x1bW5fbnVsbGAuIEFsdGVybmF0aXZlbHksIHlvdSBjb3VsZCBhZGQgdGhlIGNvbHVtbiB3aXRoIGEKZGVmYXVsdCBmaXJzdCB0byBoYXZlIHRoZSBkYXRhYmFzZSBhdXRvbWF0aWNhbGx5IGJhY2tmaWxsIGV4aXN0aW5nIHJvd3MsCmFuZCB0aGVuIHVzZSBgY2hhbmdlX2NvbHVtbl9kZWZhdWx0YCB0byByZW1vdmUgdGhlIGRlZmF1bHQuCgpgVEVYVGAgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlIGluIE15U1FMLgpUaGUgY29wIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYW4gYWRhcHRlciBmcm9tIGBkZXZlbG9wbWVudGAKZW52aXJvbm1lbnQgaW4gYGNvbmZpZy9kYXRhYmFzZS55bWxgIG9yIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZQpgREFUQUJBU0VfVVJMYCB3aGVuIHRoZSBgRGF0YWJhc2VgIG9wdGlvbiBpcyBub3Qgc2V0LiBJZiB0aGUgZGF0YWJhc2UKaXMgTXlTUUwsIHRoaXMgY29wIGlnbm9yZXMgb2ZmZW5zZXMgZm9yIGBURVhUYCBjb2x1bW5zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYWRkX2NvbHVtbiA6dXNlcnMsIDpuYW1lLCA6c3RyaW5nLCBudWxsOiBmYWxzZQphZGRfcmVmZXJlbmNlIDpwcm9kdWN0cywgOmNhdGVnb3J5LCBudWxsOiBmYWxzZQpjaGFuZ2VfdGFibGUgOnVzZXJzIGRvIHx0fAogIHQuc3RyaW5nIDpuYW1lLCBudWxsOiBmYWxzZQplbmQKCiMgZ29vZAphZGRfY29sdW1uIDp1c2VycywgOm5hbWUsIDpzdHJpbmcsIG51bGw6IHRydWUKYWRkX2NvbHVtbiA6dXNlcnMsIDpuYW1lLCA6c3RyaW5nLCBudWxsOiBmYWxzZSwgZGVmYXVsdDogJycKY2hhbmdlX3RhYmxlIDp1c2VycyBkbyB8dHwKICB0LnN0cmluZyA6bmFtZSwgbnVsbDogZmFsc2UsIGRlZmF1bHQ6ICcnCmVuZAphZGRfcmVmZXJlbmNlIDpwcm9kdWN0cywgOmNhdGVnb3J5CmNoYW5nZV9jb2x1bW5fbnVsbCA6cHJvZHVjdHMsIDpjYXRlZ29yeV9pZCwgZmFsc2UKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IERhdGFiYXNlCnwgYDxub25lPmAKfCBgbXlzcWxgCgp8IEluY2x1ZGUKfCBgK2RiLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL09yZGVyQnlJZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDIuOAp8IC0KfD09PQoKQ2hlY2tzIGZvciBwbGFjZXMgd2hlcmUgb3JkZXJpbmcgYnkgYGlkYCBjb2x1bW4gaXMgdXNlZC4KCkRvbid0IHVzZSB0aGUgYGlkYCBjb2x1bW4gZm9yIG9yZGVyaW5nLiBUaGUgc2VxdWVuY2Ugb2YgaWRzIGlzIG5vdCBndWFyYW50ZWVkCnRvIGJlIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyLCBkZXNwaXRlIG9mdGVuIChpbmNpZGVudGFsbHkpIGJlaW5nIGNocm9ub2xvZ2ljYWwuClVzZSBhIHRpbWVzdGFtcCBjb2x1bW4gdG8gb3JkZXIgY2hyb25vbG9naWNhbGx5LiBBcyBhIGJvbnVzIHRoZSBpbnRlbnQgaXMgY2xlYXJlci4KCk5PVEU6IE1ha2Ugc3VyZSB0aGUgY2hhbmdlZCBvcmRlciBjb2x1bW4gZG9lcyBub3QgaW50cm9kdWNlIHBlcmZvcm1hbmNlCmJvdHRsZW5lY2tzIGFuZCBhcHByb3ByaWF0ZSBkYXRhYmFzZSBpbmRleGVzIGFyZSBhZGRlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnNjb3BlIDpjaHJvbm9sb2dpY2FsLCAtPiB7IG9yZGVyKGlkOiA6YXNjKSB9CnNjb3BlIDpjaHJvbm9sb2dpY2FsLCAtPiB7IG9yZGVyKHByaW1hcnlfa2V5ID0+IDphc2MpIH0KCiMgZ29vZApzY29wZSA6Y2hyb25vbG9naWNhbCwgLT4geyBvcmRlcihjcmVhdGVkX2F0OiA6YXNjKSB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNvcmRlci1ieS1pZAoKPT0gUmFpbHMvT3V0cHV0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4xNQp8IDAuMTkKfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIG91dHB1dCBjYWxscyBsaWtlIHB1dHMgYW5kIHByaW50Cgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGRlcGVuZGluZyBvbiB0aGUgUmFpbHMgbG9nIGxldmVsIGNvbmZpZ3VyYXRpb24sCmNoYW5naW5nIGZyb20gYHB1dHNgIHRvIGBSYWlscy5sb2dnZXIuZGVidWdgIGNvdWxkIHJlc3VsdCBpbiBubyBvdXRwdXQgYmVpbmcgc2hvd24uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApwdXRzICdBIGRlYnVnIG1lc3NhZ2UnCnBwICdBIGRlYnVnIG1lc3NhZ2UnCnByaW50ICdBIGRlYnVnIG1lc3NhZ2UnCgojIGdvb2QKUmFpbHMubG9nZ2VyLmRlYnVnICdBIGRlYnVnIG1lc3NhZ2UnCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvKiovKi5yYitgLCBgK2NvbmZpZy8qKi8qLnJiK2AsIGArZGIvKiovKi5yYitgLCBgK2xpYi8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9PdXRwdXRTYWZldHkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNDEKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdGhlIHVzZSBvZiBvdXRwdXQgc2FmZXR5IGNhbGxzIGxpa2UgYGh0bWxfc2FmZWAsCmByYXdgLCBhbmQgYHNhZmVfY29uY2F0YC4gVGhlc2UgbWV0aG9kcyBkbyBub3QgZXNjYXBlIGNvbnRlbnQuIFRoZXkKc2ltcGx5IHJldHVybiBhIFNhZmVCdWZmZXIgY29udGFpbmluZyB0aGUgY29udGVudCBhcyBpcy4gSW5zdGVhZCwKdXNlIGBzYWZlX2pvaW5gIHRvIGpvaW4gY29udGVudCBhbmQgZXNjYXBlIGl0IGFuZCBjb25jYXQgdG8KY29uY2F0ZW5hdGUgY29udGVudCBhbmQgZXNjYXBlIGl0LCBlbnN1cmluZyBpdHMgc2FmZXR5LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KdXNlcl9jb250ZW50ID0gIjxiPmhpPC9iPiIKCiMgYmFkCiI8cD4je3VzZXJfY29udGVudH08L3A+Ii5odG1sX3NhZmUKIyA9PiBBY3RpdmVTdXBwb3J0OjpTYWZlQnVmZmVyICI8cD48Yj5oaTwvYj48L3A+IgoKIyBnb29kCmNvbnRlbnRfdGFnKDpwLCB1c2VyX2NvbnRlbnQpCiMgPT4gQWN0aXZlU3VwcG9ydDo6U2FmZUJ1ZmZlciAiPHA+Jmx0O2ImZ3Q7aGkmbHQ7L2ImZ3Q7PC9wPiIKCiMgYmFkCm91dCA9ICIiCm91dCA8PCAiPGxpPiN7dXNlcl9jb250ZW50fTwvbGk+IgpvdXQgPDwgIjxsaT4je3VzZXJfY29udGVudH08L2xpPiIKb3V0Lmh0bWxfc2FmZQojID0+IEFjdGl2ZVN1cHBvcnQ6OlNhZmVCdWZmZXIgIjxsaT48Yj5oaTwvYj48L2xpPjxsaT48Yj5oaTwvYj48L2xpPiIKCiMgZ29vZApvdXQgPSBbXQpvdXQgPDwgY29udGVudF90YWcoOmxpLCB1c2VyX2NvbnRlbnQpCm91dCA8PCBjb250ZW50X3RhZyg6bGksIHVzZXJfY29udGVudCkKc2FmZV9qb2luKG91dCkKIyA9PiBBY3RpdmVTdXBwb3J0OjpTYWZlQnVmZmVyCiMgICAgIjxsaT4mbHQ7YiZndDtoaSZsdDsvYiZndDs8L2xpPjxsaT4mbHQ7YiZndDtoaSZsdDsvYiZndDs8L2xpPiIKCiMgYmFkCm91dCA9ICI8aDE+dHJ1c3RlZCBjb250ZW50PC9oMT4iLmh0bWxfc2FmZQpvdXQuc2FmZV9jb25jYXQodXNlcl9jb250ZW50KQojID0+IEFjdGl2ZVN1cHBvcnQ6OlNhZmVCdWZmZXIgIjxoMT50cnVzdGVkX2NvbnRlbnQ8L2gxPjxiPmhpPC9iPiIKCiMgZ29vZApvdXQgPSAiPGgxPnRydXN0ZWQgY29udGVudDwvaDE+Ii5odG1sX3NhZmUKb3V0LmNvbmNhdCh1c2VyX2NvbnRlbnQpCiMgPT4gQWN0aXZlU3VwcG9ydDo6U2FmZUJ1ZmZlcgojICAgICI8aDE+dHJ1c3RlZF9jb250ZW50PC9oMT4mbHQ7YiZndDtoaSZsdDsvYiZndDsiCgojIHNhZmUsIHRob3VnaCBtYXliZSBub3QgZ29vZCBzdHlsZQpvdXQgPSAidHJ1c3RlZCBjb250ZW50IgpyZXN1bHQgPSBvdXQuY29uY2F0KHVzZXJfY29udGVudCkKIyA9PiBTdHJpbmcgInRydXN0ZWQgY29udGVudDxiPmhpPC9iPiIKIyBiZWNhdXNlIHdoZW4gcmVuZGVyZWQgaW4gRVJCIHRoZSBTdHJpbmcgd2lsbCBiZSBlc2NhcGVkOgojIDwlPSByZXN1bHQgJT4KIyA9PiB0cnVzdGVkIGNvbnRlbnQmbHQ7YiZndDtoaSZsdDsvYiZndDsKCiMgYmFkCih1c2VyX2NvbnRlbnQgKyAiICIgKyBjb250ZW50X3RhZyg6c3BhbiwgdXNlcl9jb250ZW50KSkuaHRtbF9zYWZlCiMgPT4gQWN0aXZlU3VwcG9ydDo6U2FmZUJ1ZmZlciAiPGI+aGk8L2I+IDxzcGFuPjxiPmhpPC9iPjwvc3Bhbj4iCgojIGdvb2QKc2FmZV9qb2luKFt1c2VyX2NvbnRlbnQsICIgIiwgY29udGVudF90YWcoOnNwYW4sIHVzZXJfY29udGVudCldKQojID0+IEFjdGl2ZVN1cHBvcnQ6OlNhZmVCdWZmZXIKIyAgICAiJmx0O2ImZ3Q7aGkmbHQ7L2ImZ3Q7IDxzcGFuPiZsdDtiJmd0O2hpJmx0Oy9iJmd0Ozwvc3Bhbj4iCi0tLS0KCj09IFJhaWxzL1BpY2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuNgp8IC0KfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBgcGlja2Agb3ZlciBgcGx1Y2soLi4uKS5maXJzdGAuCgpVc2luZyBgcGx1Y2tgIGZvbGxvd2VkIGJ5IGBmaXJzdGAgY3JlYXRlcyBhbiBpbnRlcm1lZGlhdGUgYXJyYXksIHdoaWNoCmBwaWNrYCBhdm9pZHMuIFdoZW4gY2FsbGVkIG9uIGFuIEFjdGl2ZSBSZWNvcmQgcmVsYXRpb24sIGBwaWNrYCBhZGRzIGEKbGltaXQgdG8gdGhlIHF1ZXJ5IHNvIHRoYXQgb25seSBvbmUgdmFsdWUgaXMgZmV0Y2hlZCBmcm9tIHRoZSBkYXRhYmFzZS4KCk5vdGUgdGhhdCB3aGVuIGBwaWNrYCBpcyBhZGRlZCB0byBhIHJlbGF0aW9uIHdpdGggYW4gZXhpc3RpbmcgbGltaXQsIGl0CmNhdXNlcyBhIHN1YnF1ZXJ5IHRvIGJlIGFkZGVkLiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgdW5kZXNpcmFibGUsIGFuZApjYXJlIHNob3VsZCBiZSB0YWtlbiB3aGlsZSByZXNvbHZpbmcgdGhpcyB2aW9sYXRpb24uCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBgcGx1Y2tgIGlzIGRlZmluZWQgb24gYm90aCBgQWN0aXZlUmVjb3JkOjpSZWxhdGlvbmAgYW5kIGBFbnVtZXJhYmxlYCwKd2hlcmVhcyBgcGlja2AgaXMgb25seSBkZWZpbmVkIG9uIGBBY3RpdmVSZWNvcmQ6OlJlbGF0aW9uYCBpbiBSYWlscyA2LjAuIFRoaXMgd2FzIGFkZHJlc3NlZAppbiBSYWlscyA2LjEgdmlhIHJhaWxzL3JhaWxzIzM4NzYwLCBhdCB3aGljaCBwb2ludCB0aGUgY29wIGlzIHNhZmUuCgpTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ydWJvY29wL3J1Ym9jb3AtcmFpbHMvcHVsbC8yNDkKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCk1vZGVsLnBsdWNrKDphKS5maXJzdApbeyBhOiA6YiwgYzogOmQgfV0ucGx1Y2soOmEsIDpiKS5maXJzdAoKIyBnb29kCk1vZGVsLnBpY2soOmEpClt7IGE6IDpiLCBjOiA6ZCB9XS5waWNrKDphLCA6YikKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjcGljawoKPT0gUmFpbHMvUGx1Y2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuNwp8IDIuMTgKfD09PQoKRW5mb3JjZXMgdGhlIHVzZSBvZiBgcGx1Y2tgIG92ZXIgYG1hcGAuCgpgcGx1Y2tgIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgYG1hcGAgdG8gZXh0cmFjdCBhIHNpbmdsZSBrZXkgZnJvbSBlYWNoCmVsZW1lbnQgaW4gYW4gZW51bWVyYWJsZS4gV2hlbiBjYWxsZWQgb24gYW4gQWN0aXZlIFJlY29yZCByZWxhdGlvbiwgaXQKcmVzdWx0cyBpbiBhIG1vcmUgZWZmaWNpZW50IHF1ZXJ5IHRoYXQgb25seSBzZWxlY3RzIHRoZSBuZWNlc3Nhcnkga2V5LgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgbW9kZWwgY2FuIHVzZSBjb2x1bW4gYWxpYXNlcy4KCltzb3VyY2UscnVieV0KLS0tLQojIE9yaWdpbmFsIGNvZGUKVXNlci5zZWxlY3QoJ25hbWUgQVMgbmlja25hbWUnKS5tYXAgeyB8dXNlcnwgdXNlcls6bmlja25hbWVdIH0gIyA9PiBhcnJheSBvZiBuaWNrbmFtZXMKCiMgQWZ0ZXIgYXV0b2NvcnJlY3Rpb24KVXNlci5zZWxlY3QoJ25hbWUgQVMgbmlja25hbWUnKS5wbHVjayg6bmlja25hbWUpICMgPT4gcmFpc2VzIEFjdGl2ZVJlY29yZDo6U3RhdGVtZW50SW52YWxpZAotLS0tCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApQb3N0LnB1Ymxpc2hlZC5tYXAgeyB8cG9zdHwgcG9zdFs6dGl0bGVdIH0KW3sgYTogOmIsIGM6IDpkIH1dLmNvbGxlY3QgeyB8ZWx8IGVsWzphXSB9CgojIGdvb2QKUG9zdC5wdWJsaXNoZWQucGx1Y2soOnRpdGxlKQpbeyBhOiA6YiwgYzogOmQgfV0ucGx1Y2soOmEpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlI3BsdWNrCgo9PSBSYWlscy9QbHVja0lkCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMi43CnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIGBpZHNgIG92ZXIgYHBsdWNrKDppZClgIGFuZCBgcGx1Y2socHJpbWFyeV9rZXkpYC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBpZiB0aGUgcmVjZWl2ZXIgb2JqZWN0IGlzIG5vdCBhbiBBY3RpdmUgUmVjb3JkIG9iamVjdC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClVzZXIucGx1Y2soOmlkKQp1c2VyLnBvc3RzLnBsdWNrKDppZCkKCmRlZiBzZWxmLnVzZXJfaWRzCiAgcGx1Y2socHJpbWFyeV9rZXkpCmVuZAoKIyBnb29kClVzZXIuaWRzCnVzZXIucG9zdHMuaWRzCgpkZWYgc2VsZi51c2VyX2lkcwogIGlkcwplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2lkcwoKPT0gUmFpbHMvUGx1Y2tJbldoZXJlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAyLjcKfCAyLjgKfD09PQoKSWRlbnRpZmllcyBwbGFjZXMgd2hlcmUgYHBsdWNrYCBpcyB1c2VkIGluIGB3aGVyZWAgcXVlcnkgbWV0aG9kcwphbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYHNlbGVjdGAuCgpTaW5jZSBgcGx1Y2tgIGlzIGFuIGVhZ2VyIG1ldGhvZCBhbmQgaGl0cyB0aGUgZGF0YWJhc2UgaW1tZWRpYXRlbHksCnVzaW5nIGBzZWxlY3RgIGhlbHBzIHRvIGF2b2lkIGFkZGl0aW9uYWwgZGF0YWJhc2UgcXVlcmllcy4KClRoaXMgY29wIGhhcyB0d28gZGlmZmVyZW50IGVuZm9yY2VtZW50IG1vZGVzLiBXaGVuIHRoZSBgRW5mb3JjZWRTdHlsZWAKaXMgYGNvbnNlcnZhdGl2ZWAgKHRoZSBkZWZhdWx0KSB0aGVuIG9ubHkgY2FsbHMgdG8gYHBsdWNrYCBvbiBhIGNvbnN0YW50CihpLmUuIGEgbW9kZWwgY2xhc3MpIGluIHRoZSBgd2hlcmVgIGlzIHVzZWQgYXMgb2ZmZW5zZXMuCgo9PT0gU2FmZXR5CgpXaGVuIHRoZSBgRW5mb3JjZWRTdHlsZWAgaXMgYGFnZ3Jlc3NpdmVgIHRoZW4gYWxsIGNhbGxzIHRvIGBwbHVja2AgaW4gdGhlCmB3aGVyZWAgaXMgdXNlZCBhcyBvZmZlbnNlcy4gVGhpcyBtYXkgbGVhZCB0byBmYWxzZSBwb3NpdGl2ZXMKYXMgdGhlIGNvcCBjYW5ub3QgcmVwbGFjZSB0byBgc2VsZWN0YCBiZXR3ZWVuIGNhbGxzIHRvIGBwbHVja2Agb24gYW4KYEFjdGl2ZVJlY29yZDo6UmVsYXRpb25gIGluc3RhbmNlIHZzIGEgY2FsbCB0byBgcGx1Y2tgIG9uIGFuIGBBcnJheWAgaW5zdGFuY2UuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApQb3N0LndoZXJlKHVzZXJfaWQ6IFVzZXIuYWN0aXZlLnBsdWNrKDppZCkpClBvc3Qud2hlcmUodXNlcl9pZDogVXNlci5hY3RpdmUuaWRzKQpQb3N0LndoZXJlLm5vdCh1c2VyX2lkOiBVc2VyLmFjdGl2ZS5wbHVjayg6aWQpKQoKIyBnb29kClBvc3Qud2hlcmUodXNlcl9pZDogVXNlci5hY3RpdmUuc2VsZWN0KDppZCkpClBvc3Qud2hlcmUodXNlcl9pZDogYWN0aXZlX3VzZXJzLnNlbGVjdCg6aWQpKQpQb3N0LndoZXJlLm5vdCh1c2VyX2lkOiBhY3RpdmVfdXNlcnMuc2VsZWN0KDppZCkpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY29uc2VydmF0aXZlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApQb3N0LndoZXJlKHVzZXJfaWQ6IGFjdGl2ZV91c2Vycy5wbHVjayg6aWQpKQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFnZ3Jlc3NpdmUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApQb3N0LndoZXJlKHVzZXJfaWQ6IGFjdGl2ZV91c2Vycy5wbHVjayg6aWQpKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBjb25zZXJ2YXRpdmVgCnwgYGNvbnNlcnZhdGl2ZWAsIGBhZ2dyZXNzaXZlYAp8PT09Cgo9PSBSYWlscy9QbHVyYWxpemF0aW9uR3JhbW1hcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMzUKfCAtCnw9PT0KCkNoZWNrcyBmb3IgY29ycmVjdCBncmFtbWFyIHdoZW4gdXNpbmcgQWN0aXZlU3VwcG9ydCdzCmNvcmUgZXh0ZW5zaW9ucyB0byB0aGUgbnVtZXJpYyBjbGFzc2VzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKMy5kYXkuYWdvCjEubW9udGhzLmFnbwoKIyBnb29kCjMuZGF5cy5hZ28KMS5tb250aC5hZ28KLS0tLQoKPT0gUmFpbHMvUHJlc2VuY2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjUyCnwgLQp8PT09CgpDaGVja3MgY29kZSB0aGF0IGNhbiBiZSB3cml0dGVuIG1vcmUgZWFzaWx5IHVzaW5nCmBPYmplY3QjcHJlc2VuY2VgIGRlZmluZWQgYnkgQWN0aXZlIFN1cHBvcnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphLnByZXNlbnQ/ID8gYSA6IG5pbAoKIyBiYWQKIWEucHJlc2VudD8gPyBuaWwgOiBhCgojIGJhZAphLmJsYW5rPyA/IG5pbCA6IGEKCiMgYmFkCiFhLmJsYW5rPyA/IGEgOiBuaWwKCiMgZ29vZAphLnByZXNlbmNlCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphLnByZXNlbnQ/ID8gYSA6IGIKCiMgYmFkCiFhLnByZXNlbnQ/ID8gYiA6IGEKCiMgYmFkCmEuYmxhbms/ID8gYiA6IGEKCiMgYmFkCiFhLmJsYW5rPyA/IGEgOiBiCgojIGdvb2QKYS5wcmVzZW5jZSB8fCBiCi0tLS0KCj09IFJhaWxzL1ByZXNlbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQ4CnwgMC42Nwp8PT09CgpDaGVja3MgZm9yIGNvZGUgdGhhdCBjYW4gYmUgd3JpdHRlbiB3aXRoIHNpbXBsZXIgY29uZGl0aW9uYWxzCnVzaW5nIGBPYmplY3QjcHJlc2VudD9gIGRlZmluZWQgYnkgQWN0aXZlIFN1cHBvcnQuCgpJbnRlcmFjdGlvbiB3aXRoIGBTdHlsZS9Vbmxlc3NFbHNlYDoKVGhlIGNvbmZpZ3VyYXRpb24gb2YgYE5vdEJsYW5rYCB3aWxsIG5vdCBwcm9kdWNlIGFuIG9mZmVuc2UgaW4gdGhlCmNvbnRleHQgb2YgYHVubGVzcyBlbHNlYCBpZiBgU3R5bGUvVW5sZXNzRWxzZWAgaXMgZW5hYmxlZC4gVGhpcyBpcwp0byBwcmV2ZW50IGludGVyZmVyZW5jZSBiZXR3ZWVuIHRoZSBhdXRvY29ycmVjdGlvbiBvZiB0aGUgdHdvIGNvcHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gTm90TmlsQW5kTm90RW1wdHk6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBDb252ZXJ0cyB1c2FnZXMgb2YgYCFuaWw/ICYmICFlbXB0eT9gIHRvIGBwcmVzZW50P2AKCiMgYmFkCiFmb28ubmlsPyAmJiAhZm9vLmVtcHR5PwoKIyBiYWQKZm9vICE9IG5pbCAmJiAhZm9vLmVtcHR5PwoKIyBnb29kCmZvby5wcmVzZW50PwotLS0tCgo9PT09IE5vdEJsYW5rOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgQ29udmVydHMgdXNhZ2VzIG9mIGAhYmxhbms/YCB0byBgcHJlc2VudD9gCgojIGJhZAohZm9vLmJsYW5rPwoKIyBiYWQKbm90IGZvby5ibGFuaz8KCiMgZ29vZApmb28ucHJlc2VudD8KLS0tLQoKPT09PSBVbmxlc3NCbGFuazogdHJ1ZSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIENvbnZlcnRzIHVzYWdlcyBvZiBgdW5sZXNzIGJsYW5rP2AgdG8gYGlmIHByZXNlbnQ/YAoKIyBiYWQKc29tZXRoaW5nIHVubGVzcyBmb28uYmxhbms/CgojIGdvb2QKc29tZXRoaW5nIGlmIGZvby5wcmVzZW50PwotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTm90TmlsQW5kTm90RW1wdHkKfCBgdHJ1ZWAKfCBCb29sZWFuCgp8IE5vdEJsYW5rCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBVbmxlc3NCbGFuawp8IGB0cnVlYAp8IEJvb2xlYW4KfD09PQoKPT0gUmFpbHMvUmFrZUVudmlyb25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAyLjQKfCAyLjYKfD09PQoKQ2hlY2tzIGZvciBSYWtlIHRhc2tzIHdpdGhvdXQgdGhlIGA6ZW52aXJvbm1lbnRgIHRhc2sKZGVwZW5kZW5jeS4gVGhlIGA6ZW52aXJvbm1lbnRgIHRhc2sgbG9hZHMgYXBwbGljYXRpb24gY29kZSBmb3Igb3RoZXIKUmFrZSB0YXNrcy4gV2l0aG91dCBpdCwgdGFza3MgY2Fubm90IG1ha2UgdXNlIG9mIGFwcGxpY2F0aW9uIGNvZGUgbGlrZQptb2RlbHMuCgpZb3UgY2FuIGlnbm9yZSB0aGUgb2ZmZW5zZSBpZiB0aGUgdGFzayBzYXRpc2ZpZXMgYXQgbGVhc3Qgb25lIG9mIHRoZQpmb2xsb3dpbmcgY29uZGl0aW9uczoKCiogVGhlIHRhc2sgZG9lcyBub3QgbmVlZCBhcHBsaWNhdGlvbiBjb2RlLgoqIFRoZSB0YXNrIGludm9rZXMgdGhlIGA6ZW52aXJvbm1lbnRgIHRhc2suCgo9PT0gU2FmZXR5CgpQcm9iYWJseSBub3QgYSBwcm9ibGVtIGluIG1vc3QgY2FzZXMsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0aGF0IGNhbGxpbmcgYDplbnZpcm9ubWVudGAgdGFzawp3aWxsIGJyZWFrIGEgYmVoYXZpb3IuIEl0J3MgYWxzbyBzbG93ZXIuIEUuZy4gc29tZSB0YXNrIHRoYXQgb25seSBuZWVkcyBvbmUgZ2VtIHRvIGJlCmxvYWRlZCB0byBydW4gd2lsbCBydW4gc2lnbmlmaWNhbnRseSBmYXN0ZXIgd2l0aG91dCBsb2FkaW5nIHRoZSB3aG9sZSBhcHBsaWNhdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnRhc2sgOmZvbyBkbwogIGRvX3NvbWV0aGluZwplbmQKCiMgZ29vZAp0YXNrIGZvbzogOmVudmlyb25tZW50IGRvCiAgZG9fc29tZXRoaW5nCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArKiovUmFrZWZpbGUrYCwgYCsqKi8qLnJha2UrYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgK2xpYi9jYXBpc3RyYW5vL3Rhc2tzLyoqLyoucmFrZStgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvUmVhZFdyaXRlQXR0cmlidXRlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC4yMAp8IDAuMjkKfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIHRoZSBgcmVhZF9hdHRyaWJ1dGVgIG9yIGB3cml0ZV9hdHRyaWJ1dGVgCm1ldGhvZHMgYW5kIHJlY29tbWVuZHMgc3F1YXJlIGJyYWNrZXRzIGluc3RlYWQuCgpJZiBhbiBhdHRyaWJ1dGUgaXMgbWlzc2luZyBmcm9tIHRoZSBpbnN0YW5jZSAoZm9yIGV4YW1wbGUsIHdoZW4KaW5pdGlhbGl6ZWQgYnkgYSBwYXJ0aWFsIGBzZWxlY3RgKSB0aGVuIGByZWFkX2F0dHJpYnV0ZWAKd2lsbCByZXR1cm4gbmlsLCBidXQgc3F1YXJlIGJyYWNrZXRzIHdpbGwgcmFpc2UKYW4gYEFjdGl2ZU1vZGVsOjpNaXNzaW5nQXR0cmlidXRlRXJyb3JgLgoKRXhwbGljaXRseSByYWlzaW5nIGFuIGVycm9yIGluIHRoaXMgc2l0dWF0aW9uIGlzIHByZWZlcmFibGUsIGFuZCB0aGF0CmlzIHdoeSBydWJvY29wIHJlY29tbWVuZHMgdXNpbmcgc3F1YXJlIGJyYWNrZXRzLgoKV2hlbiBjYWxsZWQgZnJvbSB3aXRoaW4gYSBtZXRob2Qgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBhdHRyaWJ1dGUsCmByZWFkX2F0dHJpYnV0ZWAgYW5kIGB3cml0ZV9hdHRyaWJ1dGVgIG11c3QgYmUgdXNlZCB0byBwcmV2ZW50IGFuCmluZmluaXRlIGxvb3A6Cgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp4ID0gcmVhZF9hdHRyaWJ1dGUoOmF0dHIpCndyaXRlX2F0dHJpYnV0ZSg6YXR0ciwgdmFsKQoKIyBnb29kCnggPSBzZWxmWzphdHRyXQpzZWxmWzphdHRyXSA9IHZhbAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmRlZiBmb28KICBiYXIgfHwgcmVhZF9hdHRyaWJ1dGUoOmZvbykKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbW9kZWxzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlI3JlYWQtYXR0cmlidXRlCgo9PSBSYWlscy9SZWR1bmRhbnRBY3RpdmVSZWNvcmRBbGxNZXRob2QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuMjEKfCAtCnw9PT0KCkRldGVjdCByZWR1bmRhbnQgYGFsbGAgdXNlZCBhcyBhIHJlY2VpdmVyIGZvciBBY3RpdmUgUmVjb3JkIHF1ZXJ5IG1ldGhvZHMuCgpGb3IgdGhlIG1ldGhvZHMgYGRlbGV0ZV9hbGxgIGFuZCBgZGVzdHJveV9hbGxgLCB0aGlzIGNvcCB3aWxsIG9ubHkgY2hlY2sgY2FzZXMgd2hlcmUgdGhlIHJlY2VpdmVyIGlzIGEgbW9kZWwuCkl0IHdpbGwgaWdub3JlIGNhc2VzIHdoZXJlIHRoZSByZWNlaXZlciBpcyBhbiBhc3NvY2lhdGlvbiAoZS5nLiwgYHVzZXIuYXJ0aWNsZXMuYWxsLmRlbGV0ZV9hbGxgKS4KVGhpcyBpcyBiZWNhdXNlIG9taXR0aW5nIGBhbGxgIGZyb20gYW4gYXNzb2NpYXRpb24gY2hhbmdlcyB0aGUgbWV0aG9kcwpmcm9tIGBBY3RpdmVSZWNvcmQ6OlJlbGF0aW9uYCB0byBgQWN0aXZlUmVjb3JkOjpBc3NvY2lhdGlvbnM6OkNvbGxlY3Rpb25Qcm94eWAsCndoaWNoIGNhbiBhZmZlY3QgdGhlaXIgYmVoYXZpb3IuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgZm9yIGF1dG9jb3JyZWN0aW9uIGlmIHRoZSByZWNlaXZlciBmb3IgYGFsbGAgaXMgbm90IGFuIEFjdGl2ZSBSZWNvcmQgb2JqZWN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVXNlci5hbGwuZmluZChpZCkKVXNlci5hbGwub3JkZXIoOmNyZWF0ZWRfYXQpCnVzZXJzLmFsbC53aGVyZShpZDogaWRzKQp1c2VyLmFydGljbGVzLmFsbC5vcmRlcig6Y3JlYXRlZF9hdCkKCiMgZ29vZApVc2VyLmZpbmQoaWQpClVzZXIub3JkZXIoOmNyZWF0ZWRfYXQpCnVzZXJzLndoZXJlKGlkOiBpZHMpCnVzZXIuYXJ0aWNsZXMub3JkZXIoOmNyZWF0ZWRfYXQpCi0tLS0KCj09PT0gQWxsb3dlZFJlY2VpdmVyczogWydBY3Rpb25NYWlsZXI6OlByZXZpZXcnLCAnQWN0aXZlU3VwcG9ydDo6VGltZVpvbmUnXSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKQWN0aW9uTWFpbGVyOjpQcmV2aWV3LmFsbC5maXJzdApBY3RpdmVTdXBwb3J0OjpUaW1lWm9uZS5hbGwuZmlyc3QKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93ZWRSZWNlaXZlcnMKfCBgQWN0aW9uTWFpbGVyOjpQcmV2aWV3YCwgYEFjdGl2ZVN1cHBvcnQ6OlRpbWVab25lYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNyZWR1bmRhbnQtYWxsCgo9PSBSYWlscy9SZWR1bmRhbnRBbGxvd05pbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuNjcKfCAtCnw9PT0KCkNoZWNrcyBSYWlscyBtb2RlbCB2YWxpZGF0aW9ucyBmb3IgYSByZWR1bmRhbnQgYGFsbG93X25pbGAgd2hlbgpgYWxsb3dfYmxhbmtgIGlzIHByZXNlbnQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp2YWxpZGF0ZXMgOngsIGxlbmd0aDogeyBpczogNSB9LCBhbGxvd19uaWw6IHRydWUsIGFsbG93X2JsYW5rOiB0cnVlCgojIGJhZAp2YWxpZGF0ZXMgOngsIGxlbmd0aDogeyBpczogNSB9LCBhbGxvd19uaWw6IGZhbHNlLCBhbGxvd19ibGFuazogdHJ1ZQoKIyBiYWQKdmFsaWRhdGVzIDp4LCBsZW5ndGg6IHsgaXM6IDUgfSwgYWxsb3dfbmlsOiBmYWxzZSwgYWxsb3dfYmxhbms6IGZhbHNlCgojIGdvb2QKdmFsaWRhdGVzIDp4LCBsZW5ndGg6IHsgaXM6IDUgfSwgYWxsb3dfYmxhbms6IHRydWUKCiMgZ29vZAp2YWxpZGF0ZXMgOngsIGxlbmd0aDogeyBpczogNSB9LCBhbGxvd19ibGFuazogZmFsc2UKCiMgZ29vZAojIEhlcmUsIGBuaWxgIGlzIHZhbGlkIGJ1dCBgJydgIGlzIG5vdAp2YWxpZGF0ZXMgOngsIGxlbmd0aDogeyBpczogNSB9LCBhbGxvd19uaWw6IHRydWUsIGFsbG93X2JsYW5rOiBmYWxzZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9SZWR1bmRhbnRGb3JlaWduS2V5Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMi42CnwgLQp8PT09CgpEZXRlY3RzIGNhc2VzIHdoZXJlIHRoZSBgOmZvcmVpZ25fa2V5YCBvcHRpb24gb24gYXNzb2NpYXRpb25zCmlzIHJlZHVuZGFudC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFBvc3QKICBoYXNfbWFueSA6Y29tbWVudHMsIGZvcmVpZ25fa2V5OiAncG9zdF9pZCcKZW5kCgpjbGFzcyBDb21tZW50CiAgYmVsb25nc190byA6cG9zdCwgZm9yZWlnbl9rZXk6ICdwb3N0X2lkJwplbmQKCiMgZ29vZApjbGFzcyBQb3N0CiAgaGFzX21hbnkgOmNvbW1lbnRzCmVuZAoKY2xhc3MgQ29tbWVudAogIGJlbG9uZ3NfdG8gOmF1dGhvciwgZm9yZWlnbl9rZXk6ICd1c2VyX2lkJwplbmQKLS0tLQoKPT0gUmFpbHMvUmVkdW5kYW50UHJlc2VuY2VWYWxpZGF0aW9uT25CZWxvbmdzVG8KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjEzCnwgLQp8PT09CgpTaW5jZSBSYWlscyA1LjAgdGhlIGRlZmF1bHQgZm9yIGBiZWxvbmdzX3RvYCBpcyBgb3B0aW9uYWw6IGZhbHNlYAp1bmxlc3MgYGNvbmZpZy5hY3RpdmVfcmVjb3JkLmJlbG9uZ3NfdG9fcmVxdWlyZWRfYnlfZGVmYXVsdGAgaXMKZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYC4gVGhlIHByZXNlbmNlIHZhbGlkYXRvciBpcyBhZGRlZAphdXRvbWF0aWNhbGx5LCBhbmQgZXhwbGljaXQgcHJlc2VuY2UgdmFsaWRhdGlvbiBpcyByZWR1bmRhbnQuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0IGNoYW5nZXMgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZQpmcm9tICJjYW4ndCBiZSBibGFuayIgdG8gIm11c3QgZXhpc3QiLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYmVsb25nc190byA6dXNlcgp2YWxpZGF0ZXMgOnVzZXIsIHByZXNlbmNlOiB0cnVlCgojIGJhZApiZWxvbmdzX3RvIDp1c2VyCnZhbGlkYXRlcyA6dXNlcl9pZCwgcHJlc2VuY2U6IHRydWUKCiMgYmFkCmJlbG9uZ3NfdG8gOmF1dGhvciwgZm9yZWlnbl9rZXk6IDp1c2VyX2lkCnZhbGlkYXRlcyA6dXNlcl9pZCwgcHJlc2VuY2U6IHRydWUKCiMgZ29vZApiZWxvbmdzX3RvIDp1c2VyCgojIGdvb2QKYmVsb25nc190byA6YXV0aG9yLCBmb3JlaWduX2tleTogOnVzZXJfaWQKLS0tLQoKPT0gUmFpbHMvUmVkdW5kYW50UmVjZWl2ZXJJbldpdGhPcHRpb25zCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC41Mgp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgcmVjZWl2ZXIgaW4gYHdpdGhfb3B0aW9uc2AuClJlY2VpdmVyIGlzIGltcGxpY2l0IGZyb20gUmFpbHMgNC4yIG9yIGhpZ2hlci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIEFjY291bnQgPCBBcHBsaWNhdGlvblJlY29yZAogIHdpdGhfb3B0aW9ucyBkZXBlbmRlbnQ6IDpkZXN0cm95IGRvIHxhc3NvY3wKICAgIGFzc29jLmhhc19tYW55IDpjdXN0b21lcnMKICAgIGFzc29jLmhhc19tYW55IDpwcm9kdWN0cwogICAgYXNzb2MuaGFzX21hbnkgOmludm9pY2VzCiAgICBhc3NvYy5oYXNfbWFueSA6ZXhwZW5zZXMKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgQWNjb3VudCA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgd2l0aF9vcHRpb25zIGRlcGVuZGVudDogOmRlc3Ryb3kgZG8KICAgIGhhc19tYW55IDpjdXN0b21lcnMKICAgIGhhc19tYW55IDpwcm9kdWN0cwogICAgaGFzX21hbnkgOmludm9pY2VzCiAgICBoYXNfbWFueSA6ZXhwZW5zZXMKICBlbmQKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp3aXRoX29wdGlvbnMgb3B0aW9uczogZmFsc2UgZG8gfG1lcmdlcnwKICBtZXJnZXIuaW52b2tlKG1lcmdlci5zb21ldGhpbmcpCmVuZAoKIyBnb29kCndpdGhfb3B0aW9ucyBvcHRpb25zOiBmYWxzZSBkbwogIGludm9rZShzb21ldGhpbmcpCmVuZAoKIyBnb29kCmNsaWVudCA9IENsaWVudC5uZXcKd2l0aF9vcHRpb25zIG9wdGlvbnM6IGZhbHNlIGRvIHxtZXJnZXJ8CiAgY2xpZW50Lmludm9rZShtZXJnZXIuc29tZXRoaW5nLCBzb21ldGhpbmcpCmVuZAoKIyBvawojIFdoZW4gYHdpdGhfb3B0aW9uc2AgaW5jbHVkZXMgYSBibG9jaywgYWxsIHNjb3Bpbmcgc2NlbmFyaW9zCiMgY2Fubm90IGJlIGV2YWx1YXRlZC4gVGh1cywgaXQgaXMgb2sgdG8gaW5jbHVkZSB0aGUgZXhwbGljaXQKIyByZWNlaXZlci4Kd2l0aF9vcHRpb25zIG9wdGlvbnM6IGZhbHNlIGRvIHxtZXJnZXJ8CiAgbWVyZ2VyLmludm9rZQogIHdpdGhfYW5vdGhlcl9tZXRob2QgZG8gfGFub3RoZXJfcmVjZWl2ZXJ8CiAgICBtZXJnZXIuaW52b2tlKGFub3RoZXJfcmVjZWl2ZXIpCiAgZW5kCmVuZAotLS0tCgo9PSBSYWlscy9SZWR1bmRhbnRUcmF2ZWxCYWNrCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4xMgp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgYHRyYXZlbF9iYWNrYCBjYWxscy4KU2luY2UgUmFpbHMgNS4yLCBgdHJhdmVsX2JhY2tgIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHRlc3QuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgdGVhcmRvd24KICBkb19zb21ldGhpbmcKICB0cmF2ZWxfYmFjawplbmQKCiMgZ29vZApkZWYgdGVhcmRvd24KICBkb19zb21ldGhpbmcKZW5kCgojIGJhZAphZnRlciBkbwogIGRvX3NvbWV0aGluZwogIHRyYXZlbF9iYWNrCmVuZAoKIyBnb29kCmFmdGVyIGRvCiAgZG9fc29tZXRoaW5nCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArc3BlYy8qKi8qLnJiK2AsIGArdGVzdC8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9SZWZsZWN0aW9uQ2xhc3NOYW1lCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAwLjY0CnwgMi4xMAp8PT09CgpDaGVja3MgaWYgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gYGNsYXNzX25hbWVgLCBpbgp0aGUgZGVmaW5pdGlvbiBvZiBhIHJlZmxlY3Rpb24gaXMgYSBzdHJpbmcuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgYmVjYXVzZSBpdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZCB3aGV0aGVyCmNvbnN0YW50IG9yIG1ldGhvZCByZXR1cm4gdmFsdWUgc3BlY2lmaWVkIHRvIGBjbGFzc19uYW1lYCBpcyBhIHN0cmluZy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmhhc19tYW55IDphY2NvdW50cywgY2xhc3NfbmFtZTogQWNjb3VudApoYXNfbWFueSA6YWNjb3VudHMsIGNsYXNzX25hbWU6IEFjY291bnQubmFtZQoKIyBnb29kCmhhc19tYW55IDphY2NvdW50cywgY2xhc3NfbmFtZTogJ0FjY291bnQnCi0tLS0KCj09IFJhaWxzL1JlZnV0ZU1ldGhvZHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjU2CnwgLQp8PT09CgpVc2UgYGFzc2VydF9ub3RgIG1ldGhvZHMgaW5zdGVhZCBvZiBgcmVmdXRlYCBtZXRob2RzLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFzc2VydF9ub3QgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVmdXRlIGZhbHNlCnJlZnV0ZV9lbXB0eSBbMSwgMiwgM10KcmVmdXRlX2VxdWFsIHRydWUsIGZhbHNlCgojIGdvb2QKYXNzZXJ0X25vdCBmYWxzZQphc3NlcnRfbm90X2VtcHR5IFsxLCAyLCAzXQphc3NlcnRfbm90X2VxdWFsIHRydWUsIGZhbHNlCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmVmdXRlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXNzZXJ0X25vdCBmYWxzZQphc3NlcnRfbm90X2VtcHR5IFsxLCAyLCAzXQphc3NlcnRfbm90X2VxdWFsIHRydWUsIGZhbHNlCgojIGdvb2QKcmVmdXRlIGZhbHNlCnJlZnV0ZV9lbXB0eSBbMSwgMiwgM10KcmVmdXRlX2VxdWFsIHRydWUsIGZhbHNlCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGFzc2VydF9ub3RgCnwgYGFzc2VydF9ub3RgLCBgcmVmdXRlYAoKfCBJbmNsdWRlCnwgYCsqKi90ZXN0LyoqLyorYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL1JlbGF0aXZlRGF0ZUNvbnN0YW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC40OAp8IDIuMTMKfD09PQoKQ2hlY2tzIHdoZXRoZXIgY29uc3RhbnQgdmFsdWUgaXNuJ3QgcmVsYXRpdmUgZGF0ZS4KQmVjYXVzZSB0aGUgcmVsYXRpdmUgZGF0ZSB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IG9uY2UuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0cyBkZXBlbmRlbmNlIG9uIHRoZSBjb25zdGFudCBpcyBub3QgY29ycmVjdGVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY2xhc3MgU29tZUNsYXNzCiAgRVhQSVJFRF9BVCA9IDEud2Vlay5zaW5jZQplbmQKCiMgZ29vZApjbGFzcyBTb21lQ2xhc3MKICBFWFBJUkVTID0gMS53ZWVrCgogIGRlZiBzZWxmLmV4cGlyZWRfYXQKICAgIEVYUElSRVMuc2luY2UKICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgU29tZUNsYXNzCiAgZGVmIHNlbGYuZXhwaXJlZF9hdAogICAgMS53ZWVrLnNpbmNlCiAgZW5kCmVuZAotLS0tCgo9PSBSYWlscy9SZW5kZXJJbmxpbmUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuNwp8IC0KfD09PQoKTG9va3MgZm9yIGlubGluZSByZW5kZXJpbmcgd2l0aGluIGNvbnRyb2xsZXIgYWN0aW9ucy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFByb2R1Y3RzQ29udHJvbGxlciA8IEFwcGxpY2F0aW9uQ29udHJvbGxlcgogIGRlZiBpbmRleAogICAgcmVuZGVyIGlubGluZTogIjwlIHByb2R1Y3RzLmVhY2ggZG8gfHB8ICU+PHA+PCU9IHAubmFtZSAlPjwvcD48JSBlbmQgJT4iLCB0eXBlOiA6ZXJiCiAgZW5kCmVuZAoKIyBnb29kCiMgYXBwL3ZpZXdzL3Byb2R1Y3RzL2luZGV4Lmh0bWwuZXJiCiMgPCUgcHJvZHVjdHMuZWFjaCBkbyB8cHwgJT4KIyAgIDxwPjwlPSBwLm5hbWUgJT48L3A+CiMgPCUgZW5kICU+CgpjbGFzcyBQcm9kdWN0c0NvbnRyb2xsZXIgPCBBcHBsaWNhdGlvbkNvbnRyb2xsZXIKICBkZWYgaW5kZXgKICBlbmQKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNpbmxpbmUtcmVuZGVyaW5nCgo9PSBSYWlscy9SZW5kZXJQbGFpblRleHQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjcKfCAtCnw9PT0KCklkZW50aWZpZXMgcGxhY2VzIHdoZXJlIGByZW5kZXIgdGV4dDpgIGNhbiBiZQpyZXBsYWNlZCB3aXRoIGByZW5kZXIgcGxhaW46YC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gZXhwbGljaXQgTUlNRSB0eXBlIHRvIGB0ZXh0L3BsYWluYApyZW5kZXIgdGV4dDogJ1J1YnkhJywgY29udGVudF90eXBlOiAndGV4dC9wbGFpbicKCiMgZ29vZCAtIHNob3J0IGFuZCBwcmVjaXNlCnJlbmRlciBwbGFpbjogJ1J1YnkhJwoKIyBnb29kIC0gZXhwbGljaXQgTUlNRSB0eXBlIG5vdCB0byBgdGV4dC9wbGFpbmAKcmVuZGVyIHRleHQ6ICdSdWJ5IScsIGNvbnRlbnRfdHlwZTogJ3RleHQvaHRtbCcKLS0tLQoKPT09PSBDb250ZW50VHlwZUNvbXBhdGliaWxpdHk6IHRydWUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kIC0gc2V0cyBNSU1FIHR5cGUgdG8gYHRleHQvaHRtbGAKcmVuZGVyIHRleHQ6ICdSdWJ5IScKLS0tLQoKPT09PSBDb250ZW50VHlwZUNvbXBhdGliaWxpdHk6IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSBzZXRzIE1JTUUgdHlwZSB0byBgdGV4dC9odG1sYApyZW5kZXIgdGV4dDogJ1J1YnkhJwotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQ29udGVudFR5cGVDb21wYXRpYmlsaXR5CnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZS8jcGxhaW4tdGV4dC1yZW5kZXJpbmcKCj09IFJhaWxzL1JlcXVlc3RSZWZlcmVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMC40MQp8IC0KfD09PQoKQ2hlY2tzIGZvciBjb25zaXN0ZW50IHVzZXMgb2YgYHJlcXVlc3QucmVmZXJlcmAgb3IKYHJlcXVlc3QucmVmZXJyZXJgLCBkZXBlbmRpbmcgb24gdGhlIGNvcCdzIGNvbmZpZ3VyYXRpb24uCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogcmVmZXJlciAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApyZXF1ZXN0LnJlZmVycmVyCgojIGdvb2QKcmVxdWVzdC5yZWZlcmVyCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogcmVmZXJyZXIKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApyZXF1ZXN0LnJlZmVyZXIKCiMgZ29vZApyZXF1ZXN0LnJlZmVycmVyCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHJlZmVyZXJgCnwgYHJlZmVyZXJgLCBgcmVmZXJyZXJgCnw9PT0KCj09IFJhaWxzL1JlcXVpcmVEZXBlbmRlbmN5Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMi4xMAp8IC0KfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNhZ2Ugb2YgYHJlcXVpcmVfZGVwZW5kZW5jeWAuCgpgcmVxdWlyZV9kZXBlbmRlbmN5YCBpcyBhbiBvYnNvbGV0ZSBtZXRob2QgZm9yIFJhaWxzIGFwcGxpY2F0aW9ucyBydW5uaW5nIGluIFplaXR3ZXJrIG1vZGUuCkluIFplaXR3ZXJrIG1vZGUsIHRoZSBzZW1hbnRpY3Mgc2hvdWxkIG1hdGNoIFJ1YnkncyBhbmQgbm8gbmVlZCB0byBiZSBkZWZlbnNpdmUgd2l0aCBsb2FkIG9yZGVyLApqdXN0IHJlZmVyIHRvIGNsYXNzZXMgYW5kIG1vZHVsZXMgbm9ybWFsbHkuCklmIHRoZSBjb25zdGFudCBuYW1lIGlzIGR5bmFtaWMsIGNhbWVsaXplIGlmIG5lZWRlZCwgYW5kIGNvbnN0YW50aXplLgoKQXBwbGljYXRpb25zIHJ1bm5pbmcgaW4gWmVpdHdlcmsgbW9kZSBzaG91bGQgbm90IHVzZSBgcmVxdWlyZV9kZXBlbmRlbmN5YC4KCk5PVEU6IFRoaXMgY29wIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFBsZWFzZSBlbmFibGUgaXQgaWYgeW91IGFyZSB1c2luZyBaZWl0d2VyayBtb2RlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVxdWlyZV9kZXBlbmRlbmN5ICdzb21lX2xpYicKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ndWlkZXMucnVieW9ucmFpbHMub3JnL2F1dG9sb2FkaW5nX2FuZF9yZWxvYWRpbmdfY29uc3RhbnRzLmh0bWwKCj09IFJhaWxzL1Jlc3BvbnNlUGFyc2VkQm9keQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMi4xOAp8IDIuMTkKfD09PQoKUHJlZmVyIGByZXNwb25zZS5wYXJzZWRfYm9keWAgdG8gY3VzdG9tIHBhcnNpbmcgbG9naWMgZm9yIGByZXNwb25zZS5ib2R5YC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIENvbnRlbnQtVHlwZSBtYXkgbm90IGJlIGBhcHBsaWNhdGlvbi9qc29uYCBvciBgdGV4dC9odG1sYC4KRm9yIGV4YW1wbGUsIHRoZSBwcm9wcmlldGFyeSBDb250ZW50LVR5cGUgcHJvdmlkZWQgYnkgY29ycG9yYXRlIGVudGl0aWVzIHN1Y2ggYXMKYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIranNvbmAgaXMgbm90IHN1cHBvcnRlZCBhdCBgcmVzcG9uc2UucGFyc2VkX2JvZHlgIGJ5IGRlZmF1bHQsCnNvIHlvdSBzdGlsbCBoYXZlIHRvIHVzZSBgSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KWAgdGhlcmUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpCgojIGJhZApOb2tvZ2lyaTo6SFRNTC5wYXJzZShyZXNwb25zZS5ib2R5KQoKIyBiYWQKTm9rb2dpcmk6OkhUTUw1LnBhcnNlKHJlc3BvbnNlLmJvZHkpCgojIGdvb2QKcmVzcG9uc2UucGFyc2VkX2JvZHkKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK3NwZWMvY29udHJvbGxlcnMvKiovKi5yYitgLCBgK3NwZWMvcmVxdWVzdHMvKiovKi5yYitgLCBgK3Rlc3QvY29udHJvbGxlcnMvKiovKi5yYitgLCBgK3Rlc3QvaW50ZWdyYXRpb24vKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvUmV2ZXJzaWJsZU1pZ3JhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMC40Nwp8IDIuMTMKfD09PQoKQ2hlY2tzIHdoZXRoZXIgdGhlIGNoYW5nZSBtZXRob2Qgb2YgdGhlIG1pZ3JhdGlvbiBmaWxlIGlzCnJldmVyc2libGUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZWYgY2hhbmdlCiAgY2hhbmdlX3RhYmxlIDp1c2VycyBkbyB8dHwKICAgIHQucmVtb3ZlIDpuYW1lCiAgZW5kCmVuZAoKIyBnb29kCmRlZiBjaGFuZ2UKICBjaGFuZ2VfdGFibGUgOnVzZXJzIGRvIHx0fAogICAgdC5yZW1vdmUgOm5hbWUsIHR5cGU6IDpzdHJpbmcKICBlbmQKZW5kCgojIGdvb2QKZGVmIGNoYW5nZQogIGNyZWF0ZV90YWJsZSA6dXNlcnMgZG8gfHR8CiAgICB0LnN0cmluZyA6bmFtZQogIGVuZAplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZHJvcF90YWJsZQoKIyBiYWQKZGVmIGNoYW5nZQogIGRyb3BfdGFibGUgOnVzZXJzCmVuZAoKIyBnb29kCmRlZiBjaGFuZ2UKICBkcm9wX3RhYmxlIDp1c2VycyBkbyB8dHwKICAgIHQuc3RyaW5nIDpuYW1lCiAgZW5kCmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBjaGFuZ2VfY29sdW1uX2RlZmF1bHQKCiMgYmFkCmRlZiBjaGFuZ2UKICBjaGFuZ2VfY29sdW1uX2RlZmF1bHQoOnN1cHBsaWVycywgOnF1YWxpZmljYXRpb24sICduZXcnKQplbmQKCiMgZ29vZApkZWYgY2hhbmdlCiAgY2hhbmdlX2NvbHVtbl9kZWZhdWx0KDpwb3N0cywgOnN0YXRlLCBmcm9tOiBuaWwsIHRvOiAiZHJhZnQiKQplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgcmVtb3ZlX2NvbHVtbgoKIyBiYWQKZGVmIGNoYW5nZQogIHJlbW92ZV9jb2x1bW4oOnN1cHBsaWVycywgOnF1YWxpZmljYXRpb24pCmVuZAoKIyBnb29kCmRlZiBjaGFuZ2UKICByZW1vdmVfY29sdW1uKDpzdXBwbGllcnMsIDpxdWFsaWZpY2F0aW9uLCA6c3RyaW5nKQplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgcmVtb3ZlX2ZvcmVpZ25fa2V5CgojIGJhZApkZWYgY2hhbmdlCiAgcmVtb3ZlX2ZvcmVpZ25fa2V5IDphY2NvdW50cywgY29sdW1uOiA6b3duZXJfaWQKZW5kCgojIGdvb2QKZGVmIGNoYW5nZQogIHJlbW92ZV9mb3JlaWduX2tleSA6YWNjb3VudHMsIDpicmFuY2hlcwplbmQKCiMgZ29vZApkZWYgY2hhbmdlCiAgcmVtb3ZlX2ZvcmVpZ25fa2V5IDphY2NvdW50cywgdG9fdGFibGU6IDpicmFuY2hlcwplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgY2hhbmdlX3RhYmxlCgojIGJhZApkZWYgY2hhbmdlCiAgY2hhbmdlX3RhYmxlIDp1c2VycyBkbyB8dHwKICAgIHQucmVtb3ZlIDpuYW1lCiAgICB0LmNoYW5nZV9kZWZhdWx0IDphdXRob3JpemVkLCAxCiAgICB0LmNoYW5nZSA6cHJpY2UsIDpzdHJpbmcKICBlbmQKZW5kCgojIGdvb2QKZGVmIGNoYW5nZQogIGNoYW5nZV90YWJsZSA6dXNlcnMgZG8gfHR8CiAgICB0LnN0cmluZyA6bmFtZQogIGVuZAplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgcmVtb3ZlX2NvbHVtbnMKCiMgYmFkCmRlZiBjaGFuZ2UKICByZW1vdmVfY29sdW1ucyA6dXNlcnMsIDpuYW1lLCA6ZW1haWwKZW5kCgojIGdvb2QKZGVmIGNoYW5nZQogIHJldmVyc2libGUgZG8gfGRpcnwKICAgIGRpci51cCBkbwogICAgICByZW1vdmVfY29sdW1ucyA6dXNlcnMsIDpuYW1lLCA6ZW1haWwKICAgIGVuZAoKICAgIGRpci5kb3duIGRvCiAgICAgIGFkZF9jb2x1bW4gOnVzZXJzLCA6bmFtZSwgOnN0cmluZwogICAgICBhZGRfY29sdW1uIDp1c2VycywgOmVtYWlsLCA6c3RyaW5nCiAgICBlbmQKICBlbmQKZW5kCgojIGdvb2QgKFJhaWxzID49IDYuMSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWlscy9yYWlscy9wdWxsLzM2NTg5KQpkZWYgY2hhbmdlCiAgcmVtb3ZlX2NvbHVtbnMgOnVzZXJzLCA6bmFtZSwgOmVtYWlsLCB0eXBlOiA6c3RyaW5nCmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyByZW1vdmVfaW5kZXgKCiMgYmFkCmRlZiBjaGFuZ2UKICByZW1vdmVfaW5kZXggOnVzZXJzLCBuYW1lOiA6aW5kZXhfdXNlcnNfb25fZW1haWwKZW5kCgojIGdvb2QKZGVmIGNoYW5nZQogIHJlbW92ZV9pbmRleCA6dXNlcnMsIDplbWFpbAplbmQKCiMgZ29vZApkZWYgY2hhbmdlCiAgcmVtb3ZlX2luZGV4IDp1c2VycywgY29sdW1uOiA6ZW1haWwKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCtkYi8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZSNyZXZlcnNpYmxlLW1pZ3JhdGlvbgoqIGh0dHBzOi8vYXBpLnJ1YnlvbnJhaWxzLm9yZy9jbGFzc2VzL0FjdGl2ZVJlY29yZC9NaWdyYXRpb24vQ29tbWFuZFJlY29yZGVyLmh0bWwKCj09IFJhaWxzL1JldmVyc2libGVNaWdyYXRpb25NZXRob2REZWZpbml0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMi4xMAp8IDIuMTMKfD09PQoKQ2hlY2tzIHdoZXRoZXIgdGhlIG1pZ3JhdGlvbiBpbXBsZW1lbnRzCmVpdGhlciBhIGBjaGFuZ2VgIG1ldGhvZCBvciBib3RoIGFuIGB1cGAgYW5kIGEgYGRvd25gCm1ldGhvZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNsYXNzIFNvbWVNaWdyYXRpb24gPCBBY3RpdmVSZWNvcmQ6Ok1pZ3JhdGlvbls2LjBdCiAgZGVmIHVwCiAgICAjIHVwIG1pZ3JhdGlvbgogIGVuZAoKICAjIDwtLS0tLSBtaXNzaW5nIGRvd24gbWV0aG9kCmVuZAoKY2xhc3MgU29tZU1pZ3JhdGlvbiA8IEFjdGl2ZVJlY29yZDo6TWlncmF0aW9uWzYuMF0KICAjIDwtLS0tLSBtaXNzaW5nIHVwIG1ldGhvZAoKICBkZWYgZG93bgogICAgIyBkb3duIG1pZ3JhdGlvbgogIGVuZAplbmQKCiMgZ29vZApjbGFzcyBTb21lTWlncmF0aW9uIDwgQWN0aXZlUmVjb3JkOjpNaWdyYXRpb25bNi4wXQogIGRlZiBjaGFuZ2UKICAgICMgcmV2ZXJzaWJsZSBtaWdyYXRpb24KICBlbmQKZW5kCgojIGdvb2QKY2xhc3MgU29tZU1pZ3JhdGlvbiA8IEFjdGl2ZVJlY29yZDo6TWlncmF0aW9uWzYuMF0KICBkZWYgdXAKICAgICMgdXAgbWlncmF0aW9uCiAgZW5kCgogIGRlZiBkb3duCiAgICAjIGRvd24gbWlncmF0aW9uCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArZGIvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvUm9vdEpvaW5DaGFpbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTMKfCAtCnw9PT0KClVzZSBhIHNpbmdsZSBgI2pvaW5gIGluc3RlYWQgb2YgY2hhaW5pbmcgb24gYFJhaWxzLnJvb3RgIG9yIGBSYWlscy5wdWJsaWNfcGF0aGAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSYWlscy5yb290LmpvaW4oJ2RiJykuam9pbignc2NoZW1hLnJiJykKUmFpbHMucm9vdC5qb2luKCdkYicpLmpvaW4obWlncmF0ZSkuam9pbignbWlncmF0aW9uLnJiJykKUmFpbHMucHVibGljX3BhdGguam9pbigncGF0aCcpLmpvaW4oJ2ZpbGUucGRmJykKUmFpbHMucHVibGljX3BhdGguam9pbigncGF0aCcpLmpvaW4odG8pLmpvaW4oJ2ZpbGUucGRmJykKCiMgZ29vZApSYWlscy5yb290LmpvaW4oJ2RiJywgJ3NjaGVtYS5yYicpClJhaWxzLnJvb3Quam9pbignZGInLCBtaWdyYXRlLCAnbWlncmF0aW9uLnJiJykKUmFpbHMucHVibGljX3BhdGguam9pbigncGF0aCcsICdmaWxlLnBkZicpClJhaWxzLnB1YmxpY19wYXRoLmpvaW4oJ3BhdGgnLCB0bywgJ2ZpbGUucGRmJykKLS0tLQoKPT0gUmFpbHMvUm9vdFBhdGhuYW1lTWV0aG9kcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuMTYKfCAtCnw9PT0KClVzZSBgUmFpbHMucm9vdGAgSU8gbWV0aG9kcyBpbnN0ZWFkIG9mIHBhc3NpbmcgaXQgdG8gYEZpbGVgLgoKYFJhaWxzLnJvb3RgIGlzIGFuIGluc3RhbmNlIG9mIGBQYXRobmFtZWAKc28gd2UgY2FuIGFwcGx5IG1hbnkgSU8gbWV0aG9kcyBkaXJlY3RseS4KClRoaXMgY29wIHdvcmtzIGJlc3Qgd2hlbiB1c2VkIHRvZ2V0aGVyIHdpdGgKYFN0eWxlL0ZpbGVSZWFkYCwgYFN0eWxlL0ZpbGVXcml0ZWAgYW5kIGBSYWlscy9Sb290Sm9pbkNoYWluYC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBmb3IgYXV0b2NvcnJlY3Rpb24gYmVjYXVzZSBgYERpcmBgJ3MgYGNoaWxkcmVuYCwgYGVhY2hfY2hpbGRgLCBgZW50cmllc2AsIGFuZCBgZ2xvYmAKbWV0aG9kcyByZXR1cm4gc3RyaW5nIGVsZW1lbnQsIGJ1dCB0aGVzZSBtZXRob2RzIG9mIGBQYXRobmFtZWAgcmV0dXJuIGBQYXRobmFtZWAgZWxlbWVudC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkZpbGUub3BlbihSYWlscy5yb290LmpvaW4oJ2RiJywgJ3NjaGVtYS5yYicpKQpGaWxlLm9wZW4oUmFpbHMucm9vdC5qb2luKCdkYicsICdzY2hlbWEucmInKSwgJ3cnKQpGaWxlLnJlYWQoUmFpbHMucm9vdC5qb2luKCdkYicsICdzY2hlbWEucmInKSkKRmlsZS5iaW5yZWFkKFJhaWxzLnJvb3Quam9pbignZGInLCAnc2NoZW1hLnJiJykpCkZpbGUud3JpdGUoUmFpbHMucm9vdC5qb2luKCdkYicsICdzY2hlbWEucmInKSwgY29udGVudCkKRmlsZS5iaW53cml0ZShSYWlscy5yb290LmpvaW4oJ2RiJywgJ3NjaGVtYS5yYicpLCBjb250ZW50KQoKIyBnb29kClJhaWxzLnJvb3Quam9pbignZGInLCAnc2NoZW1hLnJiJykub3BlbgpSYWlscy5yb290LmpvaW4oJ2RiJywgJ3NjaGVtYS5yYicpLm9wZW4oJ3cnKQpSYWlscy5yb290LmpvaW4oJ2RiJywgJ3NjaGVtYS5yYicpLnJlYWQKUmFpbHMucm9vdC5qb2luKCdkYicsICdzY2hlbWEucmInKS5iaW5yZWFkClJhaWxzLnJvb3Quam9pbignZGInLCAnc2NoZW1hLnJiJykud3JpdGUoY29udGVudCkKUmFpbHMucm9vdC5qb2luKCdkYicsICdzY2hlbWEucmInKS5iaW53cml0ZShjb250ZW50KQotLS0tCgo9PSBSYWlscy9Sb290UHVibGljUGF0aAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTUKfCAtCnw9PT0KCkZhdm9yIGBSYWlscy5wdWJsaWNfcGF0aGAgb3ZlciBgUmFpbHMucm9vdGAgd2l0aCBgJ3B1YmxpYydgCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSYWlscy5yb290LmpvaW4oJ3B1YmxpYycpClJhaWxzLnJvb3Quam9pbigncHVibGljL2ZpbGUucGRmJykKUmFpbHMucm9vdC5qb2luKCdwdWJsaWMnLCAnZmlsZS5wZGYnKQoKIyBnb29kClJhaWxzLnB1YmxpY19wYXRoClJhaWxzLnB1YmxpY19wYXRoLmpvaW4oJ2ZpbGUucGRmJykKUmFpbHMucHVibGljX3BhdGguam9pbignZmlsZS5wZGYnKQotLS0tCgo9PSBSYWlscy9TYWZlTmF2aWdhdGlvbgoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjQzCnwgLQp8PT09CgpDb252ZXJ0cyB1c2FnZXMgb2YgYHRyeSFgIHRvIGAmLmAuIEl0IGNhbiBhbHNvIGJlIGNvbmZpZ3VyZWQKdG8gY29udmVydCBgdHJ5YC4gSXQgd2lsbCBjb252ZXJ0IGNvZGUgdG8gdXNlIHNhZmUgbmF2aWdhdGlvbgppZiB0aGUgdGFyZ2V0IFJ1YnkgdmVyc2lvbiBpcyBzZXQgdG8gMi4zKwoKPT09IEV4YW1wbGVzCgo9PT09IENvbnZlcnRUcnk6IGZhbHNlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby50cnkhKDpiYXIpCmZvby50cnkhKDpiYXIsIGJheikKZm9vLnRyeSEoOmJhcikgeyB8ZXwgZS5iYXogfQoKZm9vLnRyeSEoOltdLCAwKQoKIyBnb29kCmZvby50cnkoOmJhcikKZm9vLnRyeSg6YmFyLCBiYXopCmZvby50cnkoOmJhcikgeyB8ZXwgZS5iYXogfQoKZm9vJi5iYXIKZm9vJi5iYXIoYmF6KQpmb28mLmJhciB7IHxlfCBlLmJheiB9Ci0tLS0KCj09PT0gQ29udmVydFRyeTogdHJ1ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmZvby50cnkhKDpiYXIpCmZvby50cnkhKDpiYXIsIGJheikKZm9vLnRyeSEoOmJhcikgeyB8ZXwgZS5iYXogfQpmb28udHJ5KDpiYXIpCmZvby50cnkoOmJhciwgYmF6KQpmb28udHJ5KDpiYXIpIHsgfGV8IGUuYmF6IH0KCiMgZ29vZApmb28mLmJhcgpmb28mLmJhcihiYXopCmZvbyYuYmFyIHsgfGV8IGUuYmF6IH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IENvbnZlcnRUcnkKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PSBSYWlscy9TYWZlTmF2aWdhdGlvbldpdGhCbGFuawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuNAp8IC0KfD09PQoKQ2hlY2tzIHRvIG1ha2Ugc3VyZSBzYWZlIG5hdmlnYXRpb24gaXNuJ3QgdXNlZCB3aXRoIGBibGFuaz9gIGluCmEgY29uZGl0aW9uYWwuCgo9PT0gU2FmZXR5CgpXaGlsZSB0aGUgc2FmZSBuYXZpZ2F0aW9uIG9wZXJhdG9yIGlzIGdlbmVyYWxseSBhIGdvb2QgaWRlYSwgd2hlbgpjaGVja2luZyBgZm9vJi5ibGFuaz9gIGluIGEgY29uZGl0aW9uYWwsIGBmb29gIGJlaW5nIGBuaWxgIHdpbGwgYWN0dWFsbHkKZG8gdGhlIG9wcG9zaXRlIG9mIHdoYXQgdGhlIGF1dGhvciBpbnRlbmRzLgoKRm9yIGV4YW1wbGU6Cgpbc291cmNlLHJ1YnldCi0tLS0KZm9vJi5ibGFuaz8gIz0+IG5pbApmb28uYmxhbms/ICM9PiB0cnVlCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRvX3NvbWV0aGluZyBpZiBmb28mLmJsYW5rPwpkb19zb21ldGhpbmcgdW5sZXNzIGZvbyYuYmxhbms/CgojIGdvb2QKZG9fc29tZXRoaW5nIGlmIGZvby5ibGFuaz8KZG9fc29tZXRoaW5nIHVubGVzcyBmb28uYmxhbms/Ci0tLS0KCj09IFJhaWxzL1NhdmVCYW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNDIKfCAwLjU5Cnw9PT0KCklkZW50aWZpZXMgcG9zc2libGUgY2FzZXMgd2hlcmUgQWN0aXZlIFJlY29yZCBzYXZlISBvciByZWxhdGVkCnNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2Ygc2F2ZSBiZWNhdXNlIHRoZSBtb2RlbCBtaWdodCBoYXZlIGZhaWxlZCB0bwpzYXZlIGFuZCBhbiBleGNlcHRpb24gaXMgYmV0dGVyIHRoYW4gdW5oYW5kbGVkIGZhaWx1cmUuCgpUaGlzIHdpbGwgYWxsb3c6CgoqIHVwZGF0ZSBvciBzYXZlIGNhbGxzLCBhc3NpZ25lZCB0byBhIHZhcmlhYmxlLAogIG9yIHVzZWQgYXMgYSBjb25kaXRpb24gaW4gYW4gaWYvdW5sZXNzL2Nhc2Ugc3RhdGVtZW50LgoqIGNyZWF0ZSBjYWxscywgYXNzaWduZWQgdG8gYSB2YXJpYWJsZSB0aGF0IHRoZW4gaGFzIGEKICBjYWxsIHRvIGBwZXJzaXN0ZWQ/YCwgb3Igd2hvc2UgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQgYnkKICBgcGVyc2lzdGVkP2AgaW1tZWRpYXRlbHkKKiBjYWxscyBpZiB0aGUgcmVzdWx0IGlzIGV4cGxpY2l0bHkgcmV0dXJuZWQgZnJvbSBtZXRob2RzIGFuZCBibG9ja3MsCiAgb3IgcHJvdmlkZWQgYXMgYXJndW1lbnRzLgoqIGNhbGxzIHdob3NlIHNpZ25hdHVyZSBkb2Vzbid0IGxvb2sgbGlrZSBhbiBBY3RpdmVSZWNvcmQKICBwZXJzaXN0ZW5jZSBtZXRob2QuCgpCeSBkZWZhdWx0IGl0IHdpbGwgYWxzbyBhbGxvdyBpbXBsaWNpdCByZXR1cm5zIGZyb20gbWV0aG9kcyBhbmQgYmxvY2tzLgp0aGF0IGJlaGF2aW9yIGNhbiBiZSB0dXJuZWQgb2ZmIHdpdGggYEFsbG93SW1wbGljaXRSZXR1cm46IGZhbHNlYC4KCllvdSBjYW4gcGVybWl0IHJlY2VpdmVycyB0aGF0IGFyZSBnaXZpbmcgZmFsc2UgcG9zaXRpdmVzIHdpdGgKYEFsbG93ZWRSZWNlaXZlcnM6IFtdYAoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBhIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgY2FsbCB3b3VsZCBiZSBjaGFuZ2VkIHRvIGB1cGRhdGUhYCwKYnV0IHRoZSBtZXRob2QgbmFtZSBpbiB0aGUgZGVmaW5pdGlvbiB3b3VsZCBiZSB1bmNoYW5nZWQuCgpbc291cmNlLHJ1YnldCi0tLS0KIyBPcmlnaW5hbCBjb2RlCmRlZiB1cGRhdGVfYXR0cmlidXRlcwplbmQKCnVwZGF0ZV9hdHRyaWJ1dGVzCgojIEFmdGVyIHJ1bm5pbmcgcnVib2NvcCAtLXNhZmUtYXV0b2NvcnJlY3QKZGVmIHVwZGF0ZV9hdHRyaWJ1dGVzCmVuZAoKdXBkYXRlCi0tLS0KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnVzZXIuc2F2ZQp1c2VyLnVwZGF0ZShuYW1lOiAnSm9lJykKdXNlci5maW5kX29yX2NyZWF0ZV9ieShuYW1lOiAnSm9lJykKdXNlci5kZXN0cm95CgojIGdvb2QKdW5sZXNzIHVzZXIuc2F2ZQogICMgLi4uCmVuZAp1c2VyLnNhdmUhCnVzZXIudXBkYXRlIShuYW1lOiAnSm9lJykKdXNlci5maW5kX29yX2NyZWF0ZV9ieSEobmFtZTogJ0pvZScpCnVzZXIuZGVzdHJveSEKCnVzZXIgPSBVc2VyLmZpbmRfb3JfY3JlYXRlX2J5KG5hbWU6ICdKb2UnKQp1bmxlc3MgdXNlci5wZXJzaXN0ZWQ/CiAgIyAuLi4KZW5kCgpkZWYgc2F2ZV91c2VyCiAgcmV0dXJuIHVzZXIuc2F2ZQplbmQKLS0tLQoKPT09PSBBbGxvd0ltcGxpY2l0UmV0dXJuOiB0cnVlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAp1c2Vycy5lYWNoIHsgfHV8IHUuc2F2ZSB9CgpkZWYgc2F2ZV91c2VyCiAgdXNlci5zYXZlCmVuZAotLS0tCgo9PT09IEFsbG93SW1wbGljaXRSZXR1cm46IGZhbHNlCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKdXNlcnMuZWFjaCB7IHx1fCB1LnNhdmUgfQpkZWYgc2F2ZV91c2VyCiAgdXNlci5zYXZlCmVuZAoKIyBnb29kCnVzZXJzLmVhY2ggeyB8dXwgdS5zYXZlISB9CgpkZWYgc2F2ZV91c2VyCiAgdXNlci5zYXZlIQplbmQKCmRlZiBzYXZlX3VzZXIKICByZXR1cm4gdXNlci5zYXZlCmVuZAotLS0tCgo9PT09IEFsbG93ZWRSZWNlaXZlcnM6IFsnbWVyY2hhbnQuY3VzdG9tZXJzJywgJ1NlcnZpY2U6Ok1haWxlciddCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbWVyY2hhbnQuY3JlYXRlCmN1c3RvbWVycy5idWlsZGVyLnNhdmUKTWFpbGVyLmNyZWF0ZQoKbW9kdWxlIFNlcnZpY2U6Ok1haWxlcgogIHNlbGYuY3JlYXRlCmVuZAoKIyBnb29kCm1lcmNoYW50LmN1c3RvbWVycy5jcmVhdGUKTWVyY2hhbnRTZXJ2aWNlLm1lcmNoYW50LmN1c3RvbWVycy5kZXN0cm95ClNlcnZpY2U6Ok1haWxlci51cGRhdGUobWVzc2FnZTogJ01lc3NhZ2UnKQo6OlNlcnZpY2U6Ok1haWxlci51cGRhdGUKU2VydmljZXM6OlNlcnZpY2U6Ok1haWxlci51cGRhdGUobWVzc2FnZTogJ01lc3NhZ2UnKQpTZXJ2aWNlOjpNYWlsZXI6OnVwZGF0ZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dJbXBsaWNpdFJldHVybgp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgQWxsb3dlZFJlY2VpdmVycwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZSNzYXZlLWJhbmcKCj09IFJhaWxzL1NjaGVtYUNvbW1lbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgTm8KfCAyLjEzCnwgLQp8PT09CgpFbmZvcmNlcyB0aGUgdXNlIG9mIHRoZSBgY29tbWVudGAgb3B0aW9uIHdoZW4gYWRkaW5nIGEgbmV3IHRhYmxlIG9yIGNvbHVtbgp0byB0aGUgZGF0YWJhc2UgZHVyaW5nIGEgbWlncmF0aW9uLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgKG5vIGNvbW1lbnQgZm9yIGEgbmV3IGNvbHVtbiBvciB0YWJsZSkKYWRkX2NvbHVtbiA6dGFibGUsIDpjb2x1bW4sIDppbnRlZ2VyCgpjcmVhdGVfdGFibGUgOnRhYmxlIGRvIHx0fAogIHQudHlwZSA6Y29sdW1uCmVuZAoKIyBnb29kCmFkZF9jb2x1bW4gOnRhYmxlLCA6Y29sdW1uLCA6aW50ZWdlciwgY29tbWVudDogJ051bWJlciBvZiBvZmZlbnNlcycKCmNyZWF0ZV90YWJsZSA6dGFibGUsIGNvbW1lbnQ6ICdUYWJsZSBvZiBvZmZlbnNlcyBkYXRhJyBkbyB8dHwKICB0LnR5cGUgOmNvbHVtbiwgY29tbWVudDogJ051bWJlciBvZiBvZmZlbnNlcycKZW5kCi0tLS0KCj09IFJhaWxzL1Njb3BlQXJncwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDAuMTkKfCAyLjEyCnw9PT0KCkNoZWNrcyBmb3Igc2NvcGUgY2FsbHMgd2hlcmUgaXQgd2FzIHBhc3NlZAphIG1ldGhvZCAodXN1YWxseSBhIHNjb3BlKSBpbnN0ZWFkIG9mIGEgbGFtYmRhL3Byb2MuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApzY29wZSA6c29tZXRoaW5nLCB3aGVyZShzb21ldGhpbmc6IHRydWUpCgojIGdvb2QKc2NvcGUgOnNvbWV0aGluZywgLT4geyB3aGVyZShzb21ldGhpbmc6IHRydWUpIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2FwcC9tb2RlbHMvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvU2VsZWN0TWFwCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAyLjIxCnwgLQp8PT09CgpDaGVja3MgZm9yIHVzZXMgb2YgYHNlbGVjdCg6Y29sdW1uX25hbWUpYCB3aXRoIGBtYXAoJjpjb2x1bW5fbmFtZSlgLgpUaGVzZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgcGx1Y2soOmNvbHVtbl9uYW1lKWAuCgpUaGVyZSBhbHNvIHNob3VsZCBiZSBzb21lIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50IHNpbmNlIGl0IHNraXBzIGluc3RhbnRpYXRpbmcgdGhlIG1vZGVsIGNsYXNzIGZvciBtYXRjaGVzLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgdGhlIG1vZGVsIG1pZ2h0IG92ZXJyaWRlIHRoZSBhdHRyaWJ1dGUgZ2V0dGVyLgpBZGRpdGlvbmFsbHksIHRoZSBtb2RlbCdzIGBhZnRlcl9pbml0aWFsaXplYCBob29rcyBhcmUgc2tpcHBlZCB3aGVuIHVzaW5nIGBwbHVja2AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApNb2RlbC5zZWxlY3QoOmNvbHVtbl9uYW1lKS5tYXAoJjpjb2x1bW5fbmFtZSkKCiMgZ29vZApNb2RlbC5wbHVjayg6Y29sdW1uX25hbWUpCi0tLS0KCj09IFJhaWxzL1Nob3J0STE4bgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuNwp8IC0KfD09PQoKRW5mb3JjZXMgdGhhdCBzaG9ydCBmb3JtcyBvZiBgSTE4bmAgbWV0aG9kcyBhcmUgdXNlZDoKYHRgIGluc3RlYWQgb2YgYHRyYW5zbGF0ZWAgYW5kIGBsYCBpbnN0ZWFkIG9mIGBsb2NhbGl6ZWAuCgpUaGlzIGNvcCBoYXMgdHdvIGRpZmZlcmVudCBlbmZvcmNlbWVudCBtb2Rlcy4gV2hlbiB0aGUgRW5mb3JjZWRTdHlsZQppcyBjb25zZXJ2YXRpdmUgKHRoZSBkZWZhdWx0KSB0aGVuIG9ubHkgYEkxOG4udHJhbnNsYXRlYCBhbmQgYEkxOG4ubG9jYWxpemVgCmNhbGxzIGFyZSBhZGRlZCBhcyBvZmZlbnNlcy4KCldoZW4gdGhlIEVuZm9yY2VkU3R5bGUgaXMgYWdncmVzc2l2ZSB0aGVuIGFsbCBgdHJhbnNsYXRlYCBhbmQgYGxvY2FsaXplYCBjYWxscwp3aXRob3V0IGEgcmVjZWl2ZXIgYXJlIGFkZGVkIGFzIG9mZmVuc2VzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKSTE4bi50cmFuc2xhdGUgOmtleQpJMThuLmxvY2FsaXplIFRpbWUubm93CgojIGdvb2QKSTE4bi50IDprZXkKSTE4bi5sIFRpbWUubm93Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogY29uc2VydmF0aXZlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAp0cmFuc2xhdGUgOmtleQpsb2NhbGl6ZSBUaW1lLm5vdwp0IDprZXkKbCBUaW1lLm5vdwotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGFnZ3Jlc3NpdmUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp0cmFuc2xhdGUgOmtleQpsb2NhbGl6ZSBUaW1lLm5vdwoKIyBnb29kCnQgOmtleQpsIFRpbWUubm93Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGNvbnNlcnZhdGl2ZWAKfCBgY29uc2VydmF0aXZlYCwgYGFnZ3Jlc3NpdmVgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNzaG9ydC1pMThuCgo9PSBSYWlscy9Ta2lwc01vZGVsVmFsaWRhdGlvbnMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDAuNDcKfCAyLjcKfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIG1ldGhvZHMgd2hpY2ggc2tpcAp2YWxpZGF0aW9ucyB3aGljaCBhcmUgbGlzdGVkIGluCmh0dHBzOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy9hY3RpdmVfcmVjb3JkX3ZhbGlkYXRpb25zLmh0bWwjc2tpcHBpbmctdmFsaWRhdGlvbnMKCk1ldGhvZHMgbWF5IGJlIGlnbm9yZWQgZnJvbSB0aGlzIHJ1bGUgYnkgY29uZmlndXJpbmcgYSBgQWxsb3dlZE1ldGhvZHNgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKQXJ0aWNsZS5maXJzdC5kZWNyZW1lbnQhKDp2aWV3X2NvdW50KQpEaXNjdXNzaW9uQm9hcmQuZGVjcmVtZW50X2NvdW50ZXIoOnBvc3RfY291bnQsIDUpCkFydGljbGUuZmlyc3QuaW5jcmVtZW50ISg6dmlld19jb3VudCkKRGlzY3Vzc2lvbkJvYXJkLmluY3JlbWVudF9jb3VudGVyKDpwb3N0X2NvdW50LCA1KQpwZXJzb24udG9nZ2xlIDphY3RpdmUKcHJvZHVjdC50b3VjaApCaWxsaW5nLnVwZGF0ZV9hbGwoImNhdGVnb3J5ID0gJ2F1dGhvcml6ZWQnLCBhdXRob3IgPSAnRGF2aWQnIikKdXNlci51cGRhdGVfYXR0cmlidXRlKDp3ZWJzaXRlLCAnZXhhbXBsZS5jb20nKQp1c2VyLnVwZGF0ZV9jb2x1bW5zKGxhc3RfcmVxdWVzdF9hdDogVGltZS5jdXJyZW50KQpQb3N0LnVwZGF0ZV9jb3VudGVycyA1LCBjb21tZW50X2NvdW50OiAtMSwgYWN0aW9uX2NvdW50OiAxCgojIGdvb2QKdXNlci51cGRhdGUod2Vic2l0ZTogJ2V4YW1wbGUuY29tJykKRmlsZVV0aWxzLnRvdWNoKCdmaWxlJykKLS0tLQoKPT09PSBBbGxvd2VkTWV0aG9kczogWyJ0b3VjaCJdCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKRGlzY3Vzc2lvbkJvYXJkLmRlY3JlbWVudF9jb3VudGVyKDpwb3N0X2NvdW50LCA1KQpEaXNjdXNzaW9uQm9hcmQuaW5jcmVtZW50X2NvdW50ZXIoOnBvc3RfY291bnQsIDUpCnBlcnNvbi50b2dnbGUgOmFjdGl2ZQoKIyBnb29kCnVzZXIudG91Y2gKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEZvcmJpZGRlbk1ldGhvZHMKfCBgZGVjcmVtZW50IWAsIGBkZWNyZW1lbnRfY291bnRlcmAsIGBpbmNyZW1lbnQhYCwgYGluY3JlbWVudF9jb3VudGVyYCwgYGluc2VydGAsIGBpbnNlcnQhYCwgYGluc2VydF9hbGxgLCBgaW5zZXJ0X2FsbCFgLCBgdG9nZ2xlIWAsIGB0b3VjaGAsIGB0b3VjaF9hbGxgLCBgdXBkYXRlX2FsbGAsIGB1cGRhdGVfYXR0cmlidXRlYCwgYHVwZGF0ZV9jb2x1bW5gLCBgdXBkYXRlX2NvbHVtbnNgLCBgdXBkYXRlX2NvdW50ZXJzYCwgYHVwc2VydGAsIGB1cHNlcnRfYWxsYAp8IEFycmF5Cgp8IEFsbG93ZWRNZXRob2RzCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy9hY3RpdmVfcmVjb3JkX3ZhbGlkYXRpb25zLmh0bWwjc2tpcHBpbmctdmFsaWRhdGlvbnMKCj09IFJhaWxzL1NxdWlzaGVkU1FMSGVyZWRvY3MKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAyLjgKfCAyLjkKfD09PQoKQ2hlY2tzIFNRTCBoZXJlZG9jcyB0byB1c2UgYC5zcXVpc2hgLgoKPT09IFNhZmV0eQoKU29tZSBTUUwgc3ludGF4IChlLmcuIFBvc3RncmVTUUwgY29tbWVudHMgYW5kIGZ1bmN0aW9ucykgcmVxdWlyZXMgbmV3bGluZXMKdG8gYmUgcHJlc2VydmVkIGluIG9yZGVyIHRvIHdvcmssIHRodXMgYXV0b2NvcnJlY3Rpb24gZm9yIHRoaXMgY29wIGlzIG5vdCBzYWZlLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKPDwtU1FMCiAgU0VMRUNUICogRlJPTSBwb3N0czsKU1FMCgo8PC1TUUwKICBTRUxFQ1QgKiBGUk9NIHBvc3RzCiAgICBXSEVSRSBpZCA9IDEKU1FMCgpleGVjdXRlKDw8flNRTCwgIlBvc3QgTG9hZCIpCiAgU0VMRUNUICogRlJPTSBwb3N0cwogICAgV0hFUkUgcG9zdF9pZCA9IDEKU1FMCgojIGdvb2QKPDwtU1FMLnNxdWlzaAogIFNFTEVDVCAqIEZST00gcG9zdHM7ClNRTAoKPDx+U1FMLnNxdWlzaAogIFNFTEVDVCAqIEZST00gdGFibGUKICAgIFdIRVJFIGlkID0gMQpTUUwKCmV4ZWN1dGUoPDx+U1FMLnNxdWlzaCwgIlBvc3QgTG9hZCIpCiAgU0VMRUNUICogRlJPTSBwb3N0cwogICAgV0hFUkUgcG9zdF9pZCA9IDEKU1FMCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNzcXVpc2hlZC1oZXJlZG9jcwoKPT0gUmFpbHMvU3RyaXBIZXJlZG9jCgpOT1RFOiBSZXF1aXJlZCBSdWJ5IHZlcnNpb246IDIuMwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTUKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSB1c2Ugb2Ygc3F1aWdnbHkgaGVyZWRvYyBvdmVyIGBzdHJpcF9oZXJlZG9jYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCjw8RU9TLnN0cmlwX2hlcmVkb2MKICBzb21lIHRleHQKRU9TCgojIGJhZAo8PC1FT1Muc3RyaXBfaGVyZWRvYwogIHNvbWUgdGV4dApFT1MKCiMgZ29vZAo8PH5FT1MKICBzb21lIHRleHQKRU9TCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNwcmVmZXItc3F1aWdnbHktaGVyZWRvYwoKPT0gUmFpbHMvVGFibGVOYW1lQXNzaWdubWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDIuMTQKfCAtCnw9PT0KCkVuZm9yY2VzIHRoZSBhYnNlbmNlIG9mIGV4cGxpY2l0IHRhYmxlIG5hbWUgYXNzaWdubWVudC4KCmBzZWxmLnRhYmxlX25hbWU9YCBzaG91bGQgb25seSBiZSB1c2VkIGZvciB2ZXJ5IGdvb2QgcmVhc29ucywKc3VjaCBhcyBub3QgaGF2aW5nIGNvbnRyb2wgb3ZlciB0aGUgZGF0YWJhc2UsIG9yIHdvcmtpbmcKb24gYSBsZWdhY3kgcHJvamVjdC4KCklmIHlvdSBuZWVkIHRvIGNoYW5nZSBob3cgeW91ciBtb2RlbCdzIG5hbWUgaXMgdHJhbnNsYXRlZCB0bwphIHRhYmxlIG5hbWUsIHlvdSBtYXkgd2FudCB0byBsb29rIGF0IEluZmxlY3Rpb25zOgpodHRwczovL2FwaS5ydWJ5b25yYWlscy5vcmcvY2xhc3Nlcy9BY3RpdmVTdXBwb3J0L0luZmxlY3Rvci9JbmZsZWN0aW9ucy5odG1sCgpJZiB5b3Ugd2lzaCB0byBhZGQgYSBwcmVmaXggaW4gZnJvbnQgb2YgeW91ciBtb2RlbCwgb3Igd2lzaCB0byBjaGFuZ2UKdGhlIGRlZmF1bHQgcHJlZml4LCBgc2VsZi50YWJsZV9uYW1lX3ByZWZpeGAgbWlnaHQgYmV0dGVyIHN1aXQgeW91ciBuZWVkczoKaHR0cHM6Ly9hcGkucnVieW9ucmFpbHMub3JnL2NsYXNzZXMvQWN0aXZlUmVjb3JkL01vZGVsU2NoZW1hLmh0bWwjbWV0aG9kLWMtdGFibGVfbmFtZV9wcmVmaXgtM0QKClNUSSBiYXNlIGNsYXNzZXMgbmFtZWQgYEJhc2VgIGFyZSBpZ25vcmVkIGJ5IHRoaXMgY29wLgpGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9hcGkucnVieW9ucmFpbHMub3JnL2NsYXNzZXMvQWN0aXZlUmVjb3JkL0luaGVyaXRhbmNlLmh0bWwKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnNlbGYudGFibGVfbmFtZSA9ICdzb21lX3RhYmxlX25hbWUnCnNlbGYudGFibGVfbmFtZSA9IDpzb21lX290aGVyX25hbWUKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK2FwcC9tb2RlbHMvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2tlZXAtYXItZGVmYXVsdHMKCj09IFJhaWxzL1RocmVlU3RhdGVCb29sZWFuQ29sdW1uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjE5CnwgLQp8PT09CgpFbmZvcmNlcyB0aGF0IGJvb2xlYW4gY29sdW1ucyBhcmUgY3JlYXRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzIChgZmFsc2VgIG9yIGB0cnVlYCkgYW5kCmBOT1QgTlVMTGAgY29uc3RyYWludC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFkZF9jb2x1bW4gOnVzZXJzLCA6YWN0aXZlLCA6Ym9vbGVhbgp0LmNvbHVtbiA6YWN0aXZlLCA6Ym9vbGVhbgp0LmJvb2xlYW4gOmFjdGl2ZQoKIyBnb29kCmFkZF9jb2x1bW4gOnVzZXJzLCA6YWN0aXZlLCA6Ym9vbGVhbiwgZGVmYXVsdDogdHJ1ZSwgbnVsbDogZmFsc2UKdC5jb2x1bW4gOmFjdGl2ZSwgOmJvb2xlYW4sIGRlZmF1bHQ6IHRydWUsIG51bGw6IGZhbHNlCnQuYm9vbGVhbiA6YWN0aXZlLCBkZWZhdWx0OiB0cnVlLCBudWxsOiBmYWxzZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArZGIvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI3RocmVlLXN0YXRlLWJvb2xlYW4KCj09IFJhaWxzL1RpbWVab25lCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMC4zMAp8IDIuMTMKfD09PQoKQ2hlY2tzIGZvciB0aGUgdXNlIG9mIFRpbWUgbWV0aG9kcyB3aXRob3V0IHpvbmUuCgpCdWlsdCBvbiB0b3Agb2YgUnVieSBvbiBSYWlscyBzdHlsZSBndWlkZSAoaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjdGltZSkKYW5kIHRoZSBhcnRpY2xlIGh0dHA6Ly9kYW5pbGVua28ub3JnLzIwMTIvNy82L3JhaWxzX3RpbWV6b25lcy8KClR3byBzdHlsZXMgYXJlIHN1cHBvcnRlZCBmb3IgdGhpcyBjb3AuIFdoZW4gYEVuZm9yY2VkU3R5bGVgIGlzICdzdHJpY3QnCnRoZW4gb25seSB1c2Ugb2YgYFRpbWUuem9uZWAgaXMgYWxsb3dlZC4KCldoZW4gRW5mb3JjZWRTdHlsZSBpcyAnZmxleGlibGUnIHRoZW4gaXQncyBhbHNvIGFsbG93ZWQKdG8gdXNlIGBUaW1lI2luX3RpbWVfem9uZWAuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCdzIGF1dG9jb3JyZWN0aW9uIGlzIHVuc2FmZSBiZWNhdXNlIGl0IG1heSBjaGFuZ2UgaGFuZGxpbmcgdGltZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClRpbWUubm93ClRpbWUucGFyc2UoJzIwMTUtMDMtMDJUMTk6MDU6MzcnKQonMjAxNS0wMy0wMlQxOTowNTozNycudG9fdGltZQoKIyBnb29kClRpbWUuY3VycmVudApUaW1lLnpvbmUubm93ClRpbWUuem9uZS5wYXJzZSgnMjAxNS0wMy0wMlQxOTowNTozNycpClRpbWUuem9uZS5wYXJzZSgnMjAxNS0wMy0wMlQxOTowNTozN1onKSAjIFJlc3BlY3QgSVNPIDg2MDEgZm9ybWF0IHdpdGggdGltZXpvbmUgc3BlY2lmaWVyLgotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGZsZXhpYmxlIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYGZsZXhpYmxlYCBhbGxvd3MgdXNhZ2Ugb2YgYGluX3RpbWVfem9uZWAgaW5zdGVhZCBvZiBgem9uZWAuCgojIGdvb2QKVGltZS5hdCh0aW1lc3RhbXApLmluX3RpbWVfem9uZQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IHN0cmljdAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYHN0cmljdGAgbWVhbnMgdGhhdCBgVGltZWAgc2hvdWxkIGJlIHVzZWQgd2l0aCBgem9uZWAuCgojIGJhZApUaW1lLmF0KHRpbWVzdGFtcCkuaW5fdGltZV96b25lCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGZsZXhpYmxlYAp8IGBzdHJpY3RgLCBgZmxleGlibGVgCgp8IEV4Y2x1ZGUKfCBgKyoqLyouZ2Vtc3BlYytgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUjdGltZQoqIGh0dHA6Ly9kYW5pbGVua28ub3JnLzIwMTIvNy82L3JhaWxzX3RpbWV6b25lcwoKPT0gUmFpbHMvVGltZVpvbmVBc3NpZ25tZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjEwCnwgLQp8PT09CgpDaGVja3MgZm9yIHRoZSB1c2Ugb2YgYFRpbWUuem9uZT1gIG1ldGhvZC4KClRoZSBgem9uZWAgYXR0cmlidXRlIHBlcnNpc3RzIGZvciB0aGUgcmVzdCBvZiB0aGUgUnVieSBydW50aW1lLCBwb3RlbnRpYWxseSBjYXVzaW5nCnVuZXhwZWN0ZWQgYmVoYXZpb3IgYXQgYSBsYXRlciB0aW1lLgpVc2luZyBgVGltZS51c2Vfem9uZWAgZW5zdXJlcyB0aGUgY29kZSBwYXNzZWQgaW4gdGhlIGJsb2NrIGlzIHRoZSBvbmx5IHBsYWNlIFRpbWUuem9uZSBpcyBhZmZlY3RlZC4KSXQgZWxpbWluYXRlcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBgem9uZWAgc3RpY2tpbmcgYXJvdW5kIGxvbmdlciB0aGFuIGludGVuZGVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVGltZS56b25lID0gJ0VTVCcKCiMgZ29vZApUaW1lLnVzZV96b25lKCdFU1QnKSBkbwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgK3NwZWMvKiovKi5yYitgLCBgK3Rlc3QvKiovKi5yYitgCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly90aG91Z2h0Ym90LmNvbS9ibG9nL2l0cy1hYm91dC10aW1lLXpvbmVzCgo9PSBSYWlscy9Ub0Zvcm1hdHRlZFMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjE1CnwgLQp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgdXNlcyBvZiBgdG9fZnNgIG9yIGB0b19mb3JtYXR0ZWRfc2AsCmRlcGVuZGluZyBvbiB0aGUgY29wJ3MgY29uZmlndXJhdGlvbi4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiB0b19mcyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp0aW1lLnRvX2Zvcm1hdHRlZF9zKDpkYikKCiMgZ29vZAp0aW1lLnRvX2ZzKDpkYikKLS0tLQoKPT09PSBFbmZvcmNlZFN0eWxlOiB0b19mb3JtYXR0ZWRfcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnRpbWUudG9fZnMoOmRiKQoKIyBnb29kCnRpbWUudG9fZm9ybWF0dGVkX3MoOmRiKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGB0b19mc2AKfCBgdG9fZnNgLCBgdG9fZm9ybWF0dGVkX3NgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNwcmVmZXItdG8tZnMKCj09IFJhaWxzL1RvU1dpdGhBcmd1bWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgQWx3YXlzIChVbnNhZmUpCnwgMi4xNgp8IC0KfD09PQoKSWRlbnRpZmllcyBwYXNzaW5nIGFueSBhcmd1bWVudCB0byBgI3RvX3NgLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgbWFya2VkIGFzIHVuc2FmZSBiZWNhdXNlIGl0IG1heSBkZXRlY3QgYCN0b19zYCBjYWxscwp0aGF0IGFyZSBub3QgcmVsYXRlZCB0byBBY3RpdmUgU3VwcG9ydCBpbXBsZW1lbnRhdGlvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm9iai50b19zKDpkZWxpbWl0ZWQpCgojIGdvb2QKb2JqLnRvX2Zvcm1hdHRlZF9zKDpkZWxpbWl0ZWQpCi0tLS0KCj09IFJhaWxzL1RvcExldmVsSGFzaFdpdGhJbmRpZmZlcmVudEFjY2VzcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTYKfCAyLjE4Cnw9PT0KCklkZW50aWZpZXMgdG9wLWxldmVsIGBIYXNoV2l0aEluZGlmZmVyZW50QWNjZXNzYC4KVGhpcyBoYXMgYmVlbiBzb2Z0LWRlcHJlY2F0ZWQgc2luY2UgUmFpbHMgNS4xLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKSGFzaFdpdGhJbmRpZmZlcmVudEFjY2Vzcy5uZXcoZm9vOiAnYmFyJykKCiMgZ29vZApBY3RpdmVTdXBwb3J0OjpIYXNoV2l0aEluZGlmZmVyZW50QWNjZXNzLm5ldyhmb286ICdiYXInKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU2V2ZXJpdHkKfCBgd2FybmluZ2AKfCBTdHJpbmcKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9ndWlkZXMucnVieW9ucmFpbHMub3JnL3VwZ3JhZGluZ19ydWJ5X29uX3JhaWxzLmh0bWwjdG9wLWxldmVsLWhhc2h3aXRoaW5kaWZmZXJlbnRhY2Nlc3MtaXMtc29mdC1kZXByZWNhdGVkCgo9PSBSYWlscy9UcmFuc2FjdGlvbkV4aXRTdGF0ZW1lbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMTQKfCAtCnw9PT0KCkNoZWNrcyBmb3IgdGhlIHVzZSBvZiBleGl0IHN0YXRlbWVudHMgKG5hbWVseSBgcmV0dXJuYCwKYGJyZWFrYCBhbmQgYHRocm93YCkgaW4gdHJhbnNhY3Rpb25zLiBUaGlzIGlzIGR1ZSB0byB0aGUgZXZlbnR1YWwKdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHVzaW5nIEFjdGl2ZVJlY29yZCA+PSA3LCB3aGVyZSB0cmFuc2FjdGlvbnMKZXhpdGVkIHVzaW5nIHRoZXNlIHN0YXRlbWVudHMgYXJlIGJlaW5nIHJvbGxiYWNrZWQgcmF0aGVyIHRoYW4KY29tbWl0dGVkIChwcmUgQWN0aXZlUmVjb3JkIDcgYmVoYXZpb3IpLgoKQXMgYWx0ZXJuYXRpdmVzLCBpdCB3b3VsZCBiZSBtb3JlIGludHVpdGl2ZSB0byBleHBsaWNpdGx5IHJhaXNlIGFuCmVycm9yIHdoZW4gcm9sbGJhY2sgaXMgZGVzaXJlZCwgYW5kIHRvIHVzZSBgbmV4dGAgd2hlbiBjb21taXQgaXMKZGVzaXJlZC4KCklmIHlvdSBhcmUgZGVmaW5pbmcgY3VzdG9tIHRyYW5zYWN0aW9uIG1ldGhvZHMsIHlvdSBjYW4gY29uZmlndXJlIGl0IHdpdGggYFRyYW5zYWN0aW9uTWV0aG9kc2AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApBcHBsaWNhdGlvblJlY29yZC50cmFuc2FjdGlvbiBkbwogIHJldHVybiBpZiB1c2VyLmFjdGl2ZT8KZW5kCgojIGJhZApBcHBsaWNhdGlvblJlY29yZC50cmFuc2FjdGlvbiBkbwogIGJyZWFrIGlmIHVzZXIuYWN0aXZlPwplbmQKCiMgYmFkCkFwcGxpY2F0aW9uUmVjb3JkLnRyYW5zYWN0aW9uIGRvCiAgdGhyb3cgaWYgdXNlci5hY3RpdmU/CmVuZAoKIyBiYWQsIGFzIGB3aXRoX2xvY2tgIGltcGxpY2l0bHkgb3BlbnMgYSB0cmFuc2FjdGlvbiB0b28KdXNlci53aXRoX2xvY2sgZG8KICB0aHJvdyBpZiB1c2VyLmFjdGl2ZT8KZW5kCgojIGJhZCwgYXMgYHdpdGhfbG9ja2AgaW1wbGljaXRseSBvcGVucyBhIHRyYW5zYWN0aW9uIHRvbwpBcHBsaWNhdGlvblJlY29yZC53aXRoX2xvY2sgZG8KICBicmVhayBpZiB1c2VyLmFjdGl2ZT8KZW5kCgojIGdvb2QKQXBwbGljYXRpb25SZWNvcmQudHJhbnNhY3Rpb24gZG8KICAjIFJvbGxiYWNrCiAgcmFpc2UgIlVzZXIgaXMgYWN0aXZlIiBpZiB1c2VyLmFjdGl2ZT8KZW5kCgojIGdvb2QKQXBwbGljYXRpb25SZWNvcmQudHJhbnNhY3Rpb24gZG8KICAjIENvbW1pdAogIG5leHQgaWYgdXNlci5hY3RpdmU/CmVuZAotLS0tCgo9PT09IFRyYW5zYWN0aW9uTWV0aG9kczogWyJjdXN0b21fdHJhbnNhY3Rpb24iXQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCkN1c3RvbU1vZGVsLmN1c3RvbV90cmFuc2FjdGlvbiBkbwogIHJldHVybiBpZiB1c2VyLmFjdGl2ZT8KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBUcmFuc2FjdGlvbk1ldGhvZHMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9naXRodWIuY29tL3JhaWxzL3JhaWxzL2NvbW1pdC8xNWFhNDIwMGUwODMKCj09IFJhaWxzL1VuaXFCZWZvcmVQbHVjawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDAuNDAKfCAyLjEzCnw9PT0KClByZWZlciB1c2luZyBgZGlzdGluY3RgIGJlZm9yZSBgcGx1Y2tgIGluc3RlYWQgb2YgYHVuaXFgIGFmdGVyIGBwbHVja2AuCgpUaGUgdXNlIG9mIGRpc3RpbmN0IGJlZm9yZSBwbHVjayBpcyBwcmVmZXJyZWQgYmVjYXVzZSBpdCBleGVjdXRlcyBieQp0aGUgZGF0YWJhc2UuCgpUaGlzIGNvcCBoYXMgdHdvIGRpZmZlcmVudCBlbmZvcmNlbWVudCBtb2Rlcy4gV2hlbiB0aGUgRW5mb3JjZWRTdHlsZQppcyBgY29uc2VydmF0aXZlYCAodGhlIGRlZmF1bHQpLCB0aGVuIG9ubHkgY2FsbHMgdG8gYHBsdWNrYCBvbiBhIGNvbnN0YW50CihpLmUuIGEgbW9kZWwgY2xhc3MpIGJlZm9yZSBgdW5pcWAgYXJlIGFkZGVkIGFzIG9mZmVuc2VzLgoKV2hlbiB0aGUgRW5mb3JjZWRTdHlsZSBpcyBgYWdncmVzc2l2ZWAgdGhlbiBhbGwgY2FsbHMgdG8gYHBsdWNrYCBiZWZvcmUKZGlzdGluY3QgYXJlIGFkZGVkIGFzIG9mZmVuc2VzLiBUaGlzIG1heSBsZWFkIHRvIGZhbHNlIHBvc2l0aXZlcwphcyB0aGUgY29wIGNhbm5vdCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGNhbGxzIHRvIGBwbHVja2Agb24gYW4KQWN0aXZlUmVjb3JkOjpSZWxhdGlvbiB2cyBhIGNhbGwgdG8gcGx1Y2sgb24gYW4KQWN0aXZlUmVjb3JkOjpBc3NvY2lhdGlvbnM6OkNvbGxlY3Rpb25Qcm94eS4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBmb3IgYXV0b2NvcnJlY3Rpb24gYmVjYXVzZSB0aGUgYmVoYXZpb3IgbWF5IGNoYW5nZQpkZXBlbmRpbmcgb24gdGhlIGRhdGFiYXNlIGNvbGxhdGlvbi4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBjb25zZXJ2YXRpdmUgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSByZWR1bmRhbnRseSBmZXRjaGVzIGR1cGxpY2F0ZSB2YWx1ZXMKQWxidW0ucGx1Y2soOmJhbmRfbmFtZSkudW5pcQoKIyBnb29kCkFsYnVtLmRpc3RpbmN0LnBsdWNrKDpiYW5kX25hbWUpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogYWdncmVzc2l2ZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gcmVkdW5kYW50bHkgZmV0Y2hlcyBkdXBsaWNhdGUgdmFsdWVzCkFsYnVtLnBsdWNrKDpiYW5kX25hbWUpLnVuaXEKCiMgYmFkIC0gcmVkdW5kYW50bHkgZmV0Y2hlcyBkdXBsaWNhdGUgdmFsdWVzCkFsYnVtLndoZXJlKHllYXI6IDE5ODUpLnBsdWNrKDpiYW5kX25hbWUpLnVuaXEKCiMgYmFkIC0gcmVkdW5kYW50bHkgZmV0Y2hlcyBkdXBsaWNhdGUgdmFsdWVzCmN1c3RvbWVyLmZhdm91cml0ZXMucGx1Y2soOmNvbG9yKS51bmlxCgojIGdvb2QKQWxidW0uZGlzdGluY3QucGx1Y2soOmJhbmRfbmFtZSkKQWxidW0uZGlzdGluY3Qud2hlcmUoeWVhcjogMTk4NSkucGx1Y2soOmJhbmRfbmFtZSkKY3VzdG9tZXIuZmF2b3VyaXRlcy5kaXN0aW5jdC5wbHVjayg6Y29sb3IpCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGNvbnNlcnZhdGl2ZWAKfCBgY29uc2VydmF0aXZlYCwgYGFnZ3Jlc3NpdmVgCnw9PT0KCj09IFJhaWxzL1VuaXF1ZVZhbGlkYXRpb25XaXRob3V0SW5kZXgKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDIuNQp8IC0KfD09PQoKV2hlbiB5b3UgZGVmaW5lIGEgdW5pcXVlbmVzcyB2YWxpZGF0aW9uIGluIEFjdGl2ZSBSZWNvcmQgbW9kZWwsCnlvdSBhbHNvIHNob3VsZCBhZGQgYSB1bmlxdWUgaW5kZXggZm9yIHRoZSBjb2x1bW4uIFRoZXJlIGFyZSB0d28gcmVhc29ucy4KRmlyc3QsIGR1cGxpY2F0ZWQgcmVjb3JkcyBtYXkgb2NjdXIgZXZlbiBpZiBBY3RpdmUgUmVjb3JkJ3MgdmFsaWRhdGlvbgppcyBkZWZpbmVkLgpTZWNvbmQsIGl0IHdpbGwgY2F1c2Ugc2xvdyBxdWVyaWVzLiBUaGUgdmFsaWRhdGlvbiBleGVjdXRlcyBhIGBTRUxFQ1RgCnN0YXRlbWVudCB3aXRoIHRoZSB0YXJnZXQgY29sdW1uIHdoZW4gaW5zZXJ0aW5nL3VwZGF0aW5nIGEgcmVjb3JkLgpJZiB0aGUgY29sdW1uIGRvZXMgbm90IGhhdmUgYW4gaW5kZXggYW5kIHRoZSB0YWJsZSBpcyBsYXJnZSwKdGhlIHF1ZXJ5IHdpbGwgYmUgaGVhdnkuCgpOb3RlIHRoYXQgdGhlIGNvcCBkb2VzIG5vdGhpbmcgaWYgZGIvc2NoZW1hLnJiIGRvZXMgbm90IGV4aXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQgLSBpZiB0aGUgc2NoZW1hIGRvZXMgbm90IGhhdmUgYSB1bmlxdWUgaW5kZXgKdmFsaWRhdGVzIDphY2NvdW50LCB1bmlxdWVuZXNzOiB0cnVlCgojIGdvb2QgLSBpZiB0aGUgc2NoZW1hIGhhcyBhIHVuaXF1ZSBpbmRleAp2YWxpZGF0ZXMgOmFjY291bnQsIHVuaXF1ZW5lc3M6IHRydWUKCiMgZ29vZCAtIGV2ZW4gaWYgdGhlIHNjaGVtYSBkb2VzIG5vdCBoYXZlIGEgdW5pcXVlIGluZGV4CnZhbGlkYXRlcyA6YWNjb3VudCwgbGVuZ3RoOiB7IG1pbmltdW06IE1JTl9MRU5HVEggfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgSW5jbHVkZQp8IGArYXBwL21vZGVscy8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PSBSYWlscy9Vbmtub3duRW52Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAwLjUxCnwgMi4xOAp8PT09CgpDaGVja3MgdGhhdCBlbnZpcm9ubWVudHMgY2FsbGVkIHdpdGggYFJhaWxzLmVudmAgcHJlZGljYXRlcwpleGlzdC4KQnkgZGVmYXVsdCB0aGUgY29wIGFsbG93cyB0aHJlZSBlbnZpcm9ubWVudHMgd2hpY2ggUmFpbHMgc2hpcHMgd2l0aDoKYGRldmVsb3BtZW50YCwgYHRlc3RgLCBhbmQgYHByb2R1Y3Rpb25gLgpNb3JlIGNhbiBiZSBhZGRlZCB0byB0aGUgYEVudmlyb25tZW50c2AgY29uZmlnIHBhcmFtZXRlci4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJhaWxzLmVudi5wcm91ZGN0aW9uPwpSYWlscy5lbnYgPT0gJ3Byb3VkY3Rpb24nCgojIGdvb2QKUmFpbHMuZW52LnByb2R1Y3Rpb24/ClJhaWxzLmVudiA9PSAncHJvZHVjdGlvbicKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFNldmVyaXR5CnwgYHdhcm5pbmdgCnwgU3RyaW5nCgp8IEVudmlyb25tZW50cwp8IGBkZXZlbG9wbWVudGAsIGB0ZXN0YCwgYHByb2R1Y3Rpb25gCnwgQXJyYXkKfD09PQoKPT0gUmFpbHMvVW51c2VkSWdub3JlZENvbHVtbnMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgTm8KfCAyLjExCnwgMi4yNQp8PT09CgpTdWdnZXN0cyB5b3UgcmVtb3ZlIGEgY29sdW1uIHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHNjaGVtYSBmcm9tIGBpZ25vcmVkX2NvbHVtbnNgLgpgaWdub3JlZF9jb2x1bW5zYCBpcyBuZWNlc3NhcnkgdG8gZHJvcCBhIGNvbHVtbiBmcm9tIFJEQk1TLCBidXQgeW91IGRvbid0IG5lZWQgaXQgYWZ0ZXIgdGhlIG1pZ3JhdGlvbgp0byBkcm9wIHRoZSBjb2x1bW4uIFlvdSBhdm9pZCBmb3JnZXR0aW5nIHRvIHJlbW92ZSBgaWdub3JlZF9jb2x1bW5zYCBieSB0aGlzIGNvcC4KCklNUE9SVEFOVDogVGhpcyBjb3AgY2FuJ3QgYmUgdXNlZCB0byBlZmZlY3RpdmVseSBjaGVjayBmb3IgdW51c2VkIGNvbHVtbnMgYmVjYXVzZSB0aGUgZGV2ZWxvcG1lbnQKYW5kIHByb2R1Y3Rpb24gc2NoZW1hIGNhbiBiZSBvdXQgb2Ygc3luYyB1bnRpbCB0aGUgbWlncmF0aW9uIGhhcyBiZWVuIHJ1biBvbiBwcm9kdWN0aW9uLiBBcyBzdWNoLAp0aGlzIGNvcCBjYW4gY2F1c2UgYGlnbm9yZWRfY29sdW1uc2AgdG8gYmUgcmVtb3ZlZCBldmVuIHRob3VnaCB0aGUgcHJvZHVjdGlvbiBzY2hlbWEgc3RpbGwgY29udGFpbnMKdGhlIGNvbHVtbiwgd2hpY2ggY2FuIGxlYWQgdG8gZG93bnRpbWUgd2hlbiB0aGUgbWlncmF0aW9uIGlzIGFjdHVhbGx5IGV4ZWN1dGVkLiBPbmx5IGVuYWJsZSB0aGlzIGNvcAppZiB5b3Uga25vdyB5b3VyIG1pZ3JhdGlvbnMgd2lsbCBiZSBydW4gYmVmb3JlIGFueSBvZiB5b3VyIFJhaWxzIGFwcGxpY2F0aW9ucyBib290IHdpdGggdGhlIG1vZGlmaWVkIGNvZGUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjbGFzcyBVc2VyIDwgQXBwbGljYXRpb25SZWNvcmQKICBzZWxmLmlnbm9yZWRfY29sdW1ucyA9IFs6YWxyZWFkeV9yZW1vdmVkX2NvbHVtbl0KZW5kCgojIGdvb2QKY2xhc3MgVXNlciA8IEFwcGxpY2F0aW9uUmVjb3JkCiAgc2VsZi5pZ25vcmVkX2NvbHVtbnMgPSBbOnN0aWxsX2V4aXN0aW5nX2NvbHVtbl0KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbW9kZWxzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL1VudXNlZFJlbmRlckNvbnRlbnQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMjEKfCAtCnw9PT0KCklmIHlvdSB0cnkgdG8gcmVuZGVyIGNvbnRlbnQgYWxvbmcgd2l0aCBhIG5vbi1jb250ZW50IHN0YXR1cyBjb2RlICgxMDAtMTk5LCAyMDQsIDIwNSwgb3IgMzA0KSwKaXQgd2lsbCBiZSBkcm9wcGVkIGZyb20gdGhlIHJlc3BvbnNlLgoKVGhpcyBjb3AgY2hlY2tzIGZvciB1c2VzIG9mIGByZW5kZXJgIHdoaWNoIHNwZWNpZnkgYm90aCBib2R5IGNvbnRlbnQgYW5kIGEgbm9uLWNvbnRlbnQgc3RhdHVzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKcmVuZGVyICdmb28nLCBzdGF0dXM6IDpjb250aW51ZQpyZW5kZXIgc3RhdHVzOiAxMDAsIHBsYWluOiAnUnVieSEnCgojIGdvb2QKaGVhZCA6Y29udGludWUKaGVhZCAxMDAKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFNldmVyaXR5CnwgYHdhcm5pbmdgCnwgU3RyaW5nCnw9PT0KCj09IFJhaWxzL1ZhbGlkYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAwLjkKfCAwLjQxCnw9PT0KCkNoZWNrcyBmb3IgdGhlIHVzZSBvZiBvbGQtc3R5bGUgYXR0cmlidXRlIHZhbGlkYXRpb24gbWFjcm9zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKdmFsaWRhdGVzX2FjY2VwdGFuY2Vfb2YgOmZvbwp2YWxpZGF0ZXNfY29uZmlybWF0aW9uX29mIDpmb28KdmFsaWRhdGVzX2V4Y2x1c2lvbl9vZiA6Zm9vCnZhbGlkYXRlc19mb3JtYXRfb2YgOmZvbwp2YWxpZGF0ZXNfaW5jbHVzaW9uX29mIDpmb28KdmFsaWRhdGVzX2xlbmd0aF9vZiA6Zm9vCnZhbGlkYXRlc19udW1lcmljYWxpdHlfb2YgOmZvbwp2YWxpZGF0ZXNfcHJlc2VuY2Vfb2YgOmZvbwp2YWxpZGF0ZXNfYWJzZW5jZV9vZiA6Zm9vCnZhbGlkYXRlc19zaXplX29mIDpmb28KdmFsaWRhdGVzX3VuaXF1ZW5lc3Nfb2YgOmZvbwoKIyBnb29kCnZhbGlkYXRlcyA6Zm9vLCBhY2NlcHRhbmNlOiB0cnVlCnZhbGlkYXRlcyA6Zm9vLCBjb25maXJtYXRpb246IHRydWUKdmFsaWRhdGVzIDpmb28sIGV4Y2x1c2lvbjogdHJ1ZQp2YWxpZGF0ZXMgOmZvbywgZm9ybWF0OiB0cnVlCnZhbGlkYXRlcyA6Zm9vLCBpbmNsdXNpb246IHRydWUKdmFsaWRhdGVzIDpmb28sIGxlbmd0aDogdHJ1ZQp2YWxpZGF0ZXMgOmZvbywgbnVtZXJpY2FsaXR5OiB0cnVlCnZhbGlkYXRlcyA6Zm9vLCBwcmVzZW5jZTogdHJ1ZQp2YWxpZGF0ZXMgOmZvbywgYWJzZW5jZTogdHJ1ZQp2YWxpZGF0ZXMgOmZvbywgbGVuZ3RoOiB0cnVlCnZhbGlkYXRlcyA6Zm9vLCB1bmlxdWVuZXNzOiB0cnVlCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCthcHAvbW9kZWxzLyoqLyoucmIrYAp8IEFycmF5Cnw9PT0KCj09IFJhaWxzL1doZXJlRXF1YWxzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMi45CnwgMi4xMAp8PT09CgpJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBtYW51YWxseSBjb25zdHJ1Y3RlZCBTUUwKaW4gYHdoZXJlYCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgd2hlcmUoYXR0cmlidXRlOiB2YWx1ZSlgLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AncyBhdXRvY29ycmVjdGlvbiBpcyB1bnNhZmUgYmVjYXVzZSBpcyBtYXkgY2hhbmdlIFNRTC4KU2VlOiBodHRwczovL2dpdGh1Yi5jb20vcnVib2NvcC9ydWJvY29wLXJhaWxzL2lzc3Vlcy80MDMKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClVzZXIud2hlcmUoJ25hbWUgPSA/JywgJ0dhYmUnKQpVc2VyLndoZXJlKCduYW1lID0gOm5hbWUnLCBuYW1lOiAnR2FiZScpClVzZXIud2hlcmUoJ25hbWUgSVMgTlVMTCcpClVzZXIud2hlcmUoJ25hbWUgSU4gKD8pJywgWydqb2huJywgJ2phbmUnXSkKVXNlci53aGVyZSgnbmFtZSBJTiAoOm5hbWVzKScsIG5hbWVzOiBbJ2pvaG4nLCAnamFuZSddKQpVc2VyLndoZXJlKCd1c2Vycy5uYW1lID0gOm5hbWUnLCBuYW1lOiAnR2FiZScpCgojIGdvb2QKVXNlci53aGVyZShuYW1lOiAnR2FiZScpClVzZXIud2hlcmUobmFtZTogbmlsKQpVc2VyLndoZXJlKG5hbWU6IFsnam9obicsICdqYW5lJ10pClVzZXIud2hlcmUodXNlcnM6IHsgbmFtZTogJ0dhYmUnIH0pCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNoYXNoLWNvbmRpdGlvbnMKCj09IFJhaWxzL1doZXJlRXhpc3RzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMi43CnwgMi4xMAp8PT09CgpFbmZvcmNlcyBjb25zaXN0ZW50IHN0eWxlIHdoZW4gdXNpbmcgYGV4aXN0cz9gLgoKVHdvIHN0eWxlcyBhcmUgc3VwcG9ydGVkIGZvciB0aGlzIGNvcC4gV2hlbiBFbmZvcmNlZFN0eWxlIGlzICdleGlzdHMnCnRoZW4gdGhlIGNvcCBlbmZvcmNlcyBgZXhpc3RzPyguLi4pYCBvdmVyIGB3aGVyZSguLi4pLmV4aXN0cz9gLgoKV2hlbiBFbmZvcmNlZFN0eWxlIGlzICd3aGVyZScgdGhlbiB0aGUgY29wIGVuZm9yY2VzCmB3aGVyZSguLi4pLmV4aXN0cz9gIG92ZXIgYGV4aXN0cz8oLi4uKWAuCgo9PT0gU2FmZXR5CgpUaGlzIGNvcCBpcyB1bnNhZmUgZm9yIGF1dG9jb3JyZWN0aW9uIGJlY2F1c2UgdGhlIGJlaGF2aW9yIG1heSBjaGFuZ2Ugb24gdGhlIGZvbGxvd2luZyBjYXNlOgoKW3NvdXJjZSxydWJ5XQotLS0tCkF1dGhvci5pbmNsdWRlcyg6YXJ0aWNsZXMpLndoZXJlKGFydGljbGVzOiB7aWQ6IGlkfSkuZXhpc3RzPwojPT4gUGVyZm9ybSBgZWFnZXJfbG9hZGAgYmVoYXZpb3IgKGBMRUZUIEpPSU5gIHF1ZXJ5KSBhbmQgZ2V0IHJlc3VsdC4KCkF1dGhvci5pbmNsdWRlcyg6YXJ0aWNsZXMpLmV4aXN0cz8oYXJ0aWNsZXM6IHtpZDogaWR9KQojPT4gUGVyZm9ybSBgcHJlbG9hZGAgYmVoYXZpb3IgYW5kIGBBY3RpdmVSZWNvcmQ6OlN0YXRlbWVudEludmFsaWRgIGVycm9yIG9jY3Vycy4KLS0tLQoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IGV4aXN0cyAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApVc2VyLndoZXJlKG5hbWU6ICdqb2huJykuZXhpc3RzPwpVc2VyLndoZXJlKFsnbmFtZSA9ID8nLCAnam9obiddKS5leGlzdHM/ClVzZXIud2hlcmUoJ25hbWUgPSA/JywgJ2pvaG4nKS5leGlzdHM/CnVzZXIucG9zdHMud2hlcmUocHVibGlzaGVkOiB0cnVlKS5leGlzdHM/CgojIGdvb2QKVXNlci5leGlzdHM/KG5hbWU6ICdqb2huJykKVXNlci53aGVyZSgnbGVuZ3RoKG5hbWUpID4gMTAnKS5leGlzdHM/CnVzZXIucG9zdHMuZXhpc3RzPyhwdWJsaXNoZWQ6IHRydWUpCi0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogd2hlcmUKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApVc2VyLmV4aXN0cz8obmFtZTogJ2pvaG4nKQpVc2VyLmV4aXN0cz8oWyduYW1lID0gPycsICdqb2huJ10pCnVzZXIucG9zdHMuZXhpc3RzPyhwdWJsaXNoZWQ6IHRydWUpCgojIGdvb2QKVXNlci53aGVyZShuYW1lOiAnam9obicpLmV4aXN0cz8KVXNlci53aGVyZShbJ25hbWUgPSA/JywgJ2pvaG4nXSkuZXhpc3RzPwpVc2VyLndoZXJlKCduYW1lID0gPycsICdqb2huJykuZXhpc3RzPwp1c2VyLnBvc3RzLndoZXJlKHB1Ymxpc2hlZDogdHJ1ZSkuZXhpc3RzPwpVc2VyLndoZXJlKCdsZW5ndGgobmFtZSkgPiAxMCcpLmV4aXN0cz8KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgZXhpc3RzYAp8IGBleGlzdHNgLCBgd2hlcmVgCnw9PT0KCj09IFJhaWxzL1doZXJlTWlzc2luZwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTYKfCAtCnw9PT0KClVzZSBgd2hlcmUubWlzc2luZyguLi4pYCB0byBmaW5kIG1pc3NpbmcgcmVsYXRpb25zaGlwIHJlY29yZHMuCgpUaGlzIGNvcCBpcyBlbmFibGVkIGluIFJhaWxzIDYuMSBvciBoaWdoZXIuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApQb3N0LmxlZnRfam9pbnMoOmF1dGhvcikud2hlcmUoYXV0aG9yczogeyBpZDogbmlsIH0pCgojIGdvb2QKUG9zdC53aGVyZS5taXNzaW5nKDphdXRob3IpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcmFpbHMucnVieXN0eWxlLmd1aWRlLyNmaW5kaW5nLW1pc3NpbmctcmVsYXRpb25zaGlwLXJlY29yZHMKCj09IFJhaWxzL1doZXJlTm90Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi44CnwgLQp8PT09CgpJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBtYW51YWxseSBjb25zdHJ1Y3RlZCBTUUwKaW4gYHdoZXJlYCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgd2hlcmUubm90KC4uLilgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKVXNlci53aGVyZSgnbmFtZSAhPSA/JywgJ0dhYmUnKQpVc2VyLndoZXJlKCduYW1lICE9IDpuYW1lJywgbmFtZTogJ0dhYmUnKQpVc2VyLndoZXJlKCduYW1lIDw+ID8nLCAnR2FiZScpClVzZXIud2hlcmUoJ25hbWUgPD4gOm5hbWUnLCBuYW1lOiAnR2FiZScpClVzZXIud2hlcmUoJ25hbWUgSVMgTk9UIE5VTEwnKQpVc2VyLndoZXJlKCduYW1lIE5PVCBJTiAoPyknLCBbJ2pvaG4nLCAnamFuZSddKQpVc2VyLndoZXJlKCduYW1lIE5PVCBJTiAoOm5hbWVzKScsIG5hbWVzOiBbJ2pvaG4nLCAnamFuZSddKQpVc2VyLndoZXJlKCd1c2Vycy5uYW1lICE9IDpuYW1lJywgbmFtZTogJ0dhYmUnKQoKIyBnb29kClVzZXIud2hlcmUubm90KG5hbWU6ICdHYWJlJykKVXNlci53aGVyZS5ub3QobmFtZTogbmlsKQpVc2VyLndoZXJlLm5vdChuYW1lOiBbJ2pvaG4nLCAnamFuZSddKQpVc2VyLndoZXJlLm5vdCh1c2VyczogeyBuYW1lOiAnR2FiZScgfSkKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yYWlscy5ydWJ5c3R5bGUuZ3VpZGUvI2hhc2gtY29uZGl0aW9ucwoKPT0gUmFpbHMvV2hlcmVOb3RXaXRoTXVsdGlwbGVDb25kaXRpb25zCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjE3CnwgMi4xOAp8PT09CgpJZGVudGlmaWVzIGNhbGxzIHRvIGB3aGVyZS5ub3RgIHdpdGggbXVsdGlwbGUgaGFzaCBhcmd1bWVudHMuCgpUaGUgYmVoYXZpb3Igb2YgYHdoZXJlLm5vdGAgY2hhbmdlZCBpbiBSYWlscyA2LjEuIFByaW9yIHRvIHRoZSBjaGFuZ2UsCmAud2hlcmUubm90KHRyYXNoZWQ6IHRydWUsIHJvbGU6ICdhZG1pbicpYCBldmFsdWF0ZWQgdG8KYFdIRVJFIHRyYXNoZWQgIT0gVFJVRSBBTkQgcm9sZSAhPSAnYWRtaW4nYC4KRnJvbSBSYWlscyA2LjEgb253YXJkcywgdGhpcyBleGVjdXRlcyB0aGUgcXVlcnkKYFdIRVJFIE5PVCAodHJhc2hlZCA9PSBUUlVFIEFORCByb2xlcyA9PSAnYWRtaW4nKWAuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApVc2VyLndoZXJlLm5vdCh0cmFzaGVkOiB0cnVlLCByb2xlOiAnYWRtaW4nKQpVc2VyLndoZXJlLm5vdCh0cmFzaGVkOiB0cnVlLCByb2xlOiBbJ21vZGVyYXRvcicsICdhZG1pbiddKQpVc2VyLmpvaW5zKDpwb3N0cykud2hlcmUubm90KHBvc3RzOiB7IHRyYXNoZWQ6IHRydWUsIHRpdGxlOiAnUmFpbHMnIH0pCgojIGdvb2QKVXNlci53aGVyZS5ub3QodHJhc2hlZDogdHJ1ZSkKVXNlci53aGVyZS5ub3Qocm9sZTogWydtb2RlcmF0b3InLCAnYWRtaW4nXSkKVXNlci53aGVyZS5ub3QodHJhc2hlZDogdHJ1ZSkud2hlcmUubm90KHJvbGU6IFsnbW9kZXJhdG9yJywgJ2FkbWluJ10pClVzZXIud2hlcmUubm90KCd0cmFzaGVkID0gPyBPUiByb2xlID0gPycsIHRydWUsICdhZG1pbicpCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBTZXZlcml0eQp8IGB3YXJuaW5nYAp8IFN0cmluZwp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZS8jd2hlcmUtbm90LXdpdGgtbXVsdGlwbGUtYXR0cmlidXRlcwoKPT0gUmFpbHMvV2hlcmVSYW5nZQoKTk9URTogUmVxdWlyZWQgUnVieSB2ZXJzaW9uOiAyLjYKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjI1CnwgLQp8PT09CgpJZGVudGlmaWVzIHBsYWNlcyB3aGVyZSBtYW51YWxseSBjb25zdHJ1Y3RlZCBTUUwKaW4gYHdoZXJlYCBjYW4gYmUgcmVwbGFjZWQgd2l0aCByYW5nZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApVc2VyLndoZXJlKCdhZ2UgPj0gPycsIDE4KQpVc2VyLndoZXJlLm5vdCgnYWdlID49ID8nLCAxOCkKVXNlci53aGVyZSgnYWdlIDwgPycsIDE4KQpVc2VyLndoZXJlKCdhZ2UgPj0gPyBBTkQgYWdlIDwgPycsIDE4LCAyMSkKVXNlci53aGVyZSgnYWdlID49IDpzdGFydCcsIHN0YXJ0OiAxOCkKVXNlci53aGVyZSgndXNlcnMuYWdlID49ID8nLCAxOCkKCiMgZ29vZApVc2VyLndoZXJlKGFnZTogMTguLikKVXNlci53aGVyZS5ub3QoYWdlOiAxOC4uKQpVc2VyLndoZXJlKGFnZTogLi4uMTgpClVzZXIud2hlcmUoYWdlOiAxOC4uLjIxKQpVc2VyLndoZXJlKHVzZXJzOiB7IGFnZTogMTguLiB9KQoKIyBnb29kCiMgVGhlcmUgYXJlIG5vIGJlZ2lubGVzcyByYW5nZXMgaW4gcnVieS4KVXNlci53aGVyZSgnYWdlID4gPycsIDE4KQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JhaWxzLnJ1YnlzdHlsZS5ndWlkZS8jd2hlcmUtcmFuZ2VzCg==
  recorded_at: Mon, 27 May 2024 05:30:44 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rails/v2.25.0/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '37130'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"da30a1ca0b0bc211467ba9a4d82a3ba8b7fd3e24345e01772340a05c2df033d5"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - B016:3DF3CA:13E2B1D:151AF60:66541A80
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:44 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230084-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787844.261454,VS0,VE211
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - dba6a547d133088b99522db395c4937b31055e93
      Expires:
      - Mon, 27 May 2024 05:35:44 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        # Common configuration.

        inherit_mode:
          merge:
            - Exclude

        AllCops:
          Exclude:
            - app/assets/**/*
            - bin/*
            # Exclude db/schema.rb and db/[CONFIGURATION_NAMESPACE]_schema.rb by default.
            # See: https://guides.rubyonrails.org/active_record_multiple_databases.html#setting-up-your-application
            - db/*schema.rb
            - log/**/*
            - public/**/*
            - storage/**/*
          # Enable checking Active Support extensions.
          # See: https://docs.rubocop.org/rubocop/configuration.html#enable-checking-active-support-extensions
          ActiveSupportExtensionsEnabled: true
          # What version of Rails is the inspected code using?  If a value is specified
          # for TargetRailsVersion then it is used.  Acceptable values are specified
          # as a float (i.e. 5.1); the patch version of Rails should not be included.
          # If TargetRailsVersion is not set, RuboCop will parse the Gemfile.lock or
          # gems.locked file to find the version of Rails that has been bound to the
          # application.  If neither of those files exist, RuboCop will use Rails 5.0
          # as the default.
          TargetRailsVersion: ~

        Lint/NumberConversion:
          # Add Rails' duration methods to the ignore list for `Lint/NumberConversion`
          # so that calling `to_i` on one of these does not register an offense.
          # See: https://github.com/rubocop/rubocop/issues/8950
          AllowedMethods:
            - ago
            - from_now
            - second
            - seconds
            - minute
            - minutes
            - hour
            - hours
            - day
            - days
            - week
            - weeks
            - fortnight
            - fortnights
            - in_milliseconds
          AllowedPatterns: []

        Lint/RedundantSafeNavigation:
          # Add `presence` and `present?` methods to the default of the RuboCop core.
          # https://github.com/rubocop/rubocop/blob/v1.51.0/config/default.yml#L2148-L2159
          AllowedMethods:
            - instance_of?
            - kind_of?
            - is_a?
            - eql?
            - respond_to?
            - equal?
            - presence
            - present?

        Lint/SafeNavigationChain:
          # Add `presence_in` method to the default of the RuboCop core:
          # https://github.com/rubocop/rubocop/blob/v1.56.0/config/default.yml#L2265-L2271
          AllowedMethods:
            - present?
            - blank?
            - presence
            - presence_in
            - try
            - try!
            - in?

        Rails:
          Enabled: true
          DocumentationBaseURL: https://docs.rubocop.org/rubocop-rails

        Rails/ActionControllerFlashBeforeRender:
          Description: 'Use `flash.now` instead of `flash` before `render`.'
          Enabled: 'pending'
          SafeAutoCorrect: false
          VersionAdded: '2.16'

        Rails/ActionControllerTestCase:
          Description: 'Use `ActionDispatch::IntegrationTest` instead of `ActionController::TestCase`.'
          StyleGuide: 'https://rails.rubystyle.guide/#integration-testing'
          Reference: 'https://api.rubyonrails.org/classes/ActionController/TestCase.html'
          Enabled: 'pending'
          SafeAutoCorrect: false
          VersionAdded: '2.14'
          Include:
            - '**/test/**/*.rb'

        Rails/ActionFilter:
          Description: 'Enforces consistent use of action filter methods.'
          Enabled: false
          VersionAdded: '0.19'
          VersionChanged: '2.22'
          EnforcedStyle: action
          SupportedStyles:
            - action
            - filter
          Include:
            - app/controllers/**/*.rb
            - app/mailers/**/*.rb

        Rails/ActionOrder:
          Description: 'Enforce consistent ordering of controller actions.'
          Enabled: pending
          VersionAdded: '2.17'
          ExpectedOrder:
            - index
            - show
            - new
            - edit
            - create
            - update
            - destroy
          Include:
            - app/controllers/**/*.rb

        Rails/ActiveRecordAliases:
          Description: >-
                          Avoid Active Record aliases:
                          Use `update` instead of `update_attributes`.
                          Use `update!` instead of `update_attributes!`.
          Enabled: true
          VersionAdded: '0.53'
          SafeAutoCorrect: false

        Rails/ActiveRecordCallbacksOrder:
          Description: 'Order callback declarations in the order in which they will be executed.'
          StyleGuide: 'https://rails.rubystyle.guide/#callbacks-order'
          Enabled: 'pending'
          VersionAdded: '2.7'
          Include:
            - app/models/**/*.rb

        Rails/ActiveRecordOverride:
          Description: >-
                          Check for overriding Active Record methods instead of using
                          callbacks.
          Enabled: true
          Severity: warning
          VersionAdded: '0.67'
          VersionChanged: '2.18'
          Include:
            - app/models/**/*.rb

        Rails/ActiveSupportAliases:
          Description: >-
                          Avoid ActiveSupport aliases of standard ruby methods:
                          `String#starts_with?`, `String#ends_with?`,
                          `Array#append`, `Array#prepend`.
          Enabled: true
          VersionAdded: '0.48'

        Rails/ActiveSupportOnLoad:
          Description: 'Use `ActiveSupport.on_load(...)` to patch Rails framework classes.'
          Enabled: 'pending'
          Reference:
            - 'https://api.rubyonrails.org/classes/ActiveSupport/LazyLoadHooks.html'
            - 'https://guides.rubyonrails.org/engines.html#available-load-hooks'
          SafeAutoCorrect: false
          VersionAdded: '2.16'
          VersionChanged: '2.24'

        Rails/AddColumnIndex:
          Description: >-
            Rails migrations don't make use of a given `index` key, but also
            doesn't given an error when it's used, so it makes it seem like an
            index might be used.
          Enabled: pending
          VersionAdded: '2.11'
          VersionChanged: '2.20'
          Include:
            - db/**/*.rb

        Rails/AfterCommitOverride:
          Description: >-
                          Enforces that there is only one call to `after_commit`
                          (and its aliases - `after_create_commit`, `after_update_commit`,
                          and `after_destroy_commit`) with the same callback name per model.
          Enabled: 'pending'
          VersionAdded: '2.8'

        Rails/ApplicationController:
          Description: 'Check that controllers subclass ApplicationController.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '2.4'
          VersionChanged: '2.5'

        Rails/ApplicationJob:
          Description: 'Check that jobs subclass ApplicationJob.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.49'
          VersionChanged: '2.5'

        Rails/ApplicationMailer:
          Description: 'Check that mailers subclass ApplicationMailer.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '2.4'
          VersionChanged: '2.5'

        Rails/ApplicationRecord:
          Description: 'Check that models subclass ApplicationRecord.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.49'
          VersionChanged: '2.5'

        Rails/ArelStar:
          Description: 'Enforces `Arel.star` instead of `"*"` for expanded columns.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '2.9'

        Rails/AssertNot:
          Description: 'Use `assert_not` instead of `assert !`.'
          Enabled: true
          VersionAdded: '0.56'
          Include:
            - '**/test/**/*'

        Rails/AttributeDefaultBlockValue:
          Description: 'Pass method call in block for attribute option `default`.'
          Enabled: pending
          VersionAdded: '2.9'
          Include:
            - 'app/models/**/*'

        Rails/BelongsTo:
          Description: >-
                          Use `optional: true` instead of `required: false` for
                          `belongs_to` relations.
          Reference:
            - https://guides.rubyonrails.org/5_0_release_notes.html
            - https://github.com/rails/rails/pull/18937
          Enabled: true
          VersionAdded: '0.62'

        Rails/Blank:
          Description: 'Enforces use of `blank?`.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.48'
          VersionChanged: '2.10'
          # Convert usages of `nil? || empty?` to `blank?`
          NilOrEmpty: true
          # Convert usages of `!present?` to `blank?`
          NotPresent: true
          # Convert usages of `unless present?` to `if blank?`
          UnlessPresent: true

        Rails/BulkChangeTable:
          Description: 'Check whether alter queries are combinable.'
          Reference:
            - https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table
            - https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
          Enabled: true
          VersionAdded: '0.57'
          VersionChanged: '2.20'
          Database: null
          SupportedDatabases:
            - mysql
            - postgresql
          Include:
            - db/**/*.rb

        Rails/CompactBlank:
          Description: 'Checks if collection can be blank-compacted with `compact_blank`.'
          Enabled: pending
          Safe: false
          VersionAdded: '2.13'

        Rails/ContentTag:
          Description: 'Use `tag.something` instead of `tag(:something)`.'
          Reference:
            - 'https://github.com/rubocop/rubocop-rails/issues/260'
            - 'https://github.com/rails/rails/issues/25195'
            - 'https://api.rubyonrails.org/classes/ActionView/Helpers/TagHelper.html#method-i-content_tag'
          Enabled: true
          VersionAdded: '2.6'
          VersionChanged: '2.12'
          # This `Exclude` config prevents false positives for `tag` calls to `has_one: tag` and Puma configuration:
          # https://puma.io/puma/Puma/DSL.html#tag-instance_method
          # No helpers are used in normal models and configs.
          Exclude:
            - app/models/**/*.rb
            - config/**/*.rb

        Rails/CreateTableWithTimestamps:
          Description: >-
                          Checks the migration for which timestamps are not included
                          when creating a new table.
          Enabled: true
          VersionAdded: '0.52'
          VersionChanged: '2.20'
          Include:
            - db/**/*.rb
          Exclude:
            # Respect the `active_storage_variant_records` table of `*_create_active_storage_tables.active_storage.rb`
            # and `*_create_active_storage_variant_records.active_storage.rb`
            # auto-generated by `bin/rails active_storage:install` even if `created_at` is not specified.
            - db/**/*_create_active_storage_tables.active_storage.rb
            - db/**/*_create_active_storage_variant_records.active_storage.rb

        Rails/DangerousColumnNames:
          Description: >-
                          Avoid dangerous column names.
          Enabled: pending
          Severity: warning
          VersionAdded: '2.21'
          Include:
            - 'db/**/*.rb'

        Rails/Date:
          Description: >-
                          Checks the correct usage of date aware methods,
                          such as Date.today, Date.current etc.
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.30'
          VersionChanged: '2.11'
          # The value `strict` disallows usage of `Date.today`, `Date.current`,
          # `Date#to_time` etc.
          # The value `flexible` allows usage of `Date.current`, `Date.yesterday`, etc
          # (but not `Date.today`) which are overridden by ActiveSupport to handle current
          # time zone.
          EnforcedStyle: flexible
          SupportedStyles:
            - strict
            - flexible
          AllowToTime: true

        Rails/DefaultScope:
          Description: 'Avoid use of `default_scope`.'
          Enabled: false
          VersionAdded: '2.7'

        Rails/Delegate:
          Description: 'Prefer delegate method for delegations.'
          Enabled: true
          VersionAdded: '0.21'
          VersionChanged: '0.50'
          # When set to true, using the target object as a prefix of the
          # method name without using the `delegate` method will be a
          # violation. When set to false, this case is legal.
          EnforceForPrefixed: true

        Rails/DelegateAllowBlank:
          Description: 'Do not use allow_blank as an option to delegate.'
          Enabled: true
          VersionAdded: '0.44'

        Rails/DeprecatedActiveModelErrorsMethods:
          Description: 'Avoid manipulating ActiveModel errors hash directly.'
          Enabled: pending
          Severity: warning
          Safe: false
          VersionAdded: '2.14'
          VersionChanged: '2.18'

        Rails/DotSeparatedKeys:
          Description: 'Enforces the use of dot-separated keys instead of `:scope` options in `I18n` translation methods.'
          StyleGuide: 'https://rails.rubystyle.guide/#dot-separated-keys'
          Enabled: pending
          VersionAdded: '2.15'

        Rails/DuplicateAssociation:
          Description: "Don't repeat associations in a model."
          Enabled: pending
          Severity: warning
          VersionAdded: '2.14'
          VersionChanged: '2.18'

        Rails/DuplicateScope:
          Description: 'Multiple scopes share this same where clause.'
          Enabled: pending
          Severity: warning
          VersionAdded: '2.14'
          VersionChanged: '2.18'

        Rails/DurationArithmetic:
          Description: 'Do not use duration as arithmetic operand with `Time.current`.'
          StyleGuide: 'https://rails.rubystyle.guide#duration-arithmetic'
          Enabled: pending
          VersionAdded: '2.13'

        Rails/DynamicFindBy:
          Description: 'Use `find_by` instead of dynamic `find_by_*`.'
          StyleGuide: 'https://rails.rubystyle.guide#find_by'
          Enabled: true
          Safe: false
          VersionAdded: '0.44'
          VersionChanged: '2.10'
          # The `Whitelist` has been deprecated, Please use `AllowedMethods` instead.
          Whitelist:
            - find_by_sql
            - find_by_token_for
          AllowedMethods:
            - find_by_sql
            - find_by_token_for
          AllowedReceivers:
            - Gem::Specification
            - page # Prevents a warning for `page.find_by_id`. See: https://github.com/rubocop/rubocop-rails/issues/778

        Rails/EagerEvaluationLogMessage:
          Description: 'Checks that blocks are used for interpolated strings passed to `Rails.logger.debug`.'
          Reference: 'https://guides.rubyonrails.org/debugging_rails_applications.html#impact-of-logs-on-performance'
          Enabled: pending
          VersionAdded: '2.11'

        Rails/EnumHash:
          Description: 'Prefer hash syntax over array syntax when defining enums.'
          StyleGuide: 'https://rails.rubystyle.guide#enums'
          Enabled: true
          VersionAdded: '2.3'
          Include:
            - app/models/**/*.rb

        Rails/EnumUniqueness:
          Description: 'Avoid duplicate integers in hash-syntax `enum` declaration.'
          Enabled: true
          VersionAdded: '0.46'
          Include:
            - app/models/**/*.rb

        Rails/EnvLocal:
          Description: 'Use `Rails.env.local?` instead of `Rails.env.development? || Rails.env.test?`.'
          Enabled: pending
          VersionAdded: '2.22'

        Rails/EnvironmentComparison:
          Description: "Favor `Rails.env.production?` over `Rails.env == 'production'`."
          Enabled: true
          VersionAdded: '0.52'

        Rails/EnvironmentVariableAccess:
          Description: 'Do not access `ENV` directly after initialization.'
          # TODO: Set to `pending` status in RuboCop Rails 2 series when migration doc will be written.
          Enabled: false
          VersionAdded: '2.10'
          VersionChanged: '2.24'
          Include:
            - app/**/*.rb
            - config/initializers/**/*.rb
            - lib/**/*.rb
          Exclude:
            - lib/**/*.rake
          AllowReads: false
          AllowWrites: false

        Rails/Exit:
          Description: >-
                          Favor `fail`, `break`, `return`, etc. over `exit` in
                          application or library code outside of Rake files to avoid
                          exits during unit testing or running in production.
          Enabled: true
          VersionAdded: '0.41'
          Include:
            - app/**/*.rb
            - config/**/*.rb
            - lib/**/*.rb
          Exclude:
            - lib/**/*.rake

        Rails/ExpandedDateRange:
          Description: 'Checks for expanded date range.'
          StyleGuide: 'https://rails.rubystyle.guide/#date-time-range'
          Enabled: pending
          VersionAdded: '2.11'

        Rails/FilePath:
          Description: 'Use `Rails.root.join` for file path joining.'
          Enabled: true
          VersionAdded: '0.47'
          VersionChanged: '2.4'
          EnforcedStyle: slashes
          SupportedStyles:
            - slashes
            - arguments

        Rails/FindBy:
          Description: 'Prefer find_by over where.first.'
          StyleGuide: 'https://rails.rubystyle.guide#find_by'
          Enabled: true
          VersionAdded: '0.30'
          VersionChanged: '2.21'
          IgnoreWhereFirst: true

        Rails/FindById:
          Description: >-
                        Favor the use of `find` over `where.take!`, `find_by!`, and `find_by_id!` when you
                        need to retrieve a single record by primary key when you expect it to be found.
          StyleGuide: 'https://rails.rubystyle.guide/#find'
          Enabled: 'pending'
          VersionAdded: '2.7'

        Rails/FindEach:
          Description: 'Prefer all.find_each over all.each.'
          StyleGuide: 'https://rails.rubystyle.guide#find-each'
          Enabled: true
          Safe: false
          VersionAdded: '0.30'
          VersionChanged: '2.21'
          AllowedMethods:
            # Methods that don't work well with `find_each`.
            - order
            - limit
            - select
            - lock
          AllowedPatterns: []

        Rails/FreezeTime:
          Description: 'Prefer `freeze_time` over `travel_to` with an argument of the current time.'
          StyleGuide: 'https://rails.rubystyle.guide/#freeze-time'
          Enabled: pending
          VersionAdded: '2.16'
          SafeAutoCorrect: false

        Rails/HasAndBelongsToMany:
          Description: 'Prefer has_many :through to has_and_belongs_to_many.'
          StyleGuide: 'https://rails.rubystyle.guide#has-many-through'
          Enabled: true
          VersionAdded: '0.12'
          Include:
            - app/models/**/*.rb

        Rails/HasManyOrHasOneDependent:
          Description: 'Define the dependent option to the has_many and has_one associations.'
          StyleGuide: 'https://rails.rubystyle.guide#has_many-has_one-dependent-option'
          Enabled: true
          VersionAdded: '0.50'
          Include:
            - app/models/**/*.rb

        Rails/HelperInstanceVariable:
          Description: 'Do not use instance variables in helpers.'
          Enabled: true
          VersionAdded: '2.0'
          Include:
            - app/helpers/**/*.rb

        Rails/HttpPositionalArguments:
          Description: 'Use keyword arguments instead of positional arguments in http method calls.'
          Enabled: true
          VersionAdded: '0.44'
          Include:
            - 'spec/**/*'
            - 'test/**/*'

        Rails/HttpStatus:
          Description: 'Enforces use of symbolic or numeric value to define HTTP status.'
          Enabled: true
          VersionAdded: '0.54'
          VersionChanged: '2.11'
          EnforcedStyle: symbolic
          SupportedStyles:
            - numeric
            - symbolic

        Rails/I18nLazyLookup:
          Description: 'Checks for places where I18n "lazy" lookup can be used.'
          StyleGuide: 'https://rails.rubystyle.guide/#lazy-lookup'
          Reference: 'https://guides.rubyonrails.org/i18n.html#lazy-lookup'
          Enabled: pending
          VersionAdded: '2.14'
          EnforcedStyle: lazy
          SupportedStyles:
            - lazy
            - explicit
          Include:
            - 'app/controllers/**/*.rb'

        Rails/I18nLocaleAssignment:
          Description: 'Prefer the usage of `I18n.with_locale` instead of manually updating `I18n.locale` value.'
          Enabled: 'pending'
          VersionAdded: '2.11'
          Include:
            - spec/**/*.rb
            - test/**/*.rb

        Rails/I18nLocaleTexts:
          Description: 'Enforces use of I18n and locale files instead of locale specific strings.'
          StyleGuide: 'https://rails.rubystyle.guide/#locale-texts'
          Enabled: pending
          VersionAdded: '2.14'

        Rails/IgnoredColumnsAssignment:
          Description: 'Looks for assignments of `ignored_columns` that override previous assignments.'
          StyleGuide: 'https://rails.rubystyle.guide/#append-ignored-columns'
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '2.17'

        Rails/IgnoredSkipActionFilterOption:
          Description: 'Checks that `if` and `only` (or `except`) are not used together as options of `skip_*` action filter.'
          Reference: 'https://api.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-_normalize_callback_options'
          Enabled: true
          VersionAdded: '0.63'
          Include:
            - app/controllers/**/*.rb
            - app/mailers/**/*.rb

        Rails/IndexBy:
          Description: 'Prefer `index_by` over `each_with_object`, `to_h`, or `map`.'
          Enabled: true
          VersionAdded: '2.5'
          VersionChanged: '2.8'

        Rails/IndexWith:
          Description: 'Prefer `index_with` over `each_with_object`, `to_h`, or `map`.'
          Enabled: true
          VersionAdded: '2.5'
          VersionChanged: '2.8'

        Rails/Inquiry:
          Description: "Prefer Ruby's comparison operators over Active Support's `Array#inquiry` and `String#inquiry`."
          StyleGuide: 'https://rails.rubystyle.guide/#inquiry'
          Enabled: 'pending'
          VersionAdded: '2.7'

        Rails/InverseOf:
          Description: 'Checks for associations where the inverse cannot be determined automatically.'
          Reference:
            - https://guides.rubyonrails.org/association_basics.html#bi-directional-associations
            - https://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#module-ActiveRecord::Associations::ClassMethods-label-Setting+Inverses
          Enabled: true
          VersionAdded: '0.52'
          IgnoreScopes: false
          Include:
            - app/models/**/*.rb

        Rails/LexicallyScopedActionFilter:
          Description: "Checks that methods specified in the filter's `only` or `except` options are explicitly defined in the class."
          StyleGuide: 'https://rails.rubystyle.guide#lexically-scoped-action-filter'
          Enabled: true
          Safe: false
          VersionAdded: '0.52'
          Include:
            - app/controllers/**/*.rb
            - app/mailers/**/*.rb

        Rails/LinkToBlank:
          Description: 'Checks that `link_to` with a `target: "_blank"` have a `rel: "noopener"` option passed to them.'
          Reference:
            - https://mathiasbynens.github.io/rel-noopener/
            - https://html.spec.whatwg.org/multipage/links.html#link-type-noopener
            - https://html.spec.whatwg.org/multipage/links.html#link-type-noreferrer
          Enabled: true
          VersionAdded: '0.62'

        Rails/MailerName:
          Description: 'Mailer should end with `Mailer` suffix.'
          StyleGuide: 'https://rails.rubystyle.guide/#mailer-name'
          Enabled: 'pending'
          SafeAutoCorrect: false
          VersionAdded: '2.7'
          Include:
            - app/mailers/**/*.rb

        Rails/MatchRoute:
          Description: >-
                          Don't use `match` to define any routes unless there is a need to map multiple request types
                          among [:get, :post, :patch, :put, :delete] to a single action using the `:via` option.
          StyleGuide: 'https://rails.rubystyle.guide/#no-match-routes'
          Enabled: 'pending'
          VersionAdded: '2.7'
          Include:
            - config/routes.rb
            - config/routes/**/*.rb

        Rails/MigrationClassName:
          Description: 'The class name of the migration should match its file name.'
          Enabled: pending
          VersionAdded: '2.14'
          VersionChanged: '2.20'
          Include:
            - db/**/*.rb

        Rails/NegateInclude:
          Description: 'Prefer `collection.exclude?(obj)` over `!collection.include?(obj)`.'
          StyleGuide: 'https://rails.rubystyle.guide#exclude'
          Enabled: 'pending'
          Safe: false
          VersionAdded: '2.7'
          VersionChanged: '2.9'

        Rails/NotNullColumn:
          Description: 'Do not add a NOT NULL column without a default value to existing tables.'
          Enabled: true
          VersionAdded: '0.43'
          VersionChanged: '2.20'
          Database: null
          SupportedDatabases:
            - mysql
          Include:
            - db/**/*.rb

        Rails/OrderById:
          Description: >-
                          Do not use the `id` column for ordering.
                          Use a timestamp column to order chronologically.
          StyleGuide: 'https://rails.rubystyle.guide/#order-by-id'
          Enabled: false
          VersionAdded: '2.8'

        Rails/Output:
          Description: 'Checks for calls to puts, print, etc.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.15'
          VersionChanged: '0.19'
          Include:
            - app/**/*.rb
            - config/**/*.rb
            - db/**/*.rb
            - lib/**/*.rb

        Rails/OutputSafety:
          Description: 'The use of `html_safe` or `raw` may be a security risk.'
          Enabled: true
          VersionAdded: '0.41'

        Rails/Pick:
          Description: 'Prefer `pick` over `pluck(...).first`.'
          StyleGuide: 'https://rails.rubystyle.guide#pick'
          Enabled: true
          Safe: false
          VersionAdded: '2.6'

        Rails/Pluck:
          Description: 'Prefer `pluck` over `map { ... }`.'
          StyleGuide: 'https://rails.rubystyle.guide#pluck'
          Enabled: 'pending'
          Safe: false
          VersionAdded: '2.7'
          VersionChanged: '2.18'

        Rails/PluckId:
          Description: 'Use `ids` instead of `pluck(:id)` or `pluck(primary_key)`.'
          StyleGuide: 'https://rails.rubystyle.guide/#ids'
          Enabled: false
          Safe: false
          VersionAdded: '2.7'

        Rails/PluckInWhere:
          Description: 'Use `select` instead of `pluck` in `where` query methods.'
          Enabled: 'pending'
          Safe: false
          VersionAdded: '2.7'
          VersionChanged: '2.8'
          EnforcedStyle: conservative
          SupportedStyles:
            - conservative
            - aggressive

        Rails/PluralizationGrammar:
          Description: 'Checks for incorrect grammar when using methods like `3.day.ago`.'
          Enabled: true
          VersionAdded: '0.35'

        Rails/Presence:
          Description: 'Checks code that can be written more easily using `Object#presence` defined by Active Support.'
          Enabled: true
          VersionAdded: '0.52'

        Rails/Present:
          Description: 'Enforces use of `present?`.'
          Enabled: true
          VersionAdded: '0.48'
          VersionChanged: '0.67'
          # Convert usages of `!nil? && !empty?` to `present?`
          NotNilAndNotEmpty: true
          # Convert usages of `!blank?` to `present?`
          NotBlank: true
          # Convert usages of `unless blank?` to `if present?`
          UnlessBlank: true

        Rails/RakeEnvironment:
          Description: 'Include `:environment` as a dependency for all Rake tasks.'
          Enabled: true
          Safe: false
          VersionAdded: '2.4'
          VersionChanged: '2.6'
          Include:
            - '**/Rakefile'
            - '**/*.rake'
          Exclude:
            - 'lib/capistrano/tasks/**/*.rake'

        Rails/ReadWriteAttribute:
          Description: >-
                         Checks for read_attribute(:attr) and
                         write_attribute(:attr, val).
          StyleGuide: 'https://rails.rubystyle.guide#read-attribute'
          Enabled: true
          VersionAdded: '0.20'
          VersionChanged: '0.29'
          Include:
            - app/models/**/*.rb

        Rails/RedundantActiveRecordAllMethod:
          Description: Detect redundant `all` used as a receiver for Active Record query methods.
          StyleGuide: 'https://rails.rubystyle.guide/#redundant-all'
          Enabled: pending
          Safe: false
          AllowedReceivers:
            - ActionMailer::Preview
            - ActiveSupport::TimeZone
          VersionAdded: '2.21'

        Rails/RedundantAllowNil:
          Description: >-
                         Finds redundant use of `allow_nil` when `allow_blank` is set to
                         certain values in model validations.
          Enabled: true
          VersionAdded: '0.67'
          Include:
            - app/models/**/*.rb

        Rails/RedundantForeignKey:
          Description: 'Checks for associations where the `:foreign_key` option is redundant.'
          Enabled: true
          VersionAdded: '2.6'

        Rails/RedundantPresenceValidationOnBelongsTo:
          Description: 'Checks for redundant presence validation on belongs_to association.'
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '2.13'

        Rails/RedundantReceiverInWithOptions:
          Description: 'Checks for redundant receiver in `with_options`.'
          Enabled: true
          VersionAdded: '0.52'

        Rails/RedundantTravelBack:
          Description: Checks for redundant `travel_back` calls.
          Enabled: pending
          VersionAdded: '2.12'
          Include:
            - spec/**/*.rb
            - test/**/*.rb

        Rails/ReflectionClassName:
          Description: 'Use a string for `class_name` option value in the definition of a reflection.'
          Enabled: true
          Safe: false
          VersionAdded: '0.64'
          VersionChanged: '2.10'

        Rails/RefuteMethods:
          Description: 'Use `assert_not` methods instead of `refute` methods.'
          Enabled: true
          VersionAdded: '0.56'
          EnforcedStyle: assert_not
          SupportedStyles:
            - assert_not
            - refute
          Include:
            - '**/test/**/*'

        Rails/RelativeDateConstant:
          Description: 'Do not assign relative date to constants.'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.48'
          VersionChanged: '2.13'

        Rails/RenderInline:
          Description: 'Prefer using a template over inline rendering.'
          StyleGuide: 'https://rails.rubystyle.guide/#inline-rendering'
          Enabled: 'pending'
          VersionAdded: '2.7'

        Rails/RenderPlainText:
          Description: 'Prefer `render plain:` over `render text:`.'
          StyleGuide: 'https://rails.rubystyle.guide/#plain-text-rendering'
          Enabled: 'pending'
          VersionAdded: '2.7'
          # Convert only when `content_type` is explicitly set to `text/plain`.
          ContentTypeCompatibility: true

        Rails/RequestReferer:
          Description: 'Use consistent syntax for request.referer.'
          Enabled: true
          VersionAdded: '0.41'
          EnforcedStyle: referer
          SupportedStyles:
            - referer
            - referrer

        Rails/RequireDependency:
          Description: 'Do not use `require_dependency` when running in Zeitwerk mode. `require_dependency` is for autoloading in classic mode.'
          Reference: 'https://guides.rubyonrails.org/autoloading_and_reloading_constants.html'
          Enabled: false
          VersionAdded: '2.10'

        Rails/ResponseParsedBody:
          Description: Prefer `response.parsed_body` to custom parsing logic for `response.body`.
          Enabled: pending
          Safe: false
          VersionAdded: '2.18'
          VersionChanged: '2.19'
          Include:
            - spec/controllers/**/*.rb
            - spec/requests/**/*.rb
            - test/controllers/**/*.rb
            - test/integration/**/*.rb

        Rails/ReversibleMigration:
          Description: 'Checks whether the change method of the migration file is reversible.'
          StyleGuide: 'https://rails.rubystyle.guide#reversible-migration'
          Reference: 'https://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html'
          Enabled: true
          VersionAdded: '0.47'
          VersionChanged: '2.13'
          Include:
            - db/**/*.rb

        Rails/ReversibleMigrationMethodDefinition:
          Description: 'Checks whether the migration implements either a `change` method or both an `up` and a `down` method.'
          Enabled: false
          VersionAdded: '2.10'
          VersionChanged: '2.13'
          Include:
            - db/**/*.rb

        Rails/RootJoinChain:
          Description: 'Use a single `#join` instead of chaining on `Rails.root` or `Rails.public_path`.'
          Enabled: pending
          VersionAdded: '2.13'

        Rails/RootPathnameMethods:
          Description: 'Use `Rails.root` IO methods instead of passing it to `File`.'
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '2.16'

        Rails/RootPublicPath:
          Description: "Favor `Rails.public_path` over `Rails.root` with `'public'`."
          Enabled: pending
          VersionAdded: '2.15'

        Rails/SafeNavigation:
          Description: "Use Ruby's safe navigation operator (`&.`) instead of `try!`."
          Enabled: true
          VersionAdded: '0.43'
          # This will convert usages of `try` to use safe navigation as well as `try!`.
          # `try` and `try!` work slightly differently. `try!` and safe navigation will
          # both raise a `NoMethodError` if the receiver of the method call does not
          # implement the intended method. `try` will not raise an exception for this.
          ConvertTry: false

        Rails/SafeNavigationWithBlank:
          Description: 'Avoid `foo&.blank?` in conditionals.'
          Enabled: true
          VersionAdded: '2.4'
          # While the safe navigation operator is generally a good idea, when
          # checking `foo&.blank?` in a conditional, `foo` being `nil` will actually
          # do the opposite of what the author intends.
          #
          # foo&.blank? #=> nil
          # foo.blank? #=> true
          SafeAutoCorrect: false

        Rails/SaveBang:
          Description: 'Identifies possible cases where Active Record save! or related should be used.'
          StyleGuide: 'https://rails.rubystyle.guide#save-bang'
          Enabled: false
          VersionAdded: '0.42'
          VersionChanged: '0.59'
          AllowImplicitReturn: true
          AllowedReceivers: []
          SafeAutoCorrect: false

        Rails/SchemaComment:
          Description: >-
            Enforces the use of the `comment` option when adding a new table or column
            to the database during a migration.
          Enabled: false
          VersionAdded: '2.13'

        Rails/ScopeArgs:
          Description: 'Checks the arguments of ActiveRecord scopes.'
          Enabled: true
          VersionAdded: '0.19'
          VersionChanged: '2.12'
          Include:
            - app/models/**/*.rb

        Rails/SelectMap:
          Description: 'Checks for uses of `select(:column_name)` with `map(&:column_name)`.'
          Enabled: pending
          Safe: false
          VersionAdded: '2.21'

        Rails/ShortI18n:
          Description: 'Use the short form of the I18n methods: `t` instead of `translate` and `l` instead of `localize`.'
          StyleGuide: 'https://rails.rubystyle.guide/#short-i18n'
          Enabled: 'pending'
          VersionAdded: '2.7'
          EnforcedStyle: conservative
          SupportedStyles:
            - conservative
            - aggressive

        Rails/SkipsModelValidations:
          Description: >-
                         Use methods that skips model validations with caution.
                         See reference for more information.
          Reference: 'https://guides.rubyonrails.org/active_record_validations.html#skipping-validations'
          Enabled: true
          VersionAdded: '0.47'
          VersionChanged: '2.7'
          ForbiddenMethods:
            - decrement!
            - decrement_counter
            - increment!
            - increment_counter
            - insert
            - insert!
            - insert_all
            - insert_all!
            - toggle!
            - touch
            - touch_all
            - update_all
            - update_attribute
            - update_column
            - update_columns
            - update_counters
            - upsert
            - upsert_all
          AllowedMethods: []

        Rails/SquishedSQLHeredocs:
          Description: 'Checks SQL heredocs to use `.squish`.'
          StyleGuide: 'https://rails.rubystyle.guide/#squished-heredocs'
          Enabled: 'pending'
          VersionAdded: '2.8'
          VersionChanged: '2.9'
          # Some SQL syntax (e.g. PostgreSQL comments and functions) requires newlines
          # to be preserved in order to work, thus autocorrection is not safe.
          SafeAutoCorrect: false

        Rails/StripHeredoc:
          Description: 'Enforces the use of squiggly heredoc over `strip_heredoc`.'
          StyleGuide: 'https://rails.rubystyle.guide/#prefer-squiggly-heredoc'
          Enabled: pending
          VersionAdded: '2.15'

        Rails/TableNameAssignment:
          Description: >-
            Do not use `self.table_name =`. Use Inflections or `table_name_prefix` instead.
          StyleGuide: 'https://rails.rubystyle.guide/#keep-ar-defaults'
          Enabled: false
          VersionAdded: '2.14'
          Include:
            - app/models/**/*.rb

        Rails/ThreeStateBooleanColumn:
          Description: 'Add a default value and a `NOT NULL` constraint to boolean columns.'
          StyleGuide: 'https://rails.rubystyle.guide/#three-state-boolean'
          Enabled: pending
          VersionAdded: '2.19'
          Include:
            - db/**/*.rb

        Rails/TimeZone:
          Description: 'Checks the correct usage of time zone aware methods.'
          StyleGuide: 'https://rails.rubystyle.guide#time'
          Reference: 'http://danilenko.org/2012/7/6/rails_timezones'
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '0.30'
          VersionChanged: '2.13'
          # The value `strict` means that `Time` should be used with `zone`.
          # The value `flexible` allows usage of `in_time_zone` instead of `zone`.
          EnforcedStyle: flexible
          SupportedStyles:
            - strict
            - flexible
          Exclude:
            - '**/*.gemspec'

        Rails/TimeZoneAssignment:
          Description: 'Prefer the usage of `Time.use_zone` instead of manually updating `Time.zone` value.'
          Reference: 'https://thoughtbot.com/blog/its-about-time-zones'
          Enabled: 'pending'
          VersionAdded: '2.10'
          Include:
            - spec/**/*.rb
            - test/**/*.rb

        Rails/ToFormattedS:
          Description: 'Checks for consistent uses of `to_fs` or `to_formatted_s`.'
          StyleGuide: 'https://rails.rubystyle.guide/#prefer-to-fs'
          Enabled: pending
          EnforcedStyle: to_fs
          SupportedStyles:
            - to_fs
            - to_formatted_s
          VersionAdded: '2.15'

        Rails/ToSWithArgument:
          Description: 'Identifies passing any argument to `#to_s`.'
          Enabled: pending
          Safe: false
          VersionAdded: '2.16'

        Rails/TopLevelHashWithIndifferentAccess:
          Description: 'Identifies top-level `HashWithIndifferentAccess`.'
          Reference: 'https://guides.rubyonrails.org/upgrading_ruby_on_rails.html#top-level-hashwithindifferentaccess-is-soft-deprecated'
          Enabled: pending
          Severity: warning
          VersionAdded: '2.16'
          VersionChanged: '2.18'

        Rails/TransactionExitStatement:
          Description: 'Avoid the usage of `return`, `break` and `throw` in transaction blocks.'
          Reference:
            - https://github.com/rails/rails/commit/15aa4200e083
          Enabled: pending
          VersionAdded: '2.14'
          TransactionMethods: []

        Rails/UniqBeforePluck:
          Description: 'Prefer the use of uniq or distinct before pluck.'
          Enabled: true
          VersionAdded: '0.40'
          VersionChanged: '2.13'
          EnforcedStyle: conservative
          SupportedStyles:
            - conservative
            - aggressive
          SafeAutoCorrect: false

        Rails/UniqueValidationWithoutIndex:
          Description: 'Uniqueness validation should have a unique index on the database column.'
          Enabled: true
          VersionAdded: '2.5'
          Include:
            - app/models/**/*.rb

        Rails/UnknownEnv:
          Description: 'Use correct environment name.'
          Enabled: true
          Severity: warning
          VersionAdded: '0.51'
          VersionChanged: '2.18'
          Environments:
            - development
            - test
            - production

        Rails/UnusedIgnoredColumns:
          Description: 'Remove a column that does not exist from `ignored_columns`.'
          Enabled: false
          VersionAdded: '2.11'
          VersionChanged: '2.25'
          Include:
            - app/models/**/*.rb

        Rails/UnusedRenderContent:
          Description: 'Do not specify body content for a response with a non-content status code.'
          Enabled: pending
          Severity: warning
          VersionAdded: '2.21'

        Rails/Validation:
          Description: 'Use validates :attribute, hash of validations.'
          Enabled: true
          VersionAdded: '0.9'
          VersionChanged: '0.41'
          Include:
            - app/models/**/*.rb

        Rails/WhereEquals:
          Description: 'Pass conditions to `where` as a hash instead of manually constructing SQL.'
          StyleGuide: 'https://rails.rubystyle.guide/#hash-conditions'
          Enabled: 'pending'
          SafeAutoCorrect: false
          VersionAdded: '2.9'
          VersionChanged: '2.10'

        Rails/WhereExists:
          Description: 'Prefer `exists?(...)` over `where(...).exists?`.'
          Enabled: 'pending'
          SafeAutoCorrect: false
          EnforcedStyle: exists
          SupportedStyles:
            - exists
            - where
          VersionAdded: '2.7'
          VersionChanged: '2.10'

        Rails/WhereMissing:
          Description: 'Use `where.missing(...)` to find missing relationship records.'
          StyleGuide: 'https://rails.rubystyle.guide/#finding-missing-relationship-records'
          Enabled: pending
          VersionAdded: '2.16'

        Rails/WhereNot:
          Description: 'Use `where.not(...)` instead of manually constructing negated SQL in `where`.'
          StyleGuide: 'https://rails.rubystyle.guide/#hash-conditions'
          Enabled: 'pending'
          VersionAdded: '2.8'

        Rails/WhereNotWithMultipleConditions:
          Description: 'Do not use `where.not(...)` with multiple conditions.'
          StyleGuide: 'https://rails.rubystyle.guide/#where-not-with-multiple-attributes'
          Enabled: 'pending'
          Severity: warning
          VersionAdded: '2.17'
          VersionChanged: '2.18'

        Rails/WhereRange:
          Description: 'Use ranges in `where` instead of manually constructing SQL.'
          StyleGuide: 'https://rails.rubystyle.guide/#where-ranges'
          Enabled: pending
          VersionAdded: '2.25'

        # Accept `redirect_to(...) and return` and similar cases.
        Style/AndOr:
          EnforcedStyle: conditionals

        Style/FormatStringToken:
          AllowedMethods:
            - redirect

        Style/InvertibleUnlessCondition:
          InverseMethods:
            # Active Support defines some common inverse methods. They are listed below:
            :present?: :blank?
            :blank?: :present?
            :include?: :exclude?
            :exclude?: :include?

        Style/SymbolProc:
          AllowedMethods:
            - define_method
            - mail
            - respond_to
  recorded_at: Mon, 27 May 2024 05:30:44 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rake/v0.6.0/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 404
      message: Not Found
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '14'
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      Content-Type:
      - text/plain; charset=utf-8
      X-Github-Request-Id:
      - E852:23E66:13976E7:14D07F5:66541A84
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:44 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230028-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787845.610023,VS0,VE281
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - fc52291cbde63b95df4f110ce29de5ced8a97411
      Expires:
      - Mon, 27 May 2024 05:35:44 GMT
      Source-Age:
      - '0'
    body:
      encoding: UTF-8
      string: '404: Not Found'
  recorded_at: Mon, 27 May 2024 05:30:45 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rake/v0.6.0/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '764'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"4b8a901e70598d90259e6b4465c4dbb0145ef52a57bb20f10bd1975a7b7b92c8"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 9AB8:3F1A91:13E306E:151AE1E:66541A83
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:45 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230155-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787845.007577,VS0,VE201
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - b8b8df2aea0ec7ddef48b591be3fd1f54f8443f4
      Expires:
      - Mon, 27 May 2024 05:35:45 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        Rake:
          Enabled: true
          Include:
            - 'Rakefile'
            - '**/*.rake'

        Rake/ClassDefinitionInTask:
          Description: 'Do not define a class or module in rake task, because it will be defined to the top level.'
          Enabled: true
          VersionAdded: '0.3.0'

        Rake/Desc:
          Description: 'Describe the task with `desc` method.'
          Enabled: true
          VersionAdded: '0.1.0'

        Rake/DuplicateNamespace:
          Description: 'Do not define namespace with the same name'
          Enabled: true
          VersionAdded: '0.5.0'

        Rake/DuplicateTask:
          Description: 'Do not define tasks with the same name'
          Enabled: true
          VersionAdded: '0.4.0'

        Rake/MethodDefinitionInTask:
          Description: 'Do not define a method in rake task, because it will be defined to the top level.'
          Enabled: true
          VersionAdded: '0.2.0'
  recorded_at: Mon, 27 May 2024 05:30:45 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/docs/modules/ROOT/pages/cops.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '9595'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"9a078acd68374e4bf230b9ee14e312b4e2fec8a51c0a13ae8f6ede2d0f52a855"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - C548:37ABCC:1275921:139F489:66541A84
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:45 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230145-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787845.325159,VS0,VE249
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 57c8f27d9f5ccc65a6f798737ce4b8d69d63c705
      Expires:
      - Mon, 27 May 2024 05:35:45 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        // START_COP_LIST

        === Department xref:cops_rspec.adoc[RSpec]

        * xref:cops_rspec.adoc#rspecalignleftletbrace[RSpec/AlignLeftLetBrace]
        * xref:cops_rspec.adoc#rspecalignrightletbrace[RSpec/AlignRightLetBrace]
        * xref:cops_rspec.adoc#rspecanyinstance[RSpec/AnyInstance]
        * xref:cops_rspec.adoc#rspecaroundblock[RSpec/AroundBlock]
        * xref:cops_rspec.adoc#rspecbe[RSpec/Be]
        * xref:cops_rspec.adoc#rspecbeempty[RSpec/BeEmpty]
        * xref:cops_rspec.adoc#rspecbeeq[RSpec/BeEq]
        * xref:cops_rspec.adoc#rspecbeeql[RSpec/BeEql]
        * xref:cops_rspec.adoc#rspecbenil[RSpec/BeNil]
        * xref:cops_rspec.adoc#rspecbeforeafterall[RSpec/BeforeAfterAll]
        * xref:cops_rspec.adoc#rspecchangebyzero[RSpec/ChangeByZero]
        * xref:cops_rspec.adoc#rspecclasscheck[RSpec/ClassCheck]
        * xref:cops_rspec.adoc#rspeccontainexactly[RSpec/ContainExactly]
        * xref:cops_rspec.adoc#rspeccontextmethod[RSpec/ContextMethod]
        * xref:cops_rspec.adoc#rspeccontextwording[RSpec/ContextWording]
        * xref:cops_rspec.adoc#rspecdescribeclass[RSpec/DescribeClass]
        * xref:cops_rspec.adoc#rspecdescribemethod[RSpec/DescribeMethod]
        * xref:cops_rspec.adoc#rspecdescribesymbol[RSpec/DescribeSymbol]
        * xref:cops_rspec.adoc#rspecdescribedclass[RSpec/DescribedClass]
        * xref:cops_rspec.adoc#rspecdescribedclassmodulewrapping[RSpec/DescribedClassModuleWrapping]
        * xref:cops_rspec.adoc#rspecdialect[RSpec/Dialect]
        * xref:cops_rspec.adoc#rspecduplicatedmetadata[RSpec/DuplicatedMetadata]
        * xref:cops_rspec.adoc#rspecemptyexamplegroup[RSpec/EmptyExampleGroup]
        * xref:cops_rspec.adoc#rspecemptyhook[RSpec/EmptyHook]
        * xref:cops_rspec.adoc#rspecemptylineafterexample[RSpec/EmptyLineAfterExample]
        * xref:cops_rspec.adoc#rspecemptylineafterexamplegroup[RSpec/EmptyLineAfterExampleGroup]
        * xref:cops_rspec.adoc#rspecemptylineafterfinallet[RSpec/EmptyLineAfterFinalLet]
        * xref:cops_rspec.adoc#rspecemptylineafterhook[RSpec/EmptyLineAfterHook]
        * xref:cops_rspec.adoc#rspecemptylineaftersubject[RSpec/EmptyLineAfterSubject]
        * xref:cops_rspec.adoc#rspecemptymetadata[RSpec/EmptyMetadata]
        * xref:cops_rspec.adoc#rspecemptyoutput[RSpec/EmptyOutput]
        * xref:cops_rspec.adoc#rspeceq[RSpec/Eq]
        * xref:cops_rspec.adoc#rspecexamplelength[RSpec/ExampleLength]
        * xref:cops_rspec.adoc#rspecexamplewithoutdescription[RSpec/ExampleWithoutDescription]
        * xref:cops_rspec.adoc#rspecexamplewording[RSpec/ExampleWording]
        * xref:cops_rspec.adoc#rspecexcessivedocstringspacing[RSpec/ExcessiveDocstringSpacing]
        * xref:cops_rspec.adoc#rspecexpectactual[RSpec/ExpectActual]
        * xref:cops_rspec.adoc#rspecexpectchange[RSpec/ExpectChange]
        * xref:cops_rspec.adoc#rspecexpectinhook[RSpec/ExpectInHook]
        * xref:cops_rspec.adoc#rspecexpectoutput[RSpec/ExpectOutput]
        * xref:cops_rspec.adoc#rspecfilepath[RSpec/FilePath]
        * xref:cops_rspec.adoc#rspecfocus[RSpec/Focus]
        * xref:cops_rspec.adoc#rspechookargument[RSpec/HookArgument]
        * xref:cops_rspec.adoc#rspechooksbeforeexamples[RSpec/HooksBeforeExamples]
        * xref:cops_rspec.adoc#rspecidenticalequalityassertion[RSpec/IdenticalEqualityAssertion]
        * xref:cops_rspec.adoc#rspecimplicitblockexpectation[RSpec/ImplicitBlockExpectation]
        * xref:cops_rspec.adoc#rspecimplicitexpect[RSpec/ImplicitExpect]
        * xref:cops_rspec.adoc#rspecimplicitsubject[RSpec/ImplicitSubject]
        * xref:cops_rspec.adoc#rspecindexedlet[RSpec/IndexedLet]
        * xref:cops_rspec.adoc#rspecinstancespy[RSpec/InstanceSpy]
        * xref:cops_rspec.adoc#rspecinstancevariable[RSpec/InstanceVariable]
        * xref:cops_rspec.adoc#rspecisexpectedspecify[RSpec/IsExpectedSpecify]
        * xref:cops_rspec.adoc#rspecitbehaveslike[RSpec/ItBehavesLike]
        * xref:cops_rspec.adoc#rspeciteratedexpectation[RSpec/IteratedExpectation]
        * xref:cops_rspec.adoc#rspecleadingsubject[RSpec/LeadingSubject]
        * xref:cops_rspec.adoc#rspecleakyconstantdeclaration[RSpec/LeakyConstantDeclaration]
        * xref:cops_rspec.adoc#rspecletbeforeexamples[RSpec/LetBeforeExamples]
        * xref:cops_rspec.adoc#rspecletsetup[RSpec/LetSetup]
        * xref:cops_rspec.adoc#rspecmatcharray[RSpec/MatchArray]
        * xref:cops_rspec.adoc#rspecmessagechain[RSpec/MessageChain]
        * xref:cops_rspec.adoc#rspecmessageexpectation[RSpec/MessageExpectation]
        * xref:cops_rspec.adoc#rspecmessagespies[RSpec/MessageSpies]
        * xref:cops_rspec.adoc#rspecmetadatastyle[RSpec/MetadataStyle]
        * xref:cops_rspec.adoc#rspecmissingexamplegroupargument[RSpec/MissingExampleGroupArgument]
        * xref:cops_rspec.adoc#rspecmultipledescribes[RSpec/MultipleDescribes]
        * xref:cops_rspec.adoc#rspecmultipleexpectations[RSpec/MultipleExpectations]
        * xref:cops_rspec.adoc#rspecmultiplememoizedhelpers[RSpec/MultipleMemoizedHelpers]
        * xref:cops_rspec.adoc#rspecmultiplesubjects[RSpec/MultipleSubjects]
        * xref:cops_rspec.adoc#rspecnamedsubject[RSpec/NamedSubject]
        * xref:cops_rspec.adoc#rspecnestedgroups[RSpec/NestedGroups]
        * xref:cops_rspec.adoc#rspecnoexpectationexample[RSpec/NoExpectationExample]
        * xref:cops_rspec.adoc#rspecnottonot[RSpec/NotToNot]
        * xref:cops_rspec.adoc#rspecoverwritingsetup[RSpec/OverwritingSetup]
        * xref:cops_rspec.adoc#rspecpending[RSpec/Pending]
        * xref:cops_rspec.adoc#rspecpendingwithoutreason[RSpec/PendingWithoutReason]
        * xref:cops_rspec.adoc#rspecpredicatematcher[RSpec/PredicateMatcher]
        * xref:cops_rspec.adoc#rspecreceivecounts[RSpec/ReceiveCounts]
        * xref:cops_rspec.adoc#rspecreceivemessages[RSpec/ReceiveMessages]
        * xref:cops_rspec.adoc#rspecreceivenever[RSpec/ReceiveNever]
        * xref:cops_rspec.adoc#rspecredundantaround[RSpec/RedundantAround]
        * xref:cops_rspec.adoc#rspecredundantpredicatematcher[RSpec/RedundantPredicateMatcher]
        * xref:cops_rspec.adoc#rspecremoveconst[RSpec/RemoveConst]
        * xref:cops_rspec.adoc#rspecrepeateddescription[RSpec/RepeatedDescription]
        * xref:cops_rspec.adoc#rspecrepeatedexample[RSpec/RepeatedExample]
        * xref:cops_rspec.adoc#rspecrepeatedexamplegroupbody[RSpec/RepeatedExampleGroupBody]
        * xref:cops_rspec.adoc#rspecrepeatedexamplegroupdescription[RSpec/RepeatedExampleGroupDescription]
        * xref:cops_rspec.adoc#rspecrepeatedincludeexample[RSpec/RepeatedIncludeExample]
        * xref:cops_rspec.adoc#rspecrepeatedsubjectcall[RSpec/RepeatedSubjectCall]
        * xref:cops_rspec.adoc#rspecreturnfromstub[RSpec/ReturnFromStub]
        * xref:cops_rspec.adoc#rspecscatteredlet[RSpec/ScatteredLet]
        * xref:cops_rspec.adoc#rspecscatteredsetup[RSpec/ScatteredSetup]
        * xref:cops_rspec.adoc#rspecsharedcontext[RSpec/SharedContext]
        * xref:cops_rspec.adoc#rspecsharedexamples[RSpec/SharedExamples]
        * xref:cops_rspec.adoc#rspecsingleargumentmessagechain[RSpec/SingleArgumentMessageChain]
        * xref:cops_rspec.adoc#rspecskipblockinsideexample[RSpec/SkipBlockInsideExample]
        * xref:cops_rspec.adoc#rspecsortmetadata[RSpec/SortMetadata]
        * xref:cops_rspec.adoc#rspecspecfilepathformat[RSpec/SpecFilePathFormat]
        * xref:cops_rspec.adoc#rspecspecfilepathsuffix[RSpec/SpecFilePathSuffix]
        * xref:cops_rspec.adoc#rspecstubbedmock[RSpec/StubbedMock]
        * xref:cops_rspec.adoc#rspecsubjectdeclaration[RSpec/SubjectDeclaration]
        * xref:cops_rspec.adoc#rspecsubjectstub[RSpec/SubjectStub]
        * xref:cops_rspec.adoc#rspecundescriptiveliteralsdescription[RSpec/UndescriptiveLiteralsDescription]
        * xref:cops_rspec.adoc#rspecunspecifiedexception[RSpec/UnspecifiedException]
        * xref:cops_rspec.adoc#rspecvariabledefinition[RSpec/VariableDefinition]
        * xref:cops_rspec.adoc#rspecvariablename[RSpec/VariableName]
        * xref:cops_rspec.adoc#rspecverifieddoublereference[RSpec/VerifiedDoubleReference]
        * xref:cops_rspec.adoc#rspecverifieddoubles[RSpec/VerifiedDoubles]
        * xref:cops_rspec.adoc#rspecvoidexpect[RSpec/VoidExpect]
        * xref:cops_rspec.adoc#rspecyield[RSpec/Yield]

        === Department xref:cops_rspec_capybara.adoc[RSpec/Capybara]

        * xref:cops_rspec_capybara.adoc#rspeccapybara/currentpathexpectation[RSpec/Capybara/CurrentPathExpectation]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/featuremethods[RSpec/Capybara/FeatureMethods]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/matchstyle[RSpec/Capybara/MatchStyle]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/negationmatcher[RSpec/Capybara/NegationMatcher]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/specificactions[RSpec/Capybara/SpecificActions]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/specificfinders[RSpec/Capybara/SpecificFinders]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/specificmatcher[RSpec/Capybara/SpecificMatcher]
        * xref:cops_rspec_capybara.adoc#rspeccapybara/visibilitymatcher[RSpec/Capybara/VisibilityMatcher]

        === Department xref:cops_rspec_factorybot.adoc[RSpec/FactoryBot]

        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/attributedefinedstatically[RSpec/FactoryBot/AttributeDefinedStatically]
        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/consistentparenthesesstyle[RSpec/FactoryBot/ConsistentParenthesesStyle]
        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/createlist[RSpec/FactoryBot/CreateList]
        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/factoryclassname[RSpec/FactoryBot/FactoryClassName]
        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/factorynamestyle[RSpec/FactoryBot/FactoryNameStyle]
        * xref:cops_rspec_factorybot.adoc#rspecfactorybot/syntaxmethods[RSpec/FactoryBot/SyntaxMethods]

        === Department xref:cops_rspec_rails.adoc[RSpec/Rails]

        * xref:cops_rspec_rails.adoc#rspecrails/avoidsetuphook[RSpec/Rails/AvoidSetupHook]
        * xref:cops_rspec_rails.adoc#rspecrails/havehttpstatus[RSpec/Rails/HaveHttpStatus]
        * xref:cops_rspec_rails.adoc#rspecrails/httpstatus[RSpec/Rails/HttpStatus]
        * xref:cops_rspec_rails.adoc#rspecrails/inferredspectype[RSpec/Rails/InferredSpecType]
        * xref:cops_rspec_rails.adoc#rspecrails/minitestassertions[RSpec/Rails/MinitestAssertions]
        * xref:cops_rspec_rails.adoc#rspecrails/negationbevalid[RSpec/Rails/NegationBeValid]
        * xref:cops_rspec_rails.adoc#rspecrails/travelaround[RSpec/Rails/TravelAround]

        // END_COP_LIST
  recorded_at: Mon, 27 May 2024 05:30:45 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/docs/modules/ROOT/pages/cops_rspec.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '99636'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"444796f86b98db03f114cceb7e796276e085239b470f105726d4d1b364322223"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 6F34:19D255:9DDC89:A83EC9:66541A84
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:45 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230052-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787846.662583,VS0,VE216
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 39c11dd591918c4de894e9d0fd10656bbca3903e
      Expires:
      - Mon, 27 May 2024 05:35:45 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: !binary |-
        Ly8vLwogIERvIE5PVCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kIGRpcmVjdGx5LCBhcyBpdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC4KCiAgUGxlYXNlIG1ha2UgYW55IG5lY2Vzc2FyeSBjaGFuZ2VzIHRvIHRoZSBjb3AgZG9jdW1lbnRhdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBmaWxlcyB0aGVtc2VsdmVzLgovLy8vCgo9IFJTcGVjCgo9PSBSU3BlYy9BbGlnbkxlZnRMZXRCcmFjZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjE2CnwgLQp8PT09CgpDaGVja3MgdGhhdCBsZWZ0IGJyYWNlcyBmb3IgYWRqYWNlbnQgc2luZ2xlIGxpbmUgbGV0cyBhcmUgYWxpZ25lZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6Zm9vYmFyKSB7IGJsYWhibGFoIH0KbGV0KDpiYXopIHsgYmFyIH0KbGV0KDphKSB7IGIgfQoKIyBnb29kCmxldCg6Zm9vYmFyKSB7IGJsYWhibGFoIH0KbGV0KDpiYXopICAgIHsgYmFyIH0KbGV0KDphKSAgICAgIHsgYiB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQWxpZ25MZWZ0TGV0QnJhY2UKCj09IFJTcGVjL0FsaWduUmlnaHRMZXRCcmFjZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjE2CnwgLQp8PT09CgpDaGVja3MgdGhhdCByaWdodCBicmFjZXMgZm9yIGFkamFjZW50IHNpbmdsZSBsaW5lIGxldHMgYXJlIGFsaWduZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsZXQoOmZvb2JhcikgeyBibGFoYmxhaCB9CmxldCg6YmF6KSAgICB7IGJhciB9CmxldCg6YSkgICAgICB7IGIgfQoKIyBnb29kCmxldCg6Zm9vYmFyKSB7IGJsYWhibGFoIH0KbGV0KDpiYXopICAgIHsgYmFyICAgICAgfQpsZXQoOmEpICAgICAgeyBiICAgICAgICB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQWxpZ25SaWdodExldEJyYWNlCgo9PSBSU3BlYy9BbnlJbnN0YW5jZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS40CnwgLQp8PT09CgpDaGVjayB0aGF0IGluc3RhbmNlcyBhcmUgbm90IGJlaW5nIHN0dWJiZWQgZ2xvYmFsbHkuCgpQcmVmZXIgaW5zdGFuY2UgZG91YmxlcyBvdmVyIHN0dWJiaW5nIGFueSBpbnN0YW5jZSBvZiBhIGNsYXNzCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgYmVmb3JlIHsgYWxsb3dfYW55X2luc3RhbmNlX29mKE15Q2xhc3MpLnRvIHJlY2VpdmUoOmZvbykgfQplbmQKCiMgZ29vZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgbGV0KDpteV9pbnN0YW5jZSkgeyBpbnN0YW5jZV9kb3VibGUoTXlDbGFzcykgfQoKICBiZWZvcmUgZG8KICAgIGFsbG93KE15Q2xhc3MpLnRvIHJlY2VpdmUoOm5ldykuYW5kX3JldHVybihteV9pbnN0YW5jZSkKICAgIGFsbG93KG15X2luc3RhbmNlKS50byByZWNlaXZlKDpmb28pCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jYW55X2luc3RhbmNlX29mCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9BbnlJbnN0YW5jZQoKPT0gUlNwZWMvQXJvdW5kQmxvY2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMTEKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IGFyb3VuZCBibG9ja3MgYWN0dWFsbHkgcnVuIHRoZSB0ZXN0LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXJvdW5kIGRvCiAgc29tZV9tZXRob2QKZW5kCgphcm91bmQgZG8gfHRlc3R8CiAgc29tZV9tZXRob2QKZW5kCgojIGdvb2QKYXJvdW5kIGRvIHx0ZXN0fAogIHNvbWVfbWV0aG9kCiAgdGVzdC5jYWxsCmVuZAoKYXJvdW5kIGRvIHx0ZXN0fAogIHNvbWVfbWV0aG9kCiAgdGVzdC5ydW4KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQXJvdW5kQmxvY2sKCj09IFJTcGVjL0JlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjI1CnwgLQp8PT09CgpDaGVjayBmb3IgZXhwZWN0YXRpb25zIHdoZXJlIGBiZWAgaXMgdXNlZCB3aXRob3V0IGFyZ3VtZW50LgoKVGhlIGBiZWAgbWF0Y2hlciBpcyB0b28gZ2VuZXJpYywgYXMgaXQgcGFzcyBvbiBldmVyeXRoaW5nIHRoYXQgaXMgbm90Cm5pbCBvciBmYWxzZS4gSWYgdGhhdCBpcyB0aGUgZXhhY3QgaW50ZW5kLCB1c2UgYGJlX3RydXRoeWAuIEluIGFsbCBvdGhlcgpjYXNlcyBpdCdzIGJldHRlciB0byBzcGVjaWZ5IHdoYXQgZXhhY3RseSBpcyB0aGUgZXhwZWN0ZWQgdmFsdWUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byBiZQoKIyBnb29kCmV4cGVjdChmb28pLnRvIGJlX3RydXRoeQpleHBlY3QoZm9vKS50byBiZSAxLjAKZXhwZWN0KGZvbykudG8gYmUodHJ1ZSkKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yc3BlYy5ydWJ5c3R5bGUuZ3VpZGUvI2JlLW1hdGNoZXIKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0JlCgo9PSBSU3BlYy9CZUVtcHR5Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4yMAp8IC0KfD09PQoKUHJlZmVyIHVzaW5nIGBiZV9lbXB0eWAgd2hlbiBjaGVja2luZyBmb3IgYW4gZW1wdHkgYXJyYXkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoYXJyYXkpLnRvIGNvbnRhaW5fZXhhY3RseQpleHBlY3QoYXJyYXkpLnRvIG1hdGNoX2FycmF5KFtdKQoKIyBnb29kCmV4cGVjdChhcnJheSkudG8gYmVfZW1wdHkKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9CZUVtcHR5Cgo9PSBSU3BlYy9CZUVxCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgTm8KfCBBbHdheXMgKFVuc2FmZSkKfCAyLjkuMAp8IDIuMTYKfD09PQoKQ2hlY2sgZm9yIGV4cGVjdGF0aW9ucyB3aGVyZSBgYmUoLi4uKWAgY2FuIHJlcGxhY2UgYGVxKC4uLilgLgoKVGhlIGBiZWAgbWF0Y2hlciBjb21wYXJlcyBieSBpZGVudGl0eSB3aGlsZSB0aGUgYGVxYCBtYXRjaGVyIGNvbXBhcmVzCnVzaW5nIGA9PWAuIEJvb2xlYW5zIGFuZCBuaWwgY2FuIGJlIGNvbXBhcmVkIGJ5IGlkZW50aXR5IGFuZCB0aGVyZWZvcmUKdGhlIGBiZWAgbWF0Y2hlciBpcyBwcmVmZXJhYmxlIGFzIGl0IGlzIGEgbW9yZSBzdHJpY3QgdGVzdC4KCj09PSBTYWZldHkKClRoaXMgY29wIGlzIHVuc2FmZSBiZWNhdXNlIGl0IGNoYW5nZXMgaG93IHZhbHVlcyBhcmUgY29tcGFyZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byBlcSh0cnVlKQpleHBlY3QoZm9vKS50byBlcShmYWxzZSkKZXhwZWN0KGZvbykudG8gZXEobmlsKQoKIyBnb29kCmV4cGVjdChmb28pLnRvIGJlKHRydWUpCmV4cGVjdChmb28pLnRvIGJlKGZhbHNlKQpleHBlY3QoZm9vKS50byBiZShuaWwpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQmVFcQoKPT0gUlNwZWMvQmVFcWwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBObwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNwp8IDIuMTYKfD09PQoKQ2hlY2sgZm9yIGV4cGVjdGF0aW9ucyB3aGVyZSBgYmUoLi4uKWAgY2FuIHJlcGxhY2UgYGVxbCguLi4pYC4KClRoZSBgYmVgIG1hdGNoZXIgY29tcGFyZXMgYnkgaWRlbnRpdHkgd2hpbGUgdGhlIGBlcWxgIG1hdGNoZXIKY29tcGFyZXMgdXNpbmcgYGVxbD9gLiBJbnRlZ2VycywgZmxvYXRzLCBib29sZWFucywgc3ltYm9scywgYW5kIG5pbApjYW4gYmUgY29tcGFyZWQgYnkgaWRlbnRpdHkgYW5kIHRoZXJlZm9yZSB0aGUgYGJlYCBtYXRjaGVyIGlzCnByZWZlcmFibGUgYXMgaXQgaXMgYSBtb3JlIHN0cmljdCB0ZXN0LgoKVGhpcyBjb3Agb25seSBsb29rcyBmb3IgaW5zdGFuY2VzIG9mIGBleHBlY3QoLi4uKS50byBlcWwoLi4uKWAuIFdlCmRvIG5vdCBjaGVjayBgdG9fbm90YCBvciBgbm90X3RvYCBzaW5jZSBgIWVxbD9gIGlzIG1vcmUgc3RyaWN0CnRoYW4gYCFlcXVhbD9gLiBXZSBhbHNvIGRvIG5vdCB0cnkgdG8gZmxhZyBgZXFgIGJlY2F1c2UgaWYKYGEgPT0gYmAsIGFuZCBgYmAgaXMgY29tcGFyYWJsZSBieSBpZGVudGl0eSwgYGFgIGlzIHN0aWxsIG5vdApuZWNlc3NhcmlseSB0aGUgc2FtZSB0eXBlIGFzIGBiYCBzaW5jZSB0aGUgYCM9PWAgb3BlcmF0b3IgY2FuCmNvZXJjZSBvYmplY3RzIGZvciBjb21wYXJpc29uLgoKPT09IFNhZmV0eQoKVGhpcyBjb3AgaXMgdW5zYWZlIGJlY2F1c2UgaXQgY2hhbmdlcyBob3cgdmFsdWVzIGFyZSBjb21wYXJlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIGVxbCgxKQpleHBlY3QoZm9vKS50byBlcWwoMS4wKQpleHBlY3QoZm9vKS50byBlcWwodHJ1ZSkKZXhwZWN0KGZvbykudG8gZXFsKGZhbHNlKQpleHBlY3QoZm9vKS50byBlcWwoOmJhcikKZXhwZWN0KGZvbykudG8gZXFsKG5pbCkKCiMgZ29vZApleHBlY3QoZm9vKS50byBiZSgxKQpleHBlY3QoZm9vKS50byBiZSgxLjApCmV4cGVjdChmb28pLnRvIGJlKHRydWUpCmV4cGVjdChmb28pLnRvIGJlKGZhbHNlKQpleHBlY3QoZm9vKS50byBiZSg6YmFyKQpleHBlY3QoZm9vKS50byBiZShuaWwpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQmVFcWwKCj09IFJTcGVjL0JlTmlsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi45LjAKfCAyLjEwLjAKfD09PQoKRW5zdXJlcyBhIGNvbnNpc3RlbnQgc3R5bGUgaXMgdXNlZCB3aGVuIG1hdGNoaW5nIGBuaWxgLgoKWW91IGNhbiBlaXRoZXIgdXNlIHRoZSBtb3JlIHNwZWNpZmljIGBiZV9uaWxgIG1hdGNoZXIsIG9yIHRoZSBtb3JlCmdlbmVyaWMgYGJlYCBtYXRjaGVyIHdpdGggYSBgbmlsYCBhcmd1bWVudC4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgRW5mb3JjZWRTdHlsZWAgb3B0aW9uCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IGJlX25pbGAgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZXhwZWN0KGZvbykudG8gYmUobmlsKQoKIyBnb29kCmV4cGVjdChmb28pLnRvIGJlX25pbAotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBiZWAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byBiZV9uaWwKCiMgZ29vZApleHBlY3QoZm9vKS50byBiZShuaWwpCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGJlX25pbGAKfCBgYmVgLCBgYmVfbmlsYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0JlTmlsCgo9PSBSU3BlYy9CZWZvcmVBZnRlckFsbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4xMgp8IDIuMjMKfD09PQoKQ2hlY2sgdGhhdCBiZWZvcmUvYWZ0ZXIoOmFsbC86Y29udGV4dCkgaXNuJ3QgYmVpbmcgdXNlZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkIC0gRmFzdGVyIGJ1dCByaXNrIG9mIHN0YXRlIGxlYWtpbmcgYmV0d2VlbiBleGFtcGxlcwpkZXNjcmliZSBNeUNsYXNzIGRvCiAgYmVmb3JlKDphbGwpIHsgV2lkZ2V0LmNyZWF0ZSB9CiAgYWZ0ZXIoOmNvbnRleHQpIHsgV2lkZ2V0LmRlbGV0ZV9hbGwgfQplbmQKCiMgZ29vZCAtIFNsb3dlciBidXQgZXhhbXBsZXMgYXJlIHByb3Blcmx5IGlzb2xhdGVkCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBiZWZvcmUoOmVhY2gpIHsgV2lkZ2V0LmNyZWF0ZSB9CiAgYWZ0ZXIoOmVhY2gpIHsgV2lkZ2V0LmRlbGV0ZV9hbGwgfQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEV4Y2x1ZGUKfCBgKyoqL3NwZWMvc3BlY19oZWxwZXIucmIrYCwgYCsqKi9zcGVjL3JhaWxzX2hlbHBlci5yYitgLCBgKyoqL3NwZWMvc3VwcG9ydC8qKi8qLnJiK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jYXZvaWQtaG9va3Mtd2l0aC1jb250ZXh0LXNjb3BlCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9CZWZvcmVBZnRlckFsbAoKPT0gUlNwZWMvQ2hhbmdlQnlaZXJvCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4xMQp8IDIuMTQKfD09PQoKUHJlZmVyIG5lZ2F0ZWQgbWF0Y2hlcnMgb3ZlciBgdG8gY2hhbmdlLmJ5KDApYC4KCkluIHRoZSBjYXNlIG9mIGNvbXBvc2l0ZSBleHBlY3RhdGlvbnMsIGNvcCBzdWdnZXN0IHVzaW5nIHRoZQpuZWdhdGlvbiBtYXRjaGVycyBvZiBgUlNwZWM6Ok1hdGNoZXJzI2NoYW5nZWAuCgpCeSBkZWZhdWx0IHRoZSBjb3AgZG9lcyBub3Qgc3VwcG9ydCBhdXRvY29ycmVjdCBvZgpjb21wb3VuZCBleHBlY3RhdGlvbnMsIGJ1dCBpZiB5b3Ugc2V0IHRoZQpuZWdhdGVkIG1hdGNoZXIgZm9yIGBjaGFuZ2VgLCBlLmcuIGBub3RfY2hhbmdlYCB3aXRoCnRoZSBgTmVnYXRlZE1hdGNoZXJgIG9wdGlvbiwgdGhlIGNvcCB3aWxsIHBlcmZvcm0gdGhlIGF1dG9jb3JyZWN0aW9uLgoKPT09IEV4YW1wbGVzCgo9PT09IE5lZ2F0ZWRNYXRjaGVyOiB+IChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdCB7IHJ1biB9LnRvIGNoYW5nZShGb28sIDpiYXIpLmJ5KDApCmV4cGVjdCB7IHJ1biB9LnRvIGNoYW5nZSB7IEZvby5iYXIgfS5ieSgwKQoKIyBiYWQgLSBjb21wb3VuZCBleHBlY3RhdGlvbnMgKGRvZXMgbm90IHN1cHBvcnQgYXV0b2NvcnJlY3Rpb24pCmV4cGVjdCB7IHJ1biB9CiAgLnRvIGNoYW5nZShGb28sIDpiYXIpLmJ5KDApCiAgLmFuZCBjaGFuZ2UoRm9vLCA6YmF6KS5ieSgwKQpleHBlY3QgeyBydW4gfQogIC50byBjaGFuZ2UgeyBGb28uYmFyIH0uYnkoMCkKICAuYW5kIGNoYW5nZSB7IEZvby5iYXogfS5ieSgwKQoKIyBnb29kCmV4cGVjdCB7IHJ1biB9Lm5vdF90byBjaGFuZ2UoRm9vLCA6YmFyKQpleHBlY3QgeyBydW4gfS5ub3RfdG8gY2hhbmdlIHsgRm9vLmJhciB9CgojIGdvb2QgLSBjb21wb3VuZCBleHBlY3RhdGlvbnMKZGVmaW5lX25lZ2F0ZWRfbWF0Y2hlciA6bm90X2NoYW5nZSwgOmNoYW5nZQpleHBlY3QgeyBydW4gfQogIC50byBub3RfY2hhbmdlKEZvbywgOmJhcikKICAuYW5kIG5vdF9jaGFuZ2UoRm9vLCA6YmF6KQpleHBlY3QgeyBydW4gfQogIC50byBub3RfY2hhbmdlIHsgRm9vLmJhciB9CiAgLmFuZCBub3RfY2hhbmdlIHsgRm9vLmJheiB9Ci0tLS0KCj09PT0gTmVnYXRlZE1hdGNoZXI6IG5vdF9jaGFuZ2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZCAoc3VwcG9ydCBhdXRvY29ycmVjdGlvbiB0byBnb29kIGNhc2UpCmV4cGVjdCB7IHJ1biB9CiAgLnRvIGNoYW5nZShGb28sIDpiYXIpLmJ5KDApCiAgLmFuZCBjaGFuZ2UoRm9vLCA6YmF6KS5ieSgwKQpleHBlY3QgeyBydW4gfQogIC50byBjaGFuZ2UgeyBGb28uYmFyIH0uYnkoMCkKICAuYW5kIGNoYW5nZSB7IEZvby5iYXogfS5ieSgwKQoKIyBnb29kCmRlZmluZV9uZWdhdGVkX21hdGNoZXIgOm5vdF9jaGFuZ2UsIDpjaGFuZ2UKZXhwZWN0IHsgcnVuIH0KICAudG8gbm90X2NoYW5nZShGb28sIDpiYXIpCiAgLmFuZCBub3RfY2hhbmdlKEZvbywgOmJheikKZXhwZWN0IHsgcnVuIH0KICAudG8gbm90X2NoYW5nZSB7IEZvby5iYXIgfQogIC5hbmQgbm90X2NoYW5nZSB7IEZvby5iYXogfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTmVnYXRlZE1hdGNoZXIKfCBgPG5vbmU+YAp8IAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0NoYW5nZUJ5WmVybwoKPT0gUlNwZWMvQ2xhc3NDaGVjawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTMKfCAtCnw9PT0KCkVuZm9yY2VzIGNvbnNpc3RlbnQgdXNlIG9mIGBiZV9hYCBvciBgYmVfa2luZF9vZmAuCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogYmVfYSAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3Qob2JqZWN0KS50byBiZV9raW5kX29mKFN0cmluZykKZXhwZWN0KG9iamVjdCkudG8gYmVfYV9raW5kX29mKFN0cmluZykKCiMgZ29vZApleHBlY3Qob2JqZWN0KS50byBiZV9hKFN0cmluZykKZXhwZWN0KG9iamVjdCkudG8gYmVfYW4oU3RyaW5nKQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGJlX2tpbmRfb2YKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3Qob2JqZWN0KS50byBiZV9hKFN0cmluZykKZXhwZWN0KG9iamVjdCkudG8gYmVfYW4oU3RyaW5nKQoKIyBnb29kCmV4cGVjdChvYmplY3QpLnRvIGJlX2tpbmRfb2YoU3RyaW5nKQpleHBlY3Qob2JqZWN0KS50byBiZV9hX2tpbmRfb2YoU3RyaW5nKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBiZV9hYAp8IGBiZV9hYCwgYGJlX2tpbmRfb2ZgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnVieXN0eWxlLmd1aWRlI2lzLWEtdnMta2luZC1vZgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQ2xhc3NDaGVjawoKPT0gUlNwZWMvQ29udGFpbkV4YWN0bHkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjE5CnwgLQp8PT09CgpDaGVja3Mgd2hlcmUgYGNvbnRhaW5fZXhhY3RseWAgaXMgdXNlZC4KClRoaXMgY29wIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzoKLSBQcmVmZXIgYG1hdGNoX2FycmF5YCB3aGVuIG1hdGNoaW5nIGFycmF5IHZhbHVlcy4KLSBQcmVmZXIgYGJlX2VtcHR5YCB3aGVuIHVzaW5nIGBjb250YWluX2V4YWN0bHlgIHdpdGggbm8gYXJndW1lbnRzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgeyBpc19leHBlY3RlZC50byBjb250YWluX2V4YWN0bHkoKmFycmF5MSwgKmFycmF5MikgfQoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gbWF0Y2hfYXJyYXkoYXJyYXkxICsgYXJyYXkyKSB9CgojIGdvb2QKaXQgeyBpc19leHBlY3RlZC50byBjb250YWluX2V4YWN0bHkoY29udGVudCwgKmFycmF5KSB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQ29udGFpbkV4YWN0bHkKCj09IFJTcGVjL0NvbnRleHRNZXRob2QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjM2CnwgLQp8PT09CgpgY29udGV4dGAgc2hvdWxkIG5vdCBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIG1ldGhvZHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjb250ZXh0ICcjZm9vX2JhcicgZG8KICAjIC4uLgplbmQKCmNvbnRleHQgJy5mb29fYmFyJyBkbwogICMgLi4uCmVuZAoKIyBnb29kCmRlc2NyaWJlICcjZm9vX2JhcicgZG8KICAjIC4uLgplbmQKCmRlc2NyaWJlICcuZm9vX2JhcicgZG8KICAjIC4uLgplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yc3BlYy5ydWJ5c3R5bGUuZ3VpZGUvI2V4YW1wbGUtZ3JvdXAtbmFtaW5nCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9Db250ZXh0TWV0aG9kCgo9PSBSU3BlYy9Db250ZXh0V29yZGluZwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4yMAp8IDIuMTMKfD09PQoKQ2hlY2tzIHRoYXQgYGNvbnRleHRgIGRvY3N0cmluZyBzdGFydHMgd2l0aCBhbiBhbGxvd2VkIHByZWZpeC4KClRoZSBkZWZhdWx0IGxpc3Qgb2YgcHJlZml4ZXMgaXMgbWluaW1hbC4gVXNlcnMgYXJlIGVuY291cmFnZWQgdG8gdGFpbG9yCnRoZSBjb25maWd1cmF0aW9uIHRvIG1lZXQgcHJvamVjdCBuZWVkcy4gT3RoZXIgYWNjZXB0YWJsZSBwcmVmaXhlcyBtYXkKaW5jbHVkZSBgaWZgLCBgdW5sZXNzYCwgYGZvcmAsIGBiZWZvcmVgLCBgYWZ0ZXJgLCBvciBgZHVyaW5nYC4KVGhleSBtYXkgY29uc2lzdCBvZiBtdWx0aXBsZSB3b3JkcyBpZiBkZXNpcmVkLgoKVGhpcyBjb3AgY2FuIGJlIGN1c3RvbWl6ZWQgYWxsb3dlZCBjb250ZXh0IGRlc2NyaXB0aW9uIHBhdHRlcm4Kd2l0aCBgQWxsb3dlZFBhdHRlcm5zYC4gQnkgZGVmYXVsdCwgdGhlcmUgYXJlIG5vIGNoZWNraW5nIGJ5IHBhdHRlcm4uCgo9PT0gRXhhbXBsZXMKCj09PT0gYFByZWZpeGVzYCBjb25maWd1cmF0aW9uCgpbc291cmNlLHJ1YnldCi0tLS0KIyAucnVib2NvcC55bWwKIyBSU3BlYy9Db250ZXh0V29yZGluZzoKIyAgIFByZWZpeGVzOgojICAgICAtIHdoZW4KIyAgICAgLSB3aXRoCiMgICAgIC0gd2l0aG91dAojICAgICAtIGlmCiMgICAgIC0gdW5sZXNzCiMgICAgIC0gZm9yCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjb250ZXh0ICd0aGUgZGlzcGxheSBuYW1lIG5vdCBwcmVzZW50JyBkbwogICMgLi4uCmVuZAoKIyBnb29kCmNvbnRleHQgJ3doZW4gdGhlIGRpc3BsYXkgbmFtZSBpcyBub3QgcHJlc2VudCcgZG8KICAjIC4uLgplbmQKLS0tLQoKPT09PSBgQWxsb3dlZFBhdHRlcm5zYCBjb25maWd1cmF0aW9uCgpbc291cmNlLHJ1YnldCi0tLS0KIyAucnVib2NvcC55bWwKIyBSU3BlYy9Db250ZXh0V29yZGluZzoKIyAgIEFsbG93ZWRQYXR0ZXJuczoKIyAgICAgLSDjgajjgY0kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjb250ZXh0ICfmnaHku7bjgpLmuoDjgZ/jgZknIGRvCiAgIyAuLi4KZW5kCgojIGdvb2QKY29udGV4dCAn5p2h5Lu244KS5rqA44Gf44GZ44Go44GNJyBkbwogICMgLi4uCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgUHJlZml4ZXMKfCBgd2hlbmAsIGB3aXRoYCwgYHdpdGhvdXRgCnwgQXJyYXkKCnwgQWxsb3dlZFBhdHRlcm5zCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNjb250ZXh0LWRlc2NyaXB0aW9ucwoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvQ29udGV4dFdvcmRpbmcKKiBodHRwOi8vd3d3LmJldHRlcnNwZWNzLm9yZy8jY29udGV4dHMKCj09IFJTcGVjL0Rlc2NyaWJlQ2xhc3MKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMAp8IDIuNwp8PT09CgpDaGVjayB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgdG9wLWxldmVsIGRlc2NyaWJlIGlzIGEgY29uc3RhbnQuCgpJdCBjYW4gYmUgY29uZmlndXJlZCB0byBpZ25vcmUgc3RyaW5ncyB3aGVuIGNlcnRhaW4gbWV0YWRhdGEgaXMgcGFzc2VkLgoKSWdub3JlcyBSYWlscyBhbmQgQXJ1YmEgYHR5cGVgIG1ldGFkYXRhIGJ5IGRlZmF1bHQuCgo9PT0gRXhhbXBsZXMKCj09PT0gYElnbm9yZWRNZXRhZGF0YWAgY29uZmlndXJhdGlvbgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgLnJ1Ym9jb3AueW1sCiMgUlNwZWMvRGVzY3JpYmVDbGFzczoKIyAgIElnbm9yZWRNZXRhZGF0YToKIyAgICAgdHlwZToKIyAgICAgICAtIHJlcXVlc3QKIyAgICAgICAtIGNvbnRyb2xsZXIKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlICdEbyBzb21ldGhpbmcnIGRvCmVuZAoKIyBnb29kCmRlc2NyaWJlIFRlc3RlZENsYXNzIGRvCiAgc3ViamVjdCB7IGRlc2NyaWJlZF9jbGFzcyB9CmVuZAoKZGVzY3JpYmUgJ1Rlc3RlZENsYXNzOjpWRVJTSU9OJyBkbwogIHN1YmplY3QgeyBPYmplY3QuY29uc3RfZ2V0KHNlbGYuY2xhc3MuZGVzY3JpcHRpb24pIH0KZW5kCgpkZXNjcmliZSAiQSBmZWF0dXJlIGV4YW1wbGUiLCB0eXBlOiA6ZmVhdHVyZSBkbwplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEV4Y2x1ZGUKfCBgKyoqL3NwZWMvZmVhdHVyZXMvKiovKitgLCBgKyoqL3NwZWMvcmVxdWVzdHMvKiovKitgLCBgKyoqL3NwZWMvcm91dGluZy8qKi8qK2AsIGArKiovc3BlYy9zeXN0ZW0vKiovKitgLCBgKyoqL3NwZWMvdmlld3MvKiovKitgCnwgQXJyYXkKCnwgSWdub3JlZE1ldGFkYXRhCnwgYHsidHlwZSI9PlsiY2hhbm5lbCIsICJjb250cm9sbGVyIiwgImhlbHBlciIsICJqb2IiLCAibWFpbGVyIiwgIm1vZGVsIiwgInJlcXVlc3QiLCAicm91dGluZyIsICJ2aWV3IiwgImZlYXR1cmUiLCAic3lzdGVtIiwgIm1haWxib3giLCAiYXJ1YmEiLCAidGFzayJdfWAKfCAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9EZXNjcmliZUNsYXNzCgo9PSBSU3BlYy9EZXNjcmliZU1ldGhvZAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4wCnwgLQp8PT09CgpDaGVja3MgdGhhdCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBkZXNjcmliZWAgc3BlY2lmaWVzIGEgbWV0aG9kLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgTXlDbGFzcywgJ2RvIHNvbWV0aGluZycgZG8KZW5kCgojIGdvb2QKZGVzY3JpYmUgTXlDbGFzcywgJyNteV9pbnN0YW5jZV9tZXRob2QnIGRvCmVuZAoKZGVzY3JpYmUgTXlDbGFzcywgJy5teV9jbGFzc19tZXRob2QnIGRvCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0Rlc2NyaWJlTWV0aG9kCgo9PSBSU3BlYy9EZXNjcmliZVN5bWJvbAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4xNQp8IC0KfD09PQoKQXZvaWQgZGVzY3JpYmluZyBzeW1ib2xzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgOm15X21ldGhvZCBkbwogICMgLi4uCmVuZAoKIyBnb29kCmRlc2NyaWJlICcjbXlfbWV0aG9kJyBkbwogICMgLi4uCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0Rlc2NyaWJlU3ltYm9sCiogaHR0cHM6Ly9naXRodWIuY29tL3JzcGVjL3JzcGVjLWNvcmUvaXNzdWVzLzE2MTAKCj09IFJTcGVjL0Rlc2NyaWJlZENsYXNzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4wCnwgMi4yNwp8PT09CgpDaGVja3MgdGhhdCB0ZXN0cyB1c2UgYGRlc2NyaWJlZF9jbGFzc2AuCgpJZiB0aGUgZmlyc3QgYXJndW1lbnQgb2YgZGVzY3JpYmUgaXMgYSBjbGFzcywgdGhlIGNsYXNzIGlzIGV4cG9zZWQgdG8KZWFjaCBleGFtcGxlIHZpYSBkZXNjcmliZWRfY2xhc3MuCgpUaGlzIGNvcCBjYW4gYmUgY29uZmlndXJlZCB1c2luZyB0aGUgYEVuZm9yY2VkU3R5bGVgLCBgU2tpcEJsb2Nrc2AKYW5kIGBPbmx5U3RhdGljQ29uc3RhbnRzYCBvcHRpb25zLgpgT25seVN0YXRpY0NvbnN0YW50c2AgaXMgb25seSByZWxldmFudCB3aGVuIGBFbmZvcmNlZFN0eWxlYCBpcwpgZGVzY3JpYmVkX2NsYXNzYC4KClRoZXJlJ3MgYSBrbm93biBjYXZlYXQgd2l0aCByc3BlYy1yYWlscydzIGBjb250cm9sbGVyYCBoZWxwZXIgdGhhdApydW5zIGl0cyBibG9jayBpbiBhIGRpZmZlcmVudCBjb250ZXh0LCBhbmQgYGRlc2NyaWJlZF9jbGFzc2AgaXMgbm90CmF2YWlsYWJsZSB0byBpdC4gYFNraXBCbG9ja3NgIG9wdGlvbiBleGNsdWRlcyBkZXRlY3Rpb24gaW4gYWxsCm5vbi1SU3BlYyByZWxhdGVkIGJsb2Nrcy4KClRvIG5hcnJvdyBkb3duIHRoaXMgc2V0dGluZyB0byBvbmx5IGEgc3BlY2lmaWMgZGlyZWN0b3J5LCBpdCBpcwpwb3NzaWJsZSB0byB1c2UgYW4gb3ZlcnJpZGluZyBjb25maWd1cmF0aW9uIGZpbGUgbG9jYWwgdG8gdGhhdApkaXJlY3RvcnkuCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IGRlc2NyaWJlZF9jbGFzc2AgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgTXlDbGFzcyBkbwogIHN1YmplY3QgeyBNeUNsYXNzLmRvX3NvbWV0aGluZyB9CmVuZAoKIyBnb29kCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBzdWJqZWN0IHsgZGVzY3JpYmVkX2NsYXNzLmRvX3NvbWV0aGluZyB9CmVuZAotLS0tCgo9PT09IGBPbmx5U3RhdGljQ29uc3RhbnRzOiB0cnVlYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVzY3JpYmUgTXlDbGFzcyBkbwogIHN1YmplY3QgeyBNeUNsYXNzOjpDT05TVEFOVCB9CmVuZAotLS0tCgo9PT09IGBPbmx5U3RhdGljQ29uc3RhbnRzOiBmYWxzZWAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgc3ViamVjdCB7IE15Q2xhc3M6OkNPTlNUQU5UIH0KZW5kCi0tLS0KCj09PT0gYEVuZm9yY2VkU3R5bGU6IGV4cGxpY2l0YAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBzdWJqZWN0IHsgZGVzY3JpYmVkX2NsYXNzLmRvX3NvbWV0aGluZyB9CmVuZAoKIyBnb29kCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBzdWJqZWN0IHsgTXlDbGFzcy5kb19zb21ldGhpbmcgfQplbmQKLS0tLQoKPT09PSBgU2tpcEJsb2NrczogdHJ1ZWAKCltzb3VyY2UscnVieV0KLS0tLQojIHNwZWMvY29udHJvbGxlcnMvLnJ1Ym9jb3AueW1sCiMgUlNwZWMvRGVzY3JpYmVkQ2xhc3M6CiMgICBTa2lwQmxvY2tzOiB0cnVlCgojIGFjY2VwdGFibGUKZGVzY3JpYmUgTXlDb25jZXJuIGRvCiAgY29udHJvbGxlcihBcHBsaWNhdGlvbkNvbnRyb2xsZXIpIGRvCiAgICBpbmNsdWRlIE15Q29uY2VybgogIGVuZAplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IFNraXBCbG9ja3MKfCBgZmFsc2VgCnwgQm9vbGVhbgoKfCBFbmZvcmNlZFN0eWxlCnwgYGRlc2NyaWJlZF9jbGFzc2AKfCBgZGVzY3JpYmVkX2NsYXNzYCwgYGV4cGxpY2l0YAoKfCBPbmx5U3RhdGljQ29uc3RhbnRzCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0Rlc2NyaWJlZENsYXNzCgo9PSBSU3BlYy9EZXNjcmliZWRDbGFzc01vZHVsZVdyYXBwaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBEaXNhYmxlZAp8IFllcwp8IE5vCnwgMS4zNwp8IC0KfD09PQoKQXZvaWQgb3BlbmluZyBtb2R1bGVzIGFuZCBkZWZpbmluZyBzcGVjcyB3aXRoaW4gdGhlbS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCm1vZHVsZSBNeU1vZHVsZQogIFJTcGVjLmRlc2NyaWJlIE15Q2xhc3MgZG8KICAgICMgLi4uCiAgZW5kCmVuZAoKIyBnb29kClJTcGVjLmRlc2NyaWJlIE15TW9kdWxlOjpNeUNsYXNzIGRvCiAgIyAuLi4KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRGVzY3JpYmVkQ2xhc3NNb2R1bGVXcmFwcGluZwoqIGh0dHBzOi8vZ2l0aHViLmNvbS9ydWJvY29wL3J1Ym9jb3AtcnNwZWMvaXNzdWVzLzczNQoKPT0gUlNwZWMvRGlhbGVjdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjMzCnwgLQp8PT09CgpFbmZvcmNlcyBjdXN0b20gUlNwZWMgZGlhbGVjdHMuCgpBIGRpYWxlY3QgY2FuIGJlIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgUlNwZWMgbWV0aG9kczoKCi0gZGVzY3JpYmUsIGNvbnRleHQsIGZlYXR1cmUsIGV4YW1wbGVfZ3JvdXAKLSB4ZGVzY3JpYmUsIHhjb250ZXh0LCB4ZmVhdHVyZQotIGZkZXNjcmliZSwgZmNvbnRleHQsIGZmZWF0dXJlCi0gc2hhcmVkX2V4YW1wbGVzLCBzaGFyZWRfZXhhbXBsZXNfZm9yLCBzaGFyZWRfY29udGV4dAotIGl0LCBzcGVjaWZ5LCBleGFtcGxlLCBzY2VuYXJpbywgaXRzCi0gZml0LCBmc3BlY2lmeSwgZmV4YW1wbGUsIGZzY2VuYXJpbywgZm9jdXMKLSB4aXQsIHhzcGVjaWZ5LCB4ZXhhbXBsZSwgeHNjZW5hcmlvLCBza2lwCi0gcGVuZGluZwotIHByZXBlbmRfYmVmb3JlLCBiZWZvcmUsIGFwcGVuZF9iZWZvcmUsCi0gYXJvdW5kCi0gcHJlcGVuZF9hZnRlciwgYWZ0ZXIsIGFwcGVuZF9hZnRlcgotIGxldCwgbGV0IQotIHN1YmplY3QsIHN1YmplY3QhCi0gZXhwZWN0LCBpc19leHBlY3RlZCwgZXhwZWN0X2FueV9pbnN0YW5jZV9vZgoKQnkgZGVmYXVsdCBhbGwgb2YgdGhlIFJTcGVjIG1ldGhvZHMgYW5kIGFsaWFzZXMgYXJlIGFsbG93ZWQuIEJ5IHNldHRpbmcKYSBjb25maWcgbGlrZToKCiAgUlNwZWMvRGlhbGVjdDoKICAgIFByZWZlcnJlZE1ldGhvZHM6CiAgICAgIGNvbnRleHQ6IGRlc2NyaWJlCgpZb3UgY2FuIGV4cGVjdCB0aGUgZm9sbG93aW5nIGJlaGF2aW9yOgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKY29udGV4dCAnZGlzcGxheSBuYW1lIHByZXNlbmNlJyBkbwogICMgLi4uCmVuZAoKIyBnb29kCmRlc2NyaWJlICdkaXNwbGF5IG5hbWUgcHJlc2VuY2UnIGRvCiAgIyAuLi4KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBQcmVmZXJyZWRNZXRob2RzCnwgYHt9YAp8IAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0RpYWxlY3QKCj09IFJTcGVjL0R1cGxpY2F0ZWRNZXRhZGF0YQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMTYKfCAtCnw9PT0KCkF2b2lkIGR1cGxpY2F0ZWQgbWV0YWRhdGEuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSAnU29tZXRoaW5nJywgOmEsIDphCgojIGdvb2QKZGVzY3JpYmUgJ1NvbWV0aGluZycsIDphCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRHVwbGljYXRlZE1ldGFkYXRhCgo9PSBSU3BlYy9FbXB0eUV4YW1wbGVHcm91cAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDEuNwp8IDIuMTMKfD09PQoKQ2hlY2tzIGlmIGFuIGV4YW1wbGUgZ3JvdXAgZG9lcyBub3QgaW5jbHVkZSBhbnkgdGVzdHMuCgo9PT0gRXhhbXBsZXMKCj09PT0gdXNhZ2UKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBCYWNvbiBkbwogIGxldCg6YmFjb24pICAgICAgeyBCYWNvbi5uZXcoY2h1bmtpbmVzcykgfQogIGxldCg6Y2h1bmtpbmVzcykgeyBmYWxzZSAgICAgICAgICAgICAgICAgfQoKICBjb250ZXh0ICdleHRyYSBjaHVua3knIGRvICAgIyBmbGFnZ2VkIGJ5IHJ1Ym9jb3AKICAgIGxldCg6Y2h1bmtpbmVzcykgeyB0cnVlIH0KICBlbmQKCiAgaXQgJ2lzIGNodW5reScgZG8KICAgIGV4cGVjdChiYWNvbi5jaHVua3k/KS50byBiZV90cnV0aHkKICBlbmQKZW5kCgojIGdvb2QKZGVzY3JpYmUgQmFjb24gZG8KICBsZXQoOmJhY29uKSAgICAgIHsgQmFjb24ubmV3KGNodW5raW5lc3MpIH0KICBsZXQoOmNodW5raW5lc3MpIHsgZmFsc2UgICAgICAgICAgICAgICAgIH0KCiAgaXQgJ2lzIGNodW5reScgZG8KICAgIGV4cGVjdChiYWNvbi5jaHVua3k/KS50byBiZV90cnV0aHkKICBlbmQKZW5kCgojIGdvb2QKZGVzY3JpYmUgQmFjb24gZG8KICBwZW5kaW5nICd3aWxsIGFkZCB0ZXN0cyBsYXRlcicKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRW1wdHlFeGFtcGxlR3JvdXAKCj09IFJTcGVjL0VtcHR5SG9vawoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMzkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgZW1wdHkgYmVmb3JlIGFuZCBhZnRlciBob29rcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJlZm9yZSB7fQphZnRlciBkbzsgZW5kCmJlZm9yZSg6YWxsKSBkbwplbmQKYWZ0ZXIoOmFsbCkgeyB9CgojIGdvb2QKYmVmb3JlIHsgY3JlYXRlX3VzZXJzIH0KYWZ0ZXIgZG8KICBjbGVhbnVwX3VzZXJzCmVuZApiZWZvcmUoOmFsbCkgZG8KICBjcmVhdGVfZmVlZAplbmQKYWZ0ZXIoOmFsbCkgeyBjbGVhbnVwX2ZlZWQgfQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0VtcHR5SG9vawoKPT0gUlNwZWMvRW1wdHlMaW5lQWZ0ZXJFeGFtcGxlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4zNgp8IC0KfD09PQoKQ2hlY2tzIGlmIHRoZXJlIGlzIGFuIGVtcHR5IGxpbmUgYWZ0ZXIgZXhhbXBsZSBibG9ja3MuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSU3BlYy5kZXNjcmliZSBGb28gZG8KICBpdCAnZG9lcyB0aGlzJyBkbwogIGVuZAogIGl0ICdkb2VzIHRoYXQnIGRvCiAgZW5kCmVuZAoKIyBnb29kClJTcGVjLmRlc2NyaWJlIEZvbyBkbwogIGl0ICdkb2VzIHRoaXMnIGRvCiAgZW5kCgogIGl0ICdkb2VzIHRoYXQnIGRvCiAgZW5kCmVuZAoKIyBmYWlyIC0gaXQncyBvayB0byBoYXZlIG5vbi1zZXBhcmF0ZWQgb25lLWxpbmVycwpSU3BlYy5kZXNjcmliZSBGb28gZG8KICBpdCB7IG9uZSB9CiAgaXQgeyB0d28gfQplbmQKLS0tLQoKPT09PSB3aXRoIEFsbG93Q29uc2VjdXRpdmVPbmVMaW5lcnMgY29uZmlndXJhdGlvbgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgcnVib2NvcC55bWwKIyBSU3BlYy9FbXB0eUxpbmVBZnRlckV4YW1wbGU6CiMgICBBbGxvd0NvbnNlY3V0aXZlT25lTGluZXJzOiBmYWxzZQoKIyBiYWQKUlNwZWMuZGVzY3JpYmUgRm9vIGRvCiAgaXQgeyBvbmUgfQogIGl0IHsgdHdvIH0KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBBbGxvd0NvbnNlY3V0aXZlT25lTGluZXJzCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jZW1wdHktbGluZXMtYXJvdW5kLWV4YW1wbGVzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9FbXB0eUxpbmVBZnRlckV4YW1wbGUKCj09IFJTcGVjL0VtcHR5TGluZUFmdGVyRXhhbXBsZUdyb3VwCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4yNwp8IC0KfD09PQoKQ2hlY2tzIGlmIHRoZXJlIGlzIGFuIGVtcHR5IGxpbmUgYWZ0ZXIgZXhhbXBsZSBncm91cCBibG9ja3MuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSU3BlYy5kZXNjcmliZSBGb28gZG8KICBkZXNjcmliZSAnI2JhcicgZG8KICBlbmQKICBkZXNjcmliZSAnI2JheicgZG8KICBlbmQKZW5kCgojIGdvb2QKUlNwZWMuZGVzY3JpYmUgRm9vIGRvCiAgZGVzY3JpYmUgJyNiYXInIGRvCiAgZW5kCgogIGRlc2NyaWJlICcjYmF6JyBkbwogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yc3BlYy5ydWJ5c3R5bGUuZ3VpZGUvI2VtcHR5LWxpbmVzLWJldHdlZW4tZGVzY3JpYmVzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9FbXB0eUxpbmVBZnRlckV4YW1wbGVHcm91cAoKPT0gUlNwZWMvRW1wdHlMaW5lQWZ0ZXJGaW5hbExldAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMTQKfCAtCnw9PT0KCkNoZWNrcyBpZiB0aGVyZSBpcyBhbiBlbXB0eSBsaW5lIGFmdGVyIHRoZSBsYXN0IGxldCBibG9jay4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6Zm9vKSB7IGJhciB9CmxldCg6c29tZXRoaW5nKSB7IG90aGVyIH0KaXQgeyBkb2VzX3NvbWV0aGluZyB9CgojIGdvb2QKbGV0KDpmb28pIHsgYmFyIH0KbGV0KDpzb21ldGhpbmcpIHsgb3RoZXIgfQoKaXQgeyBkb2VzX3NvbWV0aGluZyB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNlbXB0eS1saW5lLWFmdGVyLWxldAoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRW1wdHlMaW5lQWZ0ZXJGaW5hbExldAoKPT0gUlNwZWMvRW1wdHlMaW5lQWZ0ZXJIb29rCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4yNwp8IDIuMTMKfD09PQoKQ2hlY2tzIGlmIHRoZXJlIGlzIGFuIGVtcHR5IGxpbmUgYWZ0ZXIgaG9vayBibG9ja3MuCgpgQWxsb3dDb25zZWN1dGl2ZU9uZUxpbmVyc2AgY29uZmlndXJlcyB3aGV0aGVyIGFkamFjZW50Cm9uZS1saW5lIGRlZmluaXRpb25zIGFyZSBjb25zaWRlcmVkIGFuIG9mZmVuc2UuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApiZWZvcmUgeyBkb19zb21ldGhpbmcgfQppdCB7IGRvZXNfc29tZXRoaW5nIH0KCiMgYmFkCmFmdGVyIHsgZG9fc29tZXRoaW5nIH0KaXQgeyBkb2VzX3NvbWV0aGluZyB9CgojIGJhZAphcm91bmQgeyB8dGVzdHwgdGVzdC5ydW4gfQppdCB7IGRvZXNfc29tZXRoaW5nIH0KCiMgZ29vZAphZnRlciB7IGRvX3NvbWV0aGluZyB9CgppdCB7IGRvZXNfc29tZXRoaW5nIH0KCiMgZmFpciAtIGl0J3Mgb2sgdG8gaGF2ZSBub24tc2VwYXJhdGVkIG9uZS1saW5lcnMgaG9va3MKYXJvdW5kIHsgfHRlc3R8IHRlc3QucnVuIH0KYWZ0ZXIgeyBkb19zb21ldGhpbmcgfQoKaXQgeyBkb2VzX3NvbWV0aGluZyB9Ci0tLS0KCj09PT0gd2l0aCBBbGxvd0NvbnNlY3V0aXZlT25lTGluZXJzIGNvbmZpZ3VyYXRpb24KCltzb3VyY2UscnVieV0KLS0tLQojIHJ1Ym9jb3AueW1sCiMgUlNwZWMvRW1wdHlMaW5lQWZ0ZXJIb29rOgojICAgQWxsb3dDb25zZWN1dGl2ZU9uZUxpbmVyczogZmFsc2UKCiMgYmFkCmFyb3VuZCB7IHx0ZXN0fCB0ZXN0LnJ1biB9CmFmdGVyIHsgZG9fc29tZXRoaW5nIH0KCml0IHsgZG9lc19zb21ldGhpbmcgfQoKIyBnb29kCmFyb3VuZCB7IHx0ZXN0fCB0ZXN0LnJ1biB9CgphZnRlciB7IGRvX3NvbWV0aGluZyB9CgppdCB7IGRvZXNfc29tZXRoaW5nIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93Q29uc2VjdXRpdmVPbmVMaW5lcnMKfCBgdHJ1ZWAKfCBCb29sZWFuCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNlbXB0eS1saW5lLWFmdGVyLWxldAoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRW1wdHlMaW5lQWZ0ZXJIb29rCgo9PSBSU3BlYy9FbXB0eUxpbmVBZnRlclN1YmplY3QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjE0CnwgLQp8PT09CgpDaGVja3MgaWYgdGhlcmUgaXMgYW4gZW1wdHkgbGluZSBhZnRlciBzdWJqZWN0IGJsb2NrLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3ViamVjdCg6b2JqKSB7IGRlc2NyaWJlZF9jbGFzcyB9CmxldCg6Zm9vKSB7IGJhciB9CgojIGdvb2QKc3ViamVjdCg6b2JqKSB7IGRlc2NyaWJlZF9jbGFzcyB9CgpsZXQoOmZvbykgeyBiYXIgfQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jZW1wdHktbGluZS1hZnRlci1sZXQKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0VtcHR5TGluZUFmdGVyU3ViamVjdAoKPT0gUlNwZWMvRW1wdHlNZXRhZGF0YQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMjQKfCAtCnw9PT0KCkF2b2lkIGVtcHR5IG1ldGFkYXRhIGhhc2guCgo9PT0gRXhhbXBsZXMKCj09PT0gRW5mb3JjZWRTdHlsZTogc3ltYm9sIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlICdTb21ldGhpbmcnLCB7fQoKIyBnb29kCmRlc2NyaWJlICdTb21ldGhpbmcnCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRW1wdHlNZXRhZGF0YQoKPT0gUlNwZWMvRW1wdHlPdXRwdXQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjI5CnwgLQp8PT09CgpDaGVjayB0aGF0IHRoZSBgb3V0cHV0YCBtYXRjaGVyIGlzIG5vdCBjYWxsZWQgd2l0aCBhbiBlbXB0eSBzdHJpbmcuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QgeyBmb28gfS50byBvdXRwdXQoJycpLnRvX3N0ZG91dApleHBlY3QgeyBiYXIgfS5ub3RfdG8gb3V0cHV0KCcnKS50b19zdGRlcnIKCiMgZ29vZApleHBlY3QgeyBmb28gfS5ub3RfdG8gb3V0cHV0LnRvX3N0ZG91dApleHBlY3QgeyBiYXIgfS50byBvdXRwdXQudG9fc3RkZXJyCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRW1wdHlPdXRwdXQKCj09IFJTcGVjL0VxCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4yNAp8IC0KfD09PQoKVXNlIGBlcWAgaW5zdGVhZCBvZiBgYmUgPT1gIHRvIGNvbXBhcmUgb2JqZWN0cy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIGJlID09IDQyCgojIGdvb2QKZXhwZWN0KGZvbykudG8gZXEgNDIKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9FcQoKPT0gUlNwZWMvRXhhbXBsZUxlbmd0aAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS41CnwgMi4zCnw9PT0KCkNoZWNrcyBmb3IgbG9uZyBleGFtcGxlcy4KCkEgbG9uZyBleGFtcGxlIGlzIHVzdWFsbHkgbW9yZSBkaWZmaWN1bHQgdG8gdW5kZXJzdGFuZC4gQ29uc2lkZXIKZXh0cmFjdGluZyBvdXQgc29tZSBiZWhhdmlvciwgZS5nLiB3aXRoIGEgYGxldGAgYmxvY2ssIG9yIGEgaGVscGVyCm1ldGhvZC4KCllvdSBjYW4gc2V0IGNvbnN0cnVjdHMgeW91IHdhbnQgdG8gZm9sZCB3aXRoIGBDb3VudEFzT25lYC4KQXZhaWxhYmxlIGFyZTogJ2FycmF5JywgJ2hhc2gnLCAnaGVyZWRvYycsIGFuZCAnbWV0aG9kX2NhbGwnLgpFYWNoIGNvbnN0cnVjdCB3aWxsIGJlIGNvdW50ZWQgYXMgb25lIGxpbmUgcmVnYXJkbGVzcyBvZgppdHMgYWN0dWFsIHNpemUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCBkbwogIHNlcnZpY2UgPSBkZXNjcmliZWRfY2xhc3MubmV3CiAgbW9yZV9zZXR1cAogIG1vcmVfc2V0dXAKICByZXN1bHQgPSBzZXJ2aWNlLmNhbGwKICBleHBlY3QocmVzdWx0KS50byBiZSh0cnVlKQplbmQKCiMgZ29vZAppdCBkbwogIHNlcnZpY2UgPSBkZXNjcmliZWRfY2xhc3MubmV3CiAgcmVzdWx0ID0gc2VydmljZS5jYWxsCiAgZXhwZWN0KHJlc3VsdCkudG8gYmUodHJ1ZSkKZW5kCi0tLS0KCj09PT0gQ291bnRBc09uZTogWydhcnJheScsICdoZXJlZG9jJywgJ21ldGhvZF9jYWxsJ10KCltzb3VyY2UscnVieV0KLS0tLQppdCBkbwogIGFycmF5ID0gWyAgICAgICAgICMgKzEKICAgIDEsCiAgICAyCiAgXQoKICBoYXNoID0geyAgICAgICAgICAjICszCiAgICBrZXk6ICd2YWx1ZScKICB9CgogIG1zZyA9IDw8fkhFUkVET0MgICMgKzEKICAgIEhlcmVkb2MKICAgIGNvbnRlbnQuCiAgSEVSRURPQwoKICBmb28oICAgICAgICAgICAgIyArMQogICAgMSwKICAgIDIKICApCmVuZCAgICAgICAgICAgICAgICMgNiBwb2ludHMKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE1heAp8IGA1YAp8IEludGVnZXIKCnwgQ291bnRBc09uZQp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0V4YW1wbGVMZW5ndGgKCj09IFJTcGVjL0V4YW1wbGVXaXRob3V0RGVzY3JpcHRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMjIKfCAtCnw9PT0KCkNoZWNrcyBmb3IgZXhhbXBsZXMgd2l0aG91dCBhIGRlc2NyaXB0aW9uLgoKUlNwZWMgYWxsb3dzIGZvciBhdXRvLWdlbmVyYXRlZCBleGFtcGxlIGRlc2NyaXB0aW9ucyB3aGVuIHRoZXJlIGlzIG5vCmRlc2NyaXB0aW9uIHByb3ZpZGVkIG9yIHRoZSBkZXNjcmlwdGlvbiBpcyBhbiBlbXB0eSBvbmUuCkl0IGlzIGFjY2VwdGFibGUgdG8gdXNlIGBzcGVjaWZ5YCB3aXRob3V0IGEgZGVzY3JpcHRpb24KClRoaXMgY29wIHJlbW92ZXMgZW1wdHkgZGVzY3JpcHRpb25zLgpJdCBhbHNvIGRlZmluZXMgd2hldGhlciBhdXRvLWdlbmVyYXRlZCBkZXNjcmlwdGlvbiBpcyBhbGxvd2VkLCBiYXNlZApvbiB0aGUgY29uZmlndXJlZCBzdHlsZS4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgRW5mb3JjZWRTdHlsZWAgb3B0aW9uCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGFsd2F5cyBnb29kCnNwZWNpZnkgZG8KICByZXN1bHQgPSBzZXJ2aWNlLmNhbGwKICBleHBlY3QocmVzdWx0KS50byBiZSh0cnVlKQplbmQKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogYWx3YXlzX2FsbG93YCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCgnJykgeyBpc19leHBlY3RlZC50byBiZV9nb29kIH0Kc3BlY2lmeSAnJyBkbwogIHJlc3VsdCA9IHNlcnZpY2UuY2FsbAogIGV4cGVjdChyZXN1bHQpLnRvIGJlKHRydWUpCmVuZAoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gYmVfZ29vZCB9CnNwZWNpZnkgZG8KICByZXN1bHQgPSBzZXJ2aWNlLmNhbGwKICBleHBlY3QocmVzdWx0KS50byBiZSh0cnVlKQplbmQKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogc2luZ2xlX2xpbmVfb25seWAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCgnJykgeyBpc19leHBlY3RlZC50byBiZV9nb29kIH0KaXQgZG8KICByZXN1bHQgPSBzZXJ2aWNlLmNhbGwKICBleHBlY3QocmVzdWx0KS50byBiZSh0cnVlKQplbmQKCiMgZ29vZAppdCB7IGlzX2V4cGVjdGVkLnRvIGJlX2dvb2QgfQotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBkaXNhbGxvd2AKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCB7IGlzX2V4cGVjdGVkLnRvIGJlX2dvb2QgfQppdCBkbwogIHJlc3VsdCA9IHNlcnZpY2UuY2FsbAogIGV4cGVjdChyZXN1bHQpLnRvIGJlKHRydWUpCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBhbHdheXNfYWxsb3dgCnwgYGFsd2F5c19hbGxvd2AsIGBzaW5nbGVfbGluZV9vbmx5YCwgYGRpc2FsbG93YAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0V4YW1wbGVXaXRob3V0RGVzY3JpcHRpb24KCj09IFJTcGVjL0V4YW1wbGVXb3JkaW5nCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4wCnwgMi4xMwp8PT09CgpDaGVja3MgZm9yIGNvbW1vbiBtaXN0YWtlcyBpbiBleGFtcGxlIGRlc2NyaXB0aW9ucy4KClRoaXMgY29wIHdpbGwgY29ycmVjdCBkb2NzdHJpbmdzIHRoYXQgYmVnaW4gd2l0aCAnc2hvdWxkJyBhbmQgJ2l0Jy4KVGhpcyBjb3Agd2lsbCBhbHNvIGxvb2sgZm9yIGluc3VmZmljaWVudCBleGFtcGxlcyBhbmQgY2FsbCB0aGVtIG91dC4KClRoZSBhdXRvY29ycmVjdCBpcyBleHBlcmltZW50YWwgLSB1c2Ugd2l0aCBjYXJlISBJdCBjYW4gYmUgY29uZmlndXJlZAp3aXRoIEN1c3RvbVRyYW5zZm9ybSAoZS5nLiBoYXZlID0+IGhhcykgYW5kIElnbm9yZWRXb3JkcyAoZS5nLiBvbmx5KS4KClVzZSB0aGUgRGlzYWxsb3dlZEV4YW1wbGVzIHNldHRpbmcgdG8gcHJldmVudCB1bmNsZWFyIG9yIGluc3VmZmljaWVudApkZXNjcmlwdGlvbnMuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBjb25maWcgd2lsbCBub3QgYmUgdHJlYXRlZCBhcwpjYXNlIHNlbnNpdGl2ZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0ICdzaG91bGQgZmluZCBub3RoaW5nJyBkbwplbmQKCml0ICd3aWxsIGZpbmQgbm90aGluZycgZG8KZW5kCgojIGdvb2QKaXQgJ2ZpbmRzIG5vdGhpbmcnIGRvCmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgJ2l0IGRvZXMgdGhpbmdzJyBkbwplbmQKCiMgZ29vZAppdCAnZG9lcyB0aGluZ3MnIGRvCmVuZAotLS0tCgo9PT09IGBEaXNhbGxvd2VkRXhhbXBsZXM6IFsnd29ya3MnXWAgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgJ3dvcmtzJyBkbwplbmQKCiMgZ29vZAppdCAnbWFya3MgdGhlIHRhc2sgYXMgZG9uZScgZG8KZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBDdXN0b21UcmFuc2Zvcm0KfCBgeyJiZSI9PiJpcyIsICJCRSI9PiJJUyIsICJoYXZlIj0+ImhhcyIsICJIQVZFIj0+IkhBUyJ9YAp8IAoKfCBJZ25vcmVkV29yZHMKfCBgW11gCnwgQXJyYXkKCnwgRGlzYWxsb3dlZEV4YW1wbGVzCnwgYHdvcmtzYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNzaG91bGQtaW4tZXhhbXBsZS1kb2NzdHJpbmdzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9FeGFtcGxlV29yZGluZwoqIGh0dHA6Ly9iZXR0ZXJzcGVjcy5vcmcvI3Nob3VsZAoKPT0gUlNwZWMvRXhjZXNzaXZlRG9jc3RyaW5nU3BhY2luZwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuNQp8IC0KfD09PQoKQ2hlY2tzIGZvciBleGNlc3NpdmUgd2hpdGVzcGFjZSBpbiBleGFtcGxlIGRlc2NyaXB0aW9ucy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0ICcgIGhhcyAgZXhjZXNzaXZlICAgc3BhY2luZyAgJyBkbwplbmQKCiMgZ29vZAppdCAnaGFzIGV4Y2Vzc2l2ZSBzcGFjaW5nJyBkbwplbmQKLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmNvbnRleHQgJyAgd2hlbiBhIGNvbmRpdGlvbiAgIGlzIG1ldCAgJyBkbwplbmQKCiMgZ29vZApjb250ZXh0ICd3aGVuIGEgY29uZGl0aW9uIGlzIG1ldCcgZG8KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRXhjZXNzaXZlRG9jc3RyaW5nU3BhY2luZwoKPT0gUlNwZWMvRXhwZWN0QWN0dWFsCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS43CnwgMi4yMwp8PT09CgpDaGVja3MgZm9yIGBleHBlY3QoLi4uKWAgY2FsbHMgY29udGFpbmluZyBsaXRlcmFsIHZhbHVlcy4KCkF1dG9jb3JyZWN0aW9uIGlzIHBlcmZvcm1lZCB3aGVuIHRoZSBleHBlY3RlZCBpcyBub3QgYSBsaXRlcmFsLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZXhwZWN0KDUpLnRvIGVxKHByaWNlKQpleHBlY3QoL2Zvby8pLnRvIGVxKHBhdHRlcm4pCmV4cGVjdCgiSm9obiIpLnRvIGVxKG5hbWUpCgojIGdvb2QKZXhwZWN0KHByaWNlKS50byBlcSg1KQpleHBlY3QocGF0dGVybikudG8gZXEoL2Zvby8pCmV4cGVjdChuYW1lKS50byBlcSgiSm9obiIpCgojIGJhZCAobm90IHN1cHBvcnRlZCBhdXRvY29ycmVjdGlvbikKZXhwZWN0KGZhbHNlKS50byBlcSh0cnVlKQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRXhjbHVkZQp8IGArKiovc3BlYy9yb3V0aW5nLyoqLyorYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRXhwZWN0QWN0dWFsCgo9PSBSU3BlYy9FeHBlY3RDaGFuZ2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMgKFVuc2FmZSkKfCAxLjIyCnwgMi41Cnw9PT0KCkNoZWNrcyBmb3IgY29uc2lzdGVudCBzdHlsZSBvZiBjaGFuZ2UgbWF0Y2hlci4KCkVuZm9yY2VzIGVpdGhlciBwYXNzaW5nIG9iamVjdCBhbmQgYXR0cmlidXRlIGFzIGFyZ3VtZW50cyB0byB0aGUgbWF0Y2hlcgpvciBwYXNzaW5nIGEgYmxvY2sgdGhhdCByZWFkcyB0aGUgYXR0cmlidXRlIHZhbHVlLgoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBFbmZvcmNlZFN0eWxlYCBvcHRpb24uCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IG1ldGhvZF9jYWxsYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QgeyBydW4gfS50byBjaGFuZ2UgeyBGb28uYmFyIH0KZXhwZWN0IHsgcnVuIH0udG8gY2hhbmdlIHsgZm9vLmJheiB9CgojIGdvb2QKZXhwZWN0IHsgcnVuIH0udG8gY2hhbmdlKEZvbywgOmJhcikKZXhwZWN0IHsgcnVuIH0udG8gY2hhbmdlKGZvbywgOmJheikKIyBhbHNvIGdvb2Qgd2hlbiB0aGVyZSBhcmUgYXJndW1lbnRzIG9yIGNoYWluZWQgbWV0aG9kIGNhbGxzCmV4cGVjdCB7IHJ1biB9LnRvIGNoYW5nZSB7IEZvby5iYXIoOmNvdW50KSB9CmV4cGVjdCB7IHJ1biB9LnRvIGNoYW5nZSB7IHVzZXIucmVsb2FkLm5hbWUgfQotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBibG9ja2AKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QgeyBydW4gfS50byBjaGFuZ2UoRm9vLCA6YmFyKQoKIyBnb29kCmV4cGVjdCB7IHJ1biB9LnRvIGNoYW5nZSB7IEZvby5iYXIgfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBtZXRob2RfY2FsbGAKfCBgbWV0aG9kX2NhbGxgLCBgYmxvY2tgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRXhwZWN0Q2hhbmdlCgo9PSBSU3BlYy9FeHBlY3RJbkhvb2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMTYKfCAtCnw9PT0KCkRvIG5vdCB1c2UgYGV4cGVjdGAgaW4gaG9va3Mgc3VjaCBhcyBgYmVmb3JlYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJlZm9yZSBkbwogIGV4cGVjdChzb21ldGhpbmcpLnRvIGVxICdmb28nCmVuZAoKIyBiYWQKYWZ0ZXIgZG8KICBleHBlY3RfYW55X2luc3RhbmNlX29mKFNvbWV0aGluZykudG8gcmVjZWl2ZSg6Zm9vKQplbmQKCiMgZ29vZAppdCBkbwogIGV4cGVjdChzb21ldGhpbmcpLnRvIGVxICdmb28nCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0V4cGVjdEluSG9vawoKPT0gUlNwZWMvRXhwZWN0T3V0cHV0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjEwCnwgLQp8PT09CgpDaGVja3MgZm9yIG9wcG9ydHVuaXRpZXMgdG8gdXNlIGBleHBlY3QgeyAuLi4gfS50byBvdXRwdXRgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKJHN0ZG91dCA9IFN0cmluZ0lPLm5ldwpteV9hcHAucHJpbnRfcmVwb3J0CiRzdGRvdXQgPSBTVERPVVQKZXhwZWN0KCRzdGRvdXQuc3RyaW5nKS50byBlcSgnSGVsbG8gV29ybGQnKQoKIyBnb29kCmV4cGVjdCB7IG15X2FwcC5wcmludF9yZXBvcnQgfS50byBvdXRwdXQoJ0hlbGxvIFdvcmxkJykudG9fc3Rkb3V0Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvRXhwZWN0T3V0cHV0Cgo9PSBSU3BlYy9GaWxlUGF0aAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4yCnwgMi4yNAp8PT09CgpDaGVja3MgdGhhdCBzcGVjIGZpbGUgcGF0aHMgYXJlIGNvbnNpc3RlbnQgYW5kIHdlbGwtZm9ybWVkLgoKVGhpcyBjb3AgaXMgZGVwcmVjYXRlZC4KV2UgcGxhbiB0byByZW1vdmUgaXQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiB1cGRhdGUgdG8gMy4wLgpUaGUgbWlncmF0aW9uIHRhcmdldHMgYXJlIGBSU3BlYy9TcGVjRmlsZVBhdGhTdWZmaXhgCmFuZCBgUlNwZWMvU3BlY0ZpbGVQYXRoRm9ybWF0YC4KSWYgeW91IGFyZSB1c2luZyB0aGlzIGNvcCwgcGxlYXNlIHBsYW4gZm9yIG1pZ3JhdGlvbi4KCkJ5IGRlZmF1bHQsIHRoaXMgY2hlY2tzIHRoYXQgc3BlYyBmaWxlIHBhdGhzIGFyZSBjb25zaXN0ZW50IHdpdGggdGhlCnRlc3Qgc3ViamVjdCBhbmQgZW5mb3JjZXMgdGhhdCBpdCByZWZsZWN0cyB0aGUgZGVzY3JpYmVkCmNsYXNzL21vZHVsZSBhbmQgaXRzIG9wdGlvbmFsbHkgY2FsbGVkIG91dCBtZXRob2QuCgpXaXRoIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiBgSWdub3JlTWV0aG9kc2AgdGhlIGNhbGxlZCBvdXQgbWV0aG9kIHdpbGwKYmUgaWdub3JlZCB3aGVuIGRldGVybWluaW5nIHRoZSBlbmZvcmNlZCBwYXRoLgoKV2l0aCB0aGUgY29uZmlndXJhdGlvbiBvcHRpb24gYEN1c3RvbVRyYW5zZm9ybWAgbW9kdWxlcyBvciBjbGFzc2VzIGNhbgpiZSBzcGVjaWZpZWQgdGhhdCBzaG91bGQgbm90IGFzIHVzdWFsIGJlIHRyYW5zZm9ybWVkIGZyb20gQ2FtZWxDYXNlIHRvCnNuYWtlX2Nhc2UgKGUuZy4gJ1J1Ym9Db3AnID0+ICdydWJvY29wJyApLgoKV2l0aCB0aGUgY29uZmlndXJhdGlvbiBvcHRpb24gYFNwZWNTdWZmaXhPbmx5YCB0ZXN0IGZpbGVzIHdpbGwgb25seQpiZSBjaGVja2VkIHRvIGVuc3VyZSB0aGV5IGVuZCBpbiAnX3NwZWMucmInLiBUaGlzIG9wdGlvbiBkaXNhYmxlcwpjaGVja2luZyBmb3IgY29uc2lzdGVuY3kgaW4gdGhlIHRlc3Qgc3ViamVjdCBvciB0ZXN0IG1ldGhvZHMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAp3aGF0ZXZlcl9zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzCgojIGJhZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzLCAnI21ldGhvZCcKCiMgZ29vZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzCgojIGdvb2QKbXlfY2xhc3NfbWV0aG9kX3NwZWMucmIgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCgojIGdvb2QKbXlfY2xhc3MvbWV0aG9kX3NwZWMucmIgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCi0tLS0KCj09PT0gd2hlbiBjb25maWd1cmF0aW9uIGlzIGBJZ25vcmVNZXRob2RzOiB0cnVlYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCndoYXRldmVyX3NwZWMucmIgICAgICAgICAjIGRlc2NyaWJlIE15Q2xhc3MKCiMgZ29vZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzCgojIGdvb2QKbXlfY2xhc3Nfc3BlYy5yYiAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCi0tLS0KCj09PT0gd2hlbiBjb25maWd1cmF0aW9uIGlzIGBTcGVjU3VmZml4T25seTogdHJ1ZWAKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKd2hhdGV2ZXJfc3BlYy5yYiAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcwoKIyBnb29kCm15X2NsYXNzX3NwZWMucmIgICAgICAgICAjIGRlc2NyaWJlIE15Q2xhc3MKCiMgZ29vZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzLCAnI21ldGhvZCcKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEluY2x1ZGUKfCBgKyoqLypfc3BlYypyYiorYCwgYCsqKi9zcGVjLyoqLyorYAp8IEFycmF5Cgp8IEN1c3RvbVRyYW5zZm9ybQp8IGB7IlJ1Ym9Db3AiPT4icnVib2NvcCIsICJSU3BlYyI9PiJyc3BlYyJ9YAp8IAoKfCBJZ25vcmVNZXRob2RzCnwgYGZhbHNlYAp8IEJvb2xlYW4KCnwgU3BlY1N1ZmZpeE9ubHkKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0ZpbGVQYXRoCgo9PSBSU3BlYy9Gb2N1cwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuNQp8IDIuMQp8PT09CgpDaGVja3MgaWYgZXhhbXBsZXMgYXJlIGZvY3VzZWQuCgpUaGlzIGNvcCBkb2VzIG5vdCBzdXBwb3J0IGF1dG9jb3JyZWN0aW9uIGluIHNvbWUgY2FzZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBNeUNsYXNzLCBmb2N1czogdHJ1ZSBkbwplbmQKCmRlc2NyaWJlIE15Q2xhc3MsIDpmb2N1cyBkbwplbmQKCmZkZXNjcmliZSBNeUNsYXNzIGRvCmVuZAoKIyBnb29kCmRlc2NyaWJlIE15Q2xhc3MgZG8KZW5kCgojIGJhZApmZGVzY3JpYmUgJ3Rlc3QnIGRvOyBlbmQKCiMgZ29vZApkZXNjcmliZSAndGVzdCcgZG87IGVuZAoKIyBiYWQKZmRlc2NyaWJlICd0ZXN0JyBkbzsgZW5kCgojIGdvb2QKZGVzY3JpYmUgJ3Rlc3QnIGRvOyBlbmQKCiMgYmFkCnNoYXJlZF9leGFtcGxlcyAndGVzdCcsIGZvY3VzOiB0cnVlIGRvOyBlbmQKCiMgZ29vZApzaGFyZWRfZXhhbXBsZXMgJ3Rlc3QnIGRvOyBlbmQKCiMgYmFkCnNoYXJlZF9jb250ZXh0ICd0ZXN0JywgZm9jdXM6IHRydWUgZG87IGVuZAoKIyBnb29kCnNoYXJlZF9jb250ZXh0ICd0ZXN0JyBkbzsgZW5kCgojIGJhZCAoZG9lcyBub3Qgc3VwcG9ydCBhdXRvY29ycmVjdGlvbikKZm9jdXMgJ3Rlc3QnIGRvOyBlbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9Gb2N1cwoKPT0gUlNwZWMvSG9va0FyZ3VtZW50Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS43CnwgLQp8PT09CgpDaGVja3MgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYGJlZm9yZWAsIGBhcm91bmRgLCBhbmQgYGFmdGVyYC4KClRoaXMgY29wIGNoZWNrcyBmb3IgY29uc2lzdGVudCBzdHlsZSB3aGVuIHNwZWNpZnlpbmcgUlNwZWMKaG9va3Mgd2hpY2ggcnVuIGZvciBlYWNoIGV4YW1wbGUuIFRoZXJlIGFyZSB0aHJlZSBzdXBwb3J0ZWQKc3R5bGVzOiAiaW1wbGljaXQiLCAiZWFjaCIsIGFuZCAiZXhhbXBsZS4iIEFsbCBzdHlsZXMgaGF2ZQp0aGUgc2FtZSBiZWhhdmlvci4KCj09PSBFeGFtcGxlcwoKPT09PSBgRW5mb3JjZWRTdHlsZTogaW1wbGljaXRgIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmJlZm9yZSg6ZWFjaCkgZG8KICAjIC4uLgplbmQKCiMgYmFkCmJlZm9yZSg6ZXhhbXBsZSkgZG8KICAjIC4uLgplbmQKCiMgZ29vZApiZWZvcmUgZG8KICAjIC4uLgplbmQKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogZWFjaGAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApiZWZvcmUoOmV4YW1wbGUpIGRvCiAgIyAuLi4KZW5kCgojIGJhZApiZWZvcmUgZG8KICAjIC4uLgplbmQKCiMgZ29vZApiZWZvcmUoOmVhY2gpIGRvCiAgIyAuLi4KZW5kCi0tLS0KCj09PT0gYEVuZm9yY2VkU3R5bGU6IGV4YW1wbGVgCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYmVmb3JlKDplYWNoKSBkbwogICMgLi4uCmVuZAoKIyBiYWQKYmVmb3JlIGRvCiAgIyAuLi4KZW5kCgojIGdvb2QKYmVmb3JlKDpleGFtcGxlKSBkbwogICMgLi4uCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBpbXBsaWNpdGAKfCBgaW1wbGljaXRgLCBgZWFjaGAsIGBleGFtcGxlYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jcmVkdW5kYW50LWJlZm9yZWVhY2gKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0hvb2tBcmd1bWVudAoKPT0gUlNwZWMvSG9va3NCZWZvcmVFeGFtcGxlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMjkKfCAtCnw9PT0KCkNoZWNrcyBmb3IgYmVmb3JlL2Fyb3VuZC9hZnRlciBob29rcyB0aGF0IGNvbWUgYWZ0ZXIgYW4gZXhhbXBsZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0ICdjaGVja3Mgd2hhdCBmb28gZG9lcycgZG8KICBleHBlY3QoZm9vKS50byBiZQplbmQKCmJlZm9yZSB7IHByZXBhcmUgfQphZnRlciB7IGNsZWFuX3VwIH0KCiMgZ29vZApiZWZvcmUgeyBwcmVwYXJlIH0KYWZ0ZXIgeyBjbGVhbl91cCB9CgppdCAnY2hlY2tzIHdoYXQgZm9vIGRvZXMnIGRvCiAgZXhwZWN0KGZvbykudG8gYmUKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvSG9va3NCZWZvcmVFeGFtcGxlcwoKPT0gUlNwZWMvSWRlbnRpY2FsRXF1YWxpdHlBc3NlcnRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuNAp8IC0KfD09PQoKQ2hlY2tzIGZvciBlcXVhbGl0eSBhc3NlcnRpb25zIHdpdGggaWRlbnRpY2FsIGV4cHJlc3Npb25zIG9uIGJvdGggc2lkZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vLmJhcikudG8gZXEoZm9vLmJhcikKZXhwZWN0KGZvby5iYXIpLnRvIGVxbChmb28uYmFyKQoKIyBnb29kCmV4cGVjdChmb28uYmFyKS50byBlcSgyKQpleHBlY3QoZm9vLmJhcikudG8gZXFsKDIpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvSWRlbnRpY2FsRXF1YWxpdHlBc3NlcnRpb24KCj09IFJTcGVjL0ltcGxpY2l0QmxvY2tFeHBlY3RhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4zNQp8IC0KfD09PQoKQ2hlY2sgdGhhdCBpbXBsaWNpdCBibG9jayBleHBlY3RhdGlvbiBzeW50YXggaXMgbm90IHVzZWQuCgpQcmVmZXIgdXNpbmcgZXhwbGljaXQgYmxvY2sgZXhwZWN0YXRpb25zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3ViamVjdCB7IC0+IHsgZG9fc29tZXRoaW5nIH0gfQppdCB7IGlzX2V4cGVjdGVkLnRvIGNoYW5nZShzb21ldGhpbmcpLnRvKG5ld192YWx1ZSkgfQoKIyBnb29kCml0ICdjaGFuZ2VzIHNvbWV0aGluZyB0byBhIG5ldyB2YWx1ZScgZG8KICBleHBlY3QgeyBkb19zb21ldGhpbmcgfS50byBjaGFuZ2Uoc29tZXRoaW5nKS50byhuZXdfdmFsdWUpCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jaW1wbGljaXQtYmxvY2stZXhwZWN0YXRpb25zCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9JbXBsaWNpdEJsb2NrRXhwZWN0YXRpb24KCj09IFJTcGVjL0ltcGxpY2l0RXhwZWN0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS44CnwgLQp8PT09CgpDaGVjayB0aGF0IGEgY29uc2lzdGVudCBpbXBsaWNpdCBleHBlY3RhdGlvbiBzdHlsZSBpcyB1c2VkLgoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBFbmZvcmNlZFN0eWxlYCBvcHRpb24KYW5kIHN1cHBvcnRzIHRoZSBgLS1hdXRvLWdlbi1jb25maWdgIGZsYWcuCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IGlzX2V4cGVjdGVkYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCB7IHNob3VsZCBiZV90cnV0aHkgfQoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5IH0KLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogc2hvdWxkYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0IHsgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5IH0KCiMgZ29vZAppdCB7IHNob3VsZCBiZV90cnV0aHkgfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBpc19leHBlY3RlZGAKfCBgaXNfZXhwZWN0ZWRgLCBgc2hvdWxkYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jdXNlLWV4cGVjdAoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvSW1wbGljaXRFeHBlY3QKCj09IFJTcGVjL0ltcGxpY2l0U3ViamVjdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMjkKfCAyLjEzCnw9PT0KCkNoZWNrcyBmb3IgdXNhZ2Ugb2YgaW1wbGljaXQgc3ViamVjdCAoYGlzX2V4cGVjdGVkYCAvIGBzaG91bGRgKS4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgRW5mb3JjZWRTdHlsZWAgb3B0aW9uCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IHNpbmdsZV9saW5lX29ubHlgIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0IGRvCiAgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5CmVuZAoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5IH0KaXQgZG8KICBleHBlY3Qoc3ViamVjdCkudG8gYmVfdHJ1dGh5CmVuZAotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBzaW5nbGVfc3RhdGVtZW50X29ubHlgCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgZG8KICBmb28gPSAxCiAgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5CmVuZAoKIyBnb29kCml0IGRvCiAgZm9vID0gMQogIGV4cGVjdChzdWJqZWN0KS50byBiZV90cnV0aHkKZW5kCml0IGRvCiAgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5CmVuZAotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBkaXNhbGxvd2AKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCB7IGlzX2V4cGVjdGVkLnRvIGJlX3RydXRoeSB9CgojIGdvb2QKaXQgeyBleHBlY3Qoc3ViamVjdCkudG8gYmVfdHJ1dGh5IH0KLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogcmVxdWlyZV9pbXBsaWNpdGAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCB7IGV4cGVjdChzdWJqZWN0KS50byBiZV90cnV0aHkgfQoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gYmVfdHJ1dGh5IH0KCiMgYmFkCml0IGRvCiAgZXhwZWN0KHN1YmplY3QpLnRvIGJlX3RydXRoeQplbmQKCiMgZ29vZAppdCBkbwogIGlzX2V4cGVjdGVkLnRvIGJlX3RydXRoeQplbmQKCiMgZ29vZAppdCB7IGV4cGVjdChuYW1lZF9zdWJqZWN0KS50byBiZV90cnV0aHkgfQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBzaW5nbGVfbGluZV9vbmx5YAp8IGBzaW5nbGVfbGluZV9vbmx5YCwgYHNpbmdsZV9zdGF0ZW1lbnRfb25seWAsIGBkaXNhbGxvd2AsIGByZXF1aXJlX2ltcGxpY2l0YAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0ltcGxpY2l0U3ViamVjdAoKPT0gUlNwZWMvSW5kZXhlZExldAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IE5vCnwgMi4yMAp8IDIuMjMKfD09PQoKRG8gbm90IHNldCB1cCB0ZXN0IGRhdGEgdXNpbmcgaW5kZXhlcyAoZS5nLiwgYGl0ZW1fMWAsIGBpdGVtXzJgKS4KCkl0IG1ha2VzIHJlYWRpbmcgdGhlIHRlc3QgaGFyZGVyIGJlY2F1c2UgaXQncyBub3QgY2xlYXIgd2hhdCBleGFjdGx5CmlzIHRlc3RlZCBieSB0aGlzIHBhcnRpY3VsYXIgZXhhbXBsZS4KClRoZSBjb25maWd1cmFibGUgb3B0aW9ucyBgQWxsb3dlZElkZW50aWZpZXJzYCBhbmQgYEFsbG93ZWRQYXR0ZXJuc2AKd2lsbCBhbHNvIHJlYWQgdGhvc2Ugc2V0IGluIGBOYW1pbmcvVmFyaWFibGVOdW1iZXJgLgoKPT09IEV4YW1wbGVzCgo9PT09IGBNYXg6IDEgKGRlZmF1bHQpYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6aXRlbV8xKSB7IGNyZWF0ZSg6aXRlbSkgfQpsZXQoOml0ZW1fMikgeyBjcmVhdGUoOml0ZW0pIH0KCmxldCg6aXRlbTEpIHsgY3JlYXRlKDppdGVtKSB9CmxldCg6aXRlbTIpIHsgY3JlYXRlKDppdGVtKSB9CgojIGdvb2QKCmxldCg6dmlzaWJsZV9pdGVtKSB7IGNyZWF0ZSg6aXRlbSwgdmlzaWJsZTogdHJ1ZSkgfQpsZXQoOmludmlzaWJsZV9pdGVtKSB7IGNyZWF0ZSg6aXRlbSwgdmlzaWJsZTogZmFsc2UpIH0KLS0tLQoKPT09PSBgTWF4OiAyYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6aXRlbV8xKSB7IGNyZWF0ZSg6aXRlbSkgfQpsZXQoOml0ZW1fMikgeyBjcmVhdGUoOml0ZW0pIH0KbGV0KDppdGVtXzMpIHsgY3JlYXRlKDppdGVtKSB9CgojIGdvb2QKbGV0KDppdGVtXzEpIHsgY3JlYXRlKDppdGVtKSB9CmxldCg6aXRlbV8yKSB7IGNyZWF0ZSg6aXRlbSkgfQotLS0tCgo9PT09IGBBbGxvd2VkSWRlbnRpZmllcnM6IFsnaXRlbV8xJywgJ2l0ZW1fMiddYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApsZXQoOml0ZW1fMSkgeyBjcmVhdGUoOml0ZW0pIH0KbGV0KDppdGVtXzIpIHsgY3JlYXRlKDppdGVtKSB9Ci0tLS0KCj09PT0gYEFsbG93ZWRQYXR0ZXJuczogWydpdGVtJ11gCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kCmxldCg6aXRlbV8xKSB7IGNyZWF0ZSg6aXRlbSkgfQpsZXQoOml0ZW1fMikgeyBjcmVhdGUoOml0ZW0pIH0KLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IE1heAp8IGAxYAp8IEludGVnZXIKCnwgQWxsb3dlZElkZW50aWZpZXJzCnwgYFtdYAp8IEFycmF5Cgp8IEFsbG93ZWRQYXR0ZXJucwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0luZGV4ZWRMZXQKCj09IFJTcGVjL0luc3RhbmNlU3B5Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4xMgp8IC0KfD09PQoKQ2hlY2tzIGZvciBgaW5zdGFuY2VfZG91YmxlYCB1c2VkIHdpdGggYGhhdmVfcmVjZWl2ZWRgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgZG8KICBmb28gPSBpbnN0YW5jZV9kb3VibGUoRm9vKS5hc19udWxsX29iamVjdAogIGV4cGVjdChmb28pLnRvIGhhdmVfcmVjZWl2ZWQoOmJhcikKZW5kCgojIGdvb2QKaXQgZG8KICBmb28gPSBpbnN0YW5jZV9zcHkoRm9vKQogIGV4cGVjdChmb28pLnRvIGhhdmVfcmVjZWl2ZWQoOmJhcikKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvSW5zdGFuY2VTcHkKCj09IFJTcGVjL0luc3RhbmNlVmFyaWFibGUKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMAp8IDEuNwp8PT09CgpDaGVja3MgZm9yIGluc3RhbmNlIHZhcmlhYmxlIHVzYWdlIGluIHNwZWNzLgoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgb3B0aW9uIGBBc3NpZ25tZW50T25seWAgd2hpY2gKd2lsbCBjb25maWd1cmUgdGhlIGNvcCB0byBvbmx5IHJlZ2lzdGVyIG9mZmVuc2VzIG9uIGluc3RhbmNlCnZhcmlhYmxlIHVzYWdlIGlmIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBpcyBhbHNvIGFzc2lnbmVkIHdpdGhpbgp0aGUgc3BlYwoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgTXlDbGFzcyBkbwogIGJlZm9yZSB7IEBmb28gPSBbXSB9CiAgaXQgeyBleHBlY3QoQGZvbykudG8gYmVfZW1wdHkgfQplbmQKCiMgZ29vZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgbGV0KDpmb28pIHsgW10gfQogIGl0IHsgZXhwZWN0KGZvbykudG8gYmVfZW1wdHkgfQplbmQKLS0tLQoKPT09PSB3aXRoIEFzc2lnbm1lbnRPbmx5IGNvbmZpZ3VyYXRpb24KCltzb3VyY2UscnVieV0KLS0tLQojIHJ1Ym9jb3AueW1sCiMgUlNwZWMvSW5zdGFuY2VWYXJpYWJsZToKIyAgIEFzc2lnbm1lbnRPbmx5OiB0cnVlCgojIGJhZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgYmVmb3JlIHsgQGZvbyA9IFtdIH0KICBpdCB7IGV4cGVjdChAZm9vKS50byBiZV9lbXB0eSB9CmVuZAoKIyBhbGxvd2VkCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBpdCB7IGV4cGVjdChAZm9vKS50byBiZV9lbXB0eSB9CmVuZAoKIyBnb29kCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBsZXQoOmZvbykgeyBbXSB9CiAgaXQgeyBleHBlY3QoZm9vKS50byBiZV9lbXB0eSB9CmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQXNzaWdubWVudE9ubHkKfCBgZmFsc2VgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jaW5zdGFuY2UtdmFyaWFibGVzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9JbnN0YW5jZVZhcmlhYmxlCgo9PSBSU3BlYy9Jc0V4cGVjdGVkU3BlY2lmeQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cwp8IDIuMjcKfCAtCnw9PT0KCkNoZWNrIGZvciBgc3BlY2lmeWAgd2l0aCBgaXNfZXhwZWN0ZWRgIGFuZCBvbmUtbGluZXIgZXhwZWN0YXRpb25zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3BlY2lmeSB7IGlzX2V4cGVjdGVkLnRvIGJlX3RydXRoeSB9CgojIGdvb2QKaXQgeyBpc19leHBlY3RlZC50byBiZV90cnV0aHkgfQoKIyBnb29kCnNwZWNpZnkgZG8KICAjIC4uLgplbmQKc3BlY2lmeSB7IGV4cGVjdChzcXJ0KDQpKS50byBlcSgyKSB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNpdC1hbmQtc3BlY2lmeQoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvSXNFeHBlY3RlZFNwZWNpZnkKCj09IFJTcGVjL0l0QmVoYXZlc0xpa2UKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjEzCnwgLQp8PT09CgpDaGVja3MgdGhhdCBvbmx5IG9uZSBgaXRfYmVoYXZlc19saWtlYCBzdHlsZSBpcyB1c2VkLgoKPT09IEV4YW1wbGVzCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBpdF9iZWhhdmVzX2xpa2VgIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0X3Nob3VsZF9iZWhhdmVfbGlrZSAnYSBmb28nCgojIGdvb2QKaXRfYmVoYXZlc19saWtlICdhIGZvbycKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogaXRfc2hvdWxkX2JlaGF2ZV9saWtlYAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0X2JlaGF2ZXNfbGlrZSAnYSBmb28nCgojIGdvb2QKaXRfc2hvdWxkX2JlaGF2ZV9saWtlICdhIGZvbycKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgaXRfYmVoYXZlc19saWtlYAp8IGBpdF9iZWhhdmVzX2xpa2VgLCBgaXRfc2hvdWxkX2JlaGF2ZV9saWtlYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0l0QmVoYXZlc0xpa2UKCj09IFJTcGVjL0l0ZXJhdGVkRXhwZWN0YXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMTQKfCAtCnw9PT0KCkNoZWNrIHRoYXQgYGFsbGAgbWF0Y2hlciBpcyB1c2VkIGluc3RlYWQgb2YgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCAndmFsaWRhdGVzIHVzZXJzJyBkbwogIFt1c2VyMSwgdXNlcjIsIHVzZXIzXS5lYWNoIHsgfHVzZXJ8IGV4cGVjdCh1c2VyKS50byBiZV92YWxpZCB9CmVuZAoKIyBnb29kCml0ICd2YWxpZGF0ZXMgdXNlcnMnIGRvCiAgZXhwZWN0KFt1c2VyMSwgdXNlcjIsIHVzZXIzXSkudG8gYWxsKGJlX3ZhbGlkKQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9JdGVyYXRlZEV4cGVjdGF0aW9uCgo9PSBSU3BlYy9MZWFkaW5nU3ViamVjdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuNwp8IDEuMTQKfD09PQoKRW5mb3JjZSB0aGF0IHN1YmplY3QgaXMgdGhlIGZpcnN0IGRlZmluaXRpb24gaW4gdGhlIHRlc3QuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsZXQoOnBhcmFtcykgeyBibGFoIH0Kc3ViamVjdCB7IGRlc2NyaWJlZF9jbGFzcy5uZXcocGFyYW1zKSB9CgpiZWZvcmUgeyBkb19zb21ldGhpbmcgfQpzdWJqZWN0IHsgZGVzY3JpYmVkX2NsYXNzLm5ldyhwYXJhbXMpIH0KCml0IHsgZXhwZWN0X3NvbWV0aGluZyB9CnN1YmplY3QgeyBkZXNjcmliZWRfY2xhc3MubmV3KHBhcmFtcykgfQppdCB7IGV4cGVjdF9zb21ldGhpbmdfZWxzZSB9CgojIGdvb2QKc3ViamVjdCB7IGRlc2NyaWJlZF9jbGFzcy5uZXcocGFyYW1zKSB9CmxldCg6cGFyYW1zKSB7IGJsYWggfQoKIyBnb29kCnN1YmplY3QgeyBkZXNjcmliZWRfY2xhc3MubmV3KHBhcmFtcykgfQpiZWZvcmUgeyBkb19zb21ldGhpbmcgfQoKIyBnb29kCnN1YmplY3QgeyBkZXNjcmliZWRfY2xhc3MubmV3KHBhcmFtcykgfQppdCB7IGV4cGVjdF9zb21ldGhpbmcgfQppdCB7IGV4cGVjdF9zb21ldGhpbmdfZWxzZSB9Ci0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vcnNwZWMucnVieXN0eWxlLmd1aWRlLyNsZWFkaW5nLXN1YmplY3QKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0xlYWRpbmdTdWJqZWN0Cgo9PSBSU3BlYy9MZWFreUNvbnN0YW50RGVjbGFyYXRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuMzUKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IG5vIGNsYXNzLCBtb2R1bGUsIG9yIGNvbnN0YW50IGlzIGRlY2xhcmVkLgoKQ29uc3RhbnRzLCBpbmNsdWRpbmcgY2xhc3NlcyBhbmQgbW9kdWxlcywgd2hlbiBkZWNsYXJlZCBpbiBhIGJsb2NrCnNjb3BlLCBhcmUgZGVmaW5lZCBpbiBnbG9iYWwgbmFtZXNwYWNlLCBhbmQgbGVhayBiZXR3ZWVuIGV4YW1wbGVzLgoKSWYgc2V2ZXJhbCBleGFtcGxlcyBtYXkgZGVmaW5lIGEgYER1bW15Q2xhc3NgLCBpbnN0ZWFkIG9mIGJlaW5nIGEKYmxhbmsgc2xhdGUgY2xhc3MgYXMgaXQgd2lsbCBiZSBpbiB0aGUgZmlyc3QgZXhhbXBsZSwgc3Vic2VxdWVudApleGFtcGxlcyB3aWxsIGJlIHJlb3BlbmluZyBpdCBhbmQgbW9kaWZ5aW5nIGl0cyBiZWhhdmlvciBpbgp1bnByZWRpY3RhYmxlIHdheXMuCkV2ZW4gd29yc2Ugd2hlbiBhIGNsYXNzIHRoYXQgZXhpc3RzIGluIHRoZSBjb2RlYmFzZSBpcyByZW9wZW5lZC4KCkFub255bW91cyBjbGFzc2VzIGFyZSBmaW5lLCBzaW5jZSB0aGV5IGRvbid0IHJlc3VsdCBpbiBnbG9iYWwKbmFtZXNwYWNlIG5hbWUgY2xhc2hlcy4KCj09PSBFeGFtcGxlcwoKPT09PSBDb25zdGFudHMgbGVhayBiZXR3ZWVuIGV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgU29tZUNsYXNzIGRvCiAgT3RoZXJDbGFzcyA9IFN0cnVjdC5uZXcKICBDT05TVEFOVF9IRVJFID0gJ0kgbGVhayBpbnRvIGdsb2JhbCBuYW1lc3BhY2UnCmVuZAoKIyBnb29kCmRlc2NyaWJlIFNvbWVDbGFzcyBkbwogIGJlZm9yZSBkbwogICAgc3R1Yl9jb25zdCgnT3RoZXJDbGFzcycsIFN0cnVjdC5uZXcpCiAgICBzdHViX2NvbnN0KCdDT05TVEFOVF9IRVJFJywgJ0kgb25seSBleGlzdCBkdXJpbmcgdGhpcyBleGFtcGxlJykKICBlbmQKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBTb21lQ2xhc3MgZG8KICBjbGFzcyBGb29DbGFzcyA8IGRlc2NyaWJlZF9jbGFzcwogICAgZGVmIGRvdWJsZV90aGF0CiAgICAgIHNvbWVfYmFzZV9tZXRob2QgKiAyCiAgICBlbmQKICBlbmQKCiAgaXQgeyBleHBlY3QoRm9vQ2xhc3MubmV3LmRvdWJsZV90aGF0KS50byBlcSg0KSB9CmVuZAoKIyBnb29kIC0gYW5vbnltb3VzIGNsYXNzLCBubyBjb25zdGFudCBuZWVkcyB0byBiZSBkZWZpbmVkCmRlc2NyaWJlIFNvbWVDbGFzcyBkbwogIGxldCg6Zm9vX2NsYXNzKSBkbwogICAgQ2xhc3MubmV3KGRlc2NyaWJlZF9jbGFzcykgZG8KICAgICAgZGVmIGRvdWJsZV90aGF0CiAgICAgICAgc29tZV9iYXNlX21ldGhvZCAqIDIKICAgICAgZW5kCiAgICBlbmQKICBlbmQKCiAgaXQgeyBleHBlY3QoZm9vX2NsYXNzLm5ldy5kb3VibGVfdGhhdCkudG8gZXEoNCkgfQplbmQKCiMgZ29vZCAtIGNvbnN0YW50IGlzIHN0dWJiZWQKZGVzY3JpYmUgU29tZUNsYXNzIGRvCiAgYmVmb3JlIGRvCiAgICBmb29fY2xhc3MgPSBDbGFzcy5uZXcoZGVzY3JpYmVkX2NsYXNzKSBkbwogICAgICAgICAgICAgICAgICBkZWYgZG9fc29tZXRoaW5nCiAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICAgZW5kCiAgICBzdHViX2NvbnN0KCdGb29DbGFzcycsIGZvb19jbGFzcykKICBlbmQKCiAgaXQgeyBleHBlY3QoRm9vQ2xhc3MubmV3LmRvdWJsZV90aGF0KS50byBlcSg0KSB9CmVuZAotLS0tCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgU29tZUNsYXNzIGRvCiAgbW9kdWxlIFNvbWVNb2R1bGUKICAgIGNsYXNzIFNvbWVDbGFzcwogICAgICBkZWYgZG9fc29tZXRoaW5nCiAgICAgIGVuZAogICAgZW5kCiAgZW5kCmVuZAoKIyBnb29kCmRlc2NyaWJlIFNvbWVDbGFzcyBkbwogIGJlZm9yZSBkbwogICAgZm9vX2NsYXNzID0gQ2xhc3MubmV3KGRlc2NyaWJlZF9jbGFzcykgZG8KICAgICAgICAgICAgICAgICAgZGVmIGRvX3NvbWV0aGluZwogICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgIGVuZAogICAgc3R1Yl9jb25zdCgnU29tZU1vZHVsZTo6U29tZUNsYXNzJywgZm9vX2NsYXNzKQogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yc3BlYy5ydWJ5c3R5bGUuZ3VpZGUvI2RlY2xhcmUtY29uc3RhbnRzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9MZWFreUNvbnN0YW50RGVjbGFyYXRpb24KKiBodHRwczovL3JzcGVjLmluZm8vZmVhdHVyZXMvMy0xMi9yc3BlYy1tb2Nrcy9tdXRhdGluZy1jb25zdGFudHMKCj09IFJTcGVjL0xldEJlZm9yZUV4YW1wbGVzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4xNgp8IDEuMjIKfD09PQoKQ2hlY2tzIGZvciBgbGV0YCBkZWZpbml0aW9ucyB0aGF0IGNvbWUgYWZ0ZXIgYW4gZXhhbXBsZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6Zm9vKSB7IGJhciB9CgppdCAnY2hlY2tzIHdoYXQgZm9vIGRvZXMnIGRvCiAgZXhwZWN0KGZvbykudG8gYmUKZW5kCgpsZXQoOnNvbWUpIHsgb3RoZXIgfQoKaXQgJ2NoZWNrcyB3aGF0IHNvbWUgZG9lcycgZG8KICBleHBlY3Qoc29tZSkudG8gYmUKZW5kCgojIGdvb2QKbGV0KDpmb28pIHsgYmFyIH0KbGV0KDpzb21lKSB7IG90aGVyIH0KCml0ICdjaGVja3Mgd2hhdCBmb28gZG9lcycgZG8KICBleHBlY3QoZm9vKS50byBiZQplbmQKCml0ICdjaGVja3Mgd2hhdCBzb21lIGRvZXMnIGRvCiAgZXhwZWN0KHNvbWUpLnRvIGJlCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL0xldEJlZm9yZUV4YW1wbGVzCgo9PSBSU3BlYy9MZXRTZXR1cAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS43CnwgLQp8PT09CgpDaGVja3MgdW5yZWZlcmVuY2VkIGBsZXQhYCBjYWxscyBiZWluZyB1c2VkIGZvciB0ZXN0IHNldHVwLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbGV0ISg6bXlfd2lkZ2V0KSB7IGNyZWF0ZSg6d2lkZ2V0KSB9CgppdCAnY291bnRzIHdpZGdldHMnIGRvCiAgZXhwZWN0KFdpZGdldC5jb3VudCkudG8gZXEoMSkKZW5kCgojIGdvb2QKaXQgJ2NvdW50cyB3aWRnZXRzJyBkbwogIGNyZWF0ZSg6d2lkZ2V0KQogIGV4cGVjdChXaWRnZXQuY291bnQpLnRvIGVxKDEpCmVuZAoKIyBnb29kCmJlZm9yZSB7IGNyZWF0ZSg6d2lkZ2V0KSB9CgppdCAnY291bnRzIHdpZGdldHMnIGRvCiAgZXhwZWN0KFdpZGdldC5jb3VudCkudG8gZXEoMSkKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTGV0U2V0dXAKCj09IFJTcGVjL01hdGNoQXJyYXkKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBBbHdheXMKfCAyLjE5CnwgLQp8PT09CgpDaGVja3Mgd2hlcmUgYG1hdGNoX2FycmF5YCBpcyB1c2VkLgoKVGhpcyBjb3AgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOgotIFByZWZlciBgY29udGFpbl9leGFjdGx5YCB3aGVuIG1hdGNoaW5nIGFuIGFycmF5IHdpdGggdmFsdWVzLgotIFByZWZlciBgZXFgIHdoZW4gdXNpbmcgYG1hdGNoX2FycmF5YCB3aXRoIGFuIGVtcHR5IGFycmF5IGxpdGVyYWwuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCB7IGlzX2V4cGVjdGVkLnRvIG1hdGNoX2FycmF5KFtjb250ZW50MSwgY29udGVudDJdKSB9CgojIGdvb2QKaXQgeyBpc19leHBlY3RlZC50byBjb250YWluX2V4YWN0bHkoY29udGVudDEsIGNvbnRlbnQyKSB9CgojIGdvb2QKaXQgeyBpc19leHBlY3RlZC50byBtYXRjaF9hcnJheShbY29udGVudF0gKyBhcnJheSkgfQoKIyBnb29kCml0IHsgaXNfZXhwZWN0ZWQudG8gbWF0Y2hfYXJyYXkoJXcodHJlbWJsZSBpbiBmZWFyIGZvb2xpc2ggbW9ydGFscykpIH0KLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9NYXRjaEFycmF5Cgo9PSBSU3BlYy9NZXNzYWdlQ2hhaW4KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuNwp8IC0KfD09PQoKQ2hlY2sgdGhhdCBjaGFpbnMgb2YgbWVzc2FnZXMgYXJlIG5vdCBiZWluZyBzdHViYmVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYWxsb3coZm9vKS50byByZWNlaXZlX21lc3NhZ2VfY2hhaW4oOmJhciwgOmJheikuYW5kX3JldHVybig0MikKCiMgZ29vZAp0aGluZyA9IFRoaW5nLm5ldyhiYXo6IDQyKQphbGxvdyhmb28pLnRvIHJlY2VpdmUoOmJhcikuYW5kX3JldHVybih0aGluZykKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9NZXNzYWdlQ2hhaW4KCj09IFJTcGVjL01lc3NhZ2VFeHBlY3RhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRGlzYWJsZWQKfCBZZXMKfCBObwp8IDEuNwp8IDEuOAp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgbWVzc2FnZSBleHBlY3RhdGlvbiBzdHlsZS4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIGluIHlvdXIgY29uZmlndXJhdGlvbiB1c2luZyB0aGUKYEVuZm9yY2VkU3R5bGVgIG9wdGlvbiBhbmQgc3VwcG9ydHMgYC0tYXV0by1nZW4tY29uZmlnYC4KCj09PSBFeGFtcGxlcwoKPT09PSBgRW5mb3JjZWRTdHlsZTogYWxsb3dgIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikKCiMgZ29vZAphbGxvdyhmb28pLnRvIHJlY2VpdmUoOmJhcikKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogZXhwZWN0YAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFsbG93KGZvbykudG8gcmVjZWl2ZSg6YmFyKQoKIyBnb29kCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYWxsb3dgCnwgYGFsbG93YCwgYGV4cGVjdGAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9NZXNzYWdlRXhwZWN0YXRpb24KCj09IFJTcGVjL01lc3NhZ2VTcGllcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS45CnwgLQp8PT09CgpDaGVja3MgdGhhdCBtZXNzYWdlIGV4cGVjdGF0aW9ucyBhcmUgc2V0IHVzaW5nIHNwaWVzLgoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgaW4geW91ciBjb25maWd1cmF0aW9uIHVzaW5nIHRoZQpgRW5mb3JjZWRTdHlsZWAgb3B0aW9uIGFuZCBzdXBwb3J0cyBgLS1hdXRvLWdlbi1jb25maWdgLgoKPT09IEV4YW1wbGVzCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBoYXZlX3JlY2VpdmVkYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpCmRvX3NvbWV0aGluZwoKIyBnb29kCmFsbG93KGZvbykudG8gcmVjZWl2ZSg6YmFyKSAjIG9yIHVzZSBpbnN0YW5jZV9zcHkKZG9fc29tZXRoaW5nCmV4cGVjdChmb28pLnRvIGhhdmVfcmVjZWl2ZWQoOmJhcikKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogcmVjZWl2ZWAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphbGxvdyhmb28pLnRvIHJlY2VpdmUoOmJhcikKZG9fc29tZXRoaW5nCmV4cGVjdChmb28pLnRvIGhhdmVfcmVjZWl2ZWQoOmJhcikKCiMgZ29vZApleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpCmRvX3NvbWV0aGluZwotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBoYXZlX3JlY2VpdmVkYAp8IGBoYXZlX3JlY2VpdmVkYCwgYHJlY2VpdmVgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTWVzc2FnZVNwaWVzCgo9PSBSU3BlYy9NZXRhZGF0YVN0eWxlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4yNAp8IC0KfD09PQoKVXNlIGNvbnNpc3RlbnQgbWV0YWRhdGEgc3R5bGUuCgpUaGlzIGNvcCBkb2VzIG5vdCBzdXBwb3J0IGF1dG9jb3JyZWN0aW9uIGluIHRoZSBjYXNlIG9mCmBFbmZvcmNlZFN0eWxlOiBoYXNoYCB3aGVyZSB0aGUgdHJhaWxpbmcgbWV0YWRhdGEgdHlwZSBpcyBhbWJpZ3VvdXMuCihlLmcuIGBkZXNjcmliZSAnU29tZXRoaW5nJywgOmEsIGJgKQoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHN5bWJvbCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSAnU29tZXRoaW5nJywgYTogdHJ1ZQoKIyBnb29kCmRlc2NyaWJlICdTb21ldGhpbmcnLCA6YQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGhhc2gKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSAnU29tZXRoaW5nJywgOmEKCiMgZ29vZApkZXNjcmliZSAnU29tZXRoaW5nJywgYTogdHJ1ZQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgRW5mb3JjZWRTdHlsZQp8IGBzeW1ib2xgCnwgYGhhc2hgLCBgc3ltYm9sYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL01ldGFkYXRhU3R5bGUKCj09IFJTcGVjL01pc3NpbmdFeGFtcGxlR3JvdXBBcmd1bWVudAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4yOAp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGFuIGV4YW1wbGUgZ3JvdXAgaXMgbm90IGVtcHR5LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgZG8KZW5kCgpSU3BlYy5kZXNjcmliZSBkbwplbmQKCiMgZ29vZApkZXNjcmliZSBUZXN0ZWRDbGFzcyBkbwplbmQKCmRlc2NyaWJlICJBIGZlYXR1cmUgZXhhbXBsZSIgZG8KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTWlzc2luZ0V4YW1wbGVHcm91cEFyZ3VtZW50Cgo9PSBSU3BlYy9NdWx0aXBsZURlc2NyaWJlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4wCnwgLQp8PT09CgpDaGVja3MgZm9yIG11bHRpcGxlIHRvcC1sZXZlbCBleGFtcGxlIGdyb3Vwcy4KCk11bHRpcGxlIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHNhbWUgY2xhc3Mgb3IgbW9kdWxlIHNob3VsZCBlaXRoZXIKYmUgbmVzdGVkIG9yIHNlcGFyYXRlZCBpbnRvIGRpZmZlcmVudCB0ZXN0IGZpbGVzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgTXlDbGFzcywgJy5kb19zb21ldGhpbmcnIGRvCmVuZApkZXNjcmliZSBNeUNsYXNzLCAnLmRvX3NvbWV0aGluZ19lbHNlJyBkbwplbmQKCiMgZ29vZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgZGVzY3JpYmUgJy5kb19zb21ldGhpbmcnIGRvCiAgZW5kCiAgZGVzY3JpYmUgJy5kb19zb21ldGhpbmdfZWxzZScgZG8KICBlbmQKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTXVsdGlwbGVEZXNjcmliZXMKCj09IFJTcGVjL011bHRpcGxlRXhwZWN0YXRpb25zCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjcKfCAxLjIxCnw9PT0KCkNoZWNrcyBpZiBleGFtcGxlcyBjb250YWluIHRvbyBtYW55IGBleHBlY3RgIGNhbGxzLgoKVGhpcyBjb3AgaXMgY29uZmlndXJhYmxlIHVzaW5nIHRoZSBgTWF4YCBvcHRpb24KYW5kIHdvcmtzIHdpdGggYC0tYXV0by1nZW4tY29uZmlnYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlIFVzZXJDcmVhdG9yIGRvCiAgaXQgJ2J1aWxkcyBhIHVzZXInIGRvCiAgICBleHBlY3QodXNlci5uYW1lKS50byBlcSgiSm9obiIpCiAgICBleHBlY3QodXNlci5hZ2UpLnRvIGVxKDIyKQogIGVuZAplbmQKCiMgZ29vZApkZXNjcmliZSBVc2VyQ3JlYXRvciBkbwogIGl0ICdzZXRzIHRoZSB1c2VycyBuYW1lJyBkbwogICAgZXhwZWN0KHVzZXIubmFtZSkudG8gZXEoIkpvaG4iKQogIGVuZAoKICBpdCAnc2V0cyB0aGUgdXNlcnMgYWdlJyBkbwogICAgZXhwZWN0KHVzZXIuYWdlKS50byBlcSgyMikKICBlbmQKZW5kCi0tLS0KCj09PT0gYGFnZ3JlZ2F0ZV9mYWlsdXJlczogdHJ1ZWAgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBnb29kIC0gdGhlIGNvcCBpZ25vcmVzIHdoZW4gUlNwZWMgYWdncmVnYXRlcyBmYWlsdXJlcwpkZXNjcmliZSBVc2VyQ3JlYXRvciBkbwogIGl0ICdidWlsZHMgYSB1c2VyJywgOmFnZ3JlZ2F0ZV9mYWlsdXJlcyBkbwogICAgZXhwZWN0KHVzZXIubmFtZSkudG8gZXEoIkpvaG4iKQogICAgZXhwZWN0KHVzZXIuYWdlKS50byBlcSgyMikKICBlbmQKZW5kCi0tLS0KCj09PT0gYGFnZ3JlZ2F0ZV9mYWlsdXJlczogZmFsc2VgCgpbc291cmNlLHJ1YnldCi0tLS0KIyBEZXRlY3RlZCBhcyBhbiBvZmZlbnNlCmRlc2NyaWJlIFVzZXJDcmVhdG9yIGRvCiAgaXQgJ2J1aWxkcyBhIHVzZXInLCBhZ2dyZWdhdGVfZmFpbHVyZXM6IGZhbHNlIGRvCiAgICBleHBlY3QodXNlci5uYW1lKS50byBlcSgiSm9obiIpCiAgICBleHBlY3QodXNlci5hZ2UpLnRvIGVxKDIyKQogIGVuZAplbmQKLS0tLQoKPT09PSBgTWF4OiAxYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBVc2VyQ3JlYXRvciBkbwogIGl0ICdidWlsZHMgYSB1c2VyJyBkbwogICAgZXhwZWN0KHVzZXIubmFtZSkudG8gZXEoIkpvaG4iKQogICAgZXhwZWN0KHVzZXIuYWdlKS50byBlcSgyMikKICBlbmQKZW5kCi0tLS0KCj09PT0gYE1heDogMmAKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKZGVzY3JpYmUgVXNlckNyZWF0b3IgZG8KICBpdCAnYnVpbGRzIGEgdXNlcicgZG8KICAgIGV4cGVjdCh1c2VyLm5hbWUpLnRvIGVxKCJKb2huIikKICAgIGV4cGVjdCh1c2VyLmFnZSkudG8gZXEoMjIpCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWF4CnwgYDFgCnwgSW50ZWdlcgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jZXhwZWN0YXRpb24tcGVyLWV4YW1wbGUKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL011bHRpcGxlRXhwZWN0YXRpb25zCiogaHR0cDovL2JldHRlcnNwZWNzLm9yZy8jc2luZ2xlCgo9PSBSU3BlYy9NdWx0aXBsZU1lbW9pemVkSGVscGVycwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS40Mwp8IC0KfD09PQoKQ2hlY2tzIGlmIGV4YW1wbGUgZ3JvdXBzIGNvbnRhaW4gdG9vIG1hbnkgYGxldGAgYW5kIGBzdWJqZWN0YCBjYWxscy4KClRoaXMgY29wIGlzIGNvbmZpZ3VyYWJsZSB1c2luZyB0aGUgYE1heGAgb3B0aW9uIGFuZCB0aGUgYEFsbG93U3ViamVjdGAKd2hpY2ggd2lsbCBjb25maWd1cmUgdGhlIGNvcCB0byBvbmx5IHJlZ2lzdGVyIG9mZmVuc2VzIG9uIGNhbGxzIHRvCmBsZXRgIGFuZCBub3QgY2FsbHMgdG8gYHN1YmplY3RgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgTXlDbGFzcyBkbwogIGxldCg6Zm9vKSB7IFtdIH0KICBsZXQoOmJhcikgeyBbXSB9CiAgbGV0ISg6YmF6KSB7IFtdIH0KICBsZXQoOnF1eCkgeyBbXSB9CiAgbGV0KDpxdXV4KSB7IFtdIH0KICBsZXQoOnF1dXopIHsge30gfQplbmQKCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBsZXQoOmZvbykgeyBbXSB9CiAgbGV0KDpiYXIpIHsgW10gfQogIGxldCEoOmJheikgeyBbXSB9CgogIGNvbnRleHQgJ3doZW4gc3R1ZmYnIGRvCiAgICBsZXQoOnF1eCkgeyBbXSB9CiAgICBsZXQoOnF1dXgpIHsgW10gfQogICAgbGV0KDpxdXV6KSB7IHt9IH0KICBlbmQKZW5kCgojIGdvb2QKZGVzY3JpYmUgTXlDbGFzcyBkbwogIGxldCg6YmFyKSB7IFtdIH0KICBsZXQhKDpiYXopIHsgW10gfQogIGxldCg6cXV4KSB7IFtdIH0KICBsZXQoOnF1dXgpIHsgW10gfQogIGxldCg6cXV1eikgeyB7fSB9CmVuZAoKZGVzY3JpYmUgTXlDbGFzcyBkbwogIGNvbnRleHQgJ3doZW4gc3R1ZmYnIGRvCiAgICBsZXQoOmZvbykgeyBbXSB9CiAgICBsZXQoOmJhcikgeyBbXSB9CiAgICBsZXQhKDpib29nZXIpIHsgW10gfQogIGVuZAoKICBjb250ZXh0ICd3aGVuIG90aGVyIHN0dWZmJyBkbwogICAgbGV0KDpxdXgpIHsgW10gfQogICAgbGV0KDpxdXV4KSB7IFtdIH0KICAgIGxldCg6cXV1eikgeyB7fSB9CiAgZW5kCmVuZAotLS0tCgo9PT09IHdoZW4gZGlzYWJsaW5nIEFsbG93U3ViamVjdCBjb25maWd1cmF0aW9uCgpbc291cmNlLHJ1YnldCi0tLS0KIyBydWJvY29wLnltbAojIFJTcGVjL011bHRpcGxlTWVtb2l6ZWRIZWxwZXJzOgojICAgQWxsb3dTdWJqZWN0OiBmYWxzZQoKIyBiYWQgLSBgc3ViamVjdGAgY291bnRzIHRvd2FyZHMgbWVtb2l6ZWQgaGVscGVycwpkZXNjcmliZSBNeUNsYXNzIGRvCiAgc3ViamVjdCB7IHt9IH0KICBsZXQoOmZvbykgeyBbXSB9CiAgbGV0KDpiYXIpIHsgW10gfQogIGxldCEoOmJheikgeyBbXSB9CiAgbGV0KDpxdXgpIHsgW10gfQogIGxldCg6cXV1eCkgeyBbXSB9CmVuZAotLS0tCgo9PT09IHdpdGggTWF4IGNvbmZpZ3VyYXRpb24KCltzb3VyY2UscnVieV0KLS0tLQojIHJ1Ym9jb3AueW1sCiMgUlNwZWMvTXVsdGlwbGVNZW1vaXplZEhlbHBlcnM6CiMgICBNYXg6IDEKCiMgYmFkCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBsZXQoOmZvbykgeyBbXSB9CiAgbGV0KDpiYXIpIHsgW10gfQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEFsbG93U3ViamVjdAp8IGB0cnVlYAp8IEJvb2xlYW4KCnwgTWF4CnwgYDVgCnwgSW50ZWdlcgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jbGV0LWJsb2NrcwoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTXVsdGlwbGVNZW1vaXplZEhlbHBlcnMKCj09IFJTcGVjL011bHRpcGxlU3ViamVjdHMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjE2CnwgLQp8PT09CgpDaGVja3MgaWYgYW4gZXhhbXBsZSBncm91cCBkZWZpbmVzIGBzdWJqZWN0YCBtdWx0aXBsZSB0aW1lcy4KClRoaXMgY29wIGRvZXMgbm90IHN1cHBvcnQgYXV0b2NvcnJlY3Rpb24gaW4gc29tZSBjYXNlcy4KVGhlIGF1dG9jb3JyZWN0IGJlaGF2aW9yIGZvciB0aGlzIGNvcCBkZXBlbmRzIG9uIHRoZSB0eXBlIG9mCmR1cGxpY2F0aW9uOgoKICAtIElmIG11bHRpcGxlIG5hbWVkIHN1YmplY3RzIGFyZSBkZWZpbmVkIHRoZW4gdGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMKICAgIHRoYXQgdGhlIG92ZXJ3cml0dGVuIHN1YmplY3RzIChhbGwgc3ViamVjdHMgZXhjZXB0IHRoZSBsYXN0CiAgICBkZWZpbml0aW9uKSBhcmUgZWZmZWN0aXZlbHkgYmVpbmcgdXNlZCB0byBkZWZpbmUgaGVscGVycy4gSW4gdGhpcwogICAgY2FzZSB0aGV5IGFyZSByZXBsYWNlZCB3aXRoIGBsZXRgLgoKICAtIElmIG11bHRpcGxlIHVubmFtZWQgc3ViamVjdHMgYXJlIGRlZmluZWQgdGhvdWdoIHRoZW4gdGhpcyBjYW4gKm9ubHkqCiAgICBiZSBkZWFkIGNvZGUgYW5kIHdlIHJlbW92ZSB0aGUgb3ZlcndyaXR0ZW4gc3ViamVjdCBkZWZpbml0aW9ucy4KCiAgLSBJZiBzdWJqZWN0cyBhcmUgZGVmaW5lZCB3aXRoIGBzdWJqZWN0IWAgdGhlbiB3ZSBkb24ndCBhdXRvY29ycmVjdC4KICAgIFRoaXMgaXMgZW5vdWdoIG9mIGFuIGVkZ2UgY2FzZSB0aGF0IHBlb3BsZSBjYW4ganVzdCBtb3ZlIHRoaXMgdG8KICAgIGEgYGJlZm9yZWAgaG9vayBvbiB0aGVpciBvd24KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlIEZvbyBkbwogIHN1YmplY3QoOnVzZXIpIHsgVXNlci5uZXcgfQogIHN1YmplY3QoOnBvc3QpIHsgUG9zdC5uZXcgfQplbmQKCiMgZ29vZApkZXNjcmliZSBGb28gZG8KICBsZXQoOnVzZXIpIHsgVXNlci5uZXcgfQogIHN1YmplY3QoOnBvc3QpIHsgUG9zdC5uZXcgfQplbmQKCiMgYmFkIChkb2VzIG5vdCBzdXBwb3J0IGF1dG9jb3JyZWN0aW9uKQpkZXNjcmliZSBGb28gZG8KICBzdWJqZWN0ISg6dXNlcikgeyBVc2VyLm5ldyB9CiAgc3ViamVjdCEoOnBvc3QpIHsgUG9zdC5uZXcgfQplbmQKCiMgZ29vZApkZXNjcmliZSBGb28gZG8KICBiZWZvcmUgZG8KICAgIFVzZXIubmV3CiAgICBQb3N0Lm5ldwogIGVuZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9NdWx0aXBsZVN1YmplY3RzCgo9PSBSU3BlYy9OYW1lZFN1YmplY3QKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuNS4zCnwgMi4xNQp8PT09CgpDaGVja3MgZm9yIGV4cGxpY2l0bHkgcmVmZXJlbmNlZCB0ZXN0IHN1YmplY3RzLgoKUlNwZWMgbGV0cyB5b3UgZGVjbGFyZSBhbiAiaW1wbGljaXQgc3ViamVjdCIgdXNpbmcgYHN1YmplY3QgeyAuLi4gfWAKd2hpY2ggYWxsb3dzIGZvciB0ZXN0cyBsaWtlIGBpdCB7IGlzX2V4cGVjdGVkLnRvIGJlX3ZhbGlkIH1gLgpJZiB5b3UgbmVlZCB0byByZWZlcmVuY2UgeW91ciB0ZXN0IHN1YmplY3QgeW91IHNob3VsZCBleHBsaWNpdGx5Cm5hbWUgaXQgdXNpbmcgYHN1YmplY3QoOnlvdXJfc3ViamVjdF9uYW1lKSB7IC4uLiB9YC4gWW91ciB0ZXN0IHN1YmplY3RzCnNob3VsZCBiZSB0aGUgbW9zdCBpbXBvcnRhbnQgb2JqZWN0IGluIHlvdXIgdGVzdHMgc28gdGhleSBkZXNlcnZlCmEgZGVzY3JpcHRpdmUgbmFtZS4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIGluIHlvdXIgY29uZmlndXJhdGlvbiB1c2luZyBgRW5mb3JjZWRTdHlsZWAsCmFuZCBgSWdub3JlU2hhcmVkRXhhbXBsZXNgIHdoaWNoIHdpbGwgbm90IHJlcG9ydCBvZmZlbnNlcyBmb3IgaW1wbGljaXQKc3ViamVjdHMgaW4gc2hhcmVkIGV4YW1wbGUgZ3JvdXBzLgoKPT09IEV4YW1wbGVzCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBhbHdheXNgIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJTcGVjLmRlc2NyaWJlIFVzZXIgZG8KICBzdWJqZWN0IHsgZGVzY3JpYmVkX2NsYXNzLm5ldyB9CgogIGl0ICdpcyB2YWxpZCcgZG8KICAgIGV4cGVjdChzdWJqZWN0LnZhbGlkPykudG8gYmUodHJ1ZSkKICBlbmQKZW5kCgojIGdvb2QKUlNwZWMuZGVzY3JpYmUgVXNlciBkbwogIHN1YmplY3QoOnVzZXIpIHsgZGVzY3JpYmVkX2NsYXNzLm5ldyB9CgogIGl0ICdpcyB2YWxpZCcgZG8KICAgIGV4cGVjdCh1c2VyLnZhbGlkPykudG8gYmUodHJ1ZSkKICBlbmQKZW5kCgojIGFsc28gZ29vZApSU3BlYy5kZXNjcmliZSBVc2VyIGRvCiAgc3ViamVjdCg6dXNlcikgeyBkZXNjcmliZWRfY2xhc3MubmV3IH0KCiAgaXQgeyBpc19leHBlY3RlZC50byBiZV92YWxpZCB9CmVuZAotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBuYW1lZF9vbmx5YAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJTcGVjLmRlc2NyaWJlIFVzZXIgZG8KICBzdWJqZWN0KDp1c2VyKSB7IGRlc2NyaWJlZF9jbGFzcy5uZXcgfQoKICBpdCAnaXMgdmFsaWQnIGRvCiAgICBleHBlY3Qoc3ViamVjdC52YWxpZD8pLnRvIGJlKHRydWUpCiAgZW5kCmVuZAoKIyBnb29kClJTcGVjLmRlc2NyaWJlIFVzZXIgZG8KICBzdWJqZWN0KDp1c2VyKSB7IGRlc2NyaWJlZF9jbGFzcy5uZXcgfQoKICBpdCAnaXMgdmFsaWQnIGRvCiAgICBleHBlY3QodXNlci52YWxpZD8pLnRvIGJlKHRydWUpCiAgZW5kCmVuZAoKIyBhbHNvIGdvb2QKUlNwZWMuZGVzY3JpYmUgVXNlciBkbwogIHN1YmplY3QgeyBkZXNjcmliZWRfY2xhc3MubmV3IH0KCiAgaXQgeyBpc19leHBlY3RlZC50byBiZV92YWxpZCB9CmVuZAoKIyBhY2NlcHRhYmxlClJTcGVjLmRlc2NyaWJlIFVzZXIgZG8KICBzdWJqZWN0IHsgZGVzY3JpYmVkX2NsYXNzLm5ldyB9CgogIGl0ICdpcyB2YWxpZCcgZG8KICAgIGV4cGVjdChzdWJqZWN0LnZhbGlkPykudG8gYmUodHJ1ZSkKICBlbmQKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGFsd2F5c2AKfCBgYWx3YXlzYCwgYG5hbWVkX29ubHlgCgp8IElnbm9yZVNoYXJlZEV4YW1wbGVzCnwgYHRydWVgCnwgQm9vbGVhbgp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jdXNlLXN1YmplY3QKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL05hbWVkU3ViamVjdAoKPT0gUlNwZWMvTmVzdGVkR3JvdXBzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjcKfCAyLjEzCnw9PT0KCkNoZWNrcyBmb3IgbmVzdGVkIGV4YW1wbGUgZ3JvdXBzLgoKVGhpcyBjb3AgaXMgY29uZmlndXJhYmxlIHVzaW5nIHRoZSBgTWF4YCBvcHRpb24KYW5kIHN1cHBvcnRzIGAtLWF1dG8tZ2VuLWNvbmZpZ2AuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApjb250ZXh0ICd3aGVuIHVzaW5nIHNvbWUgZmVhdHVyZScgZG8KICBsZXQoOnNvbWUpICAgIHsgOnZhcmlvdXMgfQogIGxldCg6ZmVhdHVyZSkgeyA6c2V0dXAgICB9CgogIGNvbnRleHQgJ3doZW4gdXNlciBpcyBzaWduZWQgaW4nIGRvICAjIGZsYWdnZWQgYnkgcnVib2NvcAogICAgbGV0KDp1c2VyKSBkbwogICAgICBVc2VyQ3JlYXRlLmNhbGwodXNlcl9hdHRyaWJ1dGVzKQogICAgZW5kCgogICAgbGV0KDp1c2VyX2F0dHJpYnV0ZXMpIGRvCiAgICAgIHsKICAgICAgICBuYW1lOiAnSm9obicsCiAgICAgICAgYWdlOiAgMjIsCiAgICAgICAgcm9sZTogcm9sZQogICAgICB9CiAgICBlbmQKCiAgICBjb250ZXh0ICd3aGVuIHVzZXIgaXMgYW4gYWRtaW4nIGRvICMgZmxhZ2dlZCBieSBydWJvY29wCiAgICAgIGxldCg6cm9sZSkgeyAnYWRtaW4nIH0KCiAgICAgIGl0ICdibGFoIGJsYWgnCiAgICAgIGl0ICd5YWRhIHlhZGEnCiAgICBlbmQKICBlbmQKZW5kCgojIGdvb2QKY29udGV4dCAndXNpbmcgc29tZSBmZWF0dXJlIGFzIGFuIGFkbWluJyBkbwogIGxldCg6c29tZSkgICAgeyA6dmFyaW91cyB9CiAgbGV0KDpmZWF0dXJlKSB7IDpzZXR1cCAgIH0KCiAgbGV0KDp1c2VyKSBkbwogICAgVXNlckNyZWF0ZS5jYWxsKAogICAgICBuYW1lOiAnSm9obicsCiAgICAgIGFnZTogIDIyLAogICAgICByb2xlOiAnYWRtaW4nCiAgICApCiAgZW5kCgogIGl0ICdibGFoIGJsYWgnCiAgaXQgJ3lhZGEgeWFkYScKZW5kCi0tLS0KCj09PT0gYE1heDogM2AgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgRm9vIGRvCiAgY29udGV4dCAnZm9vJyBkbwogICAgY29udGV4dCAnYmFyJyBkbwogICAgICBjb250ZXh0ICdiYXonIGRvICMgZmxhZ2dlZCBieSBydWJvY29wCiAgICAgIGVuZAogICAgZW5kCiAgZW5kCmVuZAotLS0tCgo9PT09IGBNYXg6IDJgCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgRm9vIGRvCiAgY29udGV4dCAnZm9vJyBkbwogICAgY29udGV4dCAnYmFyJyBkbyAjIGZsYWdnZWQgYnkgcnVib2NvcAogICAgICBjb250ZXh0ICdiYXonIGRvICMgZmxhZ2dlZCBieSBydWJvY29wCiAgICAgIGVuZAogICAgZW5kCiAgZW5kCmVuZAotLS0tCgo9PT09IGBBbGxvd2VkR3JvdXBzOiBbXSAoZGVmYXVsdClgCgpbc291cmNlLHJ1YnldCi0tLS0KZGVzY3JpYmUgRm9vIGRvICMgPC0tIG5lc3RlZCBncm91cHMgMQogIGNvbnRleHQgJ2ZvbycgZG8gIyA8LS0gbmVzdGVkIGdyb3VwcyAyCiAgICBjb250ZXh0ICdiYXInIGRvICMgPC0tIG5lc3RlZCBncm91cHMgMwogICAgZW5kCiAgZW5kCmVuZAotLS0tCgo9PT09IGBBbGxvd2VkR3JvdXBzOiBbcGF0aF1gCgpbc291cmNlLHJ1YnldCi0tLS0KZGVzY3JpYmUgRm9vIGRvICMgPC0tIG5lc3RlZCBncm91cHMgMQogIHBhdGggJy9mb28nIGRvICMgPC0tIG5lc3RlZCBncm91cHMgMSAobm90IGNvdW50ZWQpCiAgICBjb250ZXh0ICdiYXInIGRvICMgPC0tIG5lc3RlZCBncm91cHMgMgogICAgZW5kCiAgZW5kCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgTWF4CnwgYDNgCnwgSW50ZWdlcgoKfCBBbGxvd2VkR3JvdXBzCnwgYFtdYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTmVzdGVkR3JvdXBzCgo9PSBSU3BlYy9Ob0V4cGVjdGF0aW9uRXhhbXBsZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IE5vCnwgTm8KfCAyLjEzCnwgMi4xNAp8PT09CgpDaGVja3MgaWYgYW4gZXhhbXBsZSBjb250YWlucyBhbnkgZXhwZWN0YXRpb24uCgpBbGwgUlNwZWMncyBleGFtcGxlIGFuZCBleHBlY3RhdGlvbiBtZXRob2RzIGFyZSBjb3ZlcmVkIGJ5IGRlZmF1bHQuCklmIHlvdSBhcmUgdXNpbmcgeW91ciBvd24gY3VzdG9tIG1ldGhvZHMsCmFkZCB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb246CgogIFJTcGVjOgogICAgTGFuZ3VhZ2U6CiAgICAgIEV4YW1wbGVzOgogICAgICAgIFJlZ3VsYXI6CiAgICAgICAgICAtIGN1c3RvbV9pdAogICAgICBFeHBlY3RhdGlvbnM6CiAgICAgICAgLSBjdXN0b21fZXhwZWN0CgpUaGlzIGNvcCBjYW4gYmUgY3VzdG9taXplZCB3aXRoIGFuIGFsbG93ZWQgZXhwZWN0YXRpb24gbWV0aG9kcyBwYXR0ZXJuCndpdGggYW4gYEFsbG93ZWRQYXR0ZXJuc2Agb3B0aW9uLiBeZXhwZWN0XyBhbmQgXmFzc2VydF8gYXJlIGFsbG93ZWQKYnkgZGVmYXVsdC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0IGRvCiAgYT8KZW5kCgojIGdvb2QKaXQgZG8KICBleHBlY3QoYT8pLnRvIGJlKHRydWUpCmVuZAotLS0tCgo9PT09IGBBbGxvd2VkUGF0dGVybnNgIGNvbmZpZ3VyYXRpb24KCltzb3VyY2UscnVieV0KLS0tLQojIC5ydWJvY29wLnltbAojIFJTcGVjL05vRXhwZWN0YXRpb25FeGFtcGxlOgojICAgQWxsb3dlZFBhdHRlcm5zOgojICAgICAtIF5leHBlY3RfCiMgICAgIC0gXmFzc2VydF8KLS0tLQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0IGRvCiAgbm90X2V4cGVjdF9zb21ldGhpbmcKZW5kCgojIGdvb2QKaXQgZG8KICBleHBlY3Rfc29tZXRoaW5nCmVuZAoKaXQgZG8KICBhc3NlcnRfc29tZXRoaW5nCmVuZAotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgQWxsb3dlZFBhdHRlcm5zCnwgYF5leHBlY3RfYCwgYF5hc3NlcnRfYAp8IEFycmF5Cnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvTm9FeHBlY3RhdGlvbkV4YW1wbGUKCj09IFJTcGVjL05vdFRvTm90Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS40CnwgLQp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgbWV0aG9kIHVzYWdlIGZvciBuZWdhdGluZyBleHBlY3RhdGlvbnMuCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IG5vdF90b2AgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgJy4uLicgZG8KICBleHBlY3QoZmFsc2UpLnRvX25vdCBiZV90cnVlCmVuZAoKIyBnb29kCml0ICcuLi4nIGRvCiAgZXhwZWN0KGZhbHNlKS5ub3RfdG8gYmVfdHJ1ZQplbmQKLS0tLQoKPT09PSBgRW5mb3JjZWRTdHlsZTogdG9fbm90YAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCml0ICcuLi4nIGRvCiAgZXhwZWN0KGZhbHNlKS5ub3RfdG8gYmVfdHJ1ZQplbmQKCiMgZ29vZAppdCAnLi4uJyBkbwogIGV4cGVjdChmYWxzZSkudG9fbm90IGJlX3RydWUKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYG5vdF90b2AKfCBgbm90X3RvYCwgYHRvX25vdGAKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9Ob3RUb05vdAoKPT0gUlNwZWMvT3ZlcndyaXRpbmdTZXR1cAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4xNAp8IC0KfD09PQoKQ2hlY2tzIGlmIHRoZXJlIGlzIGEgbGV0L3N1YmplY3QgdGhhdCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIG9uZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6Zm9vKSB7IGJhciB9CmxldCg6Zm9vKSB7IGJheiB9CgpzdWJqZWN0KDpmb28pIHsgYmFyIH0KbGV0KDpmb28pIHsgYmF6IH0KCmxldCg6Zm9vKSB7IGJhciB9CmxldCEoOmZvbykgeyBiYXogfQoKIyBnb29kCnN1YmplY3QoOnRlc3QpIHsgc29tZXRoaW5nIH0KbGV0KDpmb28pIHsgYmFyIH0KbGV0KDpiYXopIHsgYmF6IH0KbGV0ISg6b3RoZXIpIHsgb3RoZXIgfQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL092ZXJ3cml0aW5nU2V0dXAKCj09IFJTcGVjL1BlbmRpbmcKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IERpc2FibGVkCnwgWWVzCnwgTm8KfCAxLjI1CnwgLQp8PT09CgpDaGVja3MgZm9yIGFueSBwZW5kaW5nIG9yIHNraXBwZWQgZXhhbXBsZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBNeUNsYXNzIGRvCiAgaXQgInNob3VsZCBiZSB0cnVlIgplbmQKCmRlc2NyaWJlIE15Q2xhc3MgZG8KICBpdCAic2hvdWxkIGJlIHRydWUiLCBza2lwOiB0cnVlIGRvCiAgICBleHBlY3QoMSkudG8gZXEoMikKICBlbmQKZW5kCgpkZXNjcmliZSBNeUNsYXNzIGRvCiAgaXQgInNob3VsZCBiZSB0cnVlIiBkbwogICAgcGVuZGluZwogIGVuZAplbmQKCmRlc2NyaWJlIE15Q2xhc3MgZG8KICB4aXQgInNob3VsZCBiZSB0cnVlIiBkbwogIGVuZAplbmQKCiMgZ29vZApkZXNjcmliZSBNeUNsYXNzIGRvCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1BlbmRpbmcKCj09IFJTcGVjL1BlbmRpbmdXaXRob3V0UmVhc29uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjE2CnwgLQp8PT09CgpDaGVja3MgZm9yIHBlbmRpbmcgb3Igc2tpcHBlZCBleGFtcGxlcyB3aXRob3V0IHJlYXNvbi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnBlbmRpbmcgJ2RvZXMgc29tZXRoaW5nJyBkbwplbmQKCiMgYmFkCml0ICdkb2VzIHNvbWV0aGluZycsIDpwZW5kaW5nIGRvCmVuZAoKIyBiYWQKaXQgJ2RvZXMgc29tZXRoaW5nJyBkbwogIHBlbmRpbmcKZW5kCgojIGJhZAp4ZGVzY3JpYmUgJ3NvbWV0aGluZycgZG8KZW5kCgojIGJhZApza2lwICdkb2VzIHNvbWV0aGluZycgZG8KZW5kCgojIGJhZAppdCAnZG9lcyBzb21ldGhpbmcnLCA6c2tpcCBkbwplbmQKCiMgYmFkCml0ICdkb2VzIHNvbWV0aGluZycgZG8KICBza2lwCmVuZAoKIyBiYWQKaXQgJ2RvZXMgc29tZXRoaW5nJwoKIyBnb29kCml0ICdkb2VzIHNvbWV0aGluZycgZG8KICBwZW5kaW5nICdyZWFzb24nCmVuZAoKIyBnb29kCml0ICdkb2VzIHNvbWV0aGluZycgZG8KICBza2lwICdyZWFzb24nCmVuZAoKIyBnb29kCml0ICdkb2VzIHNvbWV0aGluZycsIHBlbmRpbmc6ICdyZWFzb24nIGRvCmVuZAoKIyBnb29kCml0ICdkb2VzIHNvbWV0aGluZycsIHNraXA6ICdyZWFzb24nIGRvCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1BlbmRpbmdXaXRob3V0UmVhc29uCgo9PSBSU3BlYy9QcmVkaWNhdGVNYXRjaGVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMS4xNgp8IC0KfD09PQoKUHJlZmVyIHVzaW5nIHByZWRpY2F0ZSBtYXRjaGVyIG92ZXIgdXNpbmcgcHJlZGljYXRlIG1ldGhvZCBkaXJlY3RseS4KClJTcGVjIGRlZmluZXMgbWFnaWMgbWF0Y2hlcnMgZm9yIHByZWRpY2F0ZSBtZXRob2RzLgpUaGlzIGNvcCByZWNvbW1lbmRzIHRvIHVzZSB0aGUgcHJlZGljYXRlIG1hdGNoZXIgaW5zdGVhZCBvZiB1c2luZwpwcmVkaWNhdGUgbWV0aG9kIGRpcmVjdGx5LgoKPT09IEV4YW1wbGVzCgo9PT09IFN0cmljdDogdHJ1ZSwgRW5mb3JjZWRTdHlsZTogaW5mbGVjdGVkIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28uc29tZXRoaW5nPykudG8gYmVfdHJ1dGh5CgojIGdvb2QKZXhwZWN0KGZvbykudG8gYmVfc29tZXRoaW5nCgojIGFsc28gZ29vZCAtIEl0IGNoZWNrcyAidHJ1ZSIgc3RyaWN0bHkuCmV4cGVjdChmb28uc29tZXRoaW5nPykudG8gYmUodHJ1ZSkKLS0tLQoKPT09PSBTdHJpY3Q6IGZhbHNlLCBFbmZvcmNlZFN0eWxlOiBpbmZsZWN0ZWQKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vLnNvbWV0aGluZz8pLnRvIGJlX3RydXRoeQpleHBlY3QoZm9vLnNvbWV0aGluZz8pLnRvIGJlKHRydWUpCgojIGdvb2QKZXhwZWN0KGZvbykudG8gYmVfc29tZXRoaW5nCi0tLS0KCj09PT0gU3RyaWN0OiB0cnVlLCBFbmZvcmNlZFN0eWxlOiBleHBsaWNpdAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIGJlX3NvbWV0aGluZwoKIyBnb29kIC0gdGhlIGFib3ZlIGNvZGUgaXMgcmV3cml0dGVuIHRvIGl0IGJ5IHRoaXMgY29wCmV4cGVjdChmb28uc29tZXRoaW5nPykudG8gYmUodHJ1ZSkKCiMgYmFkIC0gbm8gYXV0b2NvcnJlY3QKZXhwZWN0KGZvbykKICAudG8gYmVfc29tZXRoaW5nKDw8flRFWFQpCiAgICBiYXIKICBURVhUCgojIGdvb2QKZXhwZWN0KGZvby5zb21ldGhpbmc/KDw8flRFWFQpKS50byBiZSh0cnVlKQogIGJhcgpURVhUCi0tLS0KCj09PT0gU3RyaWN0OiBmYWxzZSwgRW5mb3JjZWRTdHlsZTogZXhwbGljaXQKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byBiZV9zb21ldGhpbmcKCiMgZ29vZCAtIHRoZSBhYm92ZSBjb2RlIGlzIHJld3JpdHRlbiB0byBpdCBieSB0aGlzIGNvcApleHBlY3QoZm9vLnNvbWV0aGluZz8pLnRvIGJlX3RydXRoeQotLS0tCgo9PT0gQ29uZmlndXJhYmxlIGF0dHJpYnV0ZXMKCnw9PT0KfCBOYW1lIHwgRGVmYXVsdCB2YWx1ZSB8IENvbmZpZ3VyYWJsZSB2YWx1ZXMKCnwgU3RyaWN0CnwgYHRydWVgCnwgQm9vbGVhbgoKfCBFbmZvcmNlZFN0eWxlCnwgYGluZmxlY3RlZGAKfCBgaW5mbGVjdGVkYCwgYGV4cGxpY2l0YAoKfCBBbGxvd2VkRXhwbGljaXRNYXRjaGVycwp8IGBbXWAKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jcHJlZGljYXRlLW1hdGNoZXJzCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9QcmVkaWNhdGVNYXRjaGVyCgo9PSBSU3BlYy9SZWNlaXZlQ291bnRzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4yNgp8IC0KfD09PQoKQ2hlY2sgZm9yIGBvbmNlYCBhbmQgYHR3aWNlYCByZWNlaXZlIGNvdW50cyBtYXRjaGVycyB1c2FnZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikuZXhhY3RseSgxKS50aW1lcwpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmV4YWN0bHkoMikudGltZXMKZXhwZWN0KGZvbykudG8gcmVjZWl2ZSg6YmFyKS5hdF9sZWFzdCgxKS50aW1lcwpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmF0X2xlYXN0KDIpLnRpbWVzCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikuYXRfbW9zdCgxKS50aW1lcwpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmF0X21vc3QoMikudGltZXMKCiMgZ29vZApleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLm9uY2UKZXhwZWN0KGZvbykudG8gcmVjZWl2ZSg6YmFyKS50d2ljZQpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmF0X2xlYXN0KDpvbmNlKQpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmF0X2xlYXN0KDp0d2ljZSkKZXhwZWN0KGZvbykudG8gcmVjZWl2ZSg6YmFyKS5hdF9tb3N0KDpvbmNlKQpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLmF0X21vc3QoOnR3aWNlKS50aW1lcwotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1JlY2VpdmVDb3VudHMKCj09IFJTcGVjL1JlY2VpdmVNZXNzYWdlcwoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IEFsd2F5cyAoVW5zYWZlKQp8IDIuMjMKfCAtCnw9PT0KCkNoZWNrcyBmb3IgbXVsdGlwbGUgbWVzc2FnZXMgc3R1YmJlZCBvbiB0aGUgc2FtZSBvYmplY3QuCgo9PT0gU2FmZXR5CgpUaGUgYXV0b2NvcnJlY3Rpb24gaXMgbWFya2VkIGFzIHVuc2FmZSwgYmVjYXVzZSBpdCBtYXkgY2hhbmdlIHRoZQpvcmRlciBvZiBzdHVicy4gVGhpcyBpbiB0dXJuIG1heSBjYXVzZSBlLmcuIHZhcmlhYmxlcyB0byBiZSBjYWxsZWQKYmVmb3JlIHRoZXkgYXJlIGRlZmluZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApiZWZvcmUgZG8KICBhbGxvdyhTZXJ2aWNlKS50byByZWNlaXZlKDpmb28pLmFuZF9yZXR1cm4oYmFyKQogIGFsbG93KFNlcnZpY2UpLnRvIHJlY2VpdmUoOmJheikuYW5kX3JldHVybihxdXgpCmVuZAoKIyBnb29kCmJlZm9yZSBkbwogIGFsbG93KFNlcnZpY2UpLnRvIHJlY2VpdmVfbWVzc2FnZXMoZm9vOiBiYXIsIGJhejogcXV4KQplbmQKCiMgZ29vZCAtIGlnbm9yZSBzYW1lIG1lc3NhZ2UKYmVmb3JlIGRvCiAgYWxsb3coU2VydmljZSkudG8gcmVjZWl2ZSg6Zm9vKS5hbmRfcmV0dXJuKGJhcikKICBhbGxvdyhTZXJ2aWNlKS50byByZWNlaXZlKDpmb28pLmFuZF9yZXR1cm4ocXV4KQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZWNlaXZlTWVzc2FnZXMKCj09IFJTcGVjL1JlY2VpdmVOZXZlcgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMjgKfCAtCnw9PT0KClByZWZlciBgbm90X3RvIHJlY2VpdmUoLi4uKWAgb3ZlciBgcmVjZWl2ZSguLi4pLm5ldmVyYC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikubmV2ZXIKCiMgZ29vZApleHBlY3QoZm9vKS5ub3RfdG8gcmVjZWl2ZSg6YmFyKQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1JlY2VpdmVOZXZlcgoKPT0gUlNwZWMvUmVkdW5kYW50QXJvdW5kCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4xOQp8IC0KfD09PQoKUmVtb3ZlIHJlZHVuZGFudCBgYXJvdW5kYCBob29rLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYXJvdW5kIGRvIHxleGFtcGxlfAogIGV4YW1wbGUucnVuCmVuZAoKIyBnb29kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvUmVkdW5kYW50QXJvdW5kCgo9PSBSU3BlYy9SZWR1bmRhbnRQcmVkaWNhdGVNYXRjaGVyCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4yNgp8IC0KfD09PQoKQ2hlY2tzIGZvciByZWR1bmRhbnQgcHJlZGljYXRlIG1hdGNoZXIuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QoZm9vKS50byBiZV9leGlzdChiYXIpCmV4cGVjdChmb28pLm5vdF90byBiZV9pbmNsdWRlKGJhcikKZXhwZWN0KGZvbykudG8gYmVfYWxsKGJhcikKCiMgZ29vZApleHBlY3QoZm9vKS50byBleGlzdChiYXIpCmV4cGVjdChmb28pLm5vdF90byBpbmNsdWRlKGJhcikKZXhwZWN0KGZvbykudG8gYWxsIGJlKGJhcikKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZWR1bmRhbnRQcmVkaWNhdGVNYXRjaGVyCgo9PSBSU3BlYy9SZW1vdmVDb25zdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IE5vCnwgMi4yNgp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgYHJlbW92ZV9jb25zdGAgaXMgbm90IHVzZWQgaW4gc3BlY3MuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCAnZG9lcyBzb21ldGhpbmcnIGRvCiAgT2JqZWN0LnNlbmQoOnJlbW92ZV9jb25zdCwgOlNvbWVDb25zdGFudCkKZW5kCgpiZWZvcmUgZG8KICBTb21lQ2xhc3Muc2VuZCg6cmVtb3ZlX2NvbnN0LCA6U29tZUNvbnN0YW50KQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZW1vdmVDb25zdAoKPT0gUlNwZWMvUmVwZWF0ZWREZXNjcmlwdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS45CnwgLQp8PT09CgpDaGVjayBmb3IgcmVwZWF0ZWQgZGVzY3JpcHRpb24gc3RyaW5ncyBpbiBleGFtcGxlIGdyb3Vwcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJTcGVjLmRlc2NyaWJlIFVzZXIgZG8KICBpdCAnaXMgdmFsaWQnIGRvCiAgICAjIC4uLgogIGVuZAoKICBpdCAnaXMgdmFsaWQnIGRvCiAgICAjIC4uLgogIGVuZAplbmQKCiMgZ29vZApSU3BlYy5kZXNjcmliZSBVc2VyIGRvCiAgaXQgJ2lzIHZhbGlkIHdoZW4gZmlyc3QgYW5kIGxhc3QgbmFtZSBhcmUgcHJlc2VudCcgZG8KICAgICMgLi4uCiAgZW5kCgogIGl0ICdpcyB2YWxpZCB3aGVuIGxhc3QgbmFtZSBvbmx5IGlzIHByZXNlbnQnIGRvCiAgICAjIC4uLgogIGVuZAplbmQKCiMgZ29vZApSU3BlYy5kZXNjcmliZSBVc2VyIGRvCiAgaXQgJ2lzIHZhbGlkJyBkbwogICAgIyAuLi4KICBlbmQKCiAgaXQgJ2lzIHZhbGlkJywgOmZsYWcgZG8KICAgICMgLi4uCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1JlcGVhdGVkRGVzY3JpcHRpb24KCj09IFJTcGVjL1JlcGVhdGVkRXhhbXBsZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4xMAp8IC0KfD09PQoKQ2hlY2sgZm9yIHJlcGVhdGVkIGV4YW1wbGVzIHdpdGhpbiBleGFtcGxlIGdyb3Vwcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCml0ICdpcyB2YWxpZCcgZG8KICBleHBlY3QodXNlcikudG8gYmVfdmFsaWQKZW5kCgppdCAndmFsaWRhdGVzIHRoZSB1c2VyJyBkbwogIGV4cGVjdCh1c2VyKS50byBiZV92YWxpZAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZXBlYXRlZEV4YW1wbGUKCj09IFJTcGVjL1JlcGVhdGVkRXhhbXBsZUdyb3VwQm9keQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4zOAp8IC0KfD09PQoKQ2hlY2sgZm9yIHJlcGVhdGVkIGRlc2NyaWJlIGFuZCBjb250ZXh0IGJsb2NrIGJvZHkuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSAnY29vbCBmZWF0dXJlIHgnIGRvCiAgaXQgeyBjb29sX3ByZWRpY2F0ZSB9CmVuZAoKZGVzY3JpYmUgJ2Nvb2wgZmVhdHVyZSB5JyBkbwogIGl0IHsgY29vbF9wcmVkaWNhdGUgfQplbmQKCiMgZ29vZApkZXNjcmliZSAnY29vbCBmZWF0dXJlJyBkbwogIGl0IHsgY29vbF9wcmVkaWNhdGUgfQplbmQKCmRlc2NyaWJlICdhbm90aGVyIGNvb2wgZmVhdHVyZScgZG8KICBpdCB7IGFub3RoZXJfcHJlZGljYXRlIH0KZW5kCgojIGdvb2QKY29udGV4dCAnd2hlbiBjYXNlIHgnLCA6dGFnIGRvCiAgaXQgeyBjb29sX3ByZWRpY2F0ZSB9CmVuZAoKY29udGV4dCAnd2hlbiBjYXNlIHknIGRvCiAgaXQgeyBjb29sX3ByZWRpY2F0ZSB9CmVuZAoKIyBnb29kCmNvbnRleHQgQXJyYXkgZG8KICBpdCB7IGlzX2V4cGVjdGVkLnRvIHJlc3BvbmRfdG8gOmVhY2ggfQplbmQKCmNvbnRleHQgSGFzaCBkbwogIGl0IHsgaXNfZXhwZWN0ZWQudG8gcmVzcG9uZF90byA6ZWFjaCB9CmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1JlcGVhdGVkRXhhbXBsZUdyb3VwQm9keQoKPT0gUlNwZWMvUmVwZWF0ZWRFeGFtcGxlR3JvdXBEZXNjcmlwdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS4zOAp8IC0KfD09PQoKQ2hlY2sgZm9yIHJlcGVhdGVkIGV4YW1wbGUgZ3JvdXAgZGVzY3JpcHRpb25zLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZGVzY3JpYmUgJ2Nvb2wgZmVhdHVyZScgZG8KICAjIGV4YW1wbGUgZ3JvdXAKZW5kCgpkZXNjcmliZSAnY29vbCBmZWF0dXJlJyBkbwogICMgZXhhbXBsZSBncm91cAplbmQKCiMgYmFkCmNvbnRleHQgJ3doZW4gY2FzZSB4JyBkbwogICMgZXhhbXBsZSBncm91cAplbmQKCmRlc2NyaWJlICd3aGVuIGNhc2UgeCcgZG8KICAjIGV4YW1wbGUgZ3JvdXAKZW5kCgojIGdvb2QKZGVzY3JpYmUgJ2Nvb2wgZmVhdHVyZScgZG8KICAjIGV4YW1wbGUgZ3JvdXAKZW5kCgpkZXNjcmliZSAnYW5vdGhlciBjb29sIGZlYXR1cmUnIGRvCiAgIyBleGFtcGxlIGdyb3VwCmVuZAoKIyBnb29kCmNvbnRleHQgJ3doZW4gY2FzZSB4JyBkbwogICMgZXhhbXBsZSBncm91cAplbmQKCmNvbnRleHQgJ3doZW4gYW5vdGhlciBjYXNlJyBkbwogICMgZXhhbXBsZSBncm91cAplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZXBlYXRlZEV4YW1wbGVHcm91cERlc2NyaXB0aW9uCgo9PSBSU3BlYy9SZXBlYXRlZEluY2x1ZGVFeGFtcGxlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjQ0CnwgLQp8PT09CgpDaGVjayBmb3IgcmVwZWF0ZWQgaW5jbHVkZSBvZiBzaGFyZWQgZXhhbXBsZXMuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSAnZm9vJyBkbwogIGluY2x1ZGVfZXhhbXBsZXMgJ2Nvb2wgc3R1ZmYnCiAgaW5jbHVkZV9leGFtcGxlcyAnY29vbCBzdHVmZicKZW5kCgojIGJhZApkZXNjcmliZSAnZm9vJyBkbwogIGl0X2JlaGF2ZXNfbGlrZSAnYSBjb29sJywgJ3RoaW5nJwogIGl0X2JlaGF2ZXNfbGlrZSAnYSBjb29sJywgJ3RoaW5nJwplbmQKCiMgYmFkCmNvbnRleHQgJ2ZvbycgZG8KICBpdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2EgZHVjaycKICBpdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2EgZHVjaycKZW5kCgojIGdvb2QKZGVzY3JpYmUgJ2ZvbycgZG8KICBpbmNsdWRlX2V4YW1wbGVzICdjb29sIHN0dWZmJwplbmQKCmRlc2NyaWJlICdiYXInIGRvCiAgaW5jbHVkZV9leGFtcGxlcyAnY29vbCBzdHVmZicKZW5kCgojIGdvb2QKZGVzY3JpYmUgJ2ZvbycgZG8KICBpdF9iZWhhdmVzX2xpa2UgJ2EgY29vbCcsICd0aGluZycKICBpdF9iZWhhdmVzX2xpa2UgJ2EgY29vbCcsICdwZXJzb24nCmVuZAoKIyBnb29kCmNvbnRleHQgJ2ZvbycgZG8KICBpdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2EgZHVjaycKICBpdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2EgZ29vc2UnCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1JlcGVhdGVkSW5jbHVkZUV4YW1wbGUKCj09IFJTcGVjL1JlcGVhdGVkU3ViamVjdENhbGwKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMjcKfCAtCnw9PT0KCkNoZWNrcyBmb3IgcmVwZWF0ZWQgY2FsbHMgdG8gc3ViamVjdCBtaXNzaW5nIHRoYXQgaXQgaXMgbWVtb2l6ZWQuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdCBkbwogIHN1YmplY3QKICBleHBlY3QgeyBzdWJqZWN0IH0udG8gbm90X2NoYW5nZSB7IEEuY291bnQgfQplbmQKCml0IGRvCiAgZXhwZWN0IHsgc3ViamVjdCB9LnRvIGNoYW5nZSB7IEEuY291bnQgfQogIGV4cGVjdCB7IHN1YmplY3QgfS50byBub3RfY2hhbmdlIHsgQS5jb3VudCB9CmVuZAoKIyBnb29kCml0IGRvCiAgZXhwZWN0IHsgbXlfbWV0aG9kIH0udG8gY2hhbmdlIHsgQS5jb3VudCB9CiAgZXhwZWN0IHsgbXlfbWV0aG9kIH0udG8gbm90X2NoYW5nZSB7IEEuY291bnQgfQplbmQKCiMgYWxzbyBnb29kCml0IGRvCiAgZXhwZWN0IHsgc3ViamVjdC5hIH0udG8gY2hhbmdlIHsgQS5jb3VudCB9CiAgZXhwZWN0IHsgc3ViamVjdC5iIH0udG8gbm90X2NoYW5nZSB7IEEuY291bnQgfQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZXBlYXRlZFN1YmplY3RDYWxsCgo9PSBSU3BlYy9SZXR1cm5Gcm9tU3R1YgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuMTYKfCAxLjIyCnw9PT0KCkNoZWNrcyBmb3IgY29uc2lzdGVudCBzdHlsZSBvZiBzdHViJ3MgcmV0dXJuIHNldHRpbmcuCgpFbmZvcmNlcyBlaXRoZXIgYGFuZF9yZXR1cm5gIG9yIGJsb2NrLXN0eWxlIHJldHVybiBpbiB0aGUgY2FzZXMKd2hlcmUgdGhlIHJldHVybmVkIHZhbHVlIGlzIGNvbnN0YW50LiBJZ25vcmVzIGR5bmFtaWMgcmV0dXJuZWQgdmFsdWVzCmFyZSB0aGUgcmVzdWx0IHdvdWxkIGJlIGRpZmZlcmVudAoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBFbmZvcmNlZFN0eWxlYCBvcHRpb24KCj09PSBFeGFtcGxlcwoKPT09PSBgRW5mb3JjZWRTdHlsZTogYW5kX3JldHVybmAgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYWxsb3coRm9vKS50byByZWNlaXZlKDpiYXIpIHsgImJheiIgfQpleHBlY3QoRm9vKS50byByZWNlaXZlKDpiYXIpIHsgImJheiIgfQoKIyBnb29kCmFsbG93KEZvbykudG8gcmVjZWl2ZSg6YmFyKS5hbmRfcmV0dXJuKCJiYXoiKQpleHBlY3QoRm9vKS50byByZWNlaXZlKDpiYXIpLmFuZF9yZXR1cm4oImJheiIpCiMgYWxzbyBnb29kIGFzIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBkeW5hbWljCmFsbG93KEZvbykudG8gcmVjZWl2ZSg6YmFyKSB7IGJhci5iYXogfQotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBibG9ja2AKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAphbGxvdyhGb28pLnRvIHJlY2VpdmUoOmJhcikuYW5kX3JldHVybigiYmF6IikKZXhwZWN0KEZvbykudG8gcmVjZWl2ZSg6YmFyKS5hbmRfcmV0dXJuKCJiYXoiKQoKIyBnb29kCmFsbG93KEZvbykudG8gcmVjZWl2ZSg6YmFyKSB7ICJiYXoiIH0KZXhwZWN0KEZvbykudG8gcmVjZWl2ZSg6YmFyKSB7ICJiYXoiIH0KIyBhbHNvIGdvb2QgYXMgdGhlIHJldHVybmVkIHZhbHVlIGlzIGR5bmFtaWMKYWxsb3coRm9vKS50byByZWNlaXZlKDpiYXIpLmFuZF9yZXR1cm4oYmFyLmJheikKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgYW5kX3JldHVybmAKfCBgYW5kX3JldHVybmAsIGBibG9ja2AKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9SZXR1cm5Gcm9tU3R1YgoKPT0gUlNwZWMvU2NhdHRlcmVkTGV0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4xNAp8IDEuMzkKfD09PQoKQ2hlY2tzIGZvciBsZXQgc2NhdHRlcmVkIGFjcm9zcyB0aGUgZXhhbXBsZSBncm91cC4KCkdyb3VwIGxldHMgdG9nZXRoZXIKCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlIEZvbyBkbwogIGxldCg6Zm9vKSB7IDEgfQogIHN1YmplY3QgeyBGb28gfQogIGxldCg6YmFyKSB7IDIgfQogIGJlZm9yZSB7IHByZXBhcmUgfQogIGxldCEoOmJheikgeyAzIH0KZW5kCgojIGdvb2QKZGVzY3JpYmUgRm9vIGRvCiAgc3ViamVjdCB7IEZvbyB9CiAgYmVmb3JlIHsgcHJlcGFyZSB9CiAgbGV0KDpmb28pIHsgMSB9CiAgbGV0KDpiYXIpIHsgMiB9CiAgbGV0ISg6YmF6KSB7IDMgfQplbmQKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9TY2F0dGVyZWRMZXQKCj09IFJTcGVjL1NjYXR0ZXJlZFNldHVwCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4xMAp8IC0KfD09PQoKQ2hlY2tzIGZvciBzZXR1cCBzY2F0dGVyZWQgYWNyb3NzIG11bHRpcGxlIGhvb2tzIGluIGFuIGV4YW1wbGUgZ3JvdXAuCgpVbmlmeSBgYmVmb3JlYCwgYGFmdGVyYCwgYW5kIGBhcm91bmRgIGhvb2tzIHdoZW4gcG9zc2libGUuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBGb28gZG8KICBiZWZvcmUgeyBzZXR1cDEgfQogIGJlZm9yZSB7IHNldHVwMiB9CmVuZAoKIyBnb29kCmRlc2NyaWJlIEZvbyBkbwogIGJlZm9yZSBkbwogICAgc2V0dXAxCiAgICBzZXR1cDIKICBlbmQKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvU2NhdHRlcmVkU2V0dXAKCj09IFJTcGVjL1NoYXJlZENvbnRleHQKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjEzCnwgLQp8PT09CgpDaGVja3MgZm9yIHByb3BlciBzaGFyZWRfY29udGV4dCBhbmQgc2hhcmVkX2V4YW1wbGVzIHVzYWdlLgoKSWYgdGhlcmUgYXJlIG5vIGV4YW1wbGVzIGRlZmluZWQsIHVzZSBzaGFyZWRfY29udGV4dC4KSWYgdGhlcmUgaXMgbm8gc2V0dXAgZGVmaW5lZCwgdXNlIHNoYXJlZF9leGFtcGxlcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkClJTcGVjLnNoYXJlZF9jb250ZXh0ICdvbmx5IGV4YW1wbGVzIGhlcmUnIGRvCiAgaXQgJ2RvZXMgeCcgZG8KICBlbmQKCiAgaXQgJ2RvZXMgeScgZG8KICBlbmQKZW5kCgojIGdvb2QKUlNwZWMuc2hhcmVkX2V4YW1wbGVzICdvbmx5IGV4YW1wbGVzIGhlcmUnIGRvCiAgaXQgJ2RvZXMgeCcgZG8KICBlbmQKCiAgaXQgJ2RvZXMgeScgZG8KICBlbmQKZW5kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApSU3BlYy5zaGFyZWRfZXhhbXBsZXMgJ29ubHkgc2V0dXAgaGVyZScgZG8KICBzdWJqZWN0KDpmb28pIHsgOmJhciB9CgogIGxldCg6YmF6KSB7IDpiYXp6IH0KCiAgYmVmb3JlIGRvCiAgICBzb21ldGhpbmcKICBlbmQKZW5kCgojIGdvb2QKUlNwZWMuc2hhcmVkX2NvbnRleHQgJ29ubHkgc2V0dXAgaGVyZScgZG8KICBzdWJqZWN0KDpmb28pIHsgOmJhciB9CgogIGxldCg6YmF6KSB7IDpiYXp6IH0KCiAgYmVmb3JlIGRvCiAgICBzb21ldGhpbmcKICBlbmQKZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvU2hhcmVkQ29udGV4dAoKPT0gUlNwZWMvU2hhcmVkRXhhbXBsZXMKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBBbHdheXMKfCAxLjI1CnwgMi4yNgp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgc3R5bGUgZm9yIHNoYXJlZCBleGFtcGxlIG5hbWVzLgoKRW5mb3JjZXMgZWl0aGVyIGBzdHJpbmdgIG9yIGBzeW1ib2xgIGZvciBzaGFyZWQgZXhhbXBsZSBuYW1lcy4KClRoaXMgY29wIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgRW5mb3JjZWRTdHlsZWAgb3B0aW9uCgo9PT0gRXhhbXBsZXMKCj09PT0gYEVuZm9yY2VkU3R5bGU6IHN0cmluZ2AgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXRfYmVoYXZlc19saWtlIDpmb29fYmFyX2JhegppdF9zaG91bGRfYmVoYXZlX2xpa2UgOmZvb19iYXJfYmF6CnNoYXJlZF9leGFtcGxlcyA6Zm9vX2Jhcl9iYXoKc2hhcmVkX2V4YW1wbGVzX2ZvciA6Zm9vX2Jhcl9iYXoKaW5jbHVkZV9leGFtcGxlcyA6Zm9vX2Jhcl9iYXoKCiMgZ29vZAppdF9iZWhhdmVzX2xpa2UgJ2ZvbyBiYXIgYmF6JwppdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2ZvbyBiYXIgYmF6JwpzaGFyZWRfZXhhbXBsZXMgJ2ZvbyBiYXIgYmF6JwpzaGFyZWRfZXhhbXBsZXNfZm9yICdmb28gYmFyIGJheicKaW5jbHVkZV9leGFtcGxlcyAnZm9vIGJhciBiYXonCi0tLS0KCj09PT0gYEVuZm9yY2VkU3R5bGU6IHN5bWJvbGAKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZAppdF9iZWhhdmVzX2xpa2UgJ2ZvbyBiYXIgYmF6JwppdF9zaG91bGRfYmVoYXZlX2xpa2UgJ2ZvbyBiYXIgYmF6JwpzaGFyZWRfZXhhbXBsZXMgJ2ZvbyBiYXIgYmF6JwpzaGFyZWRfZXhhbXBsZXNfZm9yICdmb28gYmFyIGJheicKaW5jbHVkZV9leGFtcGxlcyAnZm9vIGJhciBiYXonCgojIGdvb2QKaXRfYmVoYXZlc19saWtlIDpmb29fYmFyX2JhegppdF9zaG91bGRfYmVoYXZlX2xpa2UgOmZvb19iYXJfYmF6CnNoYXJlZF9leGFtcGxlcyA6Zm9vX2Jhcl9iYXoKc2hhcmVkX2V4YW1wbGVzX2ZvciA6Zm9vX2Jhcl9iYXoKaW5jbHVkZV9leGFtcGxlcyA6Zm9vX2Jhcl9iYXoKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IEVuZm9yY2VkU3R5bGUKfCBgc3RyaW5nYAp8IGBzdHJpbmdgLCBgc3ltYm9sYAp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1NoYXJlZEV4YW1wbGVzCgo9PSBSU3BlYy9TaW5nbGVBcmd1bWVudE1lc3NhZ2VDaGFpbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuOQp8IDEuMTAKfD09PQoKQ2hlY2tzIHRoYXQgY2hhaW5zIG9mIG1lc3NhZ2VzIGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBlbGVtZW50LgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKYWxsb3coZm9vKS50byByZWNlaXZlX21lc3NhZ2VfY2hhaW4oOmJhcikuYW5kX3JldHVybig0MikKCiMgZ29vZAphbGxvdyhmb28pLnRvIHJlY2VpdmUoOmJhcikuYW5kX3JldHVybig0MikKCiMgYWxzbyBnb29kCmFsbG93KGZvbykudG8gcmVjZWl2ZSg6YmFyLCA6YmF6KQphbGxvdyhmb28pLnRvIHJlY2VpdmUoImJhci5iYXoiKQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1NpbmdsZUFyZ3VtZW50TWVzc2FnZUNoYWluCgo9PSBSU3BlYy9Ta2lwQmxvY2tJbnNpZGVFeGFtcGxlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgTm8KfCAyLjE5CnwgLQp8PT09CgpDaGVja3MgZm9yIHBhc3NpbmcgYSBibG9jayB0byBgc2tpcGAgd2l0aGluIGV4YW1wbGVzLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKaXQgJ2RvZXMgc29tZXRoaW5nJyBkbwogIHNraXAgJ25vdCB5ZXQgaW1wbGVtZW50ZWQnIGRvCiAgICBkb19zb21ldGhpbmcKICBlbmQKZW5kCgojIGdvb2QKaXQgJ2RvZXMgc29tZXRoaW5nJyBkbwogIHNraXAgJ25vdCB5ZXQgaW1wbGVtZW50ZWQnCiAgZG9fc29tZXRoaW5nCmVuZAoKIyBnb29kIC0gd2hlbiBvdXRzaWRlIGV4YW1wbGUKc2tpcCAnbm90IHlldCBpbXBsZW1lbnRlZCcgZG8KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvU2tpcEJsb2NrSW5zaWRlRXhhbXBsZQoKPT0gUlNwZWMvU29ydE1ldGFkYXRhCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzCnwgMi4xNAp8IC0KfD09PQoKU29ydCBSU3BlYyBtZXRhZGF0YSBhbHBoYWJldGljYWxseS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlICdTb21ldGhpbmcnLCA6YiwgOmEKY29udGV4dCAnU29tZXRoaW5nJywgZm9vOiAnYmFyJywgYmF6OiB0cnVlCml0ICd3b3JrcycsIDpiLCA6YSwgZm9vOiAnYmFyJywgYmF6OiB0cnVlCgojIGdvb2QKZGVzY3JpYmUgJ1NvbWV0aGluZycsIDphLCA6Ygpjb250ZXh0ICdTb21ldGhpbmcnLCBiYXo6IHRydWUsIGZvbzogJ2JhcicKaXQgJ3dvcmtzJywgOmEsIDpiLCBiYXo6IHRydWUsIGZvbzogJ2JhcicKLS0tLQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9Tb3J0TWV0YWRhdGEKCj09IFJTcGVjL1NwZWNGaWxlUGF0aEZvcm1hdAoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IE5vCnwgMi4yNAp8IC0KfD09PQoKQ2hlY2tzIHRoYXQgc3BlYyBmaWxlIHBhdGhzIGFyZSBjb25zaXN0ZW50IGFuZCB3ZWxsLWZvcm1lZC4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCndoYXRldmVyX3NwZWMucmIgICAgICAgICAjIGRlc2NyaWJlIE15Q2xhc3MKbXlfY2xhc3Nfc3BlYy5yYiAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCgojIGdvb2QKbXlfY2xhc3Nfc3BlYy5yYiAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcwpteV9jbGFzc19tZXRob2Rfc3BlYy5yYiAgIyBkZXNjcmliZSBNeUNsYXNzLCAnI21ldGhvZCcKbXlfY2xhc3MvbWV0aG9kX3NwZWMucmIgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCi0tLS0KCj09PT0gYEN1c3RvbVRyYW5zZm9ybToge1J1Ym9Db3A9PnJ1Ym9jb3AsIFJTcGVjPT5yc3BlY31gIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApydWJvY29wX3NwZWMucmIgICAgICAgICAgIyBkZXNjcmliZSBSdWJvQ29wCnJzcGVjX3NwZWMucmIgICAgICAgICAgICAjIGRlc2NyaWJlIFJTcGVjCi0tLS0KCj09PT0gYElnbm9yZU1ldGhvZHM6IGZhbHNlYCAoZGVmYXVsdCkKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzLCAnI21ldGhvZCcKLS0tLQoKPT09PSBgSWdub3JlTWV0aG9kczogdHJ1ZWAKCltzb3VyY2UscnVieV0KLS0tLQojIGdvb2QKbXlfY2xhc3Nfc3BlYy5yYiAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcywgJyNtZXRob2QnCi0tLS0KCj09PT0gYElnbm9yZU1ldGFkYXRhOiB7dHlwZT0+cm91dGluZ31gIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZAp3aGF0ZXZlcl9zcGVjLnJiICAgICAgICAgIyBkZXNjcmliZSBNeUNsYXNzLCB0eXBlOiA6cm91dGluZyBkbzsgZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCsqKi8qX3NwZWMucmIrYAp8IEFycmF5Cgp8IEV4Y2x1ZGUKfCBgKyoqL3NwZWMvcm91dGluZy8qKi8qK2AKfCBBcnJheQoKfCBDdXN0b21UcmFuc2Zvcm0KfCBgeyJSdWJvQ29wIj0+InJ1Ym9jb3AiLCAiUlNwZWMiPT4icnNwZWMifWAKfCAKCnwgSWdub3JlTWV0aG9kcwp8IGBmYWxzZWAKfCBCb29sZWFuCgp8IElnbm9yZU1ldGFkYXRhCnwgYHsidHlwZSI9PiJyb3V0aW5nIn1gCnwgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvU3BlY0ZpbGVQYXRoRm9ybWF0Cgo9PSBSU3BlYy9TcGVjRmlsZVBhdGhTdWZmaXgKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMjQKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IHNwZWMgZmlsZSBwYXRocyBzdWZmaXggYXJlIGNvbnNpc3RlbnQgYW5kIHdlbGwtZm9ybWVkLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbXlfY2xhc3MvZm9vX3NwZWNvcmIucmIgICAjIGRlc2NyaWJlIE15Q2xhc3MKc3BlYy9tb2RlbHMvdXNlci5yYiAgICAgICAjIGRlc2NyaWJlIFVzZXIKc3BlYy9tb2RlbHMvdXNlcl9zcGVjeHJiICAjIGRlc2NyaWJlIFVzZXIKCiMgZ29vZApteV9jbGFzc19zcGVjLnJiICAgICAgICAgICMgZGVzY3JpYmUgTXlDbGFzcwoKIyBnb29kIC0gc2hhcmVkIGV4YW1wbGVzIGFyZSBhbGxvd2VkCnNwZWMvbW9kZWxzL3VzZXIucmIgICAgICAgIyBzaGFyZWRfZXhhbXBsZXNfZm9yICdmb28nCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBJbmNsdWRlCnwgYCsqKi8qX3NwZWMqcmIqK2AsIGArKiovc3BlYy8qKi8qK2AKfCBBcnJheQp8PT09Cgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1NwZWNGaWxlUGF0aFN1ZmZpeAoKPT0gUlNwZWMvU3R1YmJlZE1vY2sKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuNDQKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IG1lc3NhZ2UgZXhwZWN0YXRpb25zIGRvIG5vdCBoYXZlIGEgY29uZmlndXJlZCByZXNwb25zZS4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikud2l0aCg0MikuYW5kX3JldHVybigiaGVsbG8gd29ybGQiKQoKIyBnb29kICh3aXRob3V0IHNwaWVzKQphbGxvdyhmb28pLnRvIHJlY2VpdmUoOmJhcikud2l0aCg0MikuYW5kX3JldHVybigiaGVsbG8gd29ybGQiKQpleHBlY3QoZm9vKS50byByZWNlaXZlKDpiYXIpLndpdGgoNDIpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvU3R1YmJlZE1vY2sKCj09IFJTcGVjL1N1YmplY3REZWNsYXJhdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgUGVuZGluZwp8IFllcwp8IE5vCnwgMi41CnwgLQp8PT09CgpFbnN1cmUgdGhhdCBzdWJqZWN0IGlzIGRlZmluZWQgdXNpbmcgc3ViamVjdCBoZWxwZXIuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApsZXQoOnN1YmplY3QpIHsgZm9vIH0KbGV0ISg6c3ViamVjdCkgeyBmb28gfQpzdWJqZWN0KDpzdWJqZWN0KSB7IGZvbyB9CnN1YmplY3QhKDpzdWJqZWN0KSB7IGZvbyB9CgojIGJhZApibG9jayA9IC0+IHt9CmxldCg6c3ViamVjdCwgJmJsb2NrKQoKIyBnb29kCnN1YmplY3QoOnRlc3Rfc3ViamVjdCkgeyBmb28gfQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1N1YmplY3REZWNsYXJhdGlvbgoKPT0gUlNwZWMvU3ViamVjdFN0dWIKCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IEVuYWJsZWQKfCBZZXMKfCBObwp8IDEuNwp8IDIuOAp8PT09CgpDaGVja3MgZm9yIHN0dWJiZWQgdGVzdCBzdWJqZWN0cy4KCkNoZWNrcyBuZXN0ZWQgc3ViamVjdCBzdHVicyBmb3IgaW5uZXJtb3N0IHN1YmplY3QgZGVmaW5pdGlvbgp3aGVuIHN1YmplY3QgaXMgYWxzbyBkZWZpbmVkIGluIHBhcmVudCBleGFtcGxlIGdyb3Vwcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmRlc2NyaWJlIEFydGljbGUgZG8KICBzdWJqZWN0KDphcnRpY2xlKSB7IEFydGljbGUubmV3IH0KCiAgaXQgJ2luZGljYXRlcyB0aGF0IHRoZSBhdXRob3IgaXMgdW5rbm93bicgZG8KICAgIGFsbG93KGFydGljbGUpLnRvIHJlY2VpdmUoOmF1dGhvcikuYW5kX3JldHVybihuaWwpCiAgICBleHBlY3QoYXJ0aWNsZS5kZXNjcmlwdGlvbikudG8gaW5jbHVkZSgnYnkgYW4gdW5rbm93biBhdXRob3InKQogIGVuZAplbmQKCiMgYmFkCmRlc2NyaWJlIEFydGljbGUgZG8KICBzdWJqZWN0KDpmb28pIHsgQXJ0aWNsZS5uZXcgfQoKICBjb250ZXh0ICduZXN0ZWQgc3ViamVjdCcgZG8KICAgIHN1YmplY3QoOmFydGljbGUpIHsgQXJ0aWNsZS5uZXcgfQoKICAgIGl0ICdpbmRpY2F0ZXMgdGhhdCB0aGUgYXV0aG9yIGlzIHVua25vd24nIGRvCiAgICAgIGFsbG93KGFydGljbGUpLnRvIHJlY2VpdmUoOmF1dGhvcikuYW5kX3JldHVybihuaWwpCiAgICAgIGV4cGVjdChhcnRpY2xlLmRlc2NyaXB0aW9uKS50byBpbmNsdWRlKCdieSBhbiB1bmtub3duIGF1dGhvcicpCiAgICBlbmQKICBlbmQKZW5kCgojIGdvb2QKZGVzY3JpYmUgQXJ0aWNsZSBkbwogIHN1YmplY3QoOmFydGljbGUpIHsgQXJ0aWNsZS5uZXcoYXV0aG9yOiBuaWwpIH0KCiAgaXQgJ2luZGljYXRlcyB0aGF0IHRoZSBhdXRob3IgaXMgdW5rbm93bicgZG8KICAgIGV4cGVjdChhcnRpY2xlLmRlc2NyaXB0aW9uKS50byBpbmNsdWRlKCdieSBhbiB1bmtub3duIGF1dGhvcicpCiAgZW5kCmVuZAotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3JzcGVjLnJ1YnlzdHlsZS5ndWlkZS8jZG9udC1zdHViLXN1YmplY3QKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1N1YmplY3RTdHViCiogaHR0cHM6Ly9yb2JvdHMudGhvdWdodGJvdC5jb20vZG9uLXQtc3R1Yi10aGUtc3lzdGVtLXVuZGVyLXRlc3QKKiBodHRwczovL3BlbmVsb3BlLnpvbmUvMjAxNS8xMi8yNy9pbnRyb2R1Y2luZy1yc3BlYy1zbWVsbHMtYW5kLXdoZXJlLXRvLWZpbmQtdGhlbS5odG1sI3NtZWxsLTEtc3R1YmplYwoKPT0gUlNwZWMvVW5kZXNjcmlwdGl2ZUxpdGVyYWxzRGVzY3JpcHRpb24KCnw9PT0KfCBFbmFibGVkIGJ5IGRlZmF1bHQgfCBTYWZlIHwgU3VwcG9ydHMgYXV0b2NvcnJlY3Rpb24gfCBWZXJzaW9uIEFkZGVkIHwgVmVyc2lvbiBDaGFuZ2VkCgp8IFBlbmRpbmcKfCBZZXMKfCBObwp8IDIuMjkKfCAtCnw9PT0KCkRlc2NyaXB0aW9uIHNob3VsZCBiZSBkZXNjcmlwdGl2ZS4KCklmIGV4YW1wbGUgZ3JvdXAgb3IgZXhhbXBsZSBjb250YWlucyBvbmx5IGBleGVjdXRlIHN0cmluZ2AsIG51bWJlcnMKYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIHRoZSBkZXNjcmlwdGlvbiBpcyBub3QgY2xlYXIuCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApkZXNjcmliZSBgdGltZWAgZG8KICMgLi4uCmVuZAoKIyBiYWQKY29udGV4dCAvd2hlbiBmb28vIGRvCiAgIyAuLi4KZW5kCgojIGJhZAppdCAxMDAwMCBkbwogICMgLi4uCmVuZAoKIyBnb29kCmRlc2NyaWJlIEZvbyBkbwogICMgLi4uCmVuZAoKIyBnb29kCmRlc2NyaWJlICcjZm9vJyBkbwogICMgLi4uCmVuZAoKIyBnb29kCmNvbnRleHQgIndoZW4gI3tmb299IGlzIGJhciIgZG8KICAjIC4uLgplbmQKCiMgZ29vZAppdCAnZG9lcyBzb21ldGhpbmcnIGRvCiAgIyAuLi4KZW5kCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvVW5kZXNjcmlwdGl2ZUxpdGVyYWxzRGVzY3JpcHRpb24KCj09IFJTcGVjL1Vuc3BlY2lmaWVkRXhjZXB0aW9uCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjMwCnwgLQp8PT09CgpDaGVja3MgZm9yIGEgc3BlY2lmaWVkIGVycm9yIGluIGNoZWNraW5nIHJhaXNlZCBlcnJvcnMuCgpFbmZvcmNlcyBvbmUgb2YgYW4gRXhjZXB0aW9uIHR5cGUsIGEgc3RyaW5nLCBvciBhIHJlZ3VsYXIKZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0IHRoZSBleGNlcHRpb24gbWVzc2FnZSBhcyBhIHBhcmFtZXRlcgp0byBgcmFpc2VfZXJyb3JgCgo9PT0gRXhhbXBsZXMKCltzb3VyY2UscnVieV0KLS0tLQojIGJhZApleHBlY3QgewogIHJhaXNlIFN0YW5kYXJkRXJyb3IubmV3KCdlcnJvcicpCn0udG8gcmFpc2VfZXJyb3IKCiMgZ29vZApleHBlY3QgewogIHJhaXNlIFN0YW5kYXJkRXJyb3IubmV3KCdlcnJvcicpCn0udG8gcmFpc2VfZXJyb3IoU3RhbmRhcmRFcnJvcikKCmV4cGVjdCB7CiAgcmFpc2UgU3RhbmRhcmRFcnJvci5uZXcoJ2Vycm9yJykKfS50byByYWlzZV9lcnJvcignZXJyb3InKQoKZXhwZWN0IHsKICByYWlzZSBTdGFuZGFyZEVycm9yLm5ldygnZXJyb3InKQp9LnRvIHJhaXNlX2Vycm9yKC9lcnIvKQoKZXhwZWN0IHsgZG9fc29tZXRoaW5nIH0ubm90X3RvIHJhaXNlX2Vycm9yCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvVW5zcGVjaWZpZWRFeGNlcHRpb24KCj09IFJTcGVjL1ZhcmlhYmxlRGVmaW5pdGlvbgoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IEFsd2F5cwp8IDEuNDAKfCAtCnw9PT0KCkNoZWNrcyB0aGF0IG1lbW9pemVkIGhlbHBlcnMgbmFtZXMgYXJlIHN5bWJvbHMgb3Igc3RyaW5ncy4KCj09PSBFeGFtcGxlcwoKPT09PSBFbmZvcmNlZFN0eWxlOiBzeW1ib2xzIChkZWZhdWx0KQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnN1YmplY3QoJ3VzZXInKSB7IGNyZWF0ZV91c2VyIH0KbGV0KCd1c2VyX25hbWUnKSB7ICdBZGFtJyB9CgojIGdvb2QKc3ViamVjdCg6dXNlcikgeyBjcmVhdGVfdXNlciB9CmxldCg6dXNlcl9uYW1lKSB7ICdBZGFtJyB9Ci0tLS0KCj09PT0gRW5mb3JjZWRTdHlsZTogc3RyaW5ncwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnN1YmplY3QoOnVzZXIpIHsgY3JlYXRlX3VzZXIgfQpsZXQoOnVzZXJfbmFtZSkgeyAnQWRhbScgfQoKIyBnb29kCnN1YmplY3QoJ3VzZXInKSB7IGNyZWF0ZV91c2VyIH0KbGV0KCd1c2VyX25hbWUnKSB7ICdBZGFtJyB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHN5bWJvbHNgCnwgYHN5bWJvbHNgLCBgc3RyaW5nc2AKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9WYXJpYWJsZURlZmluaXRpb24KCj09IFJTcGVjL1ZhcmlhYmxlTmFtZQoKfD09PQp8IEVuYWJsZWQgYnkgZGVmYXVsdCB8IFNhZmUgfCBTdXBwb3J0cyBhdXRvY29ycmVjdGlvbiB8IFZlcnNpb24gQWRkZWQgfCBWZXJzaW9uIENoYW5nZWQKCnwgRW5hYmxlZAp8IFllcwp8IE5vCnwgMS40MAp8IDIuMTMKfD09PQoKQ2hlY2tzIHRoYXQgbWVtb2l6ZWQgaGVscGVyIG5hbWVzIHVzZSB0aGUgY29uZmlndXJlZCBzdHlsZS4KClZhcmlhYmxlcyBjYW4gYmUgZXhjbHVkZWQgZnJvbSBjaGVja2luZyB1c2luZyB0aGUgYEFsbG93ZWRQYXR0ZXJuc2AKb3B0aW9uLgoKPT09IEV4YW1wbGVzCgo9PT09IEVuZm9yY2VkU3R5bGU6IHNuYWtlX2Nhc2UgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKc3ViamVjdCg6dXNlck5hbWUxKSB7ICdBZGFtJyB9CmxldCg6dXNlck5hbWUyKSB7ICdBZGFtJyB9CgojIGdvb2QKc3ViamVjdCg6dXNlcl9uYW1lXzEpIHsgJ0FkYW0nIH0KbGV0KDp1c2VyX25hbWVfMikgeyAnQWRhbScgfQotLS0tCgo9PT09IEVuZm9yY2VkU3R5bGU6IGNhbWVsQ2FzZQoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCnN1YmplY3QoOnVzZXJfbmFtZV8xKSB7ICdBZGFtJyB9CmxldCg6dXNlcl9uYW1lXzIpIHsgJ0FkYW0nIH0KCiMgZ29vZApzdWJqZWN0KDp1c2VyTmFtZTEpIHsgJ0FkYW0nIH0KbGV0KDp1c2VyTmFtZTIpIHsgJ0FkYW0nIH0KLS0tLQoKPT09PSBBbGxvd2VkUGF0dGVybnMgY29uZmlndXJhdGlvbgoKW3NvdXJjZSxydWJ5XQotLS0tCiMgcnVib2NvcC55bWwKIyBSU3BlYy9WYXJpYWJsZU5hbWU6CiMgICBFbmZvcmNlZFN0eWxlOiBzbmFrZV9jYXNlCiMgICBBbGxvd2VkUGF0dGVybnM6CiMgICAgIC0gXnVzZXJGb29kCi0tLS0KCltzb3VyY2UscnVieV0KLS0tLQojIG9rYXkgYmVjYXVzZSBpdCBtYXRjaGVzIHRoZSBgXnVzZXJGb29kYCByZWdleCBpbiBgQWxsb3dlZFBhdHRlcm5zYApzdWJqZWN0KDp1c2VyRm9vZF8xKSB7ICdzcGFnaGV0dGknIH0KbGV0KDp1c2VyRm9vZF8yKSB7ICdmZXR0dWNjaW5lJyB9Ci0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYHNuYWtlX2Nhc2VgCnwgYHNuYWtlX2Nhc2VgLCBgY2FtZWxDYXNlYAoKfCBBbGxvd2VkUGF0dGVybnMKfCBgW11gCnwgQXJyYXkKfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly93d3cucnVieWRvYy5pbmZvL2dlbXMvcnVib2NvcC1yc3BlYy9SdWJvQ29wL0NvcC9SU3BlYy9WYXJpYWJsZU5hbWUKCj09IFJTcGVjL1ZlcmlmaWVkRG91YmxlUmVmZXJlbmNlCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBQZW5kaW5nCnwgWWVzCnwgQWx3YXlzIChVbnNhZmUpCnwgMi4xMC4wCnwgMi4xMgp8PT09CgpDaGVja3MgZm9yIGNvbnNpc3RlbnQgdmVyaWZpZWQgZG91YmxlIHJlZmVyZW5jZSBzdHlsZS4KCk9ubHkgaW52ZXN0aWdhdGVzIHJlZmVyZW5jZXMgdGhhdCBhcmUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgc3R5bGVzLgoKVGhpcyBjb3AgY2FuIGJlIGNvbmZpZ3VyZWQgaW4geW91ciBjb25maWd1cmF0aW9uIHVzaW5nIHRoZQpgRW5mb3JjZWRTdHlsZWAgb3B0aW9uIGFuZCBzdXBwb3J0cyBgLS1hdXRvLWdlbi1jb25maWdgLgoKPT09IEV4YW1wbGVzCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBjb25zdGFudGAgKGRlZmF1bHQpCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbGV0KDpmb28pIGRvCiAgaW5zdGFuY2VfZG91YmxlKCdDbGFzc05hbWUnLCBtZXRob2RfbmFtZTogJ3JldHVybmVkX3ZhbHVlJykKZW5kCgojIGdvb2QKbGV0KDpmb28pIGRvCiAgaW5zdGFuY2VfZG91YmxlKENsYXNzTmFtZSwgbWV0aG9kX25hbWU6ICdyZXR1cm5lZF92YWx1ZScpCmVuZAotLS0tCgo9PT09IGBFbmZvcmNlZFN0eWxlOiBzdHJpbmdgCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKbGV0KDpmb28pIGRvCiAgaW5zdGFuY2VfZG91YmxlKENsYXNzTmFtZSwgbWV0aG9kX25hbWU6ICdyZXR1cm5lZF92YWx1ZScpCmVuZAoKIyBnb29kCmxldCg6Zm9vKSBkbwogIGluc3RhbmNlX2RvdWJsZSgnQ2xhc3NOYW1lJywgbWV0aG9kX25hbWU6ICdyZXR1cm5lZF92YWx1ZScpCmVuZAotLS0tCgo9PT09IFJlZmVyZW5jZSBpcyBub3QgaW4gdGhlIHN1cHBvcnRlZCBzdHlsZSBsaXN0LiBObyBlbmZvcmNlbWVudAoKW3NvdXJjZSxydWJ5XQotLS0tCiMgZ29vZApsZXQoOmZvbykgZG8KICBpbnN0YW5jZV9kb3VibGUoQGtsYXNzLCBtZXRob2RfbmFtZTogJ3JldHVybmVkX3ZhbHVlJykKZW5kCi0tLS0KCj09PSBDb25maWd1cmFibGUgYXR0cmlidXRlcwoKfD09PQp8IE5hbWUgfCBEZWZhdWx0IHZhbHVlIHwgQ29uZmlndXJhYmxlIHZhbHVlcwoKfCBFbmZvcmNlZFN0eWxlCnwgYGNvbnN0YW50YAp8IGBjb25zdGFudGAsIGBzdHJpbmdgCnw9PT0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvVmVyaWZpZWREb3VibGVSZWZlcmVuY2UKKiBodHRwczovL3JzcGVjLmluZm8vZmVhdHVyZXMvMy0xMi9yc3BlYy1tb2Nrcy92ZXJpZnlpbmctZG91YmxlcwoKPT0gUlNwZWMvVmVyaWZpZWREb3VibGVzCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjIuMQp8IDEuNQp8PT09CgpQcmVmZXIgdXNpbmcgdmVyaWZ5aW5nIGRvdWJsZXMgb3ZlciBub3JtYWwgZG91Ymxlcy4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmxldCg6Zm9vKSBkbwogIGRvdWJsZShtZXRob2RfbmFtZTogJ3JldHVybmVkIHZhbHVlJykKZW5kCgojIGJhZApsZXQoOmZvbykgZG8KICBkb3VibGUoIkNsYXNzTmFtZSIsIG1ldGhvZF9uYW1lOiAncmV0dXJuZWQgdmFsdWUnKQplbmQKCiMgZ29vZApsZXQoOmZvbykgZG8KICBpbnN0YW5jZV9kb3VibGUoIkNsYXNzTmFtZSIsIG1ldGhvZF9uYW1lOiAncmV0dXJuZWQgdmFsdWUnKQplbmQKLS0tLQoKPT09IENvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzCgp8PT09CnwgTmFtZSB8IERlZmF1bHQgdmFsdWUgfCBDb25maWd1cmFibGUgdmFsdWVzCgp8IElnbm9yZU5hbWVsZXNzCnwgYHRydWVgCnwgQm9vbGVhbgoKfCBJZ25vcmVTeW1ib2xpY05hbWVzCnwgYGZhbHNlYAp8IEJvb2xlYW4KfD09PQoKPT09IFJlZmVyZW5jZXMKCiogaHR0cHM6Ly9yc3BlYy5ydWJ5c3R5bGUuZ3VpZGUvI2RvdWJsZXMKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1ZlcmlmaWVkRG91YmxlcwoqIGh0dHBzOi8vcnNwZWMuaW5mby9mZWF0dXJlcy8zLTEyL3JzcGVjLW1vY2tzL3ZlcmlmeWluZy1kb3VibGVzCgo9PSBSU3BlYy9Wb2lkRXhwZWN0Cgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgTm8KfCAxLjE2CnwgLQp8PT09CgpDaGVja3Mgdm9pZCBgZXhwZWN0KClgLgoKPT09IEV4YW1wbGVzCgpbc291cmNlLHJ1YnldCi0tLS0KIyBiYWQKZXhwZWN0KHNvbWV0aGluZykKCiMgZ29vZApleHBlY3Qoc29tZXRoaW5nKS50byBiZSgxKQotLS0tCgo9PT0gUmVmZXJlbmNlcwoKKiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9ydWJvY29wLXJzcGVjL1J1Ym9Db3AvQ29wL1JTcGVjL1ZvaWRFeHBlY3QKCj09IFJTcGVjL1lpZWxkCgp8PT09CnwgRW5hYmxlZCBieSBkZWZhdWx0IHwgU2FmZSB8IFN1cHBvcnRzIGF1dG9jb3JyZWN0aW9uIHwgVmVyc2lvbiBBZGRlZCB8IFZlcnNpb24gQ2hhbmdlZAoKfCBFbmFibGVkCnwgWWVzCnwgQWx3YXlzCnwgMS4zMgp8IC0KfD09PQoKQ2hlY2tzIGZvciBjYWxsaW5nIGEgYmxvY2sgd2l0aGluIGEgc3R1Yi4KCj09PSBFeGFtcGxlcwoKW3NvdXJjZSxydWJ5XQotLS0tCiMgYmFkCmFsbG93KGZvbykudG8gcmVjZWl2ZSg6YmFyKSB7IHwmYmxvY2t8IGJsb2NrLmNhbGwoMSkgfQoKIyBnb29kCmV4cGVjdChmb28pLnRvIHJlY2VpdmUoOmJhcikuYW5kX3lpZWxkKDEpCi0tLS0KCj09PSBSZWZlcmVuY2VzCgoqIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3J1Ym9jb3AtcnNwZWMvUnVib0NvcC9Db3AvUlNwZWMvWWllbGQK
  recorded_at: Mon, 27 May 2024 05:30:46 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/docs/modules/ROOT/pages/cops_rspec/capybara.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 404
      message: Not Found
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '14'
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      Content-Type:
      - text/plain; charset=utf-8
      X-Github-Request-Id:
      - 2FD0:6D2AE:1313BCC:144BFE2:66541A85
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:46 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230042-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787846.212046,VS0,VE164
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - 319b5f7f933025ee06b50608678ee72bf0139aab
      Expires:
      - Mon, 27 May 2024 05:35:46 GMT
      Source-Age:
      - '0'
    body:
      encoding: UTF-8
      string: '404: Not Found'
  recorded_at: Mon, 27 May 2024 05:30:46 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/docs/modules/ROOT/pages/cops_rspec/factorybot.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 404
      message: Not Found
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '14'
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      Content-Type:
      - text/plain; charset=utf-8
      X-Github-Request-Id:
      - A822:19D255:9DDCBD:A83F07:66541A85
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:46 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230030-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787847.544777,VS0,VE161
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - d19cd354383b0732e8398406750e11390356b700
      Expires:
      - Mon, 27 May 2024 05:35:46 GMT
      Source-Age:
      - '0'
    body:
      encoding: UTF-8
      string: '404: Not Found'
  recorded_at: Mon, 27 May 2024 05:30:46 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/docs/modules/ROOT/pages/cops_rspec/rails.adoc
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 404
      message: Not Found
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '14'
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      Content-Type:
      - text/plain; charset=utf-8
      X-Github-Request-Id:
      - A350:82772:135A093:149254D:66541A86
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:47 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230091-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787847.846925,VS0,VE161
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - e2fb9b5d7b5ebb975e7a017699b0fdbef147fde2
      Expires:
      - Mon, 27 May 2024 05:35:47 GMT
      Source-Age:
      - '0'
    body:
      encoding: UTF-8
      string: '404: Not Found'
  recorded_at: Mon, 27 May 2024 05:30:47 GMT
- request:
    method: get
    uri: https://raw.githubusercontent.com/rubocop/rubocop-rspec/v2.29.2/config/default.yml
    body:
      encoding: US-ASCII
      string: ''
    headers:
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
      Host:
      - raw.githubusercontent.com
  response:
    status:
      code: 200
      message: OK
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '39288'
      Cache-Control:
      - max-age=300
      Content-Security-Policy:
      - default-src 'none'; style-src 'unsafe-inline'; sandbox
      Content-Type:
      - text/plain; charset=utf-8
      Etag:
      - W/"6675eb230d293485fd9cad3012b3405e4d16f37b3bfef8825c6719f8800eb85e"
      Strict-Transport-Security:
      - max-age=31536000
      X-Content-Type-Options:
      - nosniff
      X-Frame-Options:
      - deny
      X-Xss-Protection:
      - 1; mode=block
      X-Github-Request-Id:
      - 3A3E:12DE69:31D941:3595F2:66541A87
      Accept-Ranges:
      - bytes
      Date:
      - Mon, 27 May 2024 05:30:47 GMT
      Via:
      - 1.1 varnish
      X-Served-By:
      - cache-fra-eddf8230113-FRA
      X-Cache:
      - MISS
      X-Cache-Hits:
      - '0'
      X-Timer:
      - S1716787847.154662,VS0,VE161
      Vary:
      - Authorization,Accept-Encoding,Origin
      Access-Control-Allow-Origin:
      - "*"
      Cross-Origin-Resource-Policy:
      - cross-origin
      X-Fastly-Request-Id:
      - c9bdcfb76e88779af57bc176f6a8a61aed071e53
      Expires:
      - Mon, 27 May 2024 05:35:47 GMT
      Source-Age:
      - '0'
    body:
      encoding: ASCII-8BIT
      string: |
        ---
        RSpec:
          Enabled: true
          StyleGuideBaseURL: https://rspec.rubystyle.guide
          DocumentationBaseURL: https://docs.rubocop.org/rubocop-rspec
          Include: &1
            - "**/*_spec.rb"
            - "**/spec/**/*"
          Language: &2
            inherit_mode:
              merge:
                - Expectations
                - Helpers
                - Hooks
                - Subjects
            ExampleGroups:
              inherit_mode:
                merge:
                  - Regular
                  - Skipped
                  - Focused
              Regular:
                - describe
                - context
                - feature
                - example_group
              Skipped:
                - xdescribe
                - xcontext
                - xfeature
              Focused:
                - fdescribe
                - fcontext
                - ffeature
            Examples:
              inherit_mode:
                merge:
                  - Regular
                  - Skipped
                  - Focused
                  - Pending
              Regular:
                - it
                - specify
                - example
                - scenario
                - its
              Focused:
                - fit
                - fspecify
                - fexample
                - fscenario
                - focus
              Skipped:
                - xit
                - xspecify
                - xexample
                - xscenario
                - skip
              Pending:
                - pending
            Expectations:
              - are_expected
              - expect
              - expect_any_instance_of
              - is_expected
              - should
              - should_not
              - should_not_receive
              - should_receive
            Helpers:
              - let
              - let!
            Hooks:
              - prepend_before
              - before
              - append_before
              - around
              - prepend_after
              - after
              - append_after
            Includes:
              inherit_mode:
                merge:
                  - Examples
                  - Context
              Examples:
                - it_behaves_like
                - it_should_behave_like
                - include_examples
              Context:
                - include_context
            SharedGroups:
              inherit_mode:
                merge:
                  - Examples
                  - Context
              Examples:
                - shared_examples
                - shared_examples_for
              Context:
                - shared_context
            Subjects:
              - subject
              - subject!

        Metrics/BlockLength:
          inherit_mode:
            merge:
              - Exclude
          Exclude:
            - "**/*_spec.rb"
            - "**/spec/**/*"

        RSpec/AlignLeftLetBrace:
          Description: Checks that left braces for adjacent single line lets are aligned.
          Enabled: false
          VersionAdded: '1.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AlignLeftLetBrace

        RSpec/AlignRightLetBrace:
          Description: Checks that right braces for adjacent single line lets are aligned.
          Enabled: false
          VersionAdded: '1.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AlignRightLetBrace

        RSpec/AnyInstance:
          Description: Check that instances are not being stubbed globally.
          Enabled: true
          VersionAdded: '1.4'
          StyleGuide: https://rspec.rubystyle.guide/#any_instance_of
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AnyInstance

        RSpec/AroundBlock:
          Description: Checks that around blocks actually run the test.
          Enabled: true
          VersionAdded: '1.11'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/AroundBlock

        RSpec/Be:
          Description: Check for expectations where `be` is used without argument.
          Enabled: true
          VersionAdded: '1.25'
          StyleGuide: https://rspec.rubystyle.guide/#be-matcher
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Be

        RSpec/BeEmpty:
          Description: Prefer using `be_empty` when checking for an empty array.
          Enabled: pending
          VersionAdded: '2.20'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEmpty

        RSpec/BeEq:
          Description: Check for expectations where `be(...)` can replace `eq(...)`.
          Enabled: pending
          Safe: false
          VersionAdded: 2.9.0
          VersionChanged: '2.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEq

        RSpec/BeEql:
          Description: Check for expectations where `be(...)` can replace `eql(...)`.
          Enabled: true
          Safe: false
          VersionAdded: '1.7'
          VersionChanged: '2.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeEql

        RSpec/BeNil:
          Description: Ensures a consistent style is used when matching `nil`.
          Enabled: pending
          EnforcedStyle: be_nil
          SupportedStyles:
            - be
            - be_nil
          VersionAdded: 2.9.0
          VersionChanged: 2.10.0
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeNil

        RSpec/BeforeAfterAll:
          Description: Check that before/after(:all/:context) isn't being used.
          Enabled: true
          Exclude:
            - "**/spec/spec_helper.rb"
            - "**/spec/rails_helper.rb"
            - "**/spec/support/**/*.rb"
          VersionAdded: '1.12'
          VersionChanged: '2.23'
          StyleGuide: https://rspec.rubystyle.guide/#avoid-hooks-with-context-scope
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/BeforeAfterAll

        RSpec/ChangeByZero:
          Description: Prefer negated matchers over `to change.by(0)`.
          Enabled: pending
          VersionAdded: '2.11'
          VersionChanged: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ChangeByZero
          NegatedMatcher: ~

        RSpec/ClassCheck:
          Description: Enforces consistent use of `be_a` or `be_kind_of`.
          StyleGuide: "#is-a-vs-kind-of"
          Enabled: pending
          VersionAdded: '2.13'
          EnforcedStyle: be_a
          SupportedStyles:
            - be_a
            - be_kind_of
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ClassCheck

        RSpec/ContainExactly:
          Description: Checks where `contain_exactly` is used.
          Enabled: pending
          VersionAdded: '2.19'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContainExactly

        RSpec/ContextMethod:
          Description: "`context` should not be used for specifying methods."
          Enabled: true
          VersionAdded: '1.36'
          StyleGuide: https://rspec.rubystyle.guide/#example-group-naming
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContextMethod

        RSpec/ContextWording:
          Description: Checks that `context` docstring starts with an allowed prefix.
          Enabled: true
          Prefixes:
            - when
            - with
            - without
          AllowedPatterns: []
          VersionAdded: '1.20'
          VersionChanged: '2.13'
          StyleGuide: https://rspec.rubystyle.guide/#context-descriptions
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ContextWording

        RSpec/DescribeClass:
          Description: Check that the first argument to the top-level describe is a constant.
          Enabled: true
          Exclude:
            - "**/spec/features/**/*"
            - "**/spec/requests/**/*"
            - "**/spec/routing/**/*"
            - "**/spec/system/**/*"
            - "**/spec/views/**/*"
          IgnoredMetadata:
            type:
              - channel
              - controller
              - helper
              - job
              - mailer
              - model
              - request
              - routing
              - view
              - feature
              - system
              - mailbox
              - aruba
              - task
          VersionAdded: '1.0'
          VersionChanged: '2.7'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeClass

        RSpec/DescribeMethod:
          Description: Checks that the second argument to `describe` specifies a method.
          Enabled: true
          VersionAdded: '1.0'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeMethod

        RSpec/DescribeSymbol:
          Description: Avoid describing symbols.
          Enabled: true
          VersionAdded: '1.15'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribeSymbol

        RSpec/DescribedClass:
          Description: Checks that tests use `described_class`.
          Enabled: true
          SkipBlocks: false
          EnforcedStyle: described_class
          SupportedStyles:
            - described_class
            - explicit
          OnlyStaticConstants: true
          SafeAutoCorrect: false
          VersionAdded: '1.0'
          VersionChanged: '2.27'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribedClass

        RSpec/DescribedClassModuleWrapping:
          Description: Avoid opening modules and defining specs within them.
          Enabled: false
          VersionAdded: '1.37'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribedClassModuleWrapping

        RSpec/Dialect:
          Description: Enforces custom RSpec dialects.
          Enabled: false
          PreferredMethods: {}
          VersionAdded: '1.33'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Dialect

        RSpec/DuplicatedMetadata:
          Description: Avoid duplicated metadata.
          Enabled: pending
          VersionAdded: '2.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DuplicatedMetadata

        RSpec/EmptyExampleGroup:
          Description: Checks if an example group does not include any tests.
          Enabled: true
          SafeAutoCorrect: false
          VersionAdded: '1.7'
          VersionChanged: '2.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyExampleGroup

        RSpec/EmptyHook:
          Description: Checks for empty before and after hooks.
          Enabled: true
          VersionAdded: '1.39'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyHook

        RSpec/EmptyLineAfterExample:
          Description: Checks if there is an empty line after example blocks.
          Enabled: true
          AllowConsecutiveOneLiners: true
          VersionAdded: '1.36'
          StyleGuide: https://rspec.rubystyle.guide/#empty-lines-around-examples
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterExample

        RSpec/EmptyLineAfterExampleGroup:
          Description: Checks if there is an empty line after example group blocks.
          Enabled: true
          VersionAdded: '1.27'
          StyleGuide: https://rspec.rubystyle.guide/#empty-lines-between-describes
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterExampleGroup

        RSpec/EmptyLineAfterFinalLet:
          Description: Checks if there is an empty line after the last let block.
          Enabled: true
          VersionAdded: '1.14'
          StyleGuide: https://rspec.rubystyle.guide/#empty-line-after-let
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterFinalLet

        RSpec/EmptyLineAfterHook:
          Description: Checks if there is an empty line after hook blocks.
          Enabled: true
          VersionAdded: '1.27'
          VersionChanged: '2.13'
          StyleGuide: https://rspec.rubystyle.guide/#empty-line-after-let
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterHook
          AllowConsecutiveOneLiners: true

        RSpec/EmptyLineAfterSubject:
          Description: Checks if there is an empty line after subject block.
          Enabled: true
          VersionAdded: '1.14'
          StyleGuide: https://rspec.rubystyle.guide/#empty-line-after-let
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyLineAfterSubject

        RSpec/EmptyMetadata:
          Description: Avoid empty metadata hash.
          Enabled: pending
          VersionAdded: '2.24'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyMetadata

        RSpec/EmptyOutput:
          Description: Check that the `output` matcher is not called with an empty string.
          Enabled: pending
          VersionAdded: '2.29'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/EmptyOutput

        RSpec/Eq:
          Description: Use `eq` instead of `be ==` to compare objects.
          Enabled: pending
          VersionAdded: '2.24'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Eq

        RSpec/ExampleLength:
          Description: Checks for long examples.
          Enabled: true
          Max: 5
          CountAsOne: []
          VersionAdded: '1.5'
          VersionChanged: '2.3'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleLength

        RSpec/ExampleWithoutDescription:
          Description: Checks for examples without a description.
          Enabled: true
          EnforcedStyle: always_allow
          SupportedStyles:
            - always_allow
            - single_line_only
            - disallow
          VersionAdded: '1.22'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleWithoutDescription

        RSpec/ExampleWording:
          Description: Checks for common mistakes in example descriptions.
          Enabled: true
          CustomTransform:
            be: is
            BE: IS
            have: has
            HAVE: HAS
          IgnoredWords: []
          DisallowedExamples:
            - works
          VersionAdded: '1.0'
          VersionChanged: '2.13'
          StyleGuide: https://rspec.rubystyle.guide/#should-in-example-docstrings
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExampleWording

        RSpec/ExcessiveDocstringSpacing:
          Description: Checks for excessive whitespace in example descriptions.
          Enabled: pending
          VersionAdded: '2.5'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExcessiveDocstringSpacing

        RSpec/ExpectActual:
          Description: Checks for `expect(...)` calls containing literal values.
          Enabled: true
          Exclude:
            - "**/spec/routing/**/*"
          VersionAdded: '1.7'
          VersionChanged: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectActual

        RSpec/ExpectChange:
          Description: Checks for consistent style of change matcher.
          Enabled: true
          EnforcedStyle: method_call
          SupportedStyles:
            - method_call
            - block
          SafeAutoCorrect: false
          VersionAdded: '1.22'
          VersionChanged: '2.5'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectChange

        RSpec/ExpectInHook:
          Description: Do not use `expect` in hooks such as `before`.
          Enabled: true
          VersionAdded: '1.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectInHook

        RSpec/ExpectOutput:
          Description: Checks for opportunities to use `expect { ... }.to output`.
          Enabled: true
          VersionAdded: '1.10'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ExpectOutput

        RSpec/FilePath:
          Description: Checks that spec file paths are consistent and well-formed.
          Enabled: true
          Include:
            - "**/*_spec*rb*"
            - "**/spec/**/*"
          CustomTransform:
            RuboCop: rubocop
            RSpec: rspec
          IgnoreMethods: false
          SpecSuffixOnly: false
          VersionAdded: '1.2'
          VersionChanged: '2.24'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FilePath

        RSpec/Focus:
          Description: Checks if examples are focused.
          Enabled: true
          VersionAdded: '1.5'
          VersionChanged: '2.1'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Focus

        RSpec/HookArgument:
          Description: Checks the arguments passed to `before`, `around`, and `after`.
          Enabled: true
          EnforcedStyle: implicit
          SupportedStyles:
            - implicit
            - each
            - example
          VersionAdded: '1.7'
          StyleGuide: https://rspec.rubystyle.guide/#redundant-beforeeach
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/HookArgument

        RSpec/HooksBeforeExamples:
          Description: Checks for before/around/after hooks that come after an example.
          Enabled: true
          VersionAdded: '1.29'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/HooksBeforeExamples

        RSpec/IdenticalEqualityAssertion:
          Description: Checks for equality assertions with identical expressions on both sides.
          Enabled: pending
          VersionAdded: '2.4'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IdenticalEqualityAssertion

        RSpec/ImplicitBlockExpectation:
          Description: Check that implicit block expectation syntax is not used.
          Enabled: true
          VersionAdded: '1.35'
          StyleGuide: https://rspec.rubystyle.guide/#implicit-block-expectations
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitBlockExpectation

        RSpec/ImplicitExpect:
          Description: Check that a consistent implicit expectation style is used.
          Enabled: true
          EnforcedStyle: is_expected
          SupportedStyles:
            - is_expected
            - should
          VersionAdded: '1.8'
          StyleGuide: https://rspec.rubystyle.guide/#use-expect
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitExpect

        RSpec/ImplicitSubject:
          Description: Checks for usage of implicit subject (`is_expected` / `should`).
          Enabled: true
          EnforcedStyle: single_line_only
          SupportedStyles:
            - single_line_only
            - single_statement_only
            - disallow
            - require_implicit
          VersionAdded: '1.29'
          VersionChanged: '2.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ImplicitSubject

        RSpec/IndexedLet:
          Description: Do not set up test data using indexes (e.g., `item_1`, `item_2`).
          Enabled: pending
          VersionAdded: '2.20'
          VersionChanged: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IndexedLet
          Max: 1
          AllowedIdentifiers: []
          AllowedPatterns: []

        RSpec/InstanceSpy:
          Description: Checks for `instance_double` used with `have_received`.
          Enabled: true
          VersionAdded: '1.12'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/InstanceSpy

        RSpec/InstanceVariable:
          Description: Checks for instance variable usage in specs.
          Enabled: true
          AssignmentOnly: false
          VersionAdded: '1.0'
          VersionChanged: '1.7'
          StyleGuide: https://rspec.rubystyle.guide/#instance-variables
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/InstanceVariable

        RSpec/IsExpectedSpecify:
          Description: Check for `specify` with `is_expected` and one-liner expectations.
          Enabled: pending
          VersionAdded: '2.27'
          StyleGuide: https://rspec.rubystyle.guide/#it-and-specify
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IsExpectedSpecify

        RSpec/ItBehavesLike:
          Description: Checks that only one `it_behaves_like` style is used.
          Enabled: true
          EnforcedStyle: it_behaves_like
          SupportedStyles:
            - it_behaves_like
            - it_should_behave_like
          VersionAdded: '1.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ItBehavesLike

        RSpec/IteratedExpectation:
          Description: Check that `all` matcher is used instead of iterating over an array.
          Enabled: true
          VersionAdded: '1.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/IteratedExpectation

        RSpec/LeadingSubject:
          Description: Enforce that subject is the first definition in the test.
          Enabled: true
          VersionAdded: '1.7'
          VersionChanged: '1.14'
          StyleGuide: https://rspec.rubystyle.guide/#leading-subject
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LeadingSubject

        RSpec/LeakyConstantDeclaration:
          Description: Checks that no class, module, or constant is declared.
          Enabled: true
          VersionAdded: '1.35'
          StyleGuide: https://rspec.rubystyle.guide/#declare-constants
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LeakyConstantDeclaration

        RSpec/LetBeforeExamples:
          Description: Checks for `let` definitions that come after an example.
          Enabled: true
          VersionAdded: '1.16'
          VersionChanged: '1.22'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LetBeforeExamples

        RSpec/LetSetup:
          Description: Checks unreferenced `let!` calls being used for test setup.
          Enabled: true
          VersionAdded: '1.7'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/LetSetup

        RSpec/MatchArray:
          Description: Checks where `match_array` is used.
          Enabled: pending
          VersionAdded: '2.19'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MatchArray

        RSpec/MessageChain:
          Description: Check that chains of messages are not being stubbed.
          Enabled: true
          VersionAdded: '1.7'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageChain

        RSpec/MessageExpectation:
          Description: Checks for consistent message expectation style.
          Enabled: false
          EnforcedStyle: allow
          SupportedStyles:
            - allow
            - expect
          VersionAdded: '1.7'
          VersionChanged: '1.8'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageExpectation

        RSpec/MessageSpies:
          Description: Checks that message expectations are set using spies.
          Enabled: true
          EnforcedStyle: have_received
          SupportedStyles:
            - have_received
            - receive
          VersionAdded: '1.9'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MessageSpies

        RSpec/MetadataStyle:
          Description: Use consistent metadata style.
          Enabled: pending
          EnforcedStyle: symbol
          SupportedStyles:
            - hash
            - symbol
          VersionAdded: '2.24'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MetadataStyle

        RSpec/MissingExampleGroupArgument:
          Description: Checks that the first argument to an example group is not empty.
          Enabled: true
          VersionAdded: '1.28'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MissingExampleGroupArgument

        RSpec/MultipleDescribes:
          Description: Checks for multiple top-level example groups.
          Enabled: true
          VersionAdded: '1.0'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleDescribes

        RSpec/MultipleExpectations:
          Description: Checks if examples contain too many `expect` calls.
          Enabled: true
          Max: 1
          VersionAdded: '1.7'
          VersionChanged: '1.21'
          StyleGuide: https://rspec.rubystyle.guide/#expectation-per-example
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleExpectations

        RSpec/MultipleMemoizedHelpers:
          Description: Checks if example groups contain too many `let` and `subject` calls.
          Enabled: true
          AllowSubject: true
          Max: 5
          VersionAdded: '1.43'
          StyleGuide: https://rspec.rubystyle.guide/#let-blocks
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleMemoizedHelpers

        RSpec/MultipleSubjects:
          Description: Checks if an example group defines `subject` multiple times.
          Enabled: true
          VersionAdded: '1.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/MultipleSubjects

        RSpec/NamedSubject:
          Description: Checks for explicitly referenced test subjects.
          Enabled: true
          EnforcedStyle: always
          SupportedStyles:
            - always
            - named_only
          IgnoreSharedExamples: true
          VersionAdded: 1.5.3
          VersionChanged: '2.15'
          StyleGuide: https://rspec.rubystyle.guide/#use-subject
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NamedSubject

        RSpec/NestedGroups:
          Description: Checks for nested example groups.
          Enabled: true
          Max: 3
          AllowedGroups: []
          VersionAdded: '1.7'
          VersionChanged: '2.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NestedGroups

        RSpec/NoExpectationExample:
          Description: Checks if an example contains any expectation.
          Enabled: pending
          Safe: false
          VersionAdded: '2.13'
          VersionChanged: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NoExpectationExample
          AllowedPatterns:
            - "^expect_"
            - "^assert_"

        RSpec/NotToNot:
          Description: Checks for consistent method usage for negating expectations.
          Enabled: true
          EnforcedStyle: not_to
          SupportedStyles:
            - not_to
            - to_not
          VersionAdded: '1.4'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/NotToNot

        RSpec/OverwritingSetup:
          Description: Checks if there is a let/subject that overwrites an existing one.
          Enabled: true
          VersionAdded: '1.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/OverwritingSetup

        RSpec/Pending:
          Description: Checks for any pending or skipped examples.
          Enabled: false
          VersionAdded: '1.25'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Pending

        RSpec/PendingWithoutReason:
          Description: Checks for pending or skipped examples without reason.
          Enabled: pending
          VersionAdded: '2.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/PendingWithoutReason

        RSpec/PredicateMatcher:
          Description: Prefer using predicate matcher over using predicate method directly.
          Enabled: true
          Strict: true
          EnforcedStyle: inflected
          AllowedExplicitMatchers: []
          SupportedStyles:
            - inflected
            - explicit
          SafeAutoCorrect: false
          VersionAdded: '1.16'
          StyleGuide: https://rspec.rubystyle.guide/#predicate-matchers
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/PredicateMatcher

        RSpec/ReceiveCounts:
          Description: Check for `once` and `twice` receive counts matchers usage.
          Enabled: true
          VersionAdded: '1.26'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveCounts

        RSpec/ReceiveMessages:
          Description: Checks for multiple messages stubbed on the same object.
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveMessages

        RSpec/ReceiveNever:
          Description: Prefer `not_to receive(...)` over `receive(...).never`.
          Enabled: true
          VersionAdded: '1.28'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReceiveNever

        RSpec/RedundantAround:
          Description: Remove redundant `around` hook.
          Enabled: pending
          VersionAdded: '2.19'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RedundantAround

        RSpec/RedundantPredicateMatcher:
          Description: Checks for redundant predicate matcher.
          Enabled: pending
          VersionAdded: '2.26'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RedundantPredicateMatcher

        RSpec/RemoveConst:
          Description: Checks that `remove_const` is not used in specs.
          Enabled: pending
          VersionAdded: '2.26'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RemoveConst

        RSpec/RepeatedDescription:
          Description: Check for repeated description strings in example groups.
          Enabled: true
          VersionAdded: '1.9'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedDescription

        RSpec/RepeatedExample:
          Description: Check for repeated examples within example groups.
          Enabled: true
          VersionAdded: '1.10'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExample

        RSpec/RepeatedExampleGroupBody:
          Description: Check for repeated describe and context block body.
          Enabled: true
          VersionAdded: '1.38'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExampleGroupBody

        RSpec/RepeatedExampleGroupDescription:
          Description: Check for repeated example group descriptions.
          Enabled: true
          VersionAdded: '1.38'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedExampleGroupDescription

        RSpec/RepeatedIncludeExample:
          Description: Check for repeated include of shared examples.
          Enabled: true
          VersionAdded: '1.44'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedIncludeExample

        RSpec/RepeatedSubjectCall:
          Description: Checks for repeated calls to subject missing that it is memoized.
          Enabled: pending
          VersionAdded: '2.27'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/RepeatedSubjectCall

        RSpec/ReturnFromStub:
          Description: Checks for consistent style of stub's return setting.
          Enabled: true
          EnforcedStyle: and_return
          SupportedStyles:
            - and_return
            - block
          VersionAdded: '1.16'
          VersionChanged: '1.22'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ReturnFromStub

        RSpec/ScatteredLet:
          Description: Checks for let scattered across the example group.
          Enabled: true
          VersionAdded: '1.14'
          VersionChanged: '1.39'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ScatteredLet

        RSpec/ScatteredSetup:
          Description: Checks for setup scattered across multiple hooks in an example group.
          Enabled: true
          VersionAdded: '1.10'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/ScatteredSetup

        RSpec/SharedContext:
          Description: Checks for proper shared_context and shared_examples usage.
          Enabled: true
          VersionAdded: '1.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SharedContext

        RSpec/SharedExamples:
          Description: Checks for consistent style for shared example names.
          Enabled: true
          EnforcedStyle: string
          SupportedStyles:
            - string
            - symbol
          VersionAdded: '1.25'
          VersionChanged: '2.26'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SharedExamples

        RSpec/SingleArgumentMessageChain:
          Description: Checks that chains of messages contain more than one element.
          Enabled: true
          VersionAdded: '1.9'
          VersionChanged: '1.10'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SingleArgumentMessageChain

        RSpec/SkipBlockInsideExample:
          Description: Checks for passing a block to `skip` within examples.
          Enabled: pending
          VersionAdded: '2.19'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SkipBlockInsideExample

        RSpec/SortMetadata:
          Description: Sort RSpec metadata alphabetically.
          Enabled: pending
          VersionAdded: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SortMetadata

        RSpec/SpecFilePathFormat:
          Description: Checks that spec file paths are consistent and well-formed.
          Enabled: pending
          Include:
            - "**/*_spec.rb"
          Exclude:
            - "**/spec/routing/**/*"
          CustomTransform:
            RuboCop: rubocop
            RSpec: rspec
          IgnoreMethods: false
          IgnoreMetadata:
            type: routing
          VersionAdded: '2.24'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SpecFilePathFormat

        RSpec/SpecFilePathSuffix:
          Description: Checks that spec file paths suffix are consistent and well-formed.
          Enabled: pending
          VersionAdded: '2.24'
          Include:
            - "**/*_spec*rb*"
            - "**/spec/**/*"
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SpecFilePathSuffix

        RSpec/StubbedMock:
          Description: Checks that message expectations do not have a configured response.
          Enabled: true
          VersionAdded: '1.44'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/StubbedMock

        RSpec/SubjectDeclaration:
          Description: Ensure that subject is defined using subject helper.
          Enabled: pending
          VersionAdded: '2.5'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SubjectDeclaration

        RSpec/SubjectStub:
          Description: Checks for stubbed test subjects.
          Enabled: true
          VersionAdded: '1.7'
          VersionChanged: '2.8'
          StyleGuide: https://rspec.rubystyle.guide/#dont-stub-subject
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/SubjectStub

        RSpec/UndescriptiveLiteralsDescription:
          Description: Description should be descriptive.
          Enabled: pending
          VersionAdded: '2.29'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/UndescriptiveLiteralsDescription

        RSpec/UnspecifiedException:
          Description: Checks for a specified error in checking raised errors.
          Enabled: true
          VersionAdded: '1.30'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/UnspecifiedException

        RSpec/VariableDefinition:
          Description: Checks that memoized helpers names are symbols or strings.
          Enabled: true
          EnforcedStyle: symbols
          SupportedStyles:
            - symbols
            - strings
          VersionAdded: '1.40'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VariableDefinition

        RSpec/VariableName:
          Description: Checks that memoized helper names use the configured style.
          Enabled: true
          EnforcedStyle: snake_case
          SupportedStyles:
            - snake_case
            - camelCase
          AllowedPatterns: []
          VersionAdded: '1.40'
          VersionChanged: '2.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VariableName

        RSpec/VerifiedDoubleReference:
          Description: Checks for consistent verified double reference style.
          Enabled: pending
          SafeAutoCorrect: false
          EnforcedStyle: constant
          SupportedStyles:
            - constant
            - string
          VersionAdded: 2.10.0
          VersionChanged: '2.12'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VerifiedDoubleReference

        RSpec/VerifiedDoubles:
          Description: Prefer using verifying doubles over normal doubles.
          Enabled: true
          IgnoreNameless: true
          IgnoreSymbolicNames: false
          VersionAdded: 1.2.1
          VersionChanged: '1.5'
          StyleGuide: https://rspec.rubystyle.guide/#doubles
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VerifiedDoubles

        RSpec/VoidExpect:
          Description: Checks void `expect()`.
          Enabled: true
          VersionAdded: '1.16'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/VoidExpect

        RSpec/Yield:
          Description: Checks for calling a block within a stub.
          Enabled: true
          VersionAdded: '1.32'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Yield

        RSpec/Capybara:
          Enabled: true
          Include: *1
          Language: *2

        RSpec/Capybara/CurrentPathExpectation:
          Description: Checks that no expectations are set on Capybara's `current_path`.
          Enabled: true
          VersionAdded: '1.18'
          VersionChanged: '2.0'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/CurrentPathExpectation

        RSpec/Capybara/FeatureMethods:
          Description: Checks for consistent method usage in feature specs.
          Enabled: true
          EnabledMethods: []
          VersionAdded: '1.17'
          VersionChanged: '2.0'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/FeatureMethods

        RSpec/Capybara/MatchStyle:
          Description: Checks for usage of deprecated style methods.
          Enabled: pending
          VersionAdded: '2.17'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/MatchStyle

        RSpec/Capybara/NegationMatcher:
          Description: Enforces use of `have_no_*` or `not_to` for negated expectations.
          Enabled: pending
          VersionAdded: '2.14'
          EnforcedStyle: not_to
          SupportedStyles:
            - have_no
            - not_to
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/NegationMatcher

        RSpec/Capybara/SpecificActions:
          Description: Checks for there is a more specific actions offered by Capybara.
          Enabled: pending
          VersionAdded: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/SpecificActions

        RSpec/Capybara/SpecificFinders:
          Description: Checks if there is a more specific finder offered by Capybara.
          Enabled: pending
          VersionAdded: '2.13'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/SpecificFinders

        RSpec/Capybara/SpecificMatcher:
          Description: Checks for there is a more specific matcher offered by Capybara.
          Enabled: pending
          VersionAdded: '2.12'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/SpecificMatcher

        RSpec/Capybara/VisibilityMatcher:
          Description: Checks for boolean visibility in Capybara finders.
          Enabled: true
          VersionAdded: '1.39'
          VersionChanged: '2.0'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Capybara/VisibilityMatcher

        RSpec/FactoryBot:
          Enabled: true
          Include: *1
          Language: *2

        RSpec/FactoryBot/AttributeDefinedStatically:
          Description: Always declare attribute values as blocks.
          Enabled: true
          Include:
            - "**/spec/factories.rb"
            - "**/spec/factories/**/*.rb"
            - "**/features/support/factories/**/*.rb"
          VersionAdded: '1.28'
          VersionChanged: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/AttributeDefinedStatically

        RSpec/FactoryBot/ConsistentParenthesesStyle:
          Description: Use a consistent style for parentheses in factory bot calls.
          Enabled: pending
          EnforcedStyle: require_parentheses
          SupportedStyles:
            - require_parentheses
            - omit_parentheses
          VersionAdded: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/ConsistentParenthesesStyle

        RSpec/FactoryBot/CreateList:
          Description: Checks for create_list usage.
          Enabled: true
          Include:
            - "**/*_spec.rb"
            - "**/spec/**/*"
            - "**/spec/factories.rb"
            - "**/spec/factories/**/*.rb"
            - "**/features/support/factories/**/*.rb"
          EnforcedStyle: create_list
          SupportedStyles:
            - create_list
            - n_times
          VersionAdded: '1.25'
          VersionChanged: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/CreateList

        RSpec/FactoryBot/FactoryClassName:
          Description: Use string value when setting the class attribute explicitly.
          Enabled: true
          Include:
            - "**/spec/factories.rb"
            - "**/spec/factories/**/*.rb"
            - "**/features/support/factories/**/*.rb"
          VersionAdded: '1.37'
          VersionChanged: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/FactoryClassName

        RSpec/FactoryBot/FactoryNameStyle:
          Description: Checks for name style for argument of FactoryBot::Syntax::Methods.
          Enabled: pending
          VersionAdded: '2.16'
          EnforcedStyle: symbol
          SupportedStyles:
            - symbol
            - string
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/FactoryNameStyle

        RSpec/FactoryBot/SyntaxMethods:
          Description: Use shorthands from `FactoryBot::Syntax::Methods` in your specs.
          Enabled: pending
          SafeAutoCorrect: false
          VersionAdded: '2.7'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/FactoryBot/SyntaxMethods

        RSpec/Rails:
          Enabled: true
          Include: *1
          Language: *2

        RSpec/Rails/AvoidSetupHook:
          Description: Checks that tests use RSpec `before` hook over Rails `setup` method.
          Enabled: pending
          VersionAdded: '2.4'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/AvoidSetupHook

        RSpec/Rails/HaveHttpStatus:
          Description: Checks that tests use `have_http_status` instead of equality matchers.
          Enabled: pending
          ResponseMethods:
            - response
            - last_response
          SafeAutoCorrect: false
          VersionAdded: '2.12'
          VersionChanged: '2.27'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/HaveHttpStatus

        RSpec/Rails/HttpStatus:
          Description: Enforces use of symbolic or numeric value to describe HTTP status.
          Enabled: true
          EnforcedStyle: symbolic
          SupportedStyles:
            - numeric
            - symbolic
            - be_status
          VersionAdded: '1.23'
          VersionChanged: '2.20'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/HttpStatus

        RSpec/Rails/InferredSpecType:
          Description: Identifies redundant spec type.
          Enabled: pending
          Safe: false
          VersionAdded: '2.14'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/InferredSpecType
          Inferences:
            channels: channel
            controllers: controller
            features: feature
            generator: generator
            helpers: helper
            jobs: job
            mailboxes: mailbox
            mailers: mailer
            models: model
            requests: request
            integration: request
            api: request
            routing: routing
            system: system
            views: view

        RSpec/Rails/MinitestAssertions:
          Description: Check if using Minitest-like matchers.
          Enabled: pending
          VersionAdded: '2.17'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/MinitestAssertions

        RSpec/Rails/NegationBeValid:
          Description: Enforces use of `be_invalid` or `not_to` for negated be_valid.
          Safe: false
          EnforcedStyle: not_to
          SupportedStyles:
            - not_to
            - be_invalid
          Enabled: pending
          VersionAdded: '2.23'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/NegationBeValid

        RSpec/Rails/TravelAround:
          Description: Prefer to travel in `before` rather than `around`.
          Enabled: pending
          Safe: false
          VersionAdded: '2.19'
          Reference: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/Rails/TravelAround
  recorded_at: Mon, 27 May 2024 05:30:47 GMT
recorded_with: VCR 6.2.0
